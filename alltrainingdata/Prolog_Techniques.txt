Prolog	Techniques
Attila	Csenki

Download	free	books	at

Attila Csenki

Prolog Techniques

2 Download free eBooks at bookboon.com

Prolog Techniques ¬© 2009 Attila Csenki & Ventus Publishing ApS ISBN 978-87-7681-476-2

To my wife √Ågnes who patiently endured me working on this book for most of my spare time during last two years.

3 Download free eBooks at bookboon.com

Prolog Techniques

Contents

Contents
Preface 1 1.1 1.2 1.3 1.4 1.5 1.6 1.6.1 1.6.2 1.6.3 2 2.1 2.2 2.2.1 2.2.2 2.2.3 2.2.4 2.3 2.3.1 Accumulator Technique A Simple Example Hand Computations Further Examples Pseudocodes Generalization Case Study: The Perceptron Training Algorithm ClassiÔ¨Åcation Problem Algorithm Implementation Difference Lists Implementations of List Concatenation Implementations of List Flattening Project: Lists as Trees & Ô¨Çatten/2 Flattening Lists by append/3 Ô¨Çatten/2 by the Difference List Technique Comparing Different Versions Implementations of List Reversal Program Transformations 11 13 13 14 14 23 26 27 27 27 29 37 37 42 43 48 49 49 50 51

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

4 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Contents

2.3.2 2.4 2.4.1 2.4.2 2.4.3 2.5 2.5.1 2.5.2 2.5.3 2.5.4 3 3.1 3.1.1 3.1.2 3.1.3 3.1.4 3.1.5 3.1.6 3.2 3.2.1 3.2.2 3.2.3 3.3

Difference Lists as Accumulators Case Study: Dijkstra‚Äôs Dutch Flag Problem Basic Implementation Using append/3 A More Concise Version Using Difference Lists Rotations Rotating a List The Perceptron Training Algorithm Revisited Planar Rotations Application: The Gauss‚ÄìSeidel Method Program Manipulations Simple Database Operations Basic Database Manipulation Changing the Database File ModiÔ¨Åcations Updating right_to/2 and people.pl Automated Saving of Selected Predicates Miniproject: Modelling a Stamp Collection Case Study: Automated Unfolding Elementary Unfolding Complete One Step Unfolding Rearranging Clauses Dijkstra‚Äôs Dutch Flag Problem Revisited

57 57 58 58 59 61 61 64 65 69 75 75 79 80 85 87 87 91 95 95 104 106 108

5 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Contents

3.3.1 Problem Generalization and First Solution 3.3.2 Enhanced Implementations 4 4.1 4.1.1 4.1.2 4.1.3 4.1.4 4.2 4.3 A A.1 A.2 A.3 A.4 B C Exploratory Code Development A Nursery Rhyme First Preliminary Implementation Another Preliminary Implementation The Final Version Other Approaches Project: ‚ÄôOne Man Went to Mow . . .‚Äô Chapter Notes Solutions of Selected Exercises Chapter 1 Exercises Chapter 2 Exercises Chapter 3 Exercises Chapter 4 Exercises Software Glossary References Index
Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

108 111 117 117 119 124 125 127 132 139 141 141 145 157 167 177 179 183 185

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

6 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

List of Figures

List of Figures
1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 1.10 1.11 1.12 1.13 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 Hand Computations for new sum/2 Hand Computations for rev/2 Hand Computations for min/2 Suggested Hand Computations for from to/3 Hand Computations for cnt/3 Hand Computations for palin/1 ‚Äî success Hand Computations for palin/1 ‚Äî failure Typical Clause Structures of a Predicate with an Accumulator Generalized Clause Structures A Linearly Separable Data Set Classifying a Point A Single Updating Step Applying the Perceptron Training Algorithm Difference List List Concatenation by Difference Lists Tree Representation of [a,[b,[],[c,a],e]] Declarative Reading of (P-2.3) Illustrating Clause (b2) in (P-2.6) Illustrating Exercise 2.9 Rotating by Difference Lists Hand Computations for averages/2 15 16 17 18 19 21 21 27 27 28 29 30 31 39 40 44 50 56 57 61 62

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

7 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

List of Figures

2.9 2.10 2.11 2.12 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 3.10 3.11 3.12 3.13 3.14 3.15 3.16 3.17

Rotating a List with Four Entries The Original List and its Rotated Image The Original Matrix A and its Rotated Image A(rot) Hand Computations for Rotation in the Plane The Initial Seating Arrangement Rectangular Table After George‚Äôs Departure After Tracy‚Äôs and Joe‚Äôs arrival File Organization for the Round Table Example The File people.pl after the Interactive Session The File committee.pl The File committee.pl Interactive Prolog‚ÄìAssisted Program Transformation: Session I Interactive Prolog‚ÄìAssisted Program Transformation: Session II Unfolding, Experiment 1: Disassembling clause 4 of a/5 Unfolding, Experiment 2: Disassembling clause 3 of c/2 Unfolding, Experiment 3: Experiments 1 & 2 followed by appropriate uniÔ¨Åcation Unfolding, Experiment 4: Experiment 3 followed by new clause creation and database update Illustrative Example of Intended Database Updates Top Level DeÔ¨Ånition of def_encolour dl/1 Example Session for Exercise 3.19

64 65 66 67 76 77 81 82 85 87 89 89 97 98 99 99 100 101 111 112 116

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

8 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

List of Figures

4.1 4.2 4.3 A.1 A.2 A.3 A.4 A.5 A.6 A.7

The Rhyme‚Äôs SimpliÔ¨Åed Pattern Exploring Details of the Rhyme‚Äôs Structure Desired Behaviour of song/0 Annotated Hand Computations for from to/3 Hand Computations for mult/3 Illustrating the Second Clause of dl/2 The Last Two Customers Swap Places Automated Solution of Exercise 2.9, Part (c) Database Changes Brought About by cosu/3 Search Tree of the Query ?- int(1,I)

118 124 133 141 144 154 159 163 166 172

9 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

List of Tables

List of Tables
1.1 1.2 1.3 1.4 2.1 3.1 4.1 4.2 A.1 Algorithm 1.4.1 and Related Hand Computations (Fig. 1.2) Algorithm 1.4.2 and Related Hand Computations (Fig. 1.5) Algorithm 1.4.3 and Related Hand Computations (Figs. 1.6 & 1.7) Co-ordinates of Points in the Plane with Class Labels Gauss‚ÄìSeidel Iterations Cases for swap_neighbours/2 Rhyme Structure CPU Times for Versions of the Query ?- rhyme_prel( V, R) Algorithm A.1.1 & Prolog Clause Correspondence (Example 1.6) 24 26 26 27 70 84 127 129 144

10 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Preface

Preface
Prolog is considered diÔ¨Écult by students. Usually, by the time they learn Prolog, which is most likely to happen in preparation for a course in ArtiÔ¨Åcial Intelligence (AI) or Expert Systems, they will have studied imperative programming and/or the object oriented paradigm. Unfortunately, this prior experience is not always conducive to learning Prolog. Even though there is a good provision of traditional Prolog textbooks (for example [2]), students still Ô¨Ånd it hard to write solutions in Prolog to problems of any notable complexity. In my experience this holds also (and in particular) for problems for which Prolog should be the natural choice. This book is intended to relieve the problem by providing a good collection of programming projects, case studies and exercises of various complexity. It will be useful for three kinds of students. ‚Ä¢ Those whose prime source of information is a traditional introductory lecture course in Prolog. For these people my book will serve to show in context how the various programming techniques and language elements may be employed. The book may be used to accompany such a course as a workbook and the student should Ô¨Ånd in it a wealth of information to answer questions concerning the aspects of Prolog taught in the course. ‚Ä¢ Those who want to refresh and extend their knowledge of Prolog, perhaps with some Ô¨Åeld of application in mind. ‚Ä¢ Students of AI learning about search algorithms in particular. Most AI books present search algorithms by pseudocode and are not concerned with details of implementation. In my experience, however, anything seen implemented is more likely to be retained (beyond the exam). There is a deeper reason also why such a book is felt timely. Programming is a creative activity and it is an innate human need to take pleasure (and pride) in the object of one‚Äôs creation, be it a sculpture, a painting, a piece of music, or indeed, a computer program. The opportunity is provided here for students to learn (and experience the said intellectual satisfaction) by creating their own solutions in Prolog to a host of interesting, challenging and varied programming problems. Many of the problems and the way they are approached here are believed to be novel. Sadly, it is felt that the creative aspect of learning is not given enough room in today‚Äôs educational environment in the UK.1 It is hoped that this book will help the student to rediscover Prolog programming as a
1 There is ample evidence to support this thesis. In degree courses, we tend to focus on the ‚Äòengineering‚Äô aspects of and tools for writing (large scale) software; this activity tends to be team-based, procedure-bound and oÔ¨Äers little scope for the kind of pleasure felt by completing a working ‚Äòwhole‚Äô. Learning by students tends to be assessment driven and many never experience the creative feedback. The tasks they have to complete for the exams are (by their very nature) not intended to create anything sizable or ambitious. Coursework assignments do not attract many marks for fear of plagiarism. Finally, modularization does not encourage students to take an interest beyond what is in the module descriptor. The only time where creativity is really called for will be the Ô¨Ånal year project by which time many will lack the practice to complete the task to their supervisor‚Äôs (and, equally importantly, their own ) satisfaction.

11 Download free eBooks at bookboon.com

Prolog Techniques

Preface

worthwhile and enjoyable activity. The core of the material in this book grew out of laboratory classes and coursework prepared by the author for second year computer science students at Bradford University, as part of the lecture course Symbolic and Declarative Computing ‚Äì ArtiÔ¨Åcial Intelligence. This is a two-semester course with an introduction to Functional Programming with Haskell, Logic Programming with Prolog and the basics of AI. The choice of examples and topics for this book is of course tinged by the context in which Prolog was presented. For example, I discuss the functional programming style since it is useful in producing concise, readable and elegant implementations also in Prolog. The selection of topics for the examples was inÔ¨Çuenced in part by the AI element of the course though much new material has found its way into the book. To make set problems more easily accessible for the reader, I subdivide the overall task into managable portions indicating in each the desired outcome (if applicable, in form of a sample session in Prolog) with suggestions for how best to attack the subtasks. The working style advocated here is best described by the following attributes: ‚Ä¢ example based, ‚Ä¢ interactive, ‚Ä¢ exploratory and experimental, ‚Ä¢ incremental, ‚Ä¢ progressing from the speciÔ¨Åc to the more general, ‚Ä¢ identifying patterns of computation with a view to generalization. It will be seen from the list of contents that the material, by its very nature, is not ordered in a linear fashion but is grouped in topics deemed important for programming in Prolog. The work comprises two parts: the present volume Prolog Techniques and the forthcoming Applications of Prolog. This Ô¨Årst volume is in four chapters and illustrates special Prolog programming techniques. The second volume will concentrate on applications of Prolog, mainly from ArtiÔ¨Åcial Intelligence. The order in which the books may be studied is fairly free even though an example introduced somewhere may serve in a later chapter to illustrate the generalization or improvement aÔ¨Äorded by the material just covered. The SWI-Prolog compiler is used throughout: it has been around for quite some time; it is well documented; it is free; and, it is being maintained with new, improved versions becoming available all the time. Furthermore, there is an object oriented extension to SWI-Prolog (XPCE) for building graphical applications, useful if one wants to pursue this line further. Solutions for a selection of exercises are discussed in the appendices. All Prolog source code produced in the course of this book project (including model solutions for all the exercises) can be downloaded from the Ventus website. I am grateful to Dr. Coxhead of Birmingham University for discussions and extensive comments on initial A versions of several of the chapters. My colleague Dr. Fretwell gave me many tips concerning L TEX, the typesetting system used to produce the books.

Bradford, April 2009

Attila Csenki

12 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Chapter 1

Accumulator Technique
One of the features of Prolog which beginners may Ô¨Ånd diÔ¨Écult to cope with is the absence of a language construct for writing loops such as the while and for loops known from imperative programming. In Prolog, repetition is accomplished by recursion which holds some pitfalls for the novice user. In this chapter, we introduce the accumulator technique for deÔ¨Åning predicates by recursion.

1.1

A Simple Example

Let us start with the simple problem of calculating the sum of the (integer) entries in a list. A na¬® ƒ±ve deÔ¨Ånition is as follows. Prolog Code P-1.1: DeÔ¨Ånition of sum/2
1 2

sum([],0). % clause 1 sum([H|T],S) :- sum(T,S0), S is H + S0. % clause 2

The deÔ¨Ånition of sum/2 in (P-1.1) is by recursion: clause 1 is the Base Case, clause 2 is the Recursive Step. It is a viable deÔ¨Ånition for lists of moderate length, as shown below.
?- from to(1,100,L), sum(L,S). 1 L = [1, 2, 3, 4, 5, 6, 7, 8, 9|...] S = 5050

For longer lists, however, error by stack overÔ¨Çow is observed:
?- from to(1,100000,L), sum(L,S). ERROR: Out of local stack2

How should sum/2 be restructured to avoid this problem? The answer lies in what is called a tail recursive deÔ¨Ånition:
1 For a deÔ¨Ånition of the predicate from to(+Low,+High,-List) , see Exercise 1.1, p. 17 and the solution of Exercise 3.16, p. 167. from to/3 returns in List the list of integers between the bounds Low and High . 2 The query below shows that stack overÔ¨Çow is caused here by sum/2 and not by from to/3 . ?- from to(1,100000,L). L = [1, 2, 3, 4, 5, 6, 7, 8, 9|...]

13 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

For a predicate deÔ¨Åned by a recursive clause, the self-invocation should be the last goal in its body. And, for the Prolog system to discard all references to the goals preceding the last one (and thereby freeing up memory), a cut (! ) should be introduced just before the self-invocation. There is no immediate way of rewriting the second clause of sum/2 along these lines (The order of the goals in its body can‚Äôt be interchanged since the tail needs summing before the Ô¨Ånal sum is computed.) The problem is solved by augmenting the old version by an accumulator argument for holding intermediate results of the computation. The new version, sum/3 , is deÔ¨Åned by Prolog Code P-1.2: DeÔ¨Ånition of sum/3
1 2

sum([],S,S). % clause 1 sum([H|T],Acc,S) :- NewAcc is Acc + H, !, sum(T,NewAcc,S). % clause 2

The second argument of sum/3 serves as an accumulator that holds a value which could be termed ‚Äòthe sum accrued thus far‚Äô. The third argument is carried (in clause 2) as an uninstantiated variable until eventually (in clause 1) it is uniÔ¨Åed with the accumulator. By the time clause 1 applies, the accumulator will have received the sum of all entries of the initial list provided that the accumulator argument has been initialized to zero; this latter step is carried out when invoking sum/3 :
?- from to(1,100000,L), sum(L,0,S). L = [1, 2, 3, 4, 5, 6, 7, 8, 9|...] S = 5.00005e+009

(There is no error due to stack overÔ¨Çow this time!) We may deÔ¨Åne new sum/2 by Prolog Code P-1.3: DeÔ¨Ånition of new sum/2
1

new_sum(L,S) :- sum(L,0,S). % clause 0

The predicate sum/3 is used by new sum/2 as an auxiliary predicate. The accumulator argument in sum/3 is initialised by new sum/2 in clause 1 to zero.

1.2

Hand Computations

It is instructive to examine the workings of new sum/2 and sum/3 by a sequence of hand computations (see, [3], pp. 116). To consider a speciÔ¨Åc case, we trace in Fig. 1.1 the computation by new sum/2 of the sum of the entries of [1,2,3] . The wavy arrow (;) is used to indicate transitions, interrelating one stage with the next. The details of how a transition is (or should be) accomplished are elaborated upon in the clause as marked above the arrow.

1.3

Further Examples

Hand computations can be carried out to test code already written but they are also useful for deÔ¨Åning new predicates. It is this latter rÀÜ ole in which we are going to illustrate their use here in several examples. The following steps will be involved.

14 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

new sum([1,2,3],S)
2

:; sum([1,2,3],0,S) :; sum([2,3],1,S) :;
1 0

0

2

2

sum([3],3,S)

:; sum([],6,S) :; S = 6 :; success

Figure 1.1: Hand Computations for new sum/2 ‚Ä¢ State the algorithm to be employed. This may take various forms, most likely, it will be in plain English.3 ‚Ä¢ Construct an example (or examples) typifying all conceivable situations. ‚Ä¢ Carry out hand computations for the examples chosen. Transitions of a similar kind (i.e. those intended to be covered by the same clause) receive identical labels. ‚Ä¢ Inspect the hand computations and deÔ¨Åne a clause for each label.
3 In

Sect. 1.4, pseudocodes will be introduced for describing algorithms.

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

15 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

Example 1.1. DeÔ¨Åne a new version of the built-in predicate reverse/2 for reversing a list. Our approach is easily visualized by thinking of the list entries as a pack of cards whose order has to be reversed. Put the pack, face down, on the table and build up a second pack by moving the cards from the top of the Ô¨Årst, one by one, to the top of the second. The stopping criterion is also obvious: stop when the Ô¨Årst pile is used up, i.e. if the Ô¨Årst list is empty. The hand computations in Fig. 1.2 have been carried out using this idea. The deÔ¨Ånition (P-1.4) is based on them.

rev([1,2,3],R)

:; rev([1,2,3],[],R) :; rev([2,3],[1],R) :; :; rev([],[3,2,1],R) :; R = [3,2,1] :; success
2 1 0

0

2

2

rev([3],[2,1],R)

Figure 1.2: Hand Computations for rev/2 Prolog Code P-1.4: DeÔ¨Ånition of rev/2
1

rev(L,R) :- rev(L,[],R).

% clause 0

2 3

rev([],R,R). % clause 1 rev([H|T],Acc,R) :- rev(T,[H|Acc],R). % clause 2

Example 1.2. DeÔ¨Åne a predicate min/2 for computing the smallest entry of an (integer) list as shown below.
?- min([7,-3,2,5],S). S = -3

The idea is again readily illustrated by using a pack of cards. We are now looking for the card with the smallest value. 1. Take the top one and set it aside. 2. Inspect the top card and compare its value with the one set aside. Retain the smaller of the two, set it aside while discarding the other. 3. Repeat step 2 until you run out of cards. The one set aside will be a one with the minimum value. From the hand computations in Fig. 1.3 it is seen that there should be two recursive clauses: in the case marked 2 , the head of the list is smaller than the current value of the accumulator and thus it will be replaced by the former; in the case marked 3 , this condition does not apply and therefore the old accumulator value is retained. Fig. 1.3 also shows that the initial value of the accumulator in min/3 is the head of the input list (step 0 ).4
4 There is an alternative to this. Use the built-in predicate current prolog flag/2 to Ô¨Ånd the largest integer Prolog can represent and initialize the accumulator to this value: ?- current prolog flag(max integer,Large), min([7,-3,2,5],Large,M). Large = 2147483647 M = -3 Yes

16 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

min([7,-3,2,5],M)
3

:; min([-3,2,5],7,M) :; min([2,5],-3,M) :;
1 0

0

2

3

min([5],-3,M)

:; min([],-3,M) :; M = -3 :; success
Figure 1.3: Hand Computations for min/2 Prolog Code P-1.5: DeÔ¨Ånition of min/2

1

min([H|T],M) :- min(T,H,M).

% clause 0

2 3 4

min([],M,M). % clause 1 min([H|T],Acc,M) :- H < Acc, !, min(T,H,M). % clause 2 min([_|T],Acc,M) :- min(T,Acc,M). % clause 3

(Notice that in clause 3 the goal H >= Acc is omitted as it would always succeed by the time that clause is tried. Here we rely on the clauses‚Äô particular order.)

Exercise 1.1. DeÔ¨Åne a predicate from to(?Low,?High,?List) for producing in List all the natural numbers in ascending order between Low and High . The various modes of operation of from to/3 are illustrated below.
?- from L = [6, ?- from E = 8 ?- from Low = 6 ?- from Yes ?- from No to(6,9,L). 5 7, 8, 9] to(6,9,[ , ,E| ]). 6 to(Low,High,[6, 7, 8, 9]). 7 High = 9 to(6,9,[6, 7, 8, 9]). to(9,6,L).

Some suggested hand computations are shown in Fig. 1.4.

Example 1.3. (Several accumulators ) DeÔ¨Åne cnt(+Atom,-U,-L) for counting the number of upper and lower case letters in an atom. The query below illustrates the intended behaviour of cnt/3 .
?- cnt(‚Äô‚Äô‚ÄôThe Magic Flute‚Äô‚Äô is Mozart‚Äô‚Äôs last opera.‚Äô,U,L). 8 U = 4 L = 27
the built-in predicates var/1 and integer/1 when implementing this functionality. we pick out the third entry of the result list by pattern matching. The built-in predicate is list/1 should be used to allow for such behaviour. 7 To implement this functionality, you will need the built-in predicate last/2 . 8 The outside quotes mark the atom. Inside the atom, the characters ‚Äô‚Äô stand for the quote.
6 Here 5 Use

17 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

from to(6,9,L)

:; from to acc(6,[9],L) :; :; from to acc(6,[7,8,9],L) :; :; L = [6,7,8,9] :; success

from to acc(6,[8,9],L)

from to acc(6,[6,7,8,9],L)

Figure 1.4: Suggested Hand Computations for from to/3 Instead of inspecting the atom‚Äôs characters directly, we will convert them by the built-in predicate atom codes/2 to the list of their corresponding ASCII values and then class each entry according to whether it is ‚Ä¢ Between 65 and 90 (‚áí upper case, increment Ô¨Årst accumulator), ‚Ä¢ Between 97 and 122 (‚áí lower case, increment second accumulator), ‚Ä¢ None of the above (‚áí non-alphabetic, no incrementation).

.

18 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

Built-in Predicate: atom codes(?Atom,?List) It converts Atom into the corresponding List of ASCII values and vice versa. Example: ?- atom codes(‚ÄôWay Out‚Äô,L). L = [87, 97, 121, 32, 79, 117, 116]

Hand computations for cnt/3 on the atom ‚ÄôWay Out‚Äô are shown in Fig. 1.5.

The code shown in (P-1.6)

cnt(‚ÄôWay Out‚Äô,U,L)

:; :;
2

0

cnt([87,97,121,32,79,117,116],0,0,U,L)
3

cnt([97,121,32,79,117,116],1,0,U,L)
3

:;
2

cnt([121,32,79,117,116],1,1,U,L)
4

:;
3

cnt([32,79,117,116],1,2,U,L)
3

:; cnt([79,117,116],1,2,U,L) :;
0

cnt([117,116],2,2,U,L)
1

:; cnt([116],2,3,U,L) :;

cnt([],2,4,U,L)

:; U = 2, L = 4 :; success

Figure 1.5: Hand Computations for cnt/3 mirrors the hand computations. Prolog Code P-1.6: DeÔ¨Ånition of cnt/3
1 2

cnt(Atom,U,L) :- atom_codes(Atom,Values), cnt(Values,0,0,U,L), !. cnt([],U,L,U,L). cnt([H|T],AccU,AccL,U,L) :- upper(H), NewAccU is AccU + 1, !, cnt(T,NewAccU,AccL,U,L). cnt([H|T],AccU,AccL,U,L) :- lower(H), NewAccL is AccL + 1, !, cnt(T,AccU,NewAccL,U,L). cnt([_|T],AccU,AccL,U,L) :- cnt(T,AccU,AccL,U,L).

% clause 0 % % % % % % % % % clause 1 clause 2

3 4 5 6 7 8 9 10

clause 3

clause 4

The auxiliary predicates used in (P-1.6) are upper/1 and lower/1 ; they are deÔ¨Åned in (P-1.7).

19 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Q Prolog Code P-1.7: DeÔ¨Ånitions of upper/1 and lower/1
1 2

upper(C) :- C >= 65, C =< 90. lower(C) :- C >= 97, C =< 122.

Example 1.4. (Grouping of arguments ) For better readibility, arguments may be grouped by using compound terms. The name of the term‚Äôs functor is chosen to reÔ¨Çect the arguments‚Äô common rÀÜ ole. For example, a new version of cnt/3 from Example 1.3, called count/2 , is shown in (P-1.8) Prolog Code P-1.8: DeÔ¨Ånition of count/2
1 2

count(Atom,cases(U,L)) :- atom_codes(Atom,Values), % clause 0 count(Values,acc(0,0),acc(U,L)), !. % count([],Acc,Acc). count([H|T],acc(U,L),Result) :- upper(H), NewU is U + 1, !, count(T,acc(NewU,L),Result). count([H|T],acc(U,L),Result) :- lower(H), NewL is L + 1, !, count(T,acc(U,NewL),Result). count([_|T],acc(U,L),Result) :- count(T,acc(U,L),Result). % % % % % % % % clause 1 clause 2

3 4 5 6 7 8 9 10

clause 3

clause 4

count/2 will behave as cnt/3 does:
?- count(‚ÄôWay Out‚Äô,cases(U,L)). U = 2 L = 4

count/2 is essentially the same predicate as cnt/3 but the number of arguments is reduced to two via the term cases/2 . The auxiliary predicate count/3 has been derived from cnt/5 by merging the two accumulator arguments and the two output arguments each. The accumulators are grouped by the compound term acc/2 ; the now single output argument is reproduced in the recursive clauses 2‚Äì4 by a variable until upon satisfying the stopping criterion in clause 1, it is uniÔ¨Åed with the term in the accumulator argument. The call to count/3 in clause 0 initialises the accumulator to acc(0,0) ; the result is received in the variables U and L by unifying the third argument with the acc(U,L) . This example shows that argument grouping allows the arity of a predicate to be reduced. This observation will be useful in our discussion of a generalization of the accumulator technique in Sect. 1.5. By repeatedly applying this technique, more elaborate hierarchical groupings of arguments may be achieved by nesting terms.

Example 1.5. (Test for success or failure only ) A palindrome is a list (of atoms) which is identical to its reverse. We can use rev/2 from Example 1.1 to test if a list is a palindrome:
?- rev([m,a,d,a,m],[m,a,d,a,m]). Yes ?- rev([a,d,a,m],[a,d,a,m]). No

20 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Clearly, in both cases the entire reverse of the Ô¨Årst argument had to be computed for subsequent matching with the original by way of uniÔ¨Åcation. (P-1.9) shows a more eÔ¨Écient solution ([8], p. 110). Prolog Code P-1.9: DeÔ¨Ånition of palin/1
1

palin(L) :- palin(L,[]).

% clause 0

2 3 4

palin(L,L). % clause 1 palin([_|T],T). % clause 2 palin([H|T],Acc) :- palin(T,[H|Acc]). % clause 3

If palin/1 succeeds, only the front of the list will be worked through as illustrated in Fig. 1.6. (Clauses like 1 and 2 will be executed by uniÔ¨Åcation.) For cases which fail, still the whole list will have to be scanned (Fig. 1.7).
0 3

palin([m,a,d,a,m])

:; palin([m,a,d,a,m],[]) :; :; palin([d,a,m],[a,m]) :; success
3 3 3 2

palin([a,d,a,m],[m])

palin([o,t,t,o])

:; palin([o,t,t,o],[]) :; palin([t,t,o],[o]) :; :; success
1

0

palin([t,o],[t,o])

Figure 1.6: Hand Computations for palin/1 ‚Äî success

palin([a,d,a,m])

:; palin([a,d,a,m],[]) :; :; palin([a,m],[d,a]) :; :; palin([],[m,a,d,a]) :; failure
3 3 3

0

3

palin([d,a,m],[a]) palin([m],[a,d,a])

Figure 1.7: Hand Computations for palin/1 ‚Äî failure

Example 1.6. (Switches as accumulators ) DeÔ¨Åne numbers(+Atom,-N) for Ô¨Ånding out how many numbers there are in an Atom . Example:
?- numbers(‚ÄôElisabeth the 1st reigned between 1558 and 1603.‚Äô,N). N = 3

21 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

This task can be solved in various ways but we are interested in a solution which makes only a single pass through the list of the (encoded) characters of Atom . We can view our problem as having to count the number of sequences of digits in Atom . We shall of course work with the characters‚Äô encoded values; the ASCII values of the ten digits are 48, . . . , 57. digit/1 in (P-1.10) succeeds for encoded digits. Prolog Code P-1.10: DeÔ¨Ånition of the auxiliary predicate digit/1
1

digit(C) :- 48 =< C, C =< 57.

As we progress through the list of (encoded) characters, the beginning of a new sequence of digits will be recognized by the condition ‚Ä¢ The previous character was not a digit ‚Ä¢ The current character is a digit. We employ a dedicated, two-valued argument, called a switch, to save the information about the digit read. The switch has two alternative states: digit and nodigit ; it will be initialized to nodigit . We also use an accumulator argument for the number of digit sequences ‚Äòencountered thus far‚Äô. The accumulator is incremented every time the switch changes state from nodigit to digit .

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

22 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

The predicate numbers(+List,+Switch,+Acc,-N) in (P-1.11) is an implementation of these ideas.9 Prolog Code P-1.11: DeÔ¨Ånition of numbers/2
1 2

numbers(Atom,N) :- atom_codes(Atom,Values), numbers(Values,nodigit,0,N), !. numbers([],_,N,N). numbers([H|T],nodigit,Acc,N) :-

% clause 0 % % % % % % % % clause 1 clause 2

3 4 5 6 7 8 9

digit(H), NewAcc is Acc + 1, !, numbers(T,digit,NewAcc,N). numbers([H|T],digit,Acc,N) :- digit(H), !, numbers(T,digit,Acc,N). numbers([_|T],_,Acc,N) :- !, numbers(T,nodigit,Acc,N).

clause 3 clause 4

Exercise 1.2. Solve the problem from Example 1.6 as before (i.e. by a single pass through the data), now without using a switch.10

1.4

Pseudocodes

Programming (in any language) is a creative activity and the accompanying thought processes may be diÔ¨Écult to formalize and will ultimately remain a personal experience. Nevertheless, there are tools intended to assist the programmer in the software production process. Here the notion of an algorithm plays a central rÀÜ ole. Indeed, one view of the (procedural) software production process is that it is a series of steps in each of which an algorithm is derived from a previous one by reÔ¨Ånement until a working implementation is obtained. Ideally, when programming in Prolog we should be less concerned with algorithms and be allowed to concentrate on a declarative description of the problem in the hope that the Prolog system will arrive at a solution from our speciÔ¨Åcation. In practice, however, both viewpoints are useful and the accumulator technique obviously favours the procedural style. Therefore, as an adjunct to our discussion of the accumulator technique, we want to look at here a particular way of describing algorithms, namely by pseudocodes. Pseudocodes are of interest in particular when using Prolog as an implementation language for ArtiÔ¨Åcial Intelligence (AI) since books in AI use pseudocode for specifying algorithms (e.g. [7, 13, 14]). We start with the algorithm for reversing lists by rev/2 in Example 1.1. Algorithm 1.4.1, shown below, is inspired by the hand computations in Fig. 1.2. It is formulated in terms of iteration and would be implemented by a while loop if we were to use an imperative programming language. It is seen that the pseudocode mimics the workings of an abstract procedural language and that the depth to which individual steps are detailed may be varied. When the pseudocode is Ô¨Ånally ‚Äòtranslated‚Äô to Prolog, recursion is used to implement iteration. Table 1.1 interrelates the steps in the hand computations with the pseudocode statements.
will be made to (P-1.11) in Exercise 1.3, p. 26. Employ a ‚Äòlook ahead‚Äô strategy to see what (encoded) character will be read after the present one. (This plan allows a concise implementation to be achieved.)
10 Hint. 9 Reference

23 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Algorithm 1.4.1: Reverse(List) Accumulator ‚Üê [] while‚éß List = [] ‚é®[H |T ] ‚Üê List do Accumulator ‚Üê [H |Accumulator] ‚é© List ‚Üê T Rev ‚Üê Accumulator return (Rev ) (1) (2) (3) (4) (5)

Statement Hand Computation Step

(1)
0

(2)
2

(3)
2

(4)
2

(5)
1

Table 1.1: Algorithm 1.4.1 and Related Hand Computations (Fig. 1.2)

A slightly more complex case is illustrated by Example 1.3 whose pseudocode, inspired by the hand computations in Fig. 1.5, is shown as Algorithm 1.4.2. (The correspondence between pseudocode statements and steps in the hand computations is displayed in Table 1.2.) These examples illustrate the following points. ‚Ä¢ The while loop is implemented by recursion and by using Prolog‚Äôs control Ô¨Çow model. ‚Ä¢ The if-then-else construct is implemented by putting the clauses in the right order and by pattern matching using uniÔ¨Åcation. ‚Ä¢ Named memory locations (variables) in the pseudocode are implemented by speciÔ¨Åc arguments of predicates or of compound terms. ‚Ä¢ Assignment (indicated in the pseudocode by ‚Üê) is accomplished by uniÔ¨Åcation. ‚Ä¢ In general, Prolog implementations tend to be more concise than the corresponding program written in a conventional language. We conclude this section with the pseudocode for Example 1.5, shown as Algorithm 1.4.3, p. 26. This is of special interest for two reasons. First, the algorithm is not expected to produce any ‚Äôoutput‚Äô in the procedural sense except for Prolog‚Äôs Yes ‚ÄìNo response. This should be no cause for concern, however; proceed as before except that the predicate now has no ‚Äôoutput‚Äô argument. The second noteworthy property of Algorithm 1.4.3 is that it contains a mid-loop exit and therefore it does not comply with the princiles of Structured Programming (one entry ‚Äì one exit), a style normally adhered to in procedural programming. Thus, Nassi-Shneiderman Diagrams (also called Structograms ) [12], would not be a suitable alternative for specifying this algorithm even though palin/1 is a good example of a perfectly acceptable Prolog deÔ¨Ånition. This shows that Prolog allows code to be written whose logic would be frowned upon under diÔ¨Äerent circumstances and whose use would be out of bounds for users of Structograms.11
11 We

note in passing that the German Code of Practice DIN 66261 [6] describes the use of Structograms.

24 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Algorithm 1.4.2: Count(Atom) V alues ‚Üê list of ASCII values of characters in Atom AccU ‚Üê 0 AccL ‚Üê 0 while‚éß V alues = [] [H |T ] ‚Üê V alues ‚é™ ‚é™ ‚é™ ‚é™ if H is an upper case letter ‚é™ ‚é™ ‚é® (5) then AccU ‚Üê AccU + 1 do else if H is a lower case letter ‚é™ ‚é™ ‚é™ ‚é™ (6) then AccL ‚Üê AccL + 1 ‚é™ ‚é™ ‚é© V alues ‚Üê T U ppers ‚Üê AccU Lowers ‚Üê AccL return (U ppers, Lowers) (1) (2) (3) (4)

(7) (8) (9)

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

25 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

Statement Hand Compn Step

(1)
0

(2)
0

(3)
0 2

(4)
3 4

(5)
2

(6)
3 2

(7)
3 4

(8)
1

(9)
1

Table 1.2: Algorithm 1.4.2 and Related Hand Computations (Fig. 1.5)

Algorithm 1.4.3: Palindrome(List) Accumulator ‚Üê [] while‚éß List = [] if List = Accumulator ‚é™ ‚é™ ‚é™ ‚é™ then ‚éß return (success) ‚é™ ‚é™ ‚é™ ‚é™ ‚é® ‚é®[H |T ] ‚Üê List else if T = Accumulator do ‚é© ‚é™ ‚é™ then return (success) ‚é™ ‚é™ ‚é™ ‚é™ List ‚Üê T ‚é™ ‚é™ ‚é© Accumulator ‚Üê [H |Accumulator] return (f ailure) (1) (2) (3) (4) (5) (6)

Statement Hand Computation Step

(1)
0

(2)
1

(3)
2 3

(4)
2

(5)
3

(6)
3

Table 1.3: Algorithm 1.4.3 and Related Hand Computations (Figs. 1.6 & 1.7)

Exercise 1.3. Construct the pseudocode for the Prolog code in Example 1.6. Also establish the correspondence between the Prolog clauses and the statements of your pseudocode.

1.5

Generalization

Each clause of the predicates seen thus far with accumulator arguments Ô¨Åts one of the two patterns shown in Fig. 1.8.12 , 13 Fig. 1.9 shows a more general scheme where we group Input and Accumulator into Argument which then is subjected to some transformations until a stopping criterion applies.
12 For 13 If

palin/2 from Example 1.5 also to Ô¨Åt this mould, the Result argument is to be ignored. necessary, apply Ô¨Årst the technique from Example 1.4 to reduce the arity of predicate to 3.

26 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

predicate(Input,Accumulator,Accumulator) :stopping-condition(Input,Accumulator). predicate(Input,Accumulator,Result) :carry-on-condition(Input,Accumulator), transform(Input,Accumulator,NewInput,NewAccumulator), !, predicate(NewInput,NewAccumulator,Result). Figure 1.8: Typical Clause Structures of a Predicate with an Accumulator predicate(Argument,Result) :- stopping-condition(Argument), extract-info-from(Argument,Result). predicate(Argument,Result) :- carry-on-condition(Argument), transform(Argument,NewArgument), !, predicate(NewArgument,Result). Figure 1.9: Generalized Clause Structures

1.6
1.6.1

Case Study: The Perceptron Training Algorithm
ClassiÔ¨Åcation Problem

A basic problem in connectionist AI is that of Ô¨Ånding a linear classiÔ¨Åer for two groups of data in the space of n‚Äìtuples of real numbers. As an illustrative example, we consider the two-dimensional data in Table 1.4. x1 x2 Label d 6.981 14.414 0.554 4.466 ‚àí1 +1 2.337 4.040 ‚àí1 8.500 3.496 +1 9.190 2.000 ‚àí1 1.149 14.786 6.100 2.179 ‚àí1 +1 7.842 6.331 +1

Table 1.4: Co-ordinates of Points in the Plane with Class Labels Each of the 8 points belongs to one of the two classes labelled +1 or ‚àí1. A plot of the data with a separating straight line is shown in Fig. 1.10. The Perceptron Training Algorithm allows a separating straight line to be found if it exists (e.g. [7, 13, 14]); the data then is said to be linearly separable.

1.6.2

Algorithm

A simple decision rule for linearly separable data is based on the perceptron which in the two‚Äìdimensional case can be written in the form +1 if w1 x1 + w2 x2 ‚â• t, d(x1 , x2 ) = (1.1) ‚àí1 if w1 x1 + w2 x2 < t, with weights w1 , w2 and threshold t. The decision rule (1.1) generalizes for n‚Äìdimensional data to

27 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

8 7 6 5 4 3 2 1 0

‚ó¶ ‚ó¶ Labels ‚Ä¢ = +1 ‚ó¶ = ‚àí1

‚Ä¢ ‚Ä¢ ‚Ä¢ ‚ó¶ ‚ó¶ ‚Ä¢

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Figure 1.10: A Linearly Separable Data Set

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

28 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

d(x1 , ¬∑ ¬∑ ¬∑ , xn , xn+1 ) =

+1 if w1 x1 + ¬∑ ¬∑ ¬∑ + wn xn + wn+1 xn+1 ‚â• 0, ‚àí1 if w1 x1 + ¬∑ ¬∑ ¬∑ + wn xn + wn+1 xn+1 < 0,

(1.2)

with weights w1 , ¬∑ ¬∑ ¬∑ , wn+1 and unit bias xn+1 = 1.14 For later reference, (1.2) is presented in Fig. 1.11 as a procedure. ' $ procedure Classify([x1 , ¬∑ ¬∑ ¬∑ , xn+1 ], [w1 , ¬∑ ¬∑ ¬∑ , wn+1 ]) class ‚Üê sign return (class) &
n+1 k=1

wk xk %

Figure 1.11: Classifying a Point The sign function in Fig. 1.11 is deÔ¨Åned by sign(s) = +1 if s ‚â• 0, ‚àí1 if s < 0.

In Fig. 1.12 it is shown how a single updating step is carried out by the perceptron. It takes a sample point x from the training data with the corresponding desired class label d, the current (list of) weights w and returns the updated weights, w(new) . The positive constant c, the learning rate, is arbitrary but Ô¨Åxed throughout the whole training session. To Ô¨Ånd a set of weights for which the decision rule correctly classiÔ¨Åes all training points, the updating step from Fig. 1.12 is repeated as indicated in Fig. 1.13, p. 31. The weights‚Äô initial values and the learning rate are arbitrary; we have chosen w(0) = [‚àí0.51, ‚àí0.35, 0.13] and c = 0.25 in our example. After each iteration step, it is checked whether any of the training data points is misclassiÔ¨Åed, in which case iteration continues. Iteration is stopped as soon as all training data points are correctly classiÔ¨Åed. This is shown in Algorithm 1.6.3, p. 32.

1.6.3

Implementation
ps([[ 6.981, 0.554, 1], ..., [ 7.842, 6.331, 1]]). % points ds([-1, 1, -1, 1, -1, -1, 1, 1]). % classes ws([-0.51, -0.35, 0.13]). % weights

We represent (the by the unit bias augmented version of) Table 1.4 and the weights‚Äô initial values by the facts

The Perceptron Training Algorithm 1.6.3 will be implemented by the predicate pta/6 with argument pattern pta(+LearningRate,+Points,+DesiredOutputs,+Weights, -FinalWeights,-Iterations) It calls in (P-1.12) the auxiliary predicate pta/2 , which itself is structured according to Fig. 1.9. Prolog Code P-1.12: DeÔ¨Ånition of pta/6
1 2 3

pta(LRate, Points, DesiredOutputs, Weights, FinalWeights,Iters) :pta(in(LRate,Points,DesiredOutputs,Weights,0), out(FinalWeights,Iters)).

29 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

[w1 , ¬∑ ¬∑ ¬∑ , wn+1 ] [x1 , ¬∑ ¬∑ ¬∑ , xn+1 ] d ¬£ ¬† ‚àí ‚àí ‚àí ‚àí ‚Üí ¬¢Perceptron ¬°
‚Üê ‚àí‚àí ‚àí ‚àí ‚Üí ‚àí ‚àí‚àí ‚àí
(new )

[w1 , ¬∑ ¬∑ ¬∑ , wn+1 ] 9 6 procedure Perceptron([x1 , ¬∑ ¬∑ ¬∑ , xn+1 ], d, [w1 , ¬∑ ¬∑ ¬∑ , wn+1 ]) for j ‚Üê ‚éß 1 to (n + 1) ‚é®class ‚Üê Classify([x1 , ¬∑ ¬∑ ¬∑ , xn+1 ], [w1 , ¬∑ ¬∑ ¬∑ , wn+1 ]) do Œîwj ‚Üê c (d ‚àí class) xj ‚é© (new) wj ‚Üê wj + Œîwj (new ) (new ) return ([w1 , ¬∑ ¬∑ ¬∑ , wn+1 ]) 8 7 Figure 1.12: A Single Updating Step

(new )

The rÀÜ oles of the arguments of in/5 and out/2 are obvious from the names chosen. (The last argument of in/5 is an accumulator for the iteration number. It is initialized to zero in (P-1.12).) The deÔ¨Ånition in (P-1.13) follows the layout from Fig. 1.9.

Prolog Code P-1.13: DeÔ¨Ånition of pta/2
1 2 3

pta(in(_,Ps,Ds,Ws,I),out(Ws,I)) :- classify_all(Ps,Ws,Ds), !. % clause 1 pta(Arg,Result) :- transform(Arg,NewArg), % clause 2 !, pta(NewArg,Result). %

With reference to Fig. 1.9 it is seen that

14 Equation 15 The

(1.2) thereby subsumes (1.1) by putting n = 2 and t = ‚àíwn+1 . symbol + + stands for list concatenation.

30 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

T

[ 6.981, 0.554, 1.000] ‚àí1 [14.414, 4.466, 1.000] 1

[ 2.337, 4.040, 1.000] ‚àí1 [ 8.500, 3.496, 1.000] 1

[ 9.190, 2.000, 1.000] ‚àí1 [ 1.149, 6.100, 1.000] ‚àí1 [14.786, 2.179, 1.000] [ 7.842, 6.331, 1.000] 1 1

c T

[ 6.981, 0.554, 1.000] ‚àí1 [14.414, 4.466, 1.000] 1

[ 2.337, 4.040, 1.000] ‚àí1 [ 8.500, 3.496, 1.000] 1

[ 9.190, 2.000, 1.000] ‚àí1 [ 1.149, 6.100, 1.000] ‚àí1 [14.786, 2.179, 1.000] [ 7.842, 6.331, 1.000] 1 1

c

¬£ ¬† ‚àíw ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (1) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (2) ¬† ‚àí w ¬£ ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (3) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (4) ¬£ ¬† ‚àí w ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (5) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (6) ¬£ ¬† ‚àí w ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (7) ¬£ ¬† ‚àí w ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (8) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (9) ¬£ ¬† ‚àí w ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (10) ¬† ‚àí w ¬£ ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (11) ¬† ‚àí w ¬£ ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (12) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (13) ¬£ ¬† ‚àí w ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (14) ¬£ ¬† ‚àí w ‚àí‚Üí ¬¢Perceptron ¬° ‚Üê ‚àí‚Üí (15) ¬† ‚àí w ¬£ ‚Üê ‚àí‚Üí ¬¢Perceptron ¬° ‚àí ‚Üí (16) w

(0)

Second Training Epoch

First Training Epoch

Figure 1.13: Applying the Perceptron Training Algorithm

31 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Algorithm 1.6.3: PTA([x(1) , ¬∑ ¬∑ ¬∑ , x(N ) ], [d1 , ¬∑ ¬∑ ¬∑ , dN ], w) comment: Perceptron Training Algorithm. Iterate until all points are correctly classiÔ¨Åed. procedure ClassifyAll([x(1) , ¬∑ ¬∑ ¬∑ , x(N ) ], w) for i ‚Üê 1 to N do ci ‚Üê Classify(x(i) , w) return ([c1 , ¬∑ ¬∑ ¬∑ , cN ]) main W eights ‚Üê w P oints ‚Üê [x(1) , ¬∑ ¬∑ ¬∑ , x(N ) ] DesiredOutputs ‚Üê [d1 , ¬∑ ¬∑ ¬∑ , dN ] ActualOutputs ‚Üê ClassifyAll(P oints, W eights) Iterations ‚Üê 0 while‚éß ActualOutputs = DesiredOutputs [P |OtherP s] ‚Üê P oints ‚é™ ‚é™ ‚é™ ‚é™ [ D|OtherDs] ‚Üê DesiredOutputs ‚é™ ‚é™ ‚é™ ‚é™ ‚é®W eights ‚Üê Perceptron(c, P, D, W eights) + 15 [P ] do P oints ‚Üê OtherP s + ‚é™ ‚é™ DesiredOutputs ‚Üê OtherDs + + [D] ‚é™ ‚é™ ‚é™ ‚é™ ActualOutputs ‚Üê ClassifyAll (P oints, W eights) ‚é™ ‚é™ ‚é© Iterations ‚Üê Iterations + 1 output (Iterations, W eights)

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

32 Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

Prolog Techniques

Accumulator Technique

‚Ä¢ In clause 1, stopping-condition is implemented by classify all/3 , deÔ¨Åned by recursion in (P-1.14). Prolog Code P-1.14: DeÔ¨Ånition of classify all/3
1 2 3 4

classify_all([],_,[]). classify_all([P|OtherPs],Weights,[Class|OtherCs]) :classify(P,Weights,Class), !, classify_all(OtherPs,Weights,OtherCs).

% clause 1 % clause 2 % %

(The predicate classify/3 is a straightforward implementation of the procedure in Fig. 1.11; for its deÔ¨Ånition, see the Ô¨Åle accumulator.pl.) ‚Ä¢ In clause 1, extract-info-from is realized by uniÔ¨Åcation of the last two arguments of in/5 with those of out/2 . ‚Ä¢ In clause 2, the carry-on-condition is implicitly deÔ¨Åned by failure of the predicate classify all/3 in clause 1. ‚Ä¢ Finally, the predicate transform/2 is deÔ¨Åned by (P-1.15). Prolog Code P-1.15: DeÔ¨Ånition of transform/2
1 2 3 4 5 6

transform(in(C,[P|OtherPs],[D|OtherDs],Ws,Acc), in(C,NewPs,NewDs,NewWs,NewAcc)) :append(OtherPs,[P],NewPs), append(OtherDs,[D],NewDs), perceptron(C,P,D,Ws,NewWs), NewAcc is Acc + 1.

The predicate perceptron/5 in (P-1.15), line 5, is a straightforward implementation of the weight updating step from Fig. 1.12. It is deÔ¨Åned in (P-1.16). Prolog Code P-1.16: DeÔ¨Ånition of perceptron/5
1 2 3 4 5

perceptron(C,Point,D,Weights,NewWeights) :classify(Point,Weights,Class), Const is C * (D - Class), mult(Const,Point,DeltaWs), add(Weights,DeltaWs,NewWeights).

The implementation thus deÔ¨Åned we use to Ô¨Ånd after 801 iterations a correct classiÔ¨Åer.
?- ps( Ps), ds( Ds), ws(W0), pta(0.25, Ps, Ds,W0,W,I). 16 W0 = [-0.51, -0.35, 0.13] W = [3.018, 4.1935, -39.87] I = 801

33 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

While the initial weights give rise to some incorrect classiÔ¨Åcations,
?- ps( Ps), classify all( Ps, [-0.51, -0.35, 0.13], Classes). Classes = [-1, -1, -1, -1, -1, -1, -1, -1]

the new weights deÔ¨Åne a correct classiÔ¨Åer,
?- ps( Ps), classify all( Ps, [3.018, 4.1935, -39.87], Classes). Classes = [-1, 1, -1, 1, -1, -1, 1, 1]

(The corresponding separating straight line { (x1 , x2 ) : 3.018x1 + 4.1935x2 ‚àí 39.87 = 0 } is shown in Fig. 1.10.)
16 In the version of SWI‚ÄìProlog used here (version 3.4.5), variables whose name starts with an underscore (such as Ps ) won‚Äôt be displayed. Issue the query ?- set prolog flag(toplevel print anon, false). Yes

at the beginning of the session to achieve the same eÔ¨Äect with version 5.2.7 (the most recent version at the time of writing).

AXA Global Graduate Program
Find out more and apply

34 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Accumulator Technique

Exercise 1.4. To make the deÔ¨Ånition of perceptron/5 in (P-1.16) complete, deÔ¨Åne mult/3 and add/3 thus implementing scalar multiplication and addition of vectors, respectively. Your deÔ¨Ånitions should be by both simple recursion and the accumulator technique. ReÔ¨Çect on the performance of each implementation.

Exercise 1.5. The Perceptron Training Algorithm may be carried out for a Ô¨Åxed number of iterations rather than until all points are correctly classiÔ¨Åed. Augment the deÔ¨Ånition of pta/6 to cover this case too. Thus the argument pattern of pta/6 is now pta(+LearningRate,+Points,+DesiredOutputs,+Weights, -FinalWeights,?Iterations) This modiÔ¨Åcation is useful for instance in our example for conÔ¨Årming that the least number of iterations needed to classify all points correctly is indeed 801:17
?- ps( Ps), ds( Ds), ws(W0), pta(0.25, Ps,_Ds,W0,W,800). W0 = [-0.51, -0.35, 0.13] W = [6.5085, 4.4705, -39.37] ?- ps( Ps), classify all( Ps,[6.5085, 4.4705, -39.37],Classes). Classes = [1, 1, -1, 1, 1, -1, 1, 1]

Hint. Use Algorithm 1.6.4 (p. 35) in lieu of Algorithm 1.6.3. A minimal change to clause 1 of pta/2 (p. 30) will do.

35 Download free eBooks at bookboon.com

Prolog Techniques

Accumulator Technique

Algorithm 1.6.4: PTA(c, [x(1) , ¬∑ ¬∑ ¬∑ , x(N ) ], [d1 , ¬∑ ¬∑ ¬∑ , dN ], w, m) comment: Perceptron Training Algorithm. Iterate m(> 0) number of times. main W eights ‚Üê w P oints ‚Üê [x(1) , ¬∑ ¬∑ ¬∑ , x(N ) ] DesiredOutputs ‚Üê [d1 , ¬∑ ¬∑ ¬∑ , dN ] Iterations ‚Üê m repeat ‚éß [P |OtherP s] ‚Üê P oints ‚é™ ‚é™ ‚é™ ‚é™ [ D|OtherDs] ‚Üê DesiredOutputs ‚é™ ‚é™ ‚é® W eights ‚Üê Perceptron(c, P, D, W eights) P oints ‚Üê OtherP s + + [P ] ‚é™ ‚é™ ‚é™ ‚é™ DesiredOutputs ‚Üê OtherDs + + [D] ‚é™ ‚é™ ‚é© Iterations ‚Üê Iterations ‚àí 1 until Iterations = 0 output (W eights)
17 From the procedure Perceptron in Fig. 1.12 it is seen that once a set of weights has been found which gives rise to correct classiÔ¨Åcation for all points, further iterations won‚Äôt change the weights‚Äô values. Thus, the fact that after 800 iterations some of the points are misclassiÔ¨Åed, shows that any lesser number of iterations won‚Äôt do either. 801 is therefore the minimum number of iterations needed for correct classiÔ¨Åcation.

36 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

Chapter 2

DiÔ¨Äerence Lists
Owing to the availability of uniÔ¨Åcation in Prolog, there is a useful technique that allows predicates involving certain list operations to be implemented very eÔ¨Éciently. Because at the conceptual level the technique appears to be manipulating ‚ÄôdiÔ¨Äerences of lists‚Äô, it is known as the DiÔ¨Äerence List Technique.

2.1

Implementations of List Concatenation

Suppose we want to concatenate the two lists [a,b,c] and [d,e] to give us the new list [a,b,c,d,e]; in other words, we want to append the list [d,e] to the list [a,b,c]. We can do this by the built-in predicate append/3 as follows:
?- append([a,b,c],[d,e],L). L = [a, b, c, d, e]

We use Prolog‚Äôs listing/1 to display the deÔ¨Ånition of append/3 :
?- listing(append/3). append([], A, A). append([A|B], C, [A|D]) :- append(B, C, D).

Due to its recursive deÔ¨Ånition, append/3 will be invoked four times when running our example. In general, the depth of the proof tree will be proportional to the length of the list in the Ô¨Årst argument. We want to explore a computationally more economical approach to the problem of list concatenation. Let us place in the database the following one-line deÔ¨Ånition of app dl1/4 :1
app_dl1(A,B,B,A).

Let us carry out the following experiment:
?- app_dl1([a,b,c|X],X,[d,e],Z). X = [d, e] Z = [a, b, c, d, e]
1 Notation: app stands for append ; dl stands for diÔ¨Äerence list ; and, 1 indicates that it is the Ô¨Årst version ‚Äì other (improved) versions soon to follow.

37 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

We have accomplished the intended append operation once again! Let us examine how. The following uniÔ¨Åcations have taken place: 1. A is uniÔ¨Åed with [a,b,c|X]. 2. B is uniÔ¨Åed with X. 3. B is instantiated to [d,e]. 4. A is uniÔ¨Åed with Z. It is easily seen that the net result of 1‚Äì4 is that Z is instantiated to [a,b,c,d,e]. We now deÔ¨Åne a new predicate app dl2/3 which is slightly diÔ¨Äerent but still equivalent to app dl1/4 :
app_dl2(A-B,B,A).

(We have chosen, for reasons to be explained soon, to reduce the arity by one by ‚Äômerging‚Äô the Ô¨Årst two arguments of app dl1/4 to a hyphenated term.2 ) Let us see how app dl2/3 behaves:
?- app dl2([a,b,c|X]-X,[d,e],Z). X = [d, e] Z = [a, b, c, d, e]

We get the earlier response since the uniÔ¨Åcation steps carried out are as before. The hyphen notation chosen in app dl2/3 is more customary, however, and it lends itself to the following interpretation. The term [a,b,c|X]-X is interpreted as a representation of the list [a,b,c] in diÔ¨Äerence list notation. The variable X stands for any list. If we unify this term with Y-[], then Y will be instantiated to [a,b,c] in the usual list notation:
?- [a,b,c|X]-X = Y-[]. X = [] Y = [a, b, c] ; No

Fig. 2.1 shows how the three conceptual lists are interrelated. It must be emphasized that the above interpretation is a mere working model for what is actually taking place inside Prolog. It turns out, however, that it is unnecessary to look beyond this conceptual model when working with ‚ÄôdiÔ¨Äerence lists‚Äô. To reinforce this point, let us consider yet another (the fourth) version of append :
app_dl4(A-B,B-C,A-C).
could have chosen some other operator for the term in the Ô¨Årst argument of the new predicate; for example, the same eÔ¨Äect is achieved by: :- op(50,xfx,&). ... app dl3(A&B,B,A). The Ô¨Årst line ‚Äì a directive ‚Äì declares & as an inÔ¨Åx operator of precedence 50. In the Ô¨Årst argument of app dl3/3 a term A&B replaces the former A-B. The response will be as before: ?- app dl3([a,b,c|X]&X,[d,e],Z). X = [d, e] Z = [a, b, c, d, e] If the hyphen (-) is chosen to denote diÔ¨Äerence lists, however, no operator declaration is required since it is a Prolog built-in.
2 We

38 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

[a,b,c|X]

[a,b,c|X] - X Figure 2.1: DiÔ¨Äerence List

X

All arguments of app dl4/3 are diÔ¨Äerence lists; the earlier query now reads as follows.
?- app_dl4([a,b,c|X]-X,[d,e|Y]-Y,Z1-Z2). X = [d, e|_G370] Y = _G370 Z1 = [a, b, c, d, e|_G370] Z2 = _G370 ; No

The (diÔ¨Äerence) lists involved here are interrelated as shown in Fig. 2.2. The concatenated list is returned in the last argument of app dl4/3 in the form of [a, b, c, d, e| G370]- G370.

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

39 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

( G370 is some internally chosen variable name.) It is easily seen that this is accomplished in one uniÔ¨Åcation

A [a,b,c] A - B [d,e] B - C A - C = [a,b,c,d,e] Figure 2.2: List Concatenation by DiÔ¨Äerence Lists C B

step irrespective of the lengths of the lists to be concatenated. (Appending diÔ¨Äerence lists is therefore a constant time operation.)

We now want to conÔ¨Årm all this experimentally, too. To get started, we need some method for creating diÔ¨Äerence lists. One way forward is by means of append/3 . For example, in

?- setof( N,between(1,5, N),Ns), append(Ns,X,L), DL = L-X. Ns = [1, 2, 3, 4, 5] X = G468 L = [1, 2, 3, 4, 5| G468] DL = [1, 2, 3, 4, 5| G468]- G468

40 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Built-in Predicates: bagof/3 and setof/3 bagof(+Item,+Goal,?Items) is used to collect in the list Items instances of Item for which Goal is satisÔ¨Åed. Free variables in Goal will be instantiated to values for which Goal succeeds. Example: Throw two dice to record all possible results whose sum does not exceed 3. ?- bagof(( D1, D2),(between(1,6, D1), between(1,6, D2), S is D1 + D2, S =< 3), Pairs). S = 2 Pairs = [ (1, 1)] ; S = 3 Pairs = [ (1, 2), (2, 1)] ; No We collect the pairs irrespective of the values taken by S by ?- bagof(( D1, D2), S^(between(1,6, D1), between(1,6, D2), S is D1 + D2, S =< 3), Pairs). Pairs = [ (1, 1), (1, 2), (2, 1)] ; No setof/3 is used in a similar fashion except that the entries in Items are sorted in ascending order and there are no multiple entries in Items .

the list [1,2,3,4,5] is written as a diÔ¨Äerence list DL using the internal variable G468.

Built-in Predicate: between(+Low,+High,?Value) On backtracking, the variable Value is uniÔ¨Åed with all integer values between Low and High . Example: ?- between(-1,3,V). V = -1 ; V = 0 ; ...

We now append to DL the diÔ¨Äerence list form of [d,e] and also measure the number of inferences by time/1 :
?- setof( N,between(1,5, N),Ns), append(Ns,X,L), DL = L-X, time(app_dl4(DL,[d,e|Y]-Y,Z1-Z2)). % 1 inferences in 0.00 seconds (Infinite Lips) Ns = [1, 2, 3, 4, 5] X = [d, e| G691] L = [1, 2, 3, 4, 5, d, e| G691] DL = [1, 2, 3, 4, 5, d, e| G691]-[d, e| G691] Y = G691 Z1 = [1, 2, 3, 4, 5, d, e| G691] Z2 = G691

We need one single inference step only. On the other hand, the corresponding operation with proper lists is more expensive (6 inferences):

41 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

?- setof( N,between(1,5, N),Ns), time(append(Ns,[d,e],Z)). % 6 inferences in 0.00 seconds (Infinite Lips) Ns = [1, 2, 3, 4, 5] Z = [1, 2, 3, 4, 5, d, e]

(You may wish to repeat the experiment with larger lists by adjusting the second argument in between/3 above.)

2.2

Implementations of List Flattening

Lists in Prolog can have a nested structure; for example, [a,[b,[],[c,a],e]] is a valid list. The built-in predicate flatten/2 is designed to ‚Äòlinearize‚Äô lists as indicated below:
?- flatten([a,[b,[],[c,a],e]],L). L = [a, b, c, a, e]

In this section, we are going to explore several implementations of flatten/2 the most eÔ¨Écient of which will turn out to be the one based on the diÔ¨Äerence list technique.

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

42 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

2.2.1

Project: Lists as Trees & flatten/2

The usual square bracket notation for lists is just a notational convenience. The underlying (but not immediately obvious) structure is that of a term with the functor ‚Äò. ‚Äô (dot). This may be demonstrated by using the triad of built-in predicates functor/3 , arg/3 and=../2 3 . For example,
?- functor([a,b,c],F,A). F = ‚Äô.‚Äô A = 2

shows that the list [a,b,c] (as any list) is represented as a term with arity 2 and functor ‚Äò.‚Äô. We may Ô¨Ånd the values of the term‚Äôs Ô¨Årst and second argument respectively by
?- arg(1,[a,b,c],A). A = a

and
?- arg(2,[a,b,c],A). A = [b, c]

The same may be gleaned from using univ :
?- [a,b,c] =.. L. L = [‚Äô.‚Äô, a, [b, c]]

Finally, we may even use the dot-notation when working with lists; for example, [b,c] may be appended to [a] by
?- append(.(a,[]),.(b,.(c,[])),L). L = [a, b, c]

Even though lists are not written in practice in this way (since the square bracket notation is more suited to human use), the dot-notation is useful for representing the structure of lists (and that of nested lists in particular) as a tree of terms. As an example, the tree representation of the list [a,[b,[],[c,a],e]] is shown in Fig. 2.3. The following is easily observed: ‚Ä¢ The Ô¨Çattened list [a,b,c,a,e] may be formed from the tree representation of [a,[b,[],[c,a],e]] by visiting all leaf terms in turn in a counter-clockwise direction and by collecting those leaves from left-hand branches which are not the empty list [] . This process will Ô¨Çatten any list. Exercises 2.1‚Äì 2.3 below elaborate on this idea, leading to an implementation of flatten/2 . We can easily convert from the dot-notation to the square bracket notation; for example,
?- L = .(a, .(.(b, .([], .(.(c, .(a, [])), .(e, [])))), [])). L = [a, [b, [], [c, a], e]]

The reverse process has to be programmed. Exercise 2.1. DeÔ¨Åne a predicate sharp/2 for converting lists into terms with functor #/2 as exempliÔ¨Åed by the following query.4
is an inÔ¨Åx predicate and is called univ. we would like to have a predicate for converting lists in the square bracket notation to a (possibly nested) term with functor ‚Äô. ‚Äô. However, this is not immediately achievable since as soon as Prolog sees a term whose functor is ‚Äô. ‚Äô it will automatically display it in the square bracket notation.
4 Ideally, 3 This

43 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

‚Ä¢ 222¬Ñ 222 2 2 2 ¬Ñ 222 222 ¬Ñ a ‚Ä¢ $$$¬Ñ $ $ $ ¬Ñ $$$ ¬Ñ $$$ b ‚Ä¢   ¬É   ¬É  ¬É  [] ‚Ä¢ &rr rr & & rr & ‚Ä¢ ‚Ä¢ &¬Ñ  ¬Ñ &  ¬Ñ ¬Ñ &  ¬Ñ & ¬Ñ e [] c ‚Ä¢ ¬Ñ  ¬Ñ  ¬Ñ a [] Figure 2.3: Tree Representation of [a,[b,[],[c,a],e]]

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

44 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

?- sharp([a,[b,[],[c,a],e]],S). S = #(a, #(#(b, #([], #(#(c, #(a, [])), #(e, [])))), []))

Hint. The deÔ¨Ånition should be recursive and the ‚Äòboundary case‚Äô may be veriÔ¨Åed by using the built-in predicate proper list/1 . If we now had a predicate lf/2 for returning the leaf nodes from the # -tree of a list (as speciÔ¨Åed earlier), we could easily implement flatten/2 , as indicated by
?- sharp([a,[b,[],[c,a],e]], S), bagof( L,lf( S, L),Ls). Ls = [a, b, c, a, e]

Exercise 2.2. DeÔ¨Åne a predicate lf(+S,-L) which on backtracking uniÔ¨Åes L with the left-hand leaves (not equal to [] ) of the # -tree S :
?- lf(#(a, #(#(b, #([], #(#(c, #(a, [])), #(e, [])))), [])),L). L = a ; L = b ; L = c ; L = a ; L = e ; No

Note. Your implementations of sharp/2 and lf/2 should be able to cope with lists involving variables, too:
?- sharp([a,[Y,[b,X]],c,f(X)],S). Y = G315 X = G321 S = #(a,#(#( G315,#(#(b,#( G321,[])),[])),#(c,#(f( G321),[])))) ?- sharp([a,[ Y,[b, X]],c,f( X)],_S), !, lf( S,Leaf). Leaf = a ; Leaf = G435 ; Leaf = b ; Leaf = G441 ; Leaf = c ; Leaf = f( G441) ; No

Exercise 2.3. Now deÔ¨Åne a Ô¨Årst version of flatten/2 :
?- flatten 1([a, [b, [], [c, a], e]],L). L = [a, b, c, a, e] ?- flatten 1([a,[Y,[b,X]],c,f(X)],L). Y = G339 X = G345 L = [a, G339, b, G345, c, f( G345)]

45 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

As indicated in Exercise 2.1, in the Ô¨Årst instance Prolog won‚Äôt convert a list to a term whose functor is the dot; more precisely, such a conversion won‚Äôt be visible since Prolog automatically shows lists in the square bracket notation. There are two ways, however, to instruct the Prolog system to suppress this conversion automatism. ‚Ä¢ The built-in predicate write term/2 may be used to display a term such that any list within it will be shown in the generic term-representation using the ‚Äò. ‚Äô functor:
?- write term([a,[b,[],fun([c,a]),e]],[ignore ops = true]). .(a,.(.(b,.([],.(fun(.(c,.(a,[]))),.(e,[])))),[]))

The second argument of write term/2 is a list-of-options where the Ô¨Çag ignore ops is set to true ; the default is false . ‚Ä¢ We may achieve the same eÔ¨Äect for the entire interactive session by the built-in predicate set prolog flag/2 ; this is exempliÔ¨Åed below:
?- L = [a, [b, [], fun([c, a]), e]]. L = [a, [b, [], fun([c, a]), e]] ?- set prolog flag(toplevel print options,[ignore ops=true]). Yes ?- L = [a, [b, [], fun([c, a]), e]]. L = .(a,.(.(b,.([],.(fun(.(c,.(a,[]))),.(e,[])))),[]))

Once it has been set by the user with set prolog flag/2 , the state of ignore ops is checked by the built-in predicate current prolog flag/2 :
?- current prolog flag(toplevel print options,[ignore ops=V]). V = true

In the next exercise, you are asked to implement a predicate allowing lists to be shown in the dot-notation. Exercise 2.4. Based on sharp/2 from Exercise 2.1, deÔ¨Åne a predicate dot/1 for displaying lists in the dot-notation as exempliÔ¨Åed by the following query.
?- dot([a, [b, [], [c, a], e]]). .(a, .(.(b, .([], .(.(c, .(a, [])), .(e, [])))), []))

Thus the predicate dot/1 will be something akin to write term/2 (with the Ô¨Çag ignore ops set to true ). However, lists within Prolog terms with other than the dot-functor should be displayed by dot/1 in the square bracket notation:
?- dot([a, [b, [], fun([c, a]), e]]). .(a, .(.(b, .([], .(fun([c, a]), .(e, [])))), []))

Hint. Proceed along the following lines. ‚Ä¢ Use the built-in predicate term to atom/2 to convert the list in the sharp-notation to an atom.

46 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Built-in Predicate: term to atom(?Term,?Atom) The atom Atom corresponds to the term Term . Example: ?- term to atom(fun1(a,fun2(c),d),A). A = ‚Äôfun1(a, fun2(c), d)‚Äô

‚Ä¢ Convert the atom into a list of one-character atoms by using the built-in predicate atom chars/2 (c.f. p. 126). ‚Ä¢ DeÔ¨Åne a predicate sharps to dots/2 by the accumulator technique for converting sharps to dots.5 Example:
?- sharps_to_dots([#, ‚Äô(‚Äô, a, ‚Äô,‚Äô, ‚Äô[‚Äô, ‚Äô]‚Äô, ‚Äô)‚Äô],D). D = [‚Äô.‚Äô, ‚Äô(‚Äô, a, (‚Äô,‚Äô), ‚Äô[‚Äô, ‚Äô]‚Äô, ‚Äô)‚Äô]

5 Alternatively,

the built-in function maplist/3 from p. 127 may be used to deÔ¨Åne sharps to dots/2 .

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

47 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

‚Ä¢ Finally, concatenate the list of one-character atoms thus obtained to an atom by using concat atom/2 from p. 126. Also show the result.

2.2.2

Flattening Lists by append/3
Prolog Code P-2.1: Clocksin‚Äôs deÔ¨Ånition of flatten/2
1 2 3 4 5

Another implementation6 of flatten/2 , proposed by Clocksin in [1], p. 58, uses the predicate append/3 :

flatten_3([],[]). flatten_3([H|T],L1) :- flatten_3(H,L2), flatten_3(T,L3), append(L2,L3,L1). flatten_3(X,[X]).

% clause 1 % clause 2 % % % clause 3

This deÔ¨Ånition is easily understood through a declarative reading: ‚Ä¢ Clause 1: This is the base case. It says that an empty list is Ô¨Çattened into an empty list. ‚Ä¢ Clause 2: This is the recursive step. A list [H|T] (whose head H is possibly a list itself) is Ô¨Çattened in the following steps. 1. Flatten the head H . 2. Flatten the tail T . 3. Concatenate the latter two Ô¨Çattened lists. ‚Ä¢ Clause 3: The Ô¨Çattened version of a term that uniÔ¨Åes neither with [] nor with [H|T] is the term itself. This clause is intended to cater for the case of list entries which are not themselves lists; a ground atom (i.e. a one without a variable) is an example thereof. List Ô¨Çattening deÔ¨Åned by (P-2.1) works as intended for (nested) lists whose tree representation has leaves which are ground atoms or are terms with other than the dot functor; for example,
?- flatten_3([a,[b,[f(X,d),[]],[c,f(X),a],e]],L). X = _G414 L = [a, b, f(_G414, d), c, f(_G414), a, e]

However, lists some of whose leaves are free variables, won‚Äôt be correctly Ô¨Çattened by flatten 3/2 :
?- flatten_3([a,[Y,[b,X]],c,f(X)],L). Y = [] X = [] L = [a, b, c, f([])]

Exercise 2.5. Augment the deÔ¨Ånition of flatten 3/2 such that it correctly handles also lists involving free variables. Another (though easy to rectify) shortcoming of flatten 3/2 is that on backtracking it will return spurious solutions:
6 We count this implementation as version 3 as you will Ô¨Ånd, in connection with the solution of Exercise 2.3, a ‚Äòversion 2‚Äô is discussed in Appendix A.2 on p. 147.

48 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

?- flatten 3([a, [b, [], [c, a], e]],L). L = [a, b, c, a, e] ; L = [a, b, c, a, e, []]

Your improved implementation (version 4) should solve also this problem.

2.2.3

flatten/2 by the DiÔ¨Äerence List Technique

(P-2.2) shows a clause-by-clause ‚Äòtranslation‚Äô of the deÔ¨Ånition of flatten 3/2 in terms of diÔ¨Äerence lists ([1], p. 58). Prolog Code P-2.2: DiÔ¨Äerence list based deÔ¨Ånition of flatten/2
1 2 3 4 5 6

% % flatten_dl([],L-L). % flatten_dl([H|T],L1-L3) :- flatten_dl(H,L1-L2), % flatten_dl(T,L2-L3). % flatten_dl(X,[X|Z]-Z). %

flatten_5(L,F) :- flatten_dl(L,F-[]), !.

clause 1 clause 2 clause 3 clause 4

The append goal does not appear in (P-2.2) as list concatenation is now accomplished by diÔ¨Äerence lists. flatten 5/2 will behave identically to flatten 3/2 except that its solution is unique because of the cut (! ) in clause 1. Exercise 2.6. The predicate flatten 5/2 in (P-2.2) won‚Äôt correctly Ô¨Çatten lists involving free variables. Modify (P-2.2) to resolve this problem.

2.2.4

Comparing DiÔ¨Äerent Versions

We have developed several versions of flatten/2 in the previous section and now their relative performance will be assessed. To do this, we need a way of generating nested lists which are ‚Äòcomplicated‚Äô enough to cause a noticeable amount of computing time when Ô¨Çattened. A predicate nested(+Num,-List) will prove useful for this purpose: given the positive integer Num , List should be uniÔ¨Åed with a nested list in the following fashion:
?- nested(9,L). L = [[[[[[[[[1], 2], 3], 4], 5], 6], 7], 8], 9]

Exercise 2.7. DeÔ¨Åne the predicate nested/2 by the accumulator technique and then use it to time the performance of the various versions of flatten/2 by the built-in predicate time/1 .

49 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

2.3

Implementations of List Reversal

There are several ways we can deÔ¨Åne our own version of the built-in predicate reverse/2 . Its Ô¨Årst implementation (P-2.3) uses append/2 . Prolog Code P-2.3: First implementation of reverse/2
1 2 3

reverse_1([],[]). % clause 1 reverse_1([H|T],R) :- reverse_1(T,L), % clause 2 append(L,[H],R). %

A declarative reading of clause 2 in (P-2.3) is suggested in Fig. 2.4. H ¬¶ ' T ' L R Figure 2.4: Declarative Reading of (P-2.3) Another implementation of list reversal, now by the accumulator technique, is by (P-2.4) (see Example 1.1, p. 16): Prolog Code P-2.4: A second implementation of reverse/2
1 2 3

E T

E ¬§ c H

reverse([],R,R). % clause 1 reverse([H|T],Acc,R) :- reverse(T,[H|Acc],R). % clause 2 reverse_2(L,R) :- reverse(L,[],R). % clause 3

(P-2.3) may be rewritten in terms of diÔ¨Äerence lists as follows: Prolog Code P-2.5: DeÔ¨Ånition of reverse/2 by diÔ¨Äerence lists
1 2 3 4

rev_dl([],L-L). rev_dl([X],[X|L]-L). rev_dl([H|T],L1-L3) :- rev_dl(T,L1-L2), rev_dl([H],L2-L3). reverse_3(L,R) :- rev_dl(L,R-[]), !.

% clause (a1) % clause (a2) % clause (a3) %

5

Notice that clause (a2) in (P-2.5) does not directly correspond to any of the clauses in (P-2.3); it simply deÔ¨Ånes the diÔ¨Äerence list representation of (the reverse of) a list with a single entry.

50 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

2.3.1

Program Transformations

The performance of a predicate with a given deÔ¨Ånition can sometimes be enhanced by employing certain transformations leading to a new but logically equivalent form. Even though this topic is not directly related to the diÔ¨Äerence list technique, it is opportune to address this issue here. SpeciÔ¨Åcally, we are going to demonstrate how the three clauses (a1)‚Äì(a3) in (P-2.5) can be transformed by folding and unfolding into the logically equivalent clauses (b1)‚Äì(b2) in (P-2.6):

Prolog Code P-2.6: Concise deÔ¨Ånition of rev dl/2
1 2

rev_dl([],L-L). % clause (b1) rev_dl([H|T],L1-L2) :- rev_dl(T,L1-[H|L2]). % clause (b2)

(For an in-depth exposition of both folding and unfolding, see [9].)

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

51 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

Unfolding Let us assume that we have in our Prolog knowledge base two clauses of the following form: A C Then the clause A :‚àí B1 , ..., Bm , D1 , ..., Dk , Bm+1 , ..., Bn . (2.3) : ‚àí B1 , ..., Bm , C, Bm+1 , ..., Bn . : ‚àí D1 , ..., Dk . (2.1) (2.2)

is a logical consequence of (2.1)‚Äì(2.2), inferred by an Elementary Unfolding Operation. Equation (2.3) is said to have been obtained by unfolding (2.1) upon the goal C . We note that, ‚Ä¢ The requirement that the head of one clause be identical to one of the goals in the body of another clause can be relaxed to the two unifying. (This is a mere reÔ¨Çection on Prolog‚Äôs inference mechanism.) ‚Ä¢ In general, the new clause (2.3) won‚Äôt be a replacement for (2.1) since in the database there may be other clauses whose head is identical to (or uniÔ¨Åes with) the goal C in (2.1). To replace a clause like (2.1), we would have to carry out each and every possible elementary unfolding operation on the goal C in (2.1); in such a case, a Complete One Step Unfolding (COSU) is said to have been carried out. ‚Ä¢ Finally, the two clauses (2.1) and (2.2) need not be distinct; they may be replicas of one and the same clause from the database. In fact, for a COSU, also such ‚Äôself-unfoldings‚Äô have to be considered. (This may be of interest for recursively deÔ¨Åned predicates.) Let us now turn to our speciÔ¨Åc example: we want to do a COSU on the call rev dl([H],L2-L3) in clause (a3) of (P-2.5). We represent the clauses (a1)‚Äì(a3) in (P-2.5) equivalently by (P-2.7) Prolog Code P-2.7: Equivalent form of (a1)‚Äì(a3) in (P-2.5)
1 2 3 4

rev_dl([],L-L) :- true. rev_dl([X],[X|L]-L) :- true. rev_dl([U|V],W1-W3) :- rev_dl(V,W1-W2), rev_dl([U],W2-W3).

and then seek to unify in turn the head of each with the term rev dl([H],L2-L3) . This can be done ‚Äòby hand‚Äô, or, more reliably, by using Prolog‚Äôs uniÔ¨Åcation mechanism:
?- rev_dl([],L-L) = rev_dl([H],L2-L3). No ?- rev_dl([X],[X|L]-L) = rev_dl([H],L2-L3). X = _G372 L = _G376 H = _G372 L2 = [_G372|_G376] L3 = _G376 Yes ?- rev_dl([U|V],W1-W3) = rev_dl([H],L2-L3). U = _G372

52 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

V = [] W1 = _G375 W3 = _G376 H = _G372 L2 = _G375 L3 = _G376 Yes

The Ô¨Årst uniÔ¨Åcation attempt fails. The second uniÔ¨Åcation succeeds and gives rise to the clause
rev_dl([_G372|T],L1-_G376) :- rev_dl(T,L1-[_G372|_G376]), true.

The third uniÔ¨Åcation also succeeds, giving rise to the clause
rev_dl([_G372|T],L1-_G376) :- rev_dl(T,L1-_G375), rev_dl([],_G375-W2), rev_dl([_G372],W2-_G376).

(This last step is an instance of an elementary unfolding operation involving self-unfolding.) The one step unfolding operation is now complete and the last two clauses thus obtained may replace clause (a3) in (P-2.5). The new database is shown in (P-2.8).7 Prolog Code P-2.8: Partially transformed clauses
1 2 3 4 5 6

rev_dl([],L-L). % rev_dl([X],[X|L]-L). % rev_dl([H|T],L1-L2) :- rev_dl(T,L1-[H|L2]). % rev_dl([H|T],L1-L3) :- rev_dl(T,L1-L2), % rev_dl([],L2-W), % rev_dl([H],W-L3). %

clause clause clause clause

(a1) (a2) (a3.1) (a3.2)

As is illustrated here, the new database after unfolding is not smaller than the initial one. We shall, however, shortly identify the clauses (a2) and (a3.2) in (P-2.8) as redundant. Clause (a2) in (P-2.8) is redundant for it may be inferred from (a1) and (a3.1) in an elementary unfolding operation on the call rev dl(T,L1-[H|L2]) in clause (a3.1).8 The requisite uniÔ¨Åcation is
?- rev_dl([],L-L) = rev_dl(T,L1-[H|L2]). L = [_G360|_G361] T = [] L1 = [_G360|_G361] H = _G360 L2 = _G361 Yes

It gives rise to the clause
rev_dl([_G360|[]],[_G360|_G361]-_G361) :- true.

which, after some variable renaming, is recognized as clause (a2) in (P-2.8). It is seen that sometimes the database may be reduced by showing that one of its clauses can be inferred from the other ones by unfolding. Here, for a further reduction of the database we need another technique, called folding.
7 Notice 8 As

that some of the variables are renamed when writing down (P-2.8). before, read clause (a1) in (P-2.8) as rev dl([],L-L):- true.

53 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Folding Let us assume that we have two clauses in the Prolog database that are of the form A : ‚àí B1 , ..., Bm , C, Bm+1 , ..., Bn . D : ‚àí C. (2.4) (2.5)

Let us furthermore assume that (2.5) is the only clause in the database whose head is the term D. Then, if during the computation it is found that the goal D succeeds, we can infer that also C holds.9 We can therefore augment the database by the clause A :‚àí B1 , ..., Bm , D, Bm+1 , ..., Bn . (2.6)

called the folding of clause (2.4). A more general formulation says that if some term D is found to hold which uniÔ¨Åes with D, then A :‚àí B1 , ..., Bm , D , Bm+1 , ..., Bn .

may be inferred in lieu of clause (2.6). We now want to apply these ideas to eliminate clause (a3.2) in (P-2.8). As a Ô¨Årst step, we show that the clauses
L1 = L2 :- rev_dl([],L1-L2). % clause (c1) W1 = [E|W2] :- rev_dl([E],W1-W2). % clause (c2)

are a logical consequence of (a1) and (a3.1) in (P-2.8).10 To justify (c1), we observe that ‚Ä¢ Clause (a1) is equivalent to
rev_dl([],L1-L2) :- L1 = L2. % clause (d)

‚Ä¢ The term rev dl([],L1-L2) does not unify with any of the heads in (a1) and (a3.1) hence we may infer clause (c1) from clause (d). (This reasoning is identical to that for justifying folding.) To justify (c2), we observe that ‚Ä¢ rev dl([E],W1-W2) will unify with the head of clause (a3.1) only:
?- rev dl([E],W1-W2) = rev dl([H|T],L1-L2). E = _G372 W1 = _G375 W2 = _G376 H = _G372 T = [] L1 = _G375 L2 = _G376 Yes
9 In the absence of clause (2.5), the query ?- not(D). would succeed by the Closed World Assumption which states that the negation of anything which cannot be inferred from the database is deemed true. Therefore, D can only hold if C holds. 10 More precisely, (c1) and (c2) are a consequence of the completion of (a.1) and (a3.1).

54 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

‚Ä¢ We may therefore infer the ‚Äòreverse‚Äô of clause (a3.1) with the above instantiation pattern as
rev_dl([],_G375-[_G372|_G376]) :- rev_dl([_G372|[]],_G375-_G376).

or, in a more readable format,
rev_dl([],W1-[E|W2]) :- rev_dl([E],W1-W2). % clause (e)

‚Ä¢ Finally, we use clause (e) rev dl([],L1-L2) in clause (c1).

to

obtain

clause

(c2)

by

unfolding

on

the

call

To infer now clause (a3.2) from (a1) and (a3.1) we hypothesize the body (i.e. the conjunction of the goals) of (a3.2):
rev_dl(T,L1-L2), rev_dl([],L2-W), rev_dl([H],W-L3).

We infer by clause (c1) that
L2 = W.

and therefore
rev_dl([H],L2-L3).

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

55 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

from which by clause (c2)
L2 = [H|L3].

and therefore
rev_dl(T,L1-[H|L3]) :- true.

Unfold now clause (a3.1) to get
rev_dl([H|T],L1-L3).

which is indeed the head of clause (a3.2).11 An interpretation of clause (b2) in (P-2.6) is shown in Fig. 2.5. It admits the following declarative interpreH ¬¶ ' T ' L1 - [H|L2] L1 Figure 2.5: Illustrating Clause (b2) in (P-2.6) tation: The diÔ¨Äerence list L1-L2 is the reverse of the list [H|T] if the diÔ¨Äerence list L1-[H|L2] is the reverse of T . (This shows once again that we can think of diÔ¨Äerence lists as if they were true diÔ¨Äerences of lists!) Exercise 2.8. Time the performance of the four versions of reverse/2 and comment on the results. You should generate long lists (of consecutive integers) by using the built-in predicates between/3 and findall/3 .12 E T E ¬§ c H [H|L2] L2

Exercise 2.9. Fig. 2.6 is an analogue of Fig. 2.5 for an enhanced implementation of reverse/2 , also based on the diÔ¨Äerence list technique. (a) Give a declarative reading of Fig. 2.6. (b) DeÔ¨Åne a new version of reverse/2 based on Fig. 2.6. (c) Obtain your new version also by unfolding clause (b2).
foregoing reasoning is an instance of the application of the Implication Introduction Rule in Propositional Calculus. is identical to bagof/3 (see p. 41) except that findall/3 will return the empty list and succeed in cases where bagof/3 fails.
12 findall/3 11 The

56 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

(d) Assess the new version‚Äôs behaviour as in Exercise 2.8. (e) What would be a further enhancement to this implementation and how could the idea be generalized?

E1 ¬¶ '

E2 ¬¶ T '

E T ¬§ c E2

E ¬§ c E1 [E2,E1|L2] L2

L1 - [E2,E1|L2] L1

Figure 2.6: Illustrating Exercise 2.9

2.3.2

DiÔ¨Äerence Lists as Accumulators

Close inspection of clause (b2) in (P-2.6) reveals another interesting feature. If rev dl is interpreted as a predicate with arity 3 then its third argument may be thought of as an accumulator akin to the second argument of reverse/3 in (P-2.4), p. 50. The other two arguments also correspond to each other accordingly. This shows, perhaps surprisingly, that two techniques based on entirely diÔ¨Äerent approaches may result in the same implementation. (You will Ô¨Ånd some other examples on the similarity of the two techniques in [16], pp. 243‚Äì244.)

2.4

Case Study: Dijkstra‚Äôs Dutch Flag Problem

We use Dijkstra‚Äôs Dutch Flag Problem (e.g. [16]) to illustrate how a predicate deÔ¨Åned in terms of append/3 can be recast to a more eÔ¨Écient form by the diÔ¨Äerence list technique. A list of terms of the form col(Object,Colour) is deÔ¨Åned by the predicate items/1 where Colour is one of the Dutch national colours, i.e. red, white or blue.
items([col(sky,blue), col(tomato,red), col(milk,white), col(blood,red), col(ocean,blue), col(cherry,red), col(snow,white)]).

We want to deÔ¨Åne a predicate dijkstra/2 for arranging the items in the order of the Dutch Ô¨Çag‚Äôs colours. Within each colour group, the original order should be retained:
?- items( Items), dijkstra( Items,Grouped). Grouped = [col(tomato, red), col(blood, red), col(cherry, red), col(milk, white), col(snow, white), col(sky, blue), col(ocean, blue)]

57 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

2.4.1

Basic Implementation Using append/3

The idea for a basic version of dijkstra/2 is as follows. We deÔ¨Åne three predicates ‚Äî one for each colour ‚Äî for returning the list of items of that particular colour. These lists are then concatenated to a list of grouped items. Below is shown the deÔ¨Ånition of reds(+Items,-Reds) ; the other two predicates are deÔ¨Åned in an analogous manner. Prolog Code P-2.9: DeÔ¨Ånition of reds/2
1 2 3 4

reds([],[]). % clause 1 reds([col(Object,red)|T],[col(Object,red)|L]) :- reds(T,L). % clause 2 reds([col(_,Colour)|T],L) :- Colour \= red, % clause 3 reds(T,L). %

(P-2.9) is a straightforward recursive deÔ¨Ånition supported by the following declarative reading: ‚Ä¢ Clause 1: If Items is the empty list then Reds will be empty. ‚Ä¢ Clause 2: Assume that the list L comprises all red entries of T . Then, the same relationship holds for the lists [Item|L] and [Item|T] if Item is red. ‚Ä¢ Clause 3: Assume again that the list L comprises all red entries of T . Also assume that Item is not red. Then, L comprises all red entries of the augmented list [Item|T] . reds/2 behaves as expected,
?- items( Items), reds( Items,Reds). Reds = [col(tomato, red), col(blood, red), col(cherry, red)]

dijkstra/2 may now be deÔ¨Åned by (P-2.10). Prolog Code P-2.10: A Ô¨Årst deÔ¨Ånition of dijkstra/2
1 2 3 4 5

dijkstra(Items,Grouped) :- reds(Items,R), whites(Items,W), blues(Items,B), append(R,W,RandW), append(RandW,B,Grouped).

2.4.2

A More Concise Version

The predicates reds/2 , whites/2 and blues/2 from Sect. 2.4.1 are structurally identical; their structure is captured by that of colour/3 in (P-2.11). Prolog Code P-2.11: DeÔ¨Ånition of colour/3
1 2 3 4

colour(_,[],[]). colour(Clr,[col(Object,Clr)|T],[col(Object,Clr)|L]) :- colour(Clr,T,L). colour(Clr,[col(_,Colour)|T],L) :- Colour \= Clr, colour(Clr,T,L).

58 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

It is clear that once the Ô¨Årst argument of colour/3 is instantiated to a particular colour, it will behave as the predicate for the corresponding colour; for example,
?- items( Items), colour(red, Items,Reds). Reds = [col(tomato, red), col(blood, red), col(cherry, red)]

This suggests a second implementation of dijkstra/2 , shown in (P-2.12). Prolog Code P-2.12: A second deÔ¨Ånition of dijkstra/2
1 2 3 4 5

dijkstra(Items,Grouped) :- colour(red,Items,R), colour(white,Items,W), colour(blue,Items,B), append(R,W,RandW), append(RandW,B,Grouped).

2.4.3

Using DiÔ¨Äerence Lists

As dijkstra/2 uses list concatenation by append/3 , it is a candidate for being recast in terms of diÔ¨Äerence lists.

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

59 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

‚Ä¢ First, we deÔ¨Åne colour dl/3 in (P-2.13) by using diÔ¨Äerence lists. Prolog Code P-2.13: DeÔ¨Ånition of colour dl/3
1 2 3 4 5 6

colour_dl(_,[],L-L). colour_dl(Clr,[col(Object,Clr)|T],[col(Object,Clr)|L1]-L2) :colour_dl(Clr,T,L1-L2). colour_dl(Clr,[col(_,Colour)|T],L1-L2) :Colour \= Clr, colour_dl(Clr,T,L1-L2).

‚Ä¢ Then, we concatenate in (P-2.14) the three lists of groups by dijkstra dl/2 . Prolog Code P-2.14: DeÔ¨Ånition of dijkstra dl/2
1 2 3

dijkstra_dl(Items,L1-L4) :- colour_dl(red,Items,L1-L2), colour_dl(white,Items,L2-L3), colour_dl(blue,Items,L3-L4).

‚Ä¢ Finally, in (P-2.15) the grouped list Grouped (as a true list) is obtained by unifying the diÔ¨Äerence list with Grouped-[] . Prolog Code P-2.15: dijkstra/2 based on diÔ¨Äerence lists
1

dijkstra(Items,Grouped) :- dijkstra_dl(Items,Grouped-[]).

Exercise 2.10. All versions of dijkstra/2 discussed thus far need three passes through the input list, one for each colour. This ineÔ¨Éciency is avoided by the version deÔ¨Åned by (P-2.16)‚Äì(P-2.17). Prolog Code P-2.16: DeÔ¨Ånition of colour/4
1 2 3 4

colour([],[],[],[]). colour([col(Object,red)|T],[col(Object,red)|R],W,B) :- colour(T,R,W,B). colour([col(Object,white)|T],R,[col(Object,white)|W],B) :- colour(T,R,W,B). colour([col(Object,blue)|T],R,W,[col(Object,blue)|B]) :- colour(T,R,W,B).

Prolog Code P-2.17: dijkstra/2 based on colour/4
1 2 3

dijkstra(Items,Grouped) :- colour(Items,R,W,B), append(R,W,RandW), append(RandW,B,Grouped).

(colour/4 features as an ‚Äòamalgamation‚Äô of the predicates reds/2 , whites/2 and blues/2 from Sect. 2.4.1.) (a) Rewrite colour/4 and dijkstra/2 (from (P-2.17)) by using diÔ¨Äerence lists. Compare the performance of all versions of dijkstra/2 available thus far by using time/1 . (b) The version of dijkstra/2 from (P-2.17) as well as its diÔ¨Äerence list based version from (a) will fail if one of the entries in Items is not coloured red, white or blue. Augment both predicates to avoid failure for such inputs. (As before, Grouped should comprise exactly the items in the Dutch national colours.)

60 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

2.5
2.5.1

Rotations
Rotating a List

Sometimes it is required to create a new (output) list by rotating some input list. We have met an example thereof in Sect. 1.6 where in the course of the Perceptron Training Algorithm, the predicate transform/2 , deÔ¨Åned in (P-1.15), p. 33, subjected some list of P s to a rotation. This meant that if [P|OtherPs] is uniÔ¨Åed with the list of training points [p1 , p2 , ¬∑ ¬∑ ¬∑ , pN ], say, then transform/2 will return in NewPs the ‚Äôrotated‚Äô list [p2 , ¬∑ ¬∑ ¬∑ , pN , p1 ]. (The list of desired class labels [D|OtherDs] is subjected by transform/2 to the same transformation.) In (P-1.15), rotation was achieved by using append/3 . DiÔ¨Äerence lists oÔ¨Äer a constant‚Äìtime alternative to accomplish the same (e.g. [1]) if the original list is a diÔ¨Äerence list; example:
?- [a1,a2,a3,a4|X]-X = [H|Y]-[H|Z], R = Y-Z. X = [a1|_G397] H = a1 Y = [a2, a3, a4, a1|_G397] Z = _G397 R = [a2, a3, a4, a1|_G397]-_G397

Fig. 2.7 spells out how the above result can be modelled in terms of diÔ¨Äerences of lists. [a1,a2,a3,a4|X]-X a1 a2 a3 a4 X [H|Z] H Y-[H|Z] = [a2,a3,a4] H [a1]Y-Z = [a2,a3,a4,a1] [H|Y] Y Z

[H|Y]-[H|Z]

Figure 2.7: Rotating by DiÔ¨Äerence Lists This idea easily carries over to more sophisticated schemes of computation where the result is based on some input from the ‚Äòfront‚Äô being transformed and placed to the ‚Äòback‚Äô. For example, the core for computing the averages of consecutive entries in a list of numbers may look like this:
?- [1,2,3,4|X]-X = [H1,H2|Y]-[Last|Z], Last is (H1 + H2)/2, R = [H2|Y]-Z. ... R = [2, 3, 4, 1.5|_G574]-_G574

61 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Exercise 2.11. Based on the above query, deÔ¨Åne averages dl(+DL,-ADL) for computing the pairwise averages of adjacent numbers in a list of positive integers. Both, DL and ADL are represented in the diÔ¨Äerence list format. Example:
?- averages dl([4,8,16,32| X]- X,ADL). ADL = [6, 12, 24| G426]- G426 ; No

Outline Idea. A version based on ordinary lists is shown in (P-2.18). Prolog Code P-2.18: DeÔ¨Ånition of averages/2
1

averages(L,A) :- aver([-1,1|L],A), !. aver([_,0,_|T],T). aver(X,Result) :- av_rotate(X,Y), aver(Y,Result).

% clause 1 % clause 2 % clause 3 %

2 3 4

5 6

av_rotate([H1,H2|Y],L) :- Last is (H1 + H2)/2, % clause 4 append([H2|Y],[Last],L). %

The auxiliary predicate av rotate/2 is the ordinary list based version of the ‚Äòcompute-the-average-and-rotate‚Äô function. Let us show an example of how averages/2 will behave:
?- averages([4,8,16,32],A). A = [6, 12, 24] ; No

It is seen that the list for which the averages are to be computed is Ô¨Årst appended to [-1,1]. This augmented list is then transformed by repeated application of av rotate/2 (via a recursive call to aver/2 ) until the zero (i.e. the average of the Ô¨Årst two entries) moves to the second position. The Ô¨Ånal result is then obtained by removing the Ô¨Årst three entries of the list thus returned. (See also the hand computations in Fig. 2.8.) Rewrite the above deÔ¨Ånition in terms of diÔ¨Äerence lists. averages([4,8,16,32], A) aver([-1,1,4,8,16,32], A) aver([4,8,16,32,0,2.5], A)

:; :; aver([1,4,8,16,32,0], A) :; :; aver([8,16,32,0,2.5,6], A) :; :; aver([32,0,2.5,6,12,24], A) :; :; A = [6,12,24]) :; success
2 1 3 3 3 3 3

1

aver([16,32,0,2.5,6,12], A)

aver([32,0,2.5 | [6,12,24]], A)

Figure 2.8: Hand Computations for averages/2 Notes.

62 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

‚ù∂ We may use this deÔ¨Ånition to implement afresh the averaging of ordinary lists of positive integers. We do this by Ô¨Årst converting the original list to a diÔ¨Äerence list by dl/2 , deÔ¨Åned in (P-2.19). Prolog Code P-2.19: dl/2 for list to diÔ¨Äerence list
1 2

dl([],L-L). % clause 1 dl([H|T],[H|L1]-L2) :- dl(T,L1-L2). % clause 2

Then, the list of averages may be computed thus.
?- dl([4,8,16,32], DL), averages dl( DL,A-[]). A = [6, 12, 24] ; No

‚ù∑ The diÔ¨Äerence list based version is faster than the one using append/3 . Faster still is the predicate deÔ¨Åned by simple recursion in (P-2.20).

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩ for Engin

M

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction M supervisor ina cons I was the North Sea supe advising and the N he helping foremen advi s solve problems Real work he helping International Internationa al opportunities ÔøΩree wo work or placements s solve p
Click on the ad to read more

63 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Prolog Code P-2.20: averages/2 by recursion
1 2 3

averages2([_],[]). averages2([H1,H2|T],[A|AS]) :- A is (H1 + H2) / 2, averages2([H2|T],AS).

Exercise 2.12. Give a pictorial illustration of clause 2 of dl/2 in (P-2.19). Based on this illustration, give it a declarative reading. The term ‚Äòrotation‚Äô is justiÔ¨Åed by the following consideration. We imagine the list entries to be labels to movable beads threaded onto a circular wire. Our ‚Äòrotation‚Äô corresponds to each bead moving one position to the left. The crucial step here is the identiÔ¨Åcation (or ‚Äòglueing together‚Äô) of both ends of the list. (See Fig. 2.9.)

‚Üí

a3 ‚Üí a2 m a4 ‚Üê a1

Figure 2.9: Rotating a List with Four Entries

‚Üí

2.5.2

The Perceptron Training Algorithm Revisited

As indicated before, there is scope for improving the Prolog implementation of the Perceptron Training Algorithm from Sect. 1.6 by using diÔ¨Äerence lists. Carrying out the two rotations via diÔ¨Äerence lists, we now have a new clause of transform/2 in (P-2.21).13 Prolog Code P-2.21: An additional clause for transform/2
1 2 3 4

transform(in(C,[P|TP1]-[P|TP2],[D|TD1]-[D|TD2],Ws,Acc), in(C,TP1-TP2,TD1-TD2,NewWs,NewAcc)) :perceptron(C,P,D,Ws,NewWs), NewAcc is Acc + 1.

The stopping criterion, originally implemented by classify all/3 in (P-1.14), p. 33, is also rewritten to accomodate diÔ¨Äerence lists; this is in (P-2.22). Prolog Code P-2.22: Additional clauses for classify/3
1 2 3 4

classify_all(L-_,_,L1-L1) :- var(L). classify_all([P|TP1]-TP2,Weights,[Class|TC1]-TC2) :classify(P,Weights,Class), !, classify_all(TP1-TP2,Weights,TC1-TC2).

13 See

(P-1.15), p. 33, for the original deÔ¨Ånition of transform/2 .

64 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

(P-2.21) and (P-2.22) are placed in the Ô¨Åle where the earlier deÔ¨Ånitions are, as all previous deÔ¨Ånitions should still apply.14 (The new clauses won‚Äôt clash with existing deÔ¨Ånitions.) To convert the list of training points and the list of desired class labels to diÔ¨Äerence lists, we use the predicate dl/2 from Exercise 2.11. With these additions then, we are now ready to run and conÔ¨Årm the computational advantage of the new version:15
?- ws(Ws), ps(_Ps), ds(_Ds), time(pta(0.25,_Ps,_Ds,Ws,W,801)). % 41,335 inferences in 0.38 seconds (108776 Lips) Ws = [-0.51, -0.35, 0.13] W = [3.018, 4.1935, -39.87] ?- ws(Ws), ps(_Ps), ds(_Ds), dl(_Ps,_PsDL), dl(_Ds,_DsDL), time(pta(0.25,_PsDL,_DsDL,Ws,W,801)). % 28,519 inferences in 0.28 seconds (101854 Lips) Ws = [-0.51, -0.35, 0.13] W = [3.018, 4.1935, -39.87]

(We have excluded from the timing the conversions to diÔ¨Äerence lists by dl/2 as they present a constant computational overhead whose relative contributions will be negligible as the number of iterations is increased.)

2.5.3

Planar Rotations16

To extend the notion of ‚Äòrotation‚Äô from lists to matrices, we consider list rotations once again. One way to rotate the list L = [a1 , a2 , a3 , a4 ] is indicated in Fig. 2.10: 1. Copy L inÔ¨Ånitely many times along the line. 2. Shift the frame of L by one cell to the right. The framed entries form the rotated list. 3. Several successive rotations will be achieved by shifting the frame the requisite number of cells to the right. ¬∑¬∑¬∑ ¬∑¬∑¬∑

a2

a3

a4

a1 E

a2

a3

a4

a1

a2

a3

a4

a1

Figure 2.10: The Original List and its Rotated Image We want to consider the analogous construction in the plane. A two‚Äìdimensional rectangular pattern (i.e. a matrix ) of entries is given; this may be, for example, the three by four matrix a11 A = ‚é£ a21 a31 ‚é° a12 a22 a32 a13 a23 a33 ‚é§ a14 a24 ‚é¶ a34

(2.7)

We tile the entire plane with copies of A and shift a three rotated matrix ‚é° a22 a23 A(rot) = ‚é£ a32 a33 a12 a13

by four frame from A to South‚ÄìEast to obtain the a24 a34 a14 ‚é§ a21 a31 ‚é¶ a11

65 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

¬∑¬∑¬∑

¬∑¬∑¬∑

¬∑¬∑¬∑

¬∑¬∑¬∑

¬∑¬∑¬∑

¬∑¬∑¬∑ ¬∑¬∑¬∑

¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑

a34 a31 a32 a33 a34 a31 a32 ¬∑ ¬∑ ¬∑ d a14 a11 a12 a13 a14 a 11 d a12 ¬∑ ¬∑ ¬∑ ¬Ç a24 a21 a22 a23 a24 a21 a22 ¬∑ ¬∑ ¬∑ a34 a31 a32 a33 a34 a31 a32 ¬∑ ¬∑ ¬∑ a11 a12 a13 a14 a11 a12 ¬∑ ¬∑ ¬∑ a14 d ¬Ç d a24 a21 a22 a23 a24 a21 a22 ¬∑ ¬∑ ¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑

Figure 2.11: The Original Matrix A and its Rotated Image A(rot)

This is illustrated in Fig. 2.11. (Several such moves may be used for successive rotations.) The argument to justify the term ‚Äòrotation‚Äô is now more involved. We Ô¨Årst identify the two horizontal edges of the matrix and glue them together. The result is a tube which then is treated as a Ô¨Çexible pipe. Then, both ends of the pipe are glued together such that the Ô¨Årst and last entries of each matrix row meet. What we then have is a torus covered with the mesh of the matrix entries. Our ‚Äòrotation‚Äô corresponds to each entry moving to its neighbouring North‚ÄìWestern cell. Implementation Initially, a matrix will be represented as a list of its rows which themselves are written as lists. Therefore, for example, the matrix A in (2.7) may be deÔ¨Åned by (P-2.23). Prolog Code P-2.23: DeÔ¨Ånition of matrix a/1
1 2 3

matrix_a([[ a11, a12, a13, a14], [ a21, a22, a23, a24], [ a31, a32, a33, a34]]).

(This is then a list of lists of Prolog atoms.) Using Proper Lists. Rotations will be carried out in two stages as indicated in Fig. 2.12. First, in step the list representations of rows undergo a rotation each; this is implemented by rot rows/2 in (P-2.24).
14 All

¬∑¬∑¬∑

1

,

code pertinent to the Perceptron Training Algorithm is replicated in the Ô¨Åle dl.pl. similar result applies when calling pta/6 with a variable in its last argument. 16 This section and the next are based on [4]. The author thankfully acknowledges the permission by Elsevier to republish this material here.
15 A

66 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

[ [a11 , [a21 , [a31 ,

a12 , a22 , a32 ,
2

a13 , a23 , a33 ,

a14 ], a24 ], a34 ] ] a23 , a33 , a13 ,

:;

1

[ [a12 , [a22 , [a32 ,

a13 , a23 , a33 ,

a14 , a24 , a34 ,

a11 ], a21 ], a31 ] ]

:;

[ [a22 , [a32 , [a12 ,

a24 , a34 , a14 ,

a21 ], a31 ], a11 ] ]

Figure 2.12: Hand Computations for Rotation in the Plane

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

67 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

Prolog Code P-2.24: DeÔ¨Ånition of rot rows/2
1 2 3

rot_rows([],[]). % clause 1 rot_rows([[H|T]|Ls],[R|Rs]) :- append(T,[H],R), !, % clause 2 rot_rows(Ls,Rs). %
2

Then, in step

, the ‚Äòoutside‚Äô list is rotated by the predicate rot matrix/2 in (P-2.25). Prolog Code P-2.25: DeÔ¨Ånition of rot matrix/2

1 2

rot_matrix(M,R) :- rot_rows(M,[H|T]), % clause 1 append(T,[H],R). %

The timed rotation of A will look like this:
?- matrix a(A), time(rot matrix(A,R)). % 20 inferences in 0.00 seconds (Infinite Lips) A = [[a11,a12,a13,a14], [a21,a22,a23,a24], [a31,a32,a33,a34]] R = [[a22,a23,a24,a21], [a32,a33,a34,a31], [a12,a13,a14,a11]]

Using DiÔ¨Äerence Lists. All lists will be replaced by diÔ¨Äerence lists; in particular, matrices are now diÔ¨Äerence lists of diÔ¨Äerence lists. We need a way of converting the old matrix representation to its new equivalent. This will be achieved by the predicate dl2(+LOfLs,-DLOfDLs) in (P-2.26). Prolog Code P-2.26: DeÔ¨Ånition of dl2/2
1 2 3

dl2([],L-L). dl2([H|T],[HDL|L1]-L2) :- dl(H,HDL), !, dl2(T,L1-L2).

Exercise 2.13. DeÔ¨Åne a predicate show matrix dl/1 for displaying the original matrix rows via the new diÔ¨Äerence list representation as shown below.
?- matrix a( A), dl2( A, ADL), show matrix dl( ADL). [a11, a12, a13, a14] [a21, a22, a23, a24] [a31, a32, a33, a34]

The new, diÔ¨Äerence lists based implementations (P-2.27) and (P-2.28) are obtained by a straightforward clause by clause ‚Äòtranslation‚Äô of (P-2.24) and (P-2.25), respectively. Prolog Code P-2.27: DeÔ¨Ånition of rot rows dl/2
1 2 3

rot_rows_dl(L-_,Y-Y) :- var(L). rot_rows_dl([[H|T1]-[H|T2]|Ls1]-Ls2,[T1-T2|R1]-R2) :rot_rows_dl(Ls1-Ls2,R1-R2).

Prolog Code P-2.28: DeÔ¨Ånition of rot matrix dl/2
1

rot_matrix_dl(MDL,T1-T2) :- rot_rows_dl(MDL,[H|T1]-[H|T2]).

The test below conÔ¨Årms the computational advantage of using diÔ¨Äerence lists.

68 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

?- matrix a( A), dl2( A, DLA), time(rot matrix dl( DLA, DLR)), show matrix dl( DLR). % 12 inferences in 0.00 seconds (Infinite Lips) [a22, a23, a24, a21] [a32, a33, a34, a31] [a12, a13, a14, a11]

Exercise 2.14. Your predicate show matrix dl/1 from Exercise 2.13 will in all likelihood interfere with predicates invoked after its call. You may Ô¨Ånd, for example, that you can‚Äôt produce the rotated matrix after you have used show matrix dl/1 for displaying the original matrix:
?- matrix a( A), dl2( A, DLA), show matrix dl( DLA), rot matrix dl( DLA, DLR), show matrix dl( DLR). [a11, a12, a13, a14] [a21, a22, a23, a24] [a31, a32, a33, a34] No

What is the reason for this? Try to remedy the situation.

2.5.4

Application: The Gauss‚ÄìSeidel Method

We want to solve iteratively the system of linear equations u + Œ±v + Œ≤w Œ≥u + v + Œ¥w Œªu + œÅv + w = r = s = t (2.8) (2.9) (2.10)

in the three unknowns u, v and w. Given some initial approximate solutions u(0) , v (0) , w(0) , we calculate a new value for u from (2.8) by u(1) = r ‚àí Œ±v (0) ‚àí Œ≤w(0) (2.11) This then is used with (2.9) to calculate a new value for v : v (1) = s ‚àí Œ≥u(1) ‚àí Œ¥w(0) Finally, an updated value for w is obtained by using u(1) , v (1) in (2.10): w(1) = t ‚àí Œªu(1) ‚àí œÅv (1) (2.13) (2.12)

We have thus completed one cycle of the iteration scheme known as the Gauss‚ÄìSeidel Method 17 (e.g. [10], [17]). In each updating step, one of the equations (2.11)‚Äì(2.13) is used to recompute the variable concerned. The following observations will be crucial. ‚Ä¢ All three updating equations (2.11)‚Äì(2.13) take the form x1 = b1 ‚àí a12 x2 ‚àí a13 x3 (2.14)

if before each iteration step the system (2.8)‚Äì(2.10) is recast in matrix form as Ax = b where A, b and x are as shown in Table 2.1. ‚Ä¢ In Table 2.1, each of the entries for A, b and x is obtained from the one above it by rotation.18

69 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Iterations 1, 4, 7, . . .

‚é°

A

2, 5, 8, . . .

3, 6, 9, . . .

1 Œ± Œ≤ ‚é£ Œ≥ 1 Œ¥ Œª œÅ 1 ‚é° 1 Œ¥ Œ≥ ‚é£ œÅ 1 Œª Œ± Œ≤ 1 ‚é° 1 Œª œÅ ‚é£ Œ≤ 1 Œ± Œ¥ Œ≥ 1

‚é§ ‚é¶ ‚é§ ‚é¶ ‚é§ ‚é¶

‚é°

b

r ‚é£ s t ‚é° s ‚é£ t r ‚é° t ‚é£ r s

‚é§ ‚é¶ ‚é§ ‚é¶ ‚é§ ‚é¶

x u ‚é£ v w ‚é° v ‚é£ w u ‚é° w ‚é£ u v ‚é° ‚é§ ‚é¶ ‚é§ ‚é¶ ‚é§ ‚é¶

Updating . . . u

v

w

Table 2.1: Gauss‚ÄìSeidel Iterations

The method and the above observations carry over to linear systems of any size. The n‚Äìdimensional analogue of (2.14) is x1 = b1 ‚àí a12 x2 ‚àí . . . ‚àí a1n xn (2.15)

Equation (2.15) is the centrepiece in our formulation of the Gauss‚ÄìSeidel algorithm and it is very easily implemented in Prolog. In fact, if A, b and x are respectively represented by [[First|Rest]|OtherRows] , [B|OtherBs] and [X|OtherXs] , the code fragment implementing (2.15) will read

... dot_product(Rest,OtherXs,P), NewX is B - P, ...

where dot product/3 deÔ¨Ånes the scalar product of two vectors (not shown here). Algorithm 2.5.1 shows the pseudocode in the form ready for implementation in Prolog using the present formulation. (The output Subscripts indicates the permutation which the components of x have been put through and is the list of subscripts thereof.)

17 The 18 By

special feature of this iteration scheme is that updated values are used as soon as they become available. observing the iteration numbers, row three is found to be ‚Äòabove‚Äô row one.

70 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Algorithm 2.5.1: Gauss-Seidel(A, b, x, s, i) comment: A is the n √ó n coeÔ¨Écient matrix with unit diagonals. b is the n‚Äìvector of r.h.s. constants. x is the n‚Äìvector of guessed solutions. s is the list of subscripts of the components of x. i is the required number of iterations. Subscripts ‚Üê s Iterations ‚Üê i while‚éß Iterations = 0 Update (the Ô¨Årst entry of) x by (2.15) ‚é™ ‚é™ ‚é™ ‚é™ A ‚Üê RotateMatrix(A) ‚é™ ‚é™ ‚é® b ‚Üê RotateList(b) do x ‚Üê RotateList(x) ‚é™ ‚é™ ‚é™ ‚é™ Subscripts ‚Üê RotateList(Subscripts) ‚é™ ‚é™ ‚é© Iterations ‚Üê Iterations ‚àí 1 output (x, Subscripts)

The core predicate in our implementation is g seidel/2 with arguments in/4 and out/4 . It is deÔ¨Åned in (P-2.29) and implements all but the last action speciÔ¨Åed inside the while loop in Algorithm 2.5.1. Prolog Code P-2.29: DeÔ¨Ånition of g seidel/2
1 2 3 4 5 6 7 8 9

g_seidel(in([[First|Rest]|OtherRows], [B|OtherBs],[_|OtherXs],[S|OtherSs]), out(NewAs,NewBs,NewXs,NewSs)) :dot_product(Rest,OtherXs,P), NewX is B - P, rot_matrix([[First|Rest]|OtherRows],NewAs), append(OtherBs,[B],NewBs), append(OtherXs,[NewX],NewXs), append(OtherSs,[S],NewSs).

g seidel/2 is used by g seidel/7 , the top level predicate deÔ¨Åned in (P-2.30), to complete the requisite number of iterations. Prolog Code P-2.30: DeÔ¨Ånition of g seidel/7
1 2 3 4 5

g_seidel(_,_,Xs,Ss,0,Xs,Ss). g_seidel(As,Bs,Xs,Ss,I,FinalXs,FinalSs) :g_seidel(in(As,Bs,Xs,Ss),out(NewAs,NewBs,NewXs,NewSs)), NewI is I - 1, !, g_seidel(NewAs,NewBs,NewXs,NewSs,NewI,FinalXs,FinalSs).

71 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Example 2.1.19 We want to solve the system Ax = b where ‚é° ‚é§ ‚é° 1 ‚àí0.25 ‚àí0.25 0 ‚é¢ ‚é¢ ‚àí0.25 1 0 ‚àí0.25 ‚é• ‚é•,b = ‚é¢ A=‚é¢ ‚é£ ‚é¶ ‚é£ ‚àí0.25 0 1 ‚àí0.25 0 ‚àí0.25 ‚àí0.25 1 The above system is deÔ¨Åned by the Prolog facts
a([[ 1, -0.25, -0.25, 0], [-0.25, 1, 0, -0.25], [-0.25, 0, 1, -0.25], [ 0, -0.25, -0.25, 1]]).

‚é§ 50 50 ‚é• ‚é•. 25 ‚é¶ 25

and
b([50, 50, 25, 25]).

The initial approximate solution x1 = . . . = x4 = 100 is deÔ¨Åned in Prolog by
x0([100, 100, 100, 100]). s([1, 2, 3, 4]).

(0)

(0)

The exact solution, x1 = x2 = 87.5, x3 = x4 = 62.5, is obtained after 50 iterations thus
19 Source:

[10].

72 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Difference Lists

?- a(A), b(B), x0(X), s(S), g seidel(A,B,X,S,50,NewX,NewS). A = [[1, -0.25, -0.25, 0], [-0.25, 1, 0, -0.25], [-0.25, 0, 1, -0.25], [0, -0.25, -0.25, 1]] B = [50, 50, 25, 25] X = [100, 100, 100, 100] S = [1, 2, 3, 4] NewX = [62.5, 62.5, 87.5, 87.5] NewS = [3, 4, 1, 2]

Exercise 2.15. Re-implement Gauss‚ÄìSeidel by using diÔ¨Äerence lists and compare the performances of the implementations. You should use the predicates dl/2 (deÔ¨Åned by (P-2.19) in Sect. 2.5.1) and dl2/2 and rot matrix dl/2 (deÔ¨Åned respectively by (P-2.26) and (P-2.28) in Sect. 2.5.3).

73 Download free eBooks at bookboon.com

Prolog Techniques

Difference Lists

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

74 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

Chapter 3

Program Manipulations
In Prolog, unlike in most other programming languages, there is no clear distinction between program code and data. In this chapter, we are going to demonstrate how this feature of Prolog can be made use of in practice. In Sect. 3.1 we discuss the built-in Prolog predicates for basic database maintenance work. In Sect. 3.2 we present a tool for automated program unfolding, a program transformation technique the ‚Äòmanual‚Äô form of which we met in Sect. 2.3.1. Finally, in Sect. 3.3 we show how Prolog can be used to deÔ¨Åne a Prolog program some features of which are speciÔ¨Åed at runtime.

3.1

Simple Database Operations

In this section, we illustrate by a simple example how the Prolog database can be modiÔ¨Åed from within the Prolog system. The Round Table Six people are seated at a round table as shown in Fig. 3.1. The predicate right to/2 , deÔ¨Åned in (P-3.1) by six facts, describes the seating arrangement in an obvious fashion. Prolog Code P-3.1: Initial deÔ¨Ånition of right to/2
1 2 3

right_to(martin,lisa). right_to(george,clara). right_to(adam,susan).

right_to(lisa,george). right_to(clara,adam). right_to(susan,martin).

Exercise 3.1. Write queries to answer the following questions: (a) Who is seated to the right of Adam? (b) To whom is Clara the right neighbour? (c) Who are the neighbours of George? DeÔ¨Åne Prolog rules for

75 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Lisa m

Martin m

m George m Clara m Adam

m Susan

Figure 3.1: The Initial Seating Arrangement (d) ‚Äù... is seated to the left of ...‚Äù (e) ‚Äù... are the neighbours of ...‚Äù (f) ‚Äù... is seated opposite to ...‚Äù Hints. The envisaged solution for this exercise is elementary and concise and should make no use of lists. The following is suggested for solving part (f): ‚Ä¢ If we want to Ô¨Ånd the person seated opposite to Adam, say, it will help to imagine that the party are seated not at a round table but at a long rectangular one at the head of which is seated Adam (Fig. 3.2). ‚Ä¢ DeÔ¨Åne an auxiliary predicate facing/3 returning all pairs of people facing each other from one particular person‚Äôs point of view (here: Adam‚Äôs), and, eventually, facing that person himself. facing/3 should respond as follows.
?- facing(adam,Left,Right). Left = clara Right = susan ; Left = george Right = martin ; Left = lisa Right = lisa ; No

‚Ä¢ Now implement opposite to/2 using facing/3 . ‚Ä¢ opposite to/2 should fail if the number of people around the table is odd.

Exercise 3.2. Further useful predicates may be deÔ¨Åned for the Round Table example. (a) Write a predicate guests/0 for displaying the names of all those at the table. (Use a failure driven loop; see inset on p. 77.) guests/0 should fail only if there aren‚Äôt any people at the table.

76 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Martin m Lisa m m George

Susan m m Adam m Clara

Figure 3.2: Rectangular Table

Built-in Predicates: fail/0 and true/0 fail/0 always fails. true/0 always succeeds. Failure driven loops may be deÔ¨Åned by fail/0 . Example: ?- right to( X, ), write( X), write(‚Äô ‚Äô), fail; true. martin lisa george clara adam susan Yes

(b) Use a failure driven loop to deÔ¨Åne a predicate opposites/0 for displaying all pairs seated opposite each other:
?- opposites. martin, clara lisa, adam george, susan adam, lisa susan, george clara, martin Yes ?- joins(fred,clara,adam). 1 fred has joined the table. Yes ?- opposites. No

(c) Use the accumulator technique to deÔ¨Åne a predicate look right(+Person) for displaying all the guests‚Äô names counterclockwise, starting with a particular person. Example:
?- look right(george).
Sects. 3.1.3 and 3.1.4for how to implement joins/3 . Here it is used only to indicate that opposites/0 should fail for an odd number of guests in the database.
1 See

77 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

george clara adam susan martin lisa Yes

Departures and Arrivals Initially, we will have read the facts in (P-3.1), p. 75, into memory by consult/1 (or by some equivalent thereof). It is important at this stage to remember that the database comprises all predicates loaded in memory; these will be those deÔ¨Åned by the user as well as the built-in ones. Let us now assume that we want to model the departure from, and the arrival to, the table of people by updating the database. Departures. Departures will obviously involve removal of clauses from the database. To model, for example, George‚Äôs departure, we shall have to remove all facts referencing George. In addition, former neighbours of George will now be seated next to each other, necessitating additions to the database. Thus, to record departures, we shall need both deletion from, and addition to, the database. Arrivals. Arrivals will clearly involve an augmentation of the deÔ¨Ånition of right to/2 by new facts. To model for example the arrival of Tracy and Joe, to be seated between Adam and Susan, we will have to add the three facts in (P-3.2) to the database.

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

78 Download free eBooks at bookboon.com

22-08-2014 12:56:57

Click on the ad to read more

Prolog Techniques

Program Manipulations

Prolog Code P-3.2: New facts for right to/2
1

right_to(adam,tracy).

right_to(tracy,joe).

right_to(joe,susan).

And, we will have to remove the fact indicating that Susan is Adam‚Äôs right-hand neighbour:
right_to(adam,susan).

Therefore, to account for arrivals, both deletion from, and addition to the database will need to be done.

3.1.1

Basic Database Manipulation

We now review a few basic built-in predicates for modifying the database. ‚Ä¢ We use retract/1 (or retractall/1 ) to remove a clause (or all clauses of a predicate) from the database. The predicate whose clause is retract ed has to be declared dynamic , implemented either as a directive in one of the source Ô¨Åles or by calling dynamic/1 as a goal just before retract ing. This is achieved in our example either by including in one of the Ô¨Åles consulted the directive
:- dynamic(right to/2).

or interactively by
?- dynamic(right to/2), retract(right to(X,Y)).

Built-in Predicate: retract(+Term) Removes from the database the Ô¨Årst clause unifying with Term . Example: ?- listing(right to(X,Y)). right to(martin, lisa). right to(lisa, george). ... ?- retract(right to( , )). Yes ?- listing(right to(X,Y)). right to(lisa, george). ...

‚Ä¢ We use assert/1 to add a new clause to the database.

79 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Built-in Predicate: assert(+Term) Adds to the database the clause in Term . Example: a possible (reasonable) deÔ¨Ånition by assert/2 of a predicate near/2 for the Round Table example may be achieved by2 ?- assert(near(X,Y) :- (right to(X,Z), right to(Z,Y))). ?- assert(near(Y,X) :- (right to(X,Z), right to(Z,Y))). Notice that, as shown above, the conjunctive body of the clause assert ed should be written in parenthesis.

A predicate newly introduced by assert/1 is deemed dynamic. An existing static (i.e. non-dynamic) predicate may be augmented by a new clause via assert/1 only after declaring it dynamic. ‚Ä¢ retractall/1 is used to remove from the database all clauses whose head uniÔ¨Åes with the pattern in its argument. As with retract/1 , retractall/1 may revoke dynamic predicates only.

Built-in Predicate: retractall(+Term) Removes from the database all clauses whose head uniÔ¨Åes with Term . For example, both clauses of the predicate near/2 assert ed earlier may be removed in a single step by ?- retractall(near( , )). Yes

3.1.2

Changing the Database

The following queries may be used to achieve the intended changes to the database. ‚Ä¢ George leaves the table (Fig. 3.3).
?- dynamic(right to/2), right to(X,george), right to(george,Y), assert(right to(X,Y)), retract(right to(X,george)), retract(right to(george,Y)). X = lisa Y = clara Yes

As is easily conÔ¨Årmed by the query ?- listing(right to/2). , the predicate right to/2 is now deÔ¨Åned in the database by the facts in (P-3.3).
2 An interactive deÔ¨Ånition of a clause by assert/1 has the same eÔ¨Äect as deÔ¨Åning the same clause via consult(user) except that in the latter case a newly deÔ¨Åned predicate is static.

80 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Lisa m

Martin m

m Susan m Clara m Adam Figure 3.3: After George‚Äôs Departure Prolog Code P-3.3: Updated deÔ¨Ånition of right to/2
1 2 3

right_to(martin, lisa). right_to(adam, susan). right_to(lisa, clara).

right_to(clara, adam). right_to(susan, martin).

(Notice, however, that the deÔ¨Ånition of right to/2 in its Prolog source Ô¨Åle is not yet aÔ¨Äected.) ‚Ä¢ Tracy and Joe join the table and are seated between Adam and Susan (Fig. 3.4).
?- right to(adam,X), retract(right to(adam,X)), assert(right to(adam,tracy)), assert(right to(tracy,joe)), assert(right to(joe,X)). X = susan Yes

Notice that due to the previous query the predicate right to/2 is now dynamic. It is now deÔ¨Åned in the database by the facts in (P-3.4).3 Prolog Code P-3.4: Final deÔ¨Ånition of right to/2
1 2 3 4

right_to(martin, lisa). right_to(susan, martin). right_to(adam, tracy). right_to(joe, susan).

right_to(clara, adam). right_to(lisa, clara). right_to(tracy, joe).

It is seen that assert/1 places the new clause behind the existing ones for the same predicate.4
before, we may conÔ¨Årm this by the query ?- listing(right to/2). . related predicate asserta/1 (not used here) behaves exactly as assert/1 except that it places the new clause in front of all existing ones for the same predicate.
4 The 3 As

81 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Martin m Lisa m

Susan m Joe m

m Clara m Adam Figure 3.4: After Tracy‚Äôs and Joe‚Äôs arrival m Tracy

This e-book is made with

SetaPDF

SETA SIGN

PDF components for PHP developers

www.setasign.com
82 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

Exercise 3.3. Thus far, we have carried out (for reasons of transparency) database changes interactively only. In this exercise, you are asked to deÔ¨Åne some predicates for manipulating the database. (a) DeÔ¨Åne a predicate swap neighbours(+Left,+Right) for recording in the database of two neighbours swapping places. (For this predicate to succeed, prior to the swap, the person named in Left should be seated to the left of the person named in Right .) If we assume, for example, that the seating arrangement is initially as shown in Fig. 3.1, then the swap of Clara and Adam will be accomplished by
?- swap neighbours(clara,adam). Yes

After this, the database will look as follows.
right_to(martin, lisa). right_to(lisa, george). right_to(susan, martin). right_to(adam, clara). right_to(george, adam). right_to(clara, susan).

(b) DeÔ¨Åne a predicate swap(+Person1,+Person2) for recording in the database of two people swapping places who need not be neighbours. To exemplify, assume again that the database is initially as shown in Fig. 3.1. Then, Adam and George‚Äôs swap is carried out by
?- swap(adam,george). Yes

upon which the database is as shown below.
right_to(martin, lisa). right_to(susan, martin). right_to(adam, clara). right_to(lisa, adam). right_to(george, susan). right_to(clara, george).

Note. You may use the predicate swap neighbours/2 from part (a) in your deÔ¨Ånition of swap/2 .

Exercise 3.4. (Modelling a queue )5 A queue with at least two customers at a checkout is modelled by the Prolog predicate behind/2 which is deÔ¨Åned in the Ô¨Åle queue.pl as shown below. (behind/2 is declared a dynamic predicate in queue.pl.)
behind(lisa,george). behind(adam,susan). behind(george,clara). behind(susan,peter). behind(clara,adam).

(These facts have an obvious interpretation: the person named in the second argument stands behind the person named in the Ô¨Årst argument.) (a) DeÔ¨Åne a predicate swap neighbours(+Person1,+Person2) for recording in the database of two neighbours swapping places. (For this predicate to succeed, prior to the swap, the person named in Person2 should be standing behind the person named in Person1 .) Example:
5 The ideas involved here will be similar to those in Exercise 3.3 but now we have also to identify the Ô¨Årst and the last person in the queue.

83 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

?- swap neighbours(clara,adam). Yes

After this query, the database will look as follows. After this, the database will look as follows.
behind(lisa,george). behind(clara,susan). behind(george,adam). behind(susan,peter). behind(adam,clara).

Hint. You should deÔ¨Åne swap neighbours(+Person1,+Person2) by four clauses, each of them covering one of the cases indicated in the Table 3.1 where the two questions concerned are deÔ¨Åned by 1. Is Person1 the Ô¨Årst person in the queue? (Yes/No) 2. Is Person2 the last person in the queue? (Yes/No) ‚ÄòYes‚Äô to 1 ‚ÄòNo‚Äô to 1 and and ‚ÄòYes‚Äô to 2 ‚ÄòYes‚Äô to 2 ‚ÄòYes‚Äô to 1 ‚ÄòNo‚Äô to 1 and and ‚ÄòNo‚Äô to 2 ‚ÄòNo‚Äô to 2

Table 3.1: Cases for swap neighbours/2

(b) (Queue jumping ) Using swap neighbours/2 , now deÔ¨Åne by recursion a predicate to front(+P) for recording in the database of person P moving to the front of the queue. Example:
?- to front(adam). Yes

After this query, the database will look as follows.
behind(adam,lisa). behind(clara,susan). behind(lisa,george). behind(susan,peter). behind(george,clara).

(c) DeÔ¨Åne by recursion a predicate before(+Person1,?Person2) for Ô¨Ånding the names of all those who will be served before Person1 . On backtracking, Person2 should be uniÔ¨Åed with the names of all those to be served before Person1 . For example, assuming that the database is as given initially, we should Ô¨Ånd the names of all customers to be served before Adam by the query:
?- before(adam,P). P = clara ; P = george ; P = lisa ; No

You will Ô¨Ånd the solution of this exercise in queue.pl.

Exercise 3.5. The predicate lives in/2 is deÔ¨Åned by (P-3.5).

84 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Prolog Code P-3.5: Initial deÔ¨Ånition of lives in/2
1 2 3 4 5

lives_in(london, paul). lives_in(leeds, susan). lives_in(london, tracy). lives_in(york, peter). lives_in(leeds, joe).

lives_in(birmingham, adam). lives_in(york, george). lives_in(birmingham, david). lives_in(york, jane). lives_in(london, jack).

They form part of an employer‚Äôs database concerning employees‚Äô locations. Let us now assume that the London branch and all its employees move to York due to relocation. Write a query which will change the Prolog database accordingly. After issuing the query, lives in/2 is deÔ¨Åned by (P-3.6). Prolog Code P-3.6: Final deÔ¨Ånition of lives in/2
1 2 3 4 5

lives_in(birmingham, adam). lives_in(york, george). lives_in(york, peter). lives_in(leeds, joe). lives_in(york, tracy).

lives_in(leeds, susan). lives_in(birmingham, david). lives_in(york, jane). lives_in(york, paul). lives_in(york, jack).

3.1.3

File ModiÔ¨Åcations

We may want to modify clauses in the Prolog source Ô¨Åle(s) as a permanent record of the changes in the database. With a view to doing this, we have distributed the Prolog source code to three separate Ô¨Åles as shown in Fig. 3.5. It is seen that the Prolog source proper (in arrange.pl) is separated from what could
:- consult([people, arrange]). :- dynamic(right to/2).

¬† ¬† ¬©
right right right right right right to(martin,lisa). to(lisa,george). to(george,clara). to(clara,adam). to(adam,susan). to(susan,martin).

party.pl

d ¬Ç d

people.pl6

leaves(Person) :report leaves(Person), !, left to(Person,X), right to(Person,Y), assert(right to(X,Y)), remove(Person), write back. ...

arrange.pl Figure 3.5: File Organization for the Round Table Example be considered the input data (in people.pl). We hasten to add, though, that this separation is not necessary
6 This

is the initial state of people.pl. By the end of the Prolog session it will have changed to its updated version, Fig. 3.6.

85 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

since, as said earlier, Prolog does not distinguish between ‚Äòprogram‚Äô and ‚Äòdata‚Äô. Separation of program and data will prove expedient, however, since predicates whose deÔ¨Ånition is kept separate from the rest of the source code are easier to manipulate. The masterÔ¨Åle party.pl comprises a mere two directives: the Ô¨Årst one causes the other two Ô¨Åles to be consult ed while the second one indicates that right to/2 is a dynamic predicate. How shall we conclude the interactive session in Sect. 3.1.2 to make the changes in the database also to be mirrored in the Ô¨Åle people.pl? To do this, we issue the query
?- tell(‚Äôpeople.pl‚Äô), listing(right to/2), told. Yes

after which people.pl will be as shown in Fig. 3.6. To understand the above query, we note that ‚Ä¢ listing/1 uses the current output stream. ‚Ä¢ At the beginning of an interactive session, the current output stream is the screen. ‚Ä¢ The current output stream can be directed to a Ô¨Åle by using the built-in predicate tell(+Filename) . ‚Ä¢ The current output stream can be redirected to the screen by the predicate told/0 .

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

86 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

right to(martin, lisa). right to(lisa, clara). right to(joe, susan).

right to(clara, adam). right to(adam, tracy).

right to(susan, martin). right to(tracy, joe).

Figure 3.6: The File people.pl after the Interactive Session ‚Ä¢ If an existing Ô¨Åle is used in the argument of tell/1 , it will be overwritten. Therefore, to avoid accidental loss of Prolog source code, program and dynamic data are best kept in separate Ô¨Åles.

3.1.4

Updating right to/2 and people.pl

The work done interactively before (database and Ô¨Åle changes), is more conveniently performed by some dedicated predicates leaves/1 and joins/3 . Their deÔ¨Ånition parallels the respective interactive session and can be found in the Ô¨Åle arrange.pl. Exercise 3.6. joins/3 in arrange.pl does not allow for a guest to join the empty table. DeÔ¨Åne join/1 to make this possible. Example:
?- guests. No ?- joins(fred). fred has joined the table. Yes ?- guests. fred Yes

3.1.5

Automated Saving of Selected Predicates

We may wish to save to a Ô¨Åle all (or some) predicate deÔ¨Ånitions loaded in memory. This is easily accomplished in a piecemeal fashion as indicated in Sect. 3.1.3. Such a ‚Äòmanual‚Äô approach is, however, tedious and therefore an automated solution is called for. save predicates to(+Filename,+Choice) , to be studied below, is designed to do this task. The collection of all predicates in memory at any given time comprises ‚Ä¢ those explicitly loaded by consult/1 (or by one of its equivalents), ‚Ä¢ some built-in predicates depending on prior usage in the same session.

We are interested here in the Ô¨Årst group, the user-deÔ¨Åned predicates. The predicate my predicate(?Functor/?Arity,?C will name each of them with the respective number of clauses in ClauseCount :
?- my_predicate(Pred,ClauseCount). Pred = my_predicate/2 ClauseCount = 1 ; Pred = opposites/0

87 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

ClauseCount = 1 ; Pred = right_to/2 ClauseCount = 6 ; ...

my predicate/2 will serve as an auxiliary for save predicates to/2 and it is deÔ¨Åned in (P-3.7). Prolog Code P-3.7: DeÔ¨Ånition of my predicate/2
1 2 3 4 5 6 7

my_predicate(Fun/Arity,ClauseCount) :current_predicate(Fun,Head), not(predicate_property(Head,built_in)), not(predicate_property(Head,imported_from(_))), not(predicate_property(Head,foreign)), predicate_property(Head,number_of_clauses(ClauseCount)), functor(Head,Fun,Arity).

The built-in predicates current predicate/2 , predicate property/2 and functor/3 are used in this largely self-documenting deÔ¨Ånition.7 The goals 2‚Äì4 in the body of my predicate/2 are designed to Ô¨Ålter out names of predicates which are not user-deÔ¨Åned. Embedding my predicate/2 into a failure driven loop (see p. 77) gives rise to (P-3.8), the Ô¨Årst clause of save predicates to/2 . Prolog Code P-3.8: First clause of save predicates to/2
1 2 3 4 5 6 7

save_predicates_to(Filename,all) :- tell(Filename), ((my_predicate(Fun/Arity,_), Fun \= ‚Äômy_predicate‚Äô, Fun \= ‚Äôsave_predicates_to‚Äô, listing(Fun/Arity), fail); true), told.

It will write to the speciÔ¨Åed Ô¨Åle all user-deÔ¨Åned predicates except its own and its auxiliary‚Äôs deÔ¨Ånition.8 Example: After the query
?- save_predicates to(‚Äôcommittee.pl‚Äô,all).

the Ô¨Åle committee.pl will be as indicated in Fig. 3.7. This copy of the database will be inferior to the original source because of (1) User-deÔ¨Åned (usually mnemonic ) variable names will be replaced by system-assigned ones (due to listing/1 ), making the code less readable. (2) Clause layout may be lost. (3) Comments will be lost. (4) The order of the predicates may be diÔ¨Äerent.
8 This 7 functor/3

is known from Sect. 2.2.1. Consult the SWI‚Äìmanual [18] for detailed information on the other two predicates. is a sensible design decision since these two deÔ¨Ånitions won‚Äôt usually be relevant to the broader context.

88 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

opposites :- right to(A, B), opposite to(A, C), write(A), write(‚Äô, ‚Äô), write(C), nl, fail. right to(martin, lisa). right to(lisa, george). ...

Figure 3.7: The File committee.pl

(5) Directives will be lost. While the Ô¨Årst four of these shortcomings could be tolerated, there will be some manual work needed to rectify the last one. Another clause of save predicates to(+Filename,+Choice) will deÔ¨Åne the case when Choice uniÔ¨Åes with a list of entries of the form Functor/Arity ; for example, upon the query
?- save predicates to(‚Äôcommittee.pl‚Äô,[remove/1,left to/2]).

the Ô¨Åle committee.pl should comprise the deÔ¨Ånitions of the speciÔ¨Åed predicates remove/1 and left to/2 (Fig. 3.8). We deÔ¨Åne the second clause of save predicates to/2 in (P-3.9) along the lines of (P-3.8) except remove(A) :- retract(right to(A, B)), retract(right to(C, A)). left to(A, B) :- right to(B, A). Figure 3.8: The File committee.pl for the additional Ô¨Åltering with the built-in predicate member/2 . Prolog Code P-3.9: Second clause of save predicates to/2
1 2 3 4 5 6

save_predicates_to(Filename,List) :- tell(Filename), ((my_predicate(Fun/Arity,_), member(Fun/Arity,List), listing(Fun/Arity), fail); true), told.

89 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Built-in Predicate: member(?Elem,?List) Succeeds when Elem uniÔ¨Åes with one of the elements of List . Example: ?- member(penguin,[sparrow,stork,magpie]). No ?- member(Bird,[sparrow,stork,magpie]). Bird = sparrow ; Bird = stork Yes

Exercise 3.7. The above version of save predicates to/2 will silently skip all entries in the list argument which do not refer to a predicate in the database. An improved version will recognize this and return an error message:
?- save predicates to(‚Äôcommittee.pl‚Äô,[remove/1,left to/3]). Error: some predicates not in the database No

90 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

(This shows that there is no predicate left to/3 in the database.) DeÔ¨Åne such an enhanced version of save predicates to/2 . It should not write anything to the Ô¨Åle unless all list entries refer to existing userdeÔ¨Åned predicates. Hint. A rather concise solution is possible by using the built-in predicate ->/2 .9

Built-in Predicate: ->/2 The predicate ->/2 (written in the operator form) is used to deÔ¨Åne the conditional statement. Syntax: (+Condition -> +Action ; +Alternative Action) . A property buyer‚Äôs example: ?- member(Capital,[1,4,10]), ((member(Mortgage,[1,2,5]),Capital + Mortgage < 9) -> (Capital + Mortgage > 4,member(Property,[cottage,house])); member(Property,[mansion,villa])). Capital = 4 Mortgage = 1 Property = cottage ; Capital = 4 Mortgage = 1 Property = house ; Capital = 10 Mortgage = G1170 Property = mansion ; Capital = 10 Mortgage = G1170 Property = villa ; No Notice in particular that ‚Ä¢ ->/2 fails if Condition succeeds and Action fails (Capital = 1). ‚Ä¢ Once Condition succeeds it won‚Äôt be re-satisÔ¨Åed on backtracking. (No move from Mortgage = 1 to Mortgage = 2 when Capital = 4.) ‚Ä¢ ->/2 succeeds if Condition fails and Alternative Action can be proved (Capital = 10).

3.1.6

Miniproject: Modelling a Stamp Collection

The solutions of the exercises in this section are in the source Ô¨Åle stamps.pl save for Exercise 3.9 which is solved in Appendix A.3. A stamp collection is modelled by the predicate album/1 in (P-3.10).

9 This corresponds to the if‚Äìthen‚Äìelse language construct familiar from imperative programming. (Observe though the PrologspeciÔ¨Åc subtleties as exempliÔ¨Åed in the inset.)

91 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Prolog Code P-3.10: Facts deÔ¨Åning album/1
1 2 3 4 5 6 7 8 9 10 11 12 13 14

album([stamp(‚ÄôBritain‚Äô,‚ÄôQueen‚Äô,1965,20), stamp(‚ÄôBritain‚Äô,‚ÄôQueen‚Äô,1967,50), stamp(‚ÄôBritain‚Äô,‚ÄôQueen‚Äô,1963,120)]). album([stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1978,19), stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1979,20), stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1978,22), stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1977,40), stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1978,100)]). album([stamp(‚ÄôGermany‚Äô,‚ÄôKaiser‚Äô,1882,5), stamp(‚ÄôGermany‚Äô,‚ÄôKaiser‚Äô,1879,20), stamp(‚ÄôGermany‚Äô,‚ÄôKaiser‚Äô,1885,50)]). album([stamp(‚ÄôGermany‚Äô,‚ÄôCastles‚Äô,1885,10), stamp(‚ÄôGermany‚Äô,‚ÄôCastles‚Äô,1879,50), stamp(‚ÄôGermany‚Äô,‚ÄôCastles‚Äô,1885,60)]).

The arguments in stamp/4 refer respectively to: country of origin, the set‚Äôs name, year of issue, denomination. Within a set, the stamps are in ascending order of denomination. Exercise 3.8. (Pattern matching ) DeÔ¨Åne a predicate collection/1 for displaying on the terminal all stamps conforming to a certain criterion. Examples: ‚Ä¢ Show all stamps with denomination 50.
?- collection(stamp( , , ,50)). stamp(Britain, Queen, 1967, 50) stamp(Germany, Kaiser, 1885, 50) stamp(Germany, Castles, 1879, 50) Yes

‚Ä¢ Show all stamps from the set Castles.
?- collection(stamp( ,‚ÄôCastles‚Äô, , )). stamp(Germany, Castles, 1885, 10) stamp(Germany, Castles, 1879, 50) stamp(Germany, Castles, 1885, 60) Yes

‚Ä¢ Show all stamps issued between 1875 and 1883.
?- between(1875,1883,Y), collection(stamp( , ,Y, )), fail. stamp(Germany, Kaiser, 1879, 20) stamp(Germany, Castles, 1879, 50) stamp(Germany, Kaiser, 1882, 5) No

Exercise 3.9. Assume that the stamp collector wants to sell the German Kaiser set of stamps. Construct a Prolog query to achieve the corresponding database modiÔ¨Åcation interactively.

92 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Exercise 3.10. (This is a task in preparation for Exercise 3.11.) DeÔ¨Åne a predicate remove all/3 for removing all entries from a list which match a given pattern. Example:
?- remove all(item( ,5), [item(6,9),item(1,5),item(7,1),item(9,5)],L). L = [item(6, 9), item(7, 1)]

(The original order is retained in the third argument of remove all/3 .)

Exercise 3.11. Use remove all/3 from Exercise 3.10 to deÔ¨Åne sell/1 for removing from the database all stamps conforming to a given criterion. For example, all British stamps from the set Poets issued in 1978 may be removed interactively thus
?- sell(stamp(‚ÄôBritain‚Äô,‚ÄôPoets‚Äô,1978, )). Yes ?- collection(stamp( ,‚ÄôPoets‚Äô, , )). stamp(Britain, Poets, 1979, 20) stamp(Britain, Poets, 1977, 40) Yes

Exercise 3.12. DeÔ¨Åne insert/3 for inserting into a list of stamps a new stamp. Requirements: ‚Ä¢ The new stamp has to be positioned according to its denomination. ‚Ä¢ The new stamp has to Ô¨Åt into the existing set supplied in the second argument of insert/3 . (Notice that insert/3 won‚Äôt aÔ¨Äect the database.) Examples:
?- insert(stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,2001,70), [stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,2000,40), stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,2000,60), stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,1991,100)],L). L = [stamp(‚ÄôBritain‚Äô, ‚ÄôFlowers‚Äô, 2000, 40), stamp(‚ÄôBritain‚Äô, ‚ÄôFlowers‚Äô, 2000, 60), stamp(‚ÄôBritain‚Äô, ‚ÄôFlowers‚Äô, 2001, 70), stamp(‚ÄôBritain‚Äô, ‚ÄôFlowers‚Äô, 1991, 100)] Yes ?- insert(stamp(‚ÄôBritain‚Äô,‚ÄôSports‚Äô,2001,70), [stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,2000,40), stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,2000,60), stamp(‚ÄôBritain‚Äô,‚ÄôFlowers‚Äô,1991,100)],L). No

(A concise recursive solution is sought.)

93 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Exercise 3.13. DeÔ¨Åne buy/1 for including a new stamp into the database. If the new stamp Ô¨Åts into an existing set, it should be included in there. Otherwise, a new set should be created with just this new stamp in it. For example, the 25 Pence stamp from the 1966 issue of the Queen set may be included in the database by
?- buy(stamp(‚ÄôBritain‚Äô,‚ÄôQueen‚Äô,1966,25)). Yes ?- collection(stamp( ,‚ÄôQueen‚Äô, , )). stamp(Britain, Queen, 1965, 20) stamp(Britain, Queen, 1966, 25) stamp(Britain, Queen, 1967, 50) stamp(Britain, Queen, 1963, 120) Yes

¬® stamp from the 1956 issue of the Swedish Nobel Laureates set by And, record the purchase of the 50 Ore
?- buy(stamp(‚ÄôSweden‚Äô,‚ÄôNobel Laureates‚Äô,1956,50)). Yes ?- collection(stamp(‚ÄôSweden‚Äô, , , )). stamp(Sweden, Nobel Laureates, 1956, 50) Yes

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

94 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

3.2

Case Study: Automated Unfolding

We have introduced in Sect. 2.3.1 the program transformation technique unfolding and saw by way of an example that it can enhance a program‚Äôs performance. There, the transformation was carried out essentially ‚Äòmanually‚Äô though with some assistance (for uniÔ¨Åcation) from the Prolog system. We now want to examine an automated tool for unfolding, written in Prolog. Figs. 3.9‚Äì3.10 (pp. 97‚Äì98) show an annotated session for solving by this tool the example from Sect. 2.3.1 interactively. The tool comprises the predicates elementary unfolding/5 , unfold/3 and clause arrange/2 , the Ô¨Årst two of which are implementations of Elementary and Complete One Step Unfolding, respectively. The meaning and use of their arguments is easily gleaned from the sample sessions. The third of these predicates, clause arrange/2 , is used to retain in the Prolog database a speciÔ¨Åed set of clauses of a predicate as indicated by the clause numbers in the second (list) argument. It thereby allows redundant clauses to be discarded and the others be sorted as deemed necessary. The steps involved in implementing elementary Unfolding and Complete One Step Unfolding will be demonstrated with reference to the deÔ¨Ånitions of some predicates a/5 and c/2 shown respectively in (P-3.11) and (P-3.12). Prolog Code P-3.11: DeÔ¨Ånition of a/5
1 2 3 4

a(U,U,U,U,U). a(U,V,U,V,U) :- m(U,V). a(U,V,W,V,U) :- n(U,n(V,W)), b(U,V), e(V,U). a(U,V,W,X,Y) :- b(U,V), c(V,W), d(W,X), e(X,Y).

Prolog Code P-3.12: DeÔ¨Ånition of c/2
1 2 3

c(A,B) :- f(A), m(A,B). c(A,B) :- A is B + 1. c(A,A) :- f(A), g(A).

3.2.1

Elementary Unfolding

Let us unfold goal 2 in clause 4 of a/5 by using clause 3 of c/2 :
?- elementary unfolding(a/5,4,2,c/2,3). Yes

Thereafter the database will contain an additional clause for a/5 :
?- listing(a/5). ... a(A, B, B, C, D) :- b(A, B), f(B), g(B), d(B, C), e(C, D). Yes

We show a series of queries in Figs. 3.11‚Äì3.14 (pp. 99‚Äì101) to illustrate the idea behind the deÔ¨Ånition of elementary unfolding/5 . The following observations on these Ô¨Ågures are in order. ‚Ä¢ Fig. 3.11: The query comprises three phases.

95 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

1. The built-in predicates functor/3 , nth clause/3 and clause/3 are used to split up the fourth clause of a/5 into its building blocks: in particular, Body1 is uniÔ¨Åed with a term which is the conjunction of the clause‚Äôs goals. (For nth clause/3 and clause/3 , see inset on p. 102.) 2. The user-deÔ¨Åned predicate conj/2 then returns the list of conjuncts of Body1 in L1 . 3. Finally, the user-deÔ¨Åned predicate splitlist/5 is used to disassemble the list of conjuncts L1 around its second entry into three parts. Notice in particular that Entry1 is uniÔ¨Åed with the goal to be unfolded later. ‚Ä¢ Fig. 3.12: Here we disassemble the third clause of c/2 in a similar manner to steps 1 and 2 above.

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

96 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

9

?- [dl,transformations]. % dl compiled 0.11 sec, 18,044 bytes % transformations compiled 0.06 sec, 9,224 bytes Yes ‚é´ ?- listing(rev dl/2). ‚é™ ‚é™ rev dl([], A-A). ‚é¨ Predicate to be rev dl([A], [A|B]-B). ' transformed ‚é™ rev dl([A|B], C-D) :- rev dl(B, C-E), ‚é™ ‚é≠ rev dl([A], E-D). Yes c ?- unfold(rev dl/2,3,2). Clause(s) used: COSU on goal 2 of clause 3 T Clause 2 of predicate rev dl/2 Clause 3 of predicate rev dl/2

6

rev dl([], A-A). rev dl([A], [A|B]-B). rev dl([A|B], C-D) :- rev dl(B, C-E), rev dl([A], E-D). rev dl([A|B], C-D) :- rev dl(B, C-[A|D]), true. rev dl([A|B], C-D) :- rev dl(B, C-E), rev dl([], E-F), rev dl([A], F-D). Clause removed: Clause 3 of predicate rev dl/2 rev dl([], A-A). rev dl([A], [A|B]-B). rev dl([A|B], C-D) :- rev dl(B, C-[A|D]), true. rev dl([A|B], C-D) :- rev dl(B, C-E), rev dl([], E-F), rev dl([A], F-D). Yes ?- clause arrange(rev dl/2,[1,3]). Yes ?- listing(rev dl/2). rev dl([], A-A). rev dl([A|B], C-D) :- rev dl(B, C-[A|D]), true. Yes

c ' ‚é´ ‚é™ ‚é™ ‚é™ ‚é™ ‚é¨ ' ‚é™ ‚é™ ‚é™ ‚é™ ‚é≠
Clause to be replaced Replacing, new clauses

‚é´ ‚é™ ‚é™ ‚é™ '‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é¨ ' ‚é´ ‚é™ ‚é¨ ‚é™ ‚é™ ‚é™ '‚é™ ‚é™ ‚é™ ‚é≠ ‚é™ ‚é≠ ' ‚é´ ‚é¨ ' ‚é≠

Redundant clause; see Fig. 3.10 Clauses of rev dl/2 after a COSU Redundant clause; see Sect. 2.3.1 Retain clauses 1 and 3 only New deÔ¨Ånition of rev dl/2

8

7

Figure 3.9: Interactive Prolog‚ÄìAssisted Program Transformation: Session I

97 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

9

?- consult(user). |: :- consult(transformations). % transformations compiled 0.06 sec, 9,584 bytes‚é´ ‚é¨ Manual input |: rev dl([],L-L). ' :- rev dl(T,L1-[H|L2]). |: rev ¬£ dl([H|T],L1-L2) ¬†¬£ ¬† ‚é≠ of rev dl/2 +¬¢Z ¬° |: ¬¢Ctrl ¬° % user compiled 86.18 sec, 10,128 bytes Yes Unfold on goal 1 of ?- elementary unfolding(rev dl/2,2,1,rev dl/2,1). ' clause 2 using Yes clause 1 ?- listing(rev dl/2). rev dl([], A-A). rev dl([A|B], C-D) :- rev dl(B, C-[A|D]). rev dl([A], [A|B]-B). Yes

6

' Old clauses ' New clause 7

8

Figure 3.10: Interactive Prolog‚ÄìAssisted Program Transformation: Session II

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

98 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

9

?- functor(Pred1,a,5), nth clause(Pred1,4,Ref1), clause(Head1,Body1,Ref1), conj(Body1,L1), splitlist(2,L1,Front1,Entry1,Behind1). Pred1 = a( G1123, G1124, G1125, G1126, G1127) Ref1 = 1794731 Head1 = a( G1132, G1133, G1134, G1135, G1136) Body1 = b( G1132, G1133), c( G1133, G1134), d( G1134, G1135), e( G1135, G1136) L1 = [b( G1132, G1133), c( G1133, G1134), d( G1134, G1135), e( G1135, G1136)] Front1 = [b( G1132, G1133)] Entry1 = c( G1133, G1134) Behind1 = [d( G1134, G1135), e( G1135, G1136)] Yes

6

8 Figure 3.11: Unfolding, Experiment 1: Disassembling clause 4 of a/5

7

99

Download free eBooks at bookboon.com

9

?- functor(Pred2,c,2), nth clause(Pred2,3,Ref2), clause(Head2,Body2,Ref2), conj(Body2,L2). Pred2 = c( G820, G821) Ref2 = 1794877 Head2 = c( G826, G826) Body2 = f( G826),g( G826) L2 = [f( G826),g( G826)] Yes

6

8 Figure 3.12: Unfolding, Experiment 2: Disassembling clause 3 of c/2

Program Manipulations

7

Prolog Techniques

9

6

100

Download free eBooks at bookboon.com

?- functor(Pred1,a,5), ..., functor(Pred2,c,2), ..., Head2 = Entry1. Pred1 = a( G1908, G1909, G1910, G1911, G1912) Ref1 = 1794731 Head1 = a( G1917, G1918, G1918, G1920, G1921) Body1 = b( G1917, G1918), c( G1918, G1918), d( G1918, G1920), e( G1920, G1921) L1 = [b( G1917, G1918), c( G1918, G1918), d( G1918, G1920), e( G1920, G1921)] Front1 = [b( G1917, G1918)] Entry1 = c( G1918, G1918) Behind1 = [d( G1918, G1920), e( G1920, G1921)] Pred2 = c( G1988, G1989) Ref2 = 1794877 Head2 = c( G1918, G1918) Body2 = f( G1918), g( G1918) L2 = [f( G1918), g( G1918)] Yes

8 Figure 3.13: Unfolding, Experiment 3: Experiments 1 & 2 followed by appropriate uniÔ¨Åcation

7

Program Manipulations

Prolog Techniques

9

6

101

Download free eBooks at bookboon.com

?- functor(Pred1,a,5), ..., functor(Pred2,c,2), ..., Head2 = Entry1, concat3(Front1,L2,Behind1,L), conj(NewBody,L), dynamic(a/5), assert(Head1 :- NewBody). Pred1 = a( G2534, G2535, G2536, G2537, G2538) Ref1 = 1794731 Head1 = a( G2543, G2544, G2544, G2546, G2547) Body1 = b( G2543, G2544), c( G2544, G2544), d( G2544, G2546), e( G2546, G2547) L1 = [b( G2543, G2544), c( G2544, G2544), d( G2544, G2546), e( G2546, G2547)] Front1 = [b( G2543, G2544)] Entry1 = c( G2544, G2544) Behind1 = [d( G2544, G2546), e( G2546, G2547)] Pred2 = c( G2614, G2615) Ref2 = 1794877 Head2 = c( G2544, G2544) Body2 = f( G2544), g( G2544) L2 = [f( G2544), g( G2544)] L = [b( G2543, G2544), f( G2544), g( G2544), d( G2544, G2546), e( G2546, G2547)] NewBody = b( G2543, G2544), f( G2544), g( G2544), d( G2544, G2546), e( G2546, G2547) Yes ?- listing(a/5). ... a(A, B, B, C, D) :- b(A, B), f(B), g(B), d(B, C), e(C, D). Yes

8 Figure 3.14: Unfolding, Experiment 4: Experiment 3 followed by new clause creation and database update

7

Program Manipulations

Prolog Techniques

Program Manipulations

Built-in Predicates: nth clause/3 and clause/3 nth clause(+Pred,+Index,?Ref) is used to assign a system‚Äìchosen reference to a speciÔ¨Åc clause of a predicate. This reference may be used subsequently to retrieve head and body of the clause by clause/3 . Example: Head and body of the second clause of the predicate c/2 , deÔ¨Åned by c(A,B) :- f(A), m(A,B). c(A,B) :- A is B + 1. c(A,A) :- f(A), g(A). may be retrieved by ?- nth clause(c( , ),2,Ref), clause(Head,Body,Ref). Ref = 1791614 Head = c( G542, G543) Body = G542 is G543+1 If used with the instantiation pattern nth clause(+Pred,-Index,-Ref) , on backtracking the references to all clauses of a given predicate are obtained: ?- nth clause(c( , ),Index,Ref). Index = 1 Ref = 1791577 ; Index = 2 Ref = 1791614 ; Index = 3 Ref = 1791649 ; No

‚Ä¢ Fig. 3.13: The previous two steps are repeated and then Head2 is uniÔ¨Åed with Entry1 , essentially completing the unfolding operation. Notice in particular that the eÔ¨Äect of unifying Head2 with Entry1 ‚Äòripples through‚Äô to all other variables: for example, as expected, in Head1 the second and third arguments become identical while this was not the case before uniÔ¨Åcation (see Fig. 3.11). ‚Ä¢ Fig. 3.14: Subsequent to the steps above, we Ô¨Årst assemble in L the list of goals for the new clause; we use here the (fairly straightforward) user-deÔ¨Åned predicate concat3/4 . Then, conj/2 is used again (now in the ‚Äòreverse‚Äô direction) to create the term NewBody , the conjunction of terms in L . Finally, the new clause is written to the database, conÔ¨Årmed also by the next query using listing/1 . The deÔ¨Ånition of elementary unfolding/5 in transformations.pl follows the query shown in Fig. 3.14. The auxiliary predicates used therein won‚Äôt be discussed here; the way conjunctions are composed/decomposed by conj/2 is noteworthy, however. This is accomplished within conj/2 via the auxiliaries conjunction(+List,+Acc,-Term) and conjuncts(+Term,+Acc,-List) whose working is illustrated below.
?- conjunction([t(X),u(Y,a),v(b,X)],s(Y),C), conjuncts(C,[],L). X = G492 Y = G497 C = v(b, G492), u(_G497, a), t( G492), s( G497) L = [s( G497), t( G492), u( G497, a), v(b, G492)]

102 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

They are deÔ¨Åned in (P-3.13) and (P-3.14) by the accumulator technique.10 Prolog Code P-3.13: DeÔ¨Ånition of conjunction/3
1 2

conjunction([],Conj,Conj). conjunction([H|T],Acc,Conj) :- conjunction(T,(H,Acc),Conj).

10 In (P-3.14) we implicitly use the fact that Prolog‚Äôs conjunction is right-associative. The two queries below thus generate the same response: ?- conjuncts((v(b,X), u(Y, a), t(X), s(Y)),[],L). X = G409 Y = G411 L = [s( G411), t( G409), u( G411, a), v(b, G409)] ?- conjuncts((v(b,X), (u(Y, a), (t(X), s(Y)))),[],L). X = G433 Y = G435 L = [s( G435), t( G433), u( G435, a), v(b, G433)] What will Prolog‚Äôs response be to the query below? ?- conjuncts((((v(b,X), u(Y, a)), t(X)), s(Y)),[],L).

103 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

Prolog Code P-3.14: DeÔ¨Ånition of conjuncts/3
1 2 3 4 5

conjuncts(Term,Acc,[Term|Acc]) :- not(functor(Term,‚Äô,‚Äô,2)). conjuncts(Term,Acc,L) :- functor(Term,‚Äô,‚Äô,2), arg(1,Term,Term1), arg(2,Term,Term2), conjuncts(Term2,[Term1|Acc],L).

3.2.2

Complete One Step Unfolding

Let us now assume that we want to unfold clause 4 of a/5 on its second goal. We can do this by repeatedly using elementary unfolding/5 in an obvious manner:
?- elementary unfolding(a/5,4,2,c/2,K). K = 1 ; K = 2 ; K = 3 ; No ?- listing(a/5). a(A, A, A, A, A). a(A, B, A, B, A) :a(A, B, C, B, A) :a(A, B, C, D, E) :a(A, B, C, D, E) :a(A, B, C, D, E) :a(A, B, B, C, D) :-

m(A, n(A, b(A, b(A, b(A, b(A,

B). n(B, C)), b(A, B), e(B, A). B), c(B, C), d(C, D), e(D, E). B), f(B), m(B, C), d(C, D), e(D, E). B), B is C+1, d(C, D), e(D, E). B), f(B), g(B), d(B, C), e(C, D).

In doing so, the following steps have been carried out: 1. We have visually identiÔ¨Åed c(V,W) as goal 2 in clause 4 of a/5 . 2. We have attempted (and successfully completed) by backtracking an elementary unfolding operation with each of the clauses of c/2 . To complete the task, we would also need to 3. Remove clause 4 of a/5 from the database. Step 2 is more concisely implemented by a failure driven loop thus
?- elementary unfolding(a/5,4,2,c/2,K), fail. No

Within the same failure driven loop we may integrate Step 1 by attempting an elementary unfolding operation with each predicate in the database. The generation of all predicates may be accomplished by11
?- current predicate(Fun,Head), not(predicate property(Head,built_in)), not(predicate property(Head,imported from( ))), not(predicate property(Head,foreign)), functor(Head,Fun,Arity).
same functionality (i.e. retrieval from the database of all user-deÔ¨Åned predicates) is achieved by the almost identical predicate my predicate/2 from p. 88.
11 The

104 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Fun = a Head = a( G1380, G1381, G1382, G1383, G1384) Arity = 5 ; ... Fun = c Head = c(_G1380, _G1381) Arity = 2 ; ...

Embedding this within the earlier failure driven loop will essentially implement unfold/3 :
?- current predicate(Fun,Head), not(predicate property(Head,built in)), not(predicate property(Head,imported from( ))), not(predicate property(Head,foreign)), functor(Head,Fun,Arity), elementary unfolding(a/5,4,2,Fun/Arity,K), fail. No

For further details on the deÔ¨Ånition of unfold/3 the reader is referred to the Ô¨Åle transformations.pl. (Noteworthy is perhaps the use in Step 3 of the built-in predicate erase/1 .)

Built-in Predicate: erase(+Ref) erase(+Ref) removes the clause with reference Ref from the database. Example: ?- dynamic(num/1), ((member( I,[1,2,3]), assert(num( I)), fail); true), listing(num/1). num(1). num(2). num(3). ?- nth clause(num( ),2,Ref), erase(Ref), listing(num/1). num(1). num(3). Ref = 3904727

Exercise 3.14. Use the predicate unfold/3 to solve Exercise 2.9, Part (c).

Self-unfolding There may seem a subtle problem with our implementation of unfold/3 which we want to address now. In the deÔ¨Ånition of unfold/3 we write (within a failure driven loop) to the database new clauses via elementary unfolding/5 which itself ‚Äòfeeds on‚Äô clauses (in its fourth argument) that are retrieved from the database. This construction could conceivably give rise to an inÔ¨Ånite loop in the case of what was termed ‚Äòself-unfolding‚Äô in Sect. 2.3.1, p. 52. This cannot happen, however, since a search tree under consideration by Prolog won‚Äôt be aÔ¨Äected by database changes created by the search itself. The following simple interactive session illustrates this point.

105 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

?- listing(num/1). num(1). Yes ?- num(X), Y is 2 * X, assert(num(Y)), fail. No ?- listing(num/1). num(1). num(2). Yes

Had the search tree been aÔ¨Äected by the database changes immediately we would have expected in the database inÔ¨Ånitely many clauses of num/1 like
num(1). num(2). num(4). ...

The session shown in Fig. 3.9 (involving self-unfolding of the predicate rev dl/2 ) conÔ¨Årms indeed that unfold/3 does not cause looping.

3.2.3

Rearranging Clauses

Clauses of a predicate may be rearranged by clause arrange/2 as illustrated in Fig. 3.9. To this end, the following auxiliary predicates have been deÔ¨Åned: ‚Ä¢ all clauses/2 collects all clauses of a predicate into a list of terms. Example:
?- all clauses(c/2,L). L = [ (c( G368, G369) :- f( G368), m( G368, G369)), (c( G350, G351) :- G350 is G351+1), (c( G331, G331) :- f( G331), g( G331))]

all clauses/2 is deÔ¨Åned by
all_clauses(Fun/Arity,List) :functor(Pred,Fun,Arity), findall((Head :- Body), (nth_clause(Pred,_,Ref), clause(Head,Body,Ref)), List).

‚Ä¢ arrange/3 selects (a subset of) the entries of list as speciÔ¨Åed by a list of integers in the Ô¨Årst argument. Example:
?- arrange([4,3,5],[a,b,c,d,e,f],L). L = [d, c, e]

arrange/3 is deÔ¨Åned by
arrange(IntList,InL,OutL) :findall(E,(member(M,IntList), nth1(M,InL,E)),OutL).

106 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Built-in Predicate: nth1(?Index,?List,?Elem) nth1/3 is used to select a speciÔ¨Åed entry from a list. Example: ?- nth1(3,[a,b,c,d,e,f],E). E = c

The deÔ¨Ånition of clause arrange/2 in terms of the two auxiliaries is fairly straightforward; see the Ô¨Åle transformations.pl for details. Exercise 3.15. Use the predicate unfold/3 to carry out a Complete One Step Unfolding on an appropriately chosen goal in one of the clauses of flatten dl/2 from Sect. 2.2.3. After some removal and rearranging of clauses via clause arrange/2 , you should arrive at a version of flatten/2 which is more eÔ¨Écient than the earlier ones. Demonstrate the gain in speed by an experiment akin to the one carried out in Exercise 2.7.

107 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

Exercise 3.16. You will have seen in Exercise 3.15 that unfold/3 places the new clauses after the existing ones. To observe the original order, the new clauses had to be subsequently moved by clause arrange/2 to the position of the clause they were replacing. Write a predicate cosu/3 which performs a Complete One Step Unfolding and then restores the predicates‚Äô order.12 For example, the suggested solution of Exercise 3.15 (p. 162) could then be achieved simply by
?- cosu(flatten dl/2,2,2). ... ?- listing(flatten dl/2). flatten dl([], A-A). flatten dl([A], B-C) :- flatten dl(A, B-C), true. flatten dl([A, B|C], D-E) :- flatten dl(A, D-F), flatten dl(B, F-G), flatten dl(C, G-E). flatten dl([A|B], C-D) :- flatten dl(A, C-[B|D]), true. flatten dl(A, [A|B]-B).

Note. When using clause arrange/2 , you will have to be able to generate integer lists with speciÔ¨Åed bounds. The built-in predicate between/3 may be used to achieve this.

3.3
3.3.1

Dijkstra‚Äôs Dutch Flag Problem Revisited
Problem Generalization and First Solution

Dijkstra‚Äôs Dutch Flag Problem from Sect. 2.4 may be generalized as follows: ‚Ä¢ The items may be of any colour and any number of colours may occur. ‚Ä¢ The items are to be grouped to a certain order of colours as speciÔ¨Åed by the user in some list Colours . This list need not include all the items‚Äô colours and may include colours not assigned to any of the items. As before, within each colour group the items‚Äô original order should be retained. We call the predicate to be deÔ¨Åned dijkstra(+Colours,+Items,-Grouped) and illustrate its desired behaviour by an example. Take the list of items
new_items([col(soot,black), col(tomato,red), col(nut,brown), col(milk,white), col(snow,white), col(coal,black), col(bile,green), col(bark,brown), col(ocean,blue), col(grass,green), col(apple,red), col(blood,red), col(night,black), col(sky,blue)]).
12 To retrieve the number of clauses of a predicate, you should use the built-in predicate predicate property/2 in the form predicate property(+Pred,number of clauses(-ClauseNumber)) .

108 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

and sort it in the order black, blue, violet, green, red and white. (Notice that brown is not one of the colours listed here, nor is there any item whose colour is violet.) The expected behaviour of dijkstra/3 is as follows.13
?- new items( Items), dijkstra([black,blue,violet,green,red,white], Items,Grouped). Grouped = [col(soot,black), col(coal,black), col(night,black), col(ocean,blue), col(sky,blue), col(bile,green), col(grass,green), col(tomato,red), col(apple,red), col(blood,red), col(milk,white), col(snow,white)]

dijkstra/3 solves the original Dutch Flag problem from Sect. 2.4 if its Ô¨Årst argument is uniÔ¨Åed with [red, white, blue]. On inspection of dijkstra/2 from Sect. 2.4.3 (the version based on diÔ¨Äerence lists) it is seen that the current, speciÔ¨Åc problem would be solved by dijkstra/2 if dijkstra dl/2 had been deÔ¨Åned by the clause
dijkstra_dl(Items,L1-L7) :- colour_dl(black,Items,L1-L2), colour_dl(blue,Items,L2-L3), colour_dl(violet,Items,L3-L4), colour_dl(green,Items,L4-L5), colour_dl(red,Items,L5-L6), colour_dl(white,Items,L6-L7).

This suggests introducing a predicate replace dijkstra dl(+Colours) for replacing the existing deÔ¨Ånition of dijkstra dl/2 in the database by the desired one. Then, dijkstra/3 may be deÔ¨Åned in terms of the old version of dijkstra/2 thus
dijkstra(Colours,Items,List) :- replace_dijkstra_dl(Colours), dijkstra(Items,List).

Let us now look at in detail how the change in the database is accomplished.
replace_dijkstra_dl(Colours) :dynamic(dijkstra_dl/2), retractall(dijkstra_dl(_,_)), conjuncts(Items,Colours,L,First,Last), conj(Body,L), assert(dijkstra_dl(Items,First-Last) :- Body). % % % % % goal goal goal goal goal 1 2 3 4 5

The Ô¨Årst two goals are obvious: dijkstra dl/2 is made a dynamic predicate and then its existing deÔ¨Ånition is removed from the database. The rÀÜ ole of conjuncts/5 is best illustrated by a sample query.
?- conjuncts(Items,[red,white,green],L,First,Last). Items = G399 L = [colour dl(red, G399, G402- G513), colour dl(white, G399, G513- G514), colour dl(green, G399, G514- G403)] First = G402 Last = G403
13 We note in passing that the default maximum number of entries of a list displayed on the terminal by SWI‚ÄìProlog is ten. For a full display of the twelve-entry list Grouped , we issue the prior query ?- set prolog flag(toplevel print options,[max depth(20)]). Yes

109 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Here, L is uniÔ¨Åed with the list of terms whose conjunction will form the body of the clause for dijkstra dl/2 . The variables First , Last and Items will be used in goal 5 as variables in the head of the clause for dijkstra dl/2 . We won‚Äôt spell out the deÔ¨Ånition of conjuncts/5 here but consider some salient points only. The list of terms in the third argument is created by an auxiliary predicate using the accumulator technique; see the source code for details. Perhaps the most imminent question here is how to get hold of an unspeciÔ¨Åed number of variable names.14 This is accomplished by vars/2 ,
?- vars(5,V). V = [ G239, G240, G241, G242, G243]

which may be deÔ¨Åned as shown below.15 vars(N,Vars) :- functor(Term,dummy,N), bagof(Var,Arg^arg(Arg,Term,Var),Vars). The requisite number of variables is generated by the built-in predicate functor/3 , as in ?- functor(Term,dummy,5). Term = dummy( G313, G314, G315, G316, G317) subsequent to which bagof/3 is used to collect the variables in a list. In goal 4, we use conj/2 (which is known from Sect. 3.2.1, p. 102) to unify with Body the conjunction of terms for the body of the clause to be created. Finally, in goal 5 the clause is written to the database. Exercise 3.17. Use dijkstra/3 to deÔ¨Åne dijkstra st(+Items,-Grouped) for returning in Grouped the entries of Items such that ‚Ä¢ All entries of Items feature in Grouped ; ‚Ä¢ The colours are sorted in alphabetical order; ‚Ä¢ And, as before, within each colour group, the items‚Äô original order is retained. Example:
?- items( Items), dijkstra st( Items,Grouped). Grouped = [col(sky, blue), col(ocean, blue), col(tomato, red), col(blood, red), col(cherry, red), col(milk, white), col(snow, white)]

at runtime will it be known how many colours conjuncts/5 holds in its second argument! There are at least two other alternatives for deÔ¨Åning vars/2 . The simplest is by using the built-in predicate length/2 : ?- length(Vars,5). Vars = [ G251, G254, G257, G260, G263] The second one is based on the built-in predicate =../2 (univ ) for assembling and disassembling terms. The idea for this implementation of vars/2 should be clear from the query below. ?- functor(Term,dummy,5), Term =.. [ |Vars]. Term = dummy( G478, G479, G480, G481, G482) Vars = [ G478, G479, G480, G481, G482] (The predicates functor/3 , arg/3 and univ will be familiar from Sect. 2.2.1.)
15

14 Only

110 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

3.3.2

Enhanced Implementations

The predicate dijkstra(+Colours,+Items,-Grouped) from Sect. 3.3.1 is ineÔ¨Écient inasmuch as it will require as many passes through Items as there are entries in Colours . We have seen implementations for the original Dutch Flag Problem in Exercise 2.10, requiring a single pass only through the input list Items . In this section, those versions will be enhanced for solving the problem‚Äôs more general formulation. As in Sect. 3.3.1 before, we want to glean the plan for solving the general problem by considering a speciÔ¨Åc example. Let us assume that Colours is the list [black,white,red,green] . Then, it is easily seen that the plan for the solution of Exercise 2.10 (pp. 152‚Äì153) still applies if colour dl/4 and dijkstra dl/2 are respectively replaced by the predicates encolour dl/5 and endijkstra dl/2 as shown in Fig. 3.15. Clearly,
encolour dl([],B-B,W-W,R-R,G-G).
1

‚é´ ‚é™ ‚é™ encolour dl([col(Object,black)|T], ‚é™ ‚é™ ‚é™ [col(Object,black)|B1]-B2,W1-W2,R1-R2,G1-G2) :- ‚é™ ‚é™ ‚é™ ‚é™ encolour dl(T,B1-B2,W1-W2,R1-R2,G1-G2). ‚é™ ‚é™ ‚é™ ‚é™ encolour dl([col(Object,white)|T], ‚é™ ‚é™ ‚é™ B1-B2,[col(Object,white)|W1]-W2,R1-R2,G1-G2) :- ‚é™ ‚é™ ‚é¨
encolour dl(T,B1-B2,W1-W2,R1-R2,G1-G2). encolour dl([col(Object,red)|T], B1-B2,W1-W2,[col(Object,red)|R1]-R2,G1-G2) :encolour dl(T,B1-B2,W1-W2,R1-R2,G1-G2). encolour dl([col(Object,green)|T], B1-B2,W1-W2,R1-R2,[col(Object,green)|G1]-G2) :encolour dl(T,B1-B2,W1-W2,R1-R2,G1-G2). encolour dl([col( , )|T],B1-B2,W1-W2,R1-R2,G1-G2) :encolour dl(T,B1-B2,W1-W2,R1-R2,G1-G2). endijkstra dl(Items, L1-L7) :encolour dl(Items,L1-L2,L2-L3,L3-L4,L4-L5,L5-L6,L6-L7).

‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ ‚é≠

2

3

4

Figure 3.15: Illustrative Example of Intended Database Updates the list of colours in Colours will be known at runtime only and thus the predicate deÔ¨Ånitions indicated in Fig. 3.15 should be accomplished by prior database updates. The predicates def encolour dl(+Colours) and def endijkstra dl(+Colours) shall be responsible for writing to the database clauses like 1 ‚Äì 3 and 4 , respectively. The present problem is more complex than that in Sect. 3.3.1 in two respects: both the number of clauses for, and the arity of the predicate encolour dl will be known at runtime only. Implementing def encolour dl/1 and def endijkstra dl/1 The top level deÔ¨Ånition of def encolour dl/1 is shown in Fig. 3.16. The following features are noteworthy: ‚Ä¢ The old deÔ¨Ånition (if present) of encolour dl (with the same arity as the one to be implemented) is removed from the database.

111 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

def encolour dl(Colours) :length(Colours,N), M is N + 1, dynamic(encolour dl/M), length(Vars,M), Old Version =.. [encolour dl|Vars], retractall(Old Version), ¬£ ' Implements base clause(Colours,B Clause), ¬¢ ‚é´ assert(B Clause), ‚é™ ‚é™ ((member(Colour,Colours), ‚é¨ ¬£ recursive clause(Colour,Colours,R Clause), ' Implements ¬¢ ‚é™ assert(R Clause), ‚é™ ‚é≠ fail); true), ¬£ catch all clause(Colours,C Clause), ' Implements ¬¢ assert(C Clause).

1

¬† ¬° ¬† ¬° ¬† ¬°

2

3

Figure 3.16: Top Level DeÔ¨Ånition of def encolour dl/1 ‚Ä¢ The auxiliary predicate base clause/2 creates the term for the base clause (marked followed by a database update. It is deÔ¨Åned by the predicates
base_clause(Colours,(Head :- true)) :- length(Colours,N), base(N,Head). base(N,Term) :- diffvars1(N,D), Term =.. [encolour_dl,[]|D]. diffvars1(N,D) :- functor(Term,dummy,N), Term =.. [_|L], diffterms(L,L,D).
1

in Fig. 3.15),

where diffvars1/2 produces a list with a given number of diÔ¨Äerences of pairwise identical variables as exempliÔ¨Åed by
?- diffvars1(3,D). D = [ G287- G287, G288- G288, G289- G289]

‚Ä¢ The terms for the recursive clauses (marked 2 in Fig. 3.15) are created by the auxiliary predicate recursive clause/3 and written to the database within a failure driven loop. recursive clause/3 reads at the top level as
recursive_clause(Colour,Colours,(Head :- Body)) :length(Colours,N), diffvars2(N,D), head(Colour,Colours,T,D,Head), body(T,D,Body), !.

where

112 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

1. diffvars2/2 produces a list with a given number of diÔ¨Äerences of pairwise distinct variables, 2. head/5 produces the term for the head of encolour , 3. body/3 produces the term for the body of encolour . head/5 and body/3 are respectively deÔ¨Åned by
head(Colour,Colours,T,D,Head) :comb(Object,Colour,Colours,D,Modified), Head =.. [encolour_dl,[col(Object,Colour)|T]|Modified]. body(T,D,Body) :- Body =.. [encolour_dl,T|D].

The predicate comb/5 combines the list of colours with the list of diÔ¨Äerence terms as exempliÔ¨Åed below.
?- comb(Object,w,[r,w,g],[R1-R2,W1-W2,G1-G2],M). Object = G429 R1 = G411 R2 = G412 W1 = G417 W2 = G418 G1 = G423 G2 = G424 M = [ G411- G412, [col( G429, w)| G417]- G418, G423- G424]

In the deÔ¨Ånition of comb/5 (not shown here) the accumulator technique is used. ‚Ä¢ Finally, the catch-all clause (marked 3 in Fig. 3.15) is created by the auxiliary predicate catch all clause/2 along similar lines to body/3 . (Its deÔ¨Ånition is not shown here). The deÔ¨Ånition of def endijkstra dl/1 is broadly analogous to that of catch all clause/2 and is not shown here. The full source code for the present version is available in the Ô¨Åle dl.pl. Exercise 3.18. In the above development, for simplicity, def encolour dl/1 was deÔ¨Åned such that clause 3 in Fig. 3.15 does not contain any reference to the colours to be omitted; this was accomplished by 3 being the last clause. The resulting deÔ¨Ånition of encolour dl will therefore be sensitive to the ordering of its clauses. This is not ideal, however, as it prevents code to be interpreted declaratively. RedeÔ¨Åne def encolour dl(+Colours) such that it writes to the database code which is not sensitive to clause reordering. Hints. ‚Ä¢ Aim at excluding the colours not in Colours by using the built-in predicate member/2 . If, for example, Colours is uniÔ¨Åed with [black, white, red, green] , then def encolour dl/1 writes instead of 3 the following clause to the database
encolour_dl([col(_, Clr)|T], B1-B2, W1-W2, R1-R2, G1-G2) :not(member(Clr, [black, white, red, green])), encolour_dl(T, B1-B2, W1-W2, R1-R2, G1-G2).

‚Ä¢ All we need is a new deÔ¨Ånition of catch all clause/2 , used in Fig 3.16. Use conj/2 (known from Sect. 3.2.1, p. 102) to construct the conjunction of the two goals in the body of the new clause of encolour dl . Each of the two conjuncts will be obtained by using =../2 . ‚Ä¢ The solution is in dl.pl.

113 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

Performance Comparison An experiment conÔ¨Årms that the enhanced version needs a lesser number of inferences than the version from Sect. 3.3.1.
?- new items( Items), Colours = [black,blue,violet,green,red,white], def encolour dl( Colours), def endijkstra dl( Colours), time(endijkstra dl( Items,Grouped-[])). % 16 inferences in 0.00 seconds (Infinite Lips) Grouped = [col(soot, black), col(coal, black), ...] ?- new items( Items), Colours = [black,blue,violet,green,red,white], replace dijkstra dl( Colours), time(dijkstra dl( Items,Grouped-[])). % 91 inferences in 0.00 seconds (Infinite Lips) Grouped = [col(soot, black), col(coal, black), ...]

The earlier version will appear more eÔ¨Écient, however, if we repeat this experiment and take also into account the overhead for creating and writing to the database the versions‚Äô deÔ¨Ånitions. This apparent advantage disappears,

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

114 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Program Manipulations

however, as soon as the list of items exceeds a certain length. Creating Plain Implementations Exercise 3.19. def encolour dl/1 and def endijkstra dl/1 gave rise to enhanced implementations which themselves were using diÔ¨Äerence lists. Write analogues of these two predicates creating plain solutions of the Dutch Flag Problem. More precisely, the implementations thus created should themselves be (the augmented) analogues of the solution proposed in Exercise 2.10, p. 60. The interactive session in Fig. 3.17 overleaf illustrates the desired behaviour of def encolour pl/1 and def endijkstra pl/1 .

115 Download free eBooks at bookboon.com

Prolog Techniques

Program Manipulations

?- listing(encolour pl). ERROR: No predicates for ‚Äòencolour pl‚Äô No ?- def encolour pl([black,white,red,green]). Yes ?- listing(encolour pl). encolour pl([], [], [], [], []). encolour pl([col(A, black)|B], [col(A, black)|C], D, E, F) encolour pl(B, C, D, E, F). encolour pl([col(A, white)|B], C, [col(A, white)|D], E, F) encolour pl(B, C, D, E, F). encolour pl([col(A, red)|B], C, D, [col(A, red)|E], F) :encolour pl(B, C, D, E, F). encolour pl([col(A, green)|B], C, D, E, [col(A, green)|F]) encolour pl(B, C, D, E, F). encolour pl([col(A, B)|C], D, E, F, G) :encolour pl(C, D, E, F, G). Yes ?- listing(endijkstra pl). ERROR: No predicates for ‚Äòendijkstra pl‚Äô No ?- def endijkstra pl([black,white,red,green]). Yes ?- listing(endijkstra pl). endijkstra pl(A, B) :- encolour pl(A, C, D, E, F), flatten([C, D, E, F], B).16 Yes ?- items( Items)17 , endijkstra pl( Items,Grouped). Grouped = [col(milk, white), col(snow, white), col(tomato, col(blood, red), col(cherry, red)] Yes 8

9

6

::-

:-

red),

7

Figure 3.17: Example Session for Exercise 3.19

16 In contrast to the special case in Exercise 2.10, now the number of lists to be concatenated will be known at runtime only. Thus the concatenation is best accomplished by using flatten/2 and not by (repeated use of) append/3 . 17 The predicate items/1 is as deÔ¨Åned in Sect. 2.4, p. 57.

116 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

Chapter 4

Exploratory Code Development
Conciseness and accessibility of source code through declarative reading are Prolog‚Äôs major strengths. It is therefore relatively easy to appreciate the workings of someone else‚Äôs implementation, while it is much harder independently to arrive at one‚Äôs own solution to the same problem. In this chapter, we illustrate a practical methodology which is intended to overcome this discrepancy: it is a software development style that is interactive, incremental, exploratory and allows Prolog code to be arrived at in a relatively eÔ¨Äortless manner.

4.1

A Nursery Rhyme

The task is to write a Prolog predicate rhyme/0 which displays on the screen the well-known nursery rhyme This is the House that Jack Built ([11]):
This is the house that Jack built. This is the malt That lay in the house that Jack built. This is the rat That ate the malt That lay in the house that Jack built. This is the cat That killed the rat That ate the malt That lay in the house that Jack built. This is the dog That worried the cat That killed the rat That ate the malt That lay in the house that Jack built. This is the cow with the crumpled horn That tossed the dog That worried the cat That killed the rat That ate the malt That lay in the house that Jack built. This is the maiden all forlorn That milked the cow with the crumpled horn That That That That That tossed the dog worried the cat killed the rat ate the malt lay in the house that Jack built.

This is the man all tattered and torn That kissed the maiden all forlorn That milked the cow with the crumpled horn That tossed the dog That worried the cat That killed the rat That ate the malt That lay in the house that Jack built. This is the priest all shaven and shorn That married the man all tattered and torn That kissed the maiden all forlorn That milked the cow with the crumpled horn That tossed the dog That worried the cat That killed the rat That ate the malt That lay in the house that Jack built. This is the cock that crowed in the morn That waked the priest all shaven and shorn That married the man all tattered and torn That kissed the maiden all forlorn

117 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

That That That That That That

milked the cow with the crumpled horn tossed the dog worried the cat killed the rat ate the malt lay in the house that Jack built.

This is the farmer sowing his corn That kept the cock that crowed in the morn

That That That That That That That That That

waked the priest all shaven and shorn married the man all tattered and torn kissed the maiden all forlorn milked the cow with the crumpled horn tossed the dog worried the cat killed the rat ate the malt lay in the house that Jack built.

In our implementation of rhyme/0 we want to exploit the rhyme‚Äôs repetitive structure and the fact that all essential information is contained in its last verse. We record the last verse in the database by verse/1 as shown in (P-4.1). Prolog Code P-4.1: DeÔ¨Ånition of verse/1
1 2 3 4 5 6 7 8 9 10 11

verse([‚ÄôThis ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat ‚ÄôThat

is the farmer sowing his corn‚Äô, kept the cock that crowed in the morn‚Äô, waked the priest all shaven and shorn‚Äô, married the man all tattered and torn‚Äô, kissed the maiden all forlorn‚Äô, milked the cow with the crumpled horn‚Äô, tossed the dog‚Äô, worried the cat‚Äô, killed the rat‚Äô, ate the malt‚Äô, lay in the house that Jack built.‚Äô]).

The rhyme is seen roughly to match the simpliÔ¨Åed pattern shown in Fig. 4.1. verse 1 ‚Üì A verse 2 ‚Üì B A verse 3 ‚Üì C B A verse 4 ‚Üì D C B A verse 5 ‚Üì E D C B A verse 6 ‚Üì F E D C B A ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑ ¬∑¬∑¬∑

Figure 4.1: The Rhyme‚Äôs SimpliÔ¨Åed Pattern Knowing the rhyme‚Äôs last verse and the above structure will allow (up to some Ô¨Åner detail) the rhyme to be fully reconstructed. With a view to a simpliÔ¨Åed preliminary Prolog implementation, we therefore deÔ¨Åne the following Prolog fact in the database
verse_skeleton([‚ÄôF‚Äô,‚ÄôE‚Äô,‚ÄôD‚Äô,‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô]).

The Ô¨Årst task is now to deÔ¨Åne a predicate rhyme prel/2 which should enable us to obtain the skeleton rhyme‚Äôs structure in the following manner.

118 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

?- verse skeleton( V), rhyme prel( V, R), write term( R,[]). [[A], [B, A], [C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

Taking this as an informal speciÔ¨Åcation of rhyme prel/2 , we want to arrive at its deÔ¨Ånition by a series of interactive experiments.

4.1.1

First Preliminary Implementation

What could be the least ambitious Ô¨Årst step in implementing rhyme prel/2 ? We may for example create a list whose only entry is the last entry of the above list-of-lists. (This will correspond to reproducing the last verse.) This we do by
?- verse skeleton( V), R = [ V], write term( R,[]). [[F, E, D, C, B, A]]

Still interactively, a list comprising the last two entries of the target list-of-lists may be generated by
?- verse skeleton( V), V = [ | T1], R = [ T1, V], write term( R,[]). [[E, D, C, B, A], [F, E, D, C, B, A]]

.

119 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Exploratory Code Development

Here we unify T1 with the tail of V and position it in front of V to form the new list (of lists). How do we now generate the next larger list (comprising the last three entries of the target list-of-lists)? We proceed as before except that we assemble R from the entries T2 , T1 and V (in that order!) where T2 is uniÔ¨Åed with the tail of T1 .
?- verse skeleton( V), V = [ | T1], T1 = [ | T2], R = [ T2, T1, V], write term( R,[]). [[D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

One more such step should suÔ¨Éce to appreciate the underlying pattern of interactively generating instances of R.
?- verse skeleton( V), V = [ | T1], T1 = [ | T2], T2 = [ | T3], R = [ T3, T2, T1, V], write term( R,[]). [[C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

Since our aim is to identify a recursive pattern in the above interactive session, we recast the inputs slightly by observing that [a1 , ¬∑ ¬∑ ¬∑ , an‚àí1 , an ] and [a1 |[a2 |[a3 | ¬∑ ¬∑ ¬∑ |[an‚àí1 |[an ]] ¬∑ ¬∑ ¬∑ ]] are equivalent representations of the same list. Let‚Äôs have a look at the last two queries again. ?- verse skeleton( V), V = [ | T1], T1 = [ | T2], R = [ T2 |[ T1|[ V]]], write term( R,[]).
Head Old Tail Old Rhyme Old

[[D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]] ?- verse skeleton( V), V = [ | T1], T1 = [ | T2], T2 = [ | T3 ], R = [ T3 |[ T2|[ T1|[ V]]]],
Head Old Head Head Rhyme Old Rhyme

write term( R,[]). [[C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]] The annotated lists suggest the following pseudocode (using Prolog‚Äôs list-notation) for one single recursive step. Rhyme Old Head Old Rhyme = = = [Head Old|Tail Old] [ |Head] [Head|Rhyme Old] (4.1) (4.2)

Notice that by equations (4.1) and (4.2) we may replace the latter by Rhyme = [Head|[Head Old|Tail Old]]

The base case for the recursion is given by First Rhyme = [[‚ÄôF‚Äô, ‚ÄôE‚Äô, ‚ÄôD‚Äô, ‚ÄôC‚Äô, ‚ÄôB‚Äô, ‚ÄôA‚Äô]]

120 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

A straightforward implementation of the recursive step is by the (auxiliary) predicate rhyme aux/3 in (P-4.2). Prolog Code P-4.2: First deÔ¨Ånition of the auxiliary predicate
1 2 3 4 5

rhyme_aux(R,1,R). rhyme_aux([Head_Old|Tail_Old],Counter,R) :Head_Old = [_|Head], New_Counter is Counter - 1, rhyme_aux([Head|[Head_Old|Tail_Old]],New_Counter,R).

In the Ô¨Årst argument of rhyme aux/3 the most recent version of the rhyme is accumulated; its second argument is a counter which is decremented from an initial value until it reaches unity at which point the third argument is instantiated to the Ô¨Årst. It is noteworthy in the deÔ¨Ånition of rhyme aux/3 that, as a consequence of using the accumulator technique, reference to the more complex case in the recursive step is found in the rule‚Äôs body. (In this sense, as opposed to the familiar situation from imperative programming, progression is from right to left.) We Ô¨Ånd out by an experiment what the counter should be initialized to.
?- verse skeleton( V), rhyme aux([ V],1, R), write term( R,[]). [[F, E, D, C, B, A]] ?- verse skeleton( V), rhyme aux([ V],2, R), write term( R,[]). [[E, D, C, B, A], [F, E, D, C, B, A]] ... ?- verse skeleton( V), rhyme aux([ V],6, R), write term( R,[]). [[A], [B, A], [C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

It is seen that the second argument of rhyme aux/3 (the counter) will have to be initialized to the length of (what stands for) the last verse. This gives rise to the following Ô¨Årst version of the predicate rhyme prel/2
rhyme_prel_1(V,R) :- length(V,L), rhyme_aux([V],L,R).

which then behaves as speciÔ¨Åed on p. 119. Even though the solution thus obtained is perfectly acceptable, there is scope for improvement. Counters are commonly used in imperative programming for verifying a stopping criterion. The corresponding task in declarative programming is best achieved by pattern matching . There is indeed no need for a counter here since the information for when not to apply the recursive step (any more) can be gleaned from the pattern of the Ô¨Årst argument of rhyme aux/3 : For the recursion to stop, the head of the list-of-lists (in the Ô¨Årst argument) should itself be a list with exactly one entry. (The complete rhyme will have been arrived at when the Ô¨Årst verse comprises a single line!) This idea gives rise in (P-4.3) to a new, improved (and more concise) version of the auxiliary predicate, now called rhyme aux/3 . Prolog Code P-4.3: Another deÔ¨Ånition of the auxiliary predicate
1 2 3 4

rhyme_aux_2([[First]|Rest],[[First]|Rest]). rhyme_aux_2([Head_Old|Tail_Old],R) :Head_Old = [_|Head], rhyme_aux_2([Head|[Head_Old|Tail_Old]],R).

rhyme aux 2/3 behaves as intended:

121 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

?- verse skeleton( V), rhyme aux 2([ V], R), write term( R,[]). [[A], [B, A], [C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

The deÔ¨Ånition of a second, improved version of the preliminary rhyme predicate now simpliÔ¨Åes to
rhyme_prel_2(V,R) :- rhyme_aux_2([V],R).

To complete the ‚Äòskeleton version‚Äô of the rhyme, we display the above by
?- verse skeleton( V), rhyme prel 2( V, R), show rhyme( R). A B A ... F E D C B A

with the predicate show rhyme/1 deÔ¨Åned by
show_list([]). show_list([H|T]) :- write(H), nl, show_list(T). show_rhyme([]). show_rhyme([H|T]) :- show_list(H), nl, show_rhyme(T).

There is still scope for further improvement leading to an even more concise version of the auxiliary predicate. We may replace in the deÔ¨Ånition of rhyme aux 2/2 all occurrences of Head Old by [H|T], say, accounting for the fact that Head Old will be uniÔ¨Åed with a list.
rhyme_aux_2([[H|T]|Tail_Old],R) :[H|T] = [_|Head], rhyme_aux_2([Head|[[H|T]|Tail_Old]],R).

But then, by virtue of the Ô¨Årst goal in the body of this rule we may replace all occurrences of Head by T. Subsequently, the Ô¨Årst goal may be dropped. Overall, we obtain in (P-4.4) a third, even more concise version of the auxiliary predicate. Prolog Code P-4.4: Third deÔ¨Ånition of the auxiliary predicate
1 2

rhyme_aux_3([[First]|Rest],[[First]|Rest]). rhyme_aux_3([[H|T]|Tail_Old],R) :- rhyme_aux_3([T|[[H|T]|Tail_Old]],R).

There is hardly any room for improvement left save perhaps a minor simpliÔ¨Åcation of the Ô¨Årst clause. We derive an alternative boundary case by Ô¨Årst completing the interactive session from p. 120 and then carrying out one more step:

122 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

?- verse skeleton( V), V = [ | T1], T1 = [ | T2], T2 = [ | T3], T3 = [ | T4], T4 = [ | T5], R = [ T5|[ T4|[ T3|[ T2|[ T1|[ V]]]]]], write term( R,[]). [[A], [B, A], [C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]] ?- verse skeleton(_V), V = [ | T1], T1 = [ | T2], T2 = [ | T3], _T3 = [ | T4], T4 = [ | T5], T5 = [ | T6], R = [_T6|[_T5|[_T4|[_T3|[_T2|[_T1|[_V]]]]]]], write term(_R,[]). [[], [A], [B, A], [C, B, A], [D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

The Ô¨Årst query suggests that we are Ô¨Ånished if the (partially) completed skeleton rhyme‚Äôs head is a singleelement list; this condition gave rise to the earlier boundary case. On the other hand, in the second query the variable R is uniÔ¨Åed with a list whose head is empty and whose tail is the full skeleton rhyme. This suggests the following alternative Ô¨Årst clause for rhyme aux 3/2 ,
rhyme_aux_3([[]|R],R).

The disadvantage of this stopping criterion is that it will cause one additional invocation of the recursive step.

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

123 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Exploratory Code Development

Of course, the third version of the auxiliary predicate, rhyme aux 3/2 , (with any of the two alternative Ô¨Årst clauses) gives rise to yet another version of rhyme prel/2 .
rhyme_prel_3(V,R) :- rhyme_aux_3([V],R).

4.1.2

Another Preliminary Implementation

With a view to wishing to use the accumulator technique (yet again), let us examine the Ô¨Årst few steps of an (as yet imaginary ) interactive session.
?-... [F, E, ?-... [E, D, ?-... [D, C, ?-... [C, B, D, C, B, A], [] C, B, A], [[F, E, D, C, B, A]] B, A], [[E, D, C, B, A], [F, E, D, C, B, A]] A], [[D, C, B, A], [E, D, C, B, A], [F, E, D, C, B, A]]

Two lists are involved here. The Ô¨Årst list serves as a ‚Äòsupplier‚Äô for updating the second one in which the skeleton rhyme‚Äôs verses are accumulated. We observe that in each step the Ô¨Årst list ‚Äòloses‚Äô its head, whereas the second list is augmented by the Ô¨Årst one. At the end of this sequence of steps (i.e. when the Ô¨Årst list is empty) the second list will contain the full skeleton rhyme. Having established the underlying idea, we now turn to the corresponding interactive session. (This may look tedious but is easily carried out using ‚Äòcopy-and-paste‚Äô.)
?- verse skeleton( V), P1 = ( V,[]), write term( P1,[]). [F, E, D, C, B, A], [] ?- verse skeleton( V), P1 = ( V,[]), ([ H1| T1], Acc1) = P1, P2 = ( T1,[[ H1| T1]| Acc1]), write term( P2,[]). [E, D, C, B, A], [[F, E, D, C, B, A]] ?- verse skeleton( V), P1 = ( V,[]), ([ H1| T1], Acc1) = P1, P2 = ( T1,[[ H1| T1]| Acc1]), ([ H2| T2], Acc2) = P2, P3 = ( T2,[[ H2| T2]| Acc2]), write term( P3,[]). [D, C, B, A], [[E, D, C, B, A], [F, E, D, C, B, A]] ?- ...

To see how consecutive steps in the above query are interrelated, we have a look at two goals in the last query in some more detail; this is shown in Fig. 4.2. It is indicated here how the new pair P3 is expressed in terms c ([ H2| T2 ], Acc2) = P2, P3 = ( T2 ,[[ H2| T2]| Acc2]), T T

Figure 4.2: Exploring Details of the Rhyme‚Äôs Structure

124 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

of the old pair P2 . This observation gives rise to (P-4.5), a fourth version of rhyme prel/2 . Prolog Code P-4.5: Fourth version of rhyme prel/2
1

rhyme_prel_4(V,R) :- rhyme_acc(V,[],R). rhyme_acc([],R,R). rhyme_acc([HOld|TOld],AccOld,R) :rhyme_acc(TOld,[[HOld|TOld]|AccOld],R).

2 3 4

4.1.3

The Final Version

We may use any of the four versions produced thus far of rhyme prel/2 to obtain a rough version of rhyme/0 by replacing in the query on p. 122, Sect. 4.1.1, the term verse skeleton( V) by the term verse( V) ; for example,
?- verse( V), rhyme prel 2( V, R), show rhyme( R). That lay in the house that Jack built. That ate the malt That lay in the house that Jack built. ... This That ... That That That That That is the farmer sowing his corn kept the cock that crowed in the morn tossed the dog worried the cat killed the rat ate the malt lay in the house that Jack built.

We realize that the rhyme thus produced is not quite what we want: the Ô¨Årst line of each verse (and not merely that of the last verse) should begin with ‚ÄòThis is ...‚Äô. This eÔ¨Äect will be achieved in three steps. 1. DeÔ¨Åne a predicate to first/2 which, when applied to an atom, replaces all its characters up to the Ô¨Årst occurrence of the string ‚Äòthe‚Äô by the string ‚ÄòThis is ‚Äô. Example:
?- to first(‚ÄôWe find the definite article.‚Äô,A). A = ‚ÄôThis is the definite article.‚Äô

2. DeÔ¨Åne change first/2 in terms of to first/2 by
change_first([H1|T],[H2|T]) :- to_first(H1,H2).

This predicate applies to first/2 to the head of a list of atoms while leaving the tail unchanged. Example:
?- change first([‚ÄôThat was the first‚Äô,‚ÄôNow the second‚Äô, ‚ÄôNow the third‚Äô],L). L = [‚ÄôThis is the first‚Äô, ‚ÄôNow the second‚Äô, ‚ÄôNow the third‚Äô]

125 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

3. Now apply change first/2 by means of the built-in predicate maplist/3 to the Ô¨Årst line of each verse of the rhyme‚Äôs rough version. Below we show our deÔ¨Ånition of to first/2 .
to_first(Old,New) :- atom_chars(Old,Charlist), change(Charlist,Newlist), concat_atom(Newlist,New).

Given an atom (in Old), it is Ô¨Årst converted by means of the built-in predicate atom chars/2 into a list of one-character atoms (in Charlist).

Built-in Predicate: atom chars(?Atom,?CharList) It converts an atom into the corresponding list of one‚Äìcharacter atoms and vice versa. Example: ?- atom chars(‚ÄôText‚Äô,L). L = [‚ÄôT‚Äô, e, x, t]

The predicate change/2 is then used to eÔ¨Äect the intended change in the atom‚Äôs list-of-characters representation; it is deÔ¨Åned by1
change([t,h,e|T],[‚ÄôT‚Äô,h,i,s,‚Äô ‚Äô,i,s,‚Äô ‚Äô,t,h,e|T]) :- !. change([_|T],X):- change(T,X).

and its behaviour is exempliÔ¨Åed by
?- change([‚ÄôF‚Äô,i,n,d,‚Äô ‚Äô,t,h,e,‚Äô ‚Äô,s,t,r,i,n,g], L), write_term( L,[]). [T, h, i, s, , i, s, , t, h, e, ,s, t, r, i, n, g]

Finally, the built-in predicate concat atom/2 is used to convert the list-of-characters in Newlist into an atom (in New).2

Built-in Predicate: concat atom(+List,-Atom) Atom is obtained by concatenating the elements of List . Example: ?- concat atom([atom1,atom2,atom3],A). A = atom1atom2atom3

Having thus arrived at an implementation of change first/2 , we now want to apply this predicate to the head of each of the rough rhyme‚Äôs verses. Since the latter is available (from rhyme prel/2 ) as a list, we may use maplist/3 for a concise deÔ¨Ånition of rhyme/0 .
of the cut, change/2 will fail on backtracking even for multiple occurrences of the substring ‚Äòthe‚Äô in its Ô¨Årst argument. the present purposes where a list of single character atoms needs concatenating, we may use atom chars/2 as an alternative. The last goal in the deÔ¨Ånition of to first/2 then reads as atom chars(New,Newlist).
2 For 1 Because

126 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

Built-in Predicate: maplist(+Pred,?List1,?List2) The 2‚Äìary predicate Pred is applied to each entry of List1 giving List2 and vice versa.3 Example: ?- maplist(append([a,b]),[[r,s],[u,v]],L). L = [[a, b, r, s], [a, b, u, v]] ?- maplist(append([a,b]),L,[[a,b,r,s],[a,b,u,v]]). L = [[r, s], [u, v]] (Here, append/3 became a 2‚Äìary predicate by partial application by Ô¨Åxing its Ô¨Årst argument to [a,b] .)

Now, any of the four versions of rhyme prel/2 may be used to deÔ¨Åne rhyme/0 ; for example,
rhyme_2 :- verse(V), rhyme_prel_2(V,RTemp), maplist(change_first,RTemp,R), show_rhyme(R).

4.1.4

Other Approaches

All solutions considered thus far were based on (some form of) the accumulator technique. The problem at hand can also be approached by simple recursion, however. To arrive at such a solution, we Ô¨Årst show in Table 4.1 the desired rhyme for some last verses of various lengths. We ask ourselves the following question: Last Verse
[‚ÄôA‚Äô] [‚ÄôB‚Äô,‚ÄôA‚Äô] [‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô] [‚ÄôD‚Äô,‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô] ¬∑¬∑¬∑ [[‚ÄôA‚Äô]] [[‚ÄôA‚Äô],[‚ÄôB‚Äô,‚ÄôA‚Äô]] [[‚ÄôA‚Äô],[‚ÄôB‚Äô,‚ÄôA‚Äô],[‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô]] [[‚ÄôA‚Äô],[‚ÄôB‚Äô,‚ÄôA‚Äô],[‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô],[‚ÄôD‚Äô,‚ÄôC‚Äô,‚ÄôB‚Äô,‚ÄôA‚Äô]] ¬∑¬∑¬∑

Rhyme

Table 4.1: Rhyme Structure

Given a particular rhyme, how can the previous rhyme be expressed in terms of the current one? A declarative reading of the last two lines of Table 4.1 suggest the following: [H|T] is the last verse of the current rhyme C if T is the last verse of the previous rhyme P and C comes about by appending [[H|T]] to
3 The ‚Äòreverse‚Äô application of maplist/3 is possible only if the second argument of Pred may be used in the input mode. This is not the case for example for flatten/2 as is shown below.

?- maplist(flatten,[[a,[b,[c,d],e]],[[[r,s],t],x,y]],L). L = [[a, b, c, d, e], [r, s, t, x, y]] ?- maplist(flatten,L,[[a,b,c,d,e],[r,s,t,x,y]]). No

127 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

P . And, the boundary case is identiÔ¨Åed by observing that the one-line verse [L] is the last verse of [[L]] . The aforesaid is immediately expressed in Prolog by either of the two (logically equivalent) deÔ¨Ånitions (P-4.6) and (P-4.7).4 Prolog Code P-4.6: Fifth version of rhyme prel/2
1 2

rhyme_prel_5([L],[[L]]). rhyme_prel_5([H|T],C) :- append(P,[[H|T]],C), rhyme_prel_5(T,P).

Prolog Code P-4.7: Sixth version of rhyme prel/2
1 2

rhyme_prel_6([L],[[L]]). rhyme_prel_6([H|T],C) :- rhyme_prel_6(T,P), append(P,[[H|T]],C).

(It is readily conÔ¨Årmed that both versions behave as earlier ones do.) As each of the last two predicates is deÔ¨Åned in terms of append/3 we would expect some improvement in elegance (and performance) by rewriting

4 The following are alternative Ô¨Årst clauses: rhyme prel 5([],[]). rhyme prel 6([],[]).

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

128 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Exploratory Code Development

them using diÔ¨Äerence lists . Indeed, both versions give rise to (P-4.8), the same concise, tail recursive implementation using diÔ¨Äerence lists. Prolog Code P-4.8: Seventh version of rhyme prel/2
1 2

rhyme_prel_dl([L],[[L]|X]-X). rhyme_prel_dl([H|T],C1-C2) :- rhyme_prel_dl(T,C1-[[H|T]|C2]). rhyme_prel_7(V,R) :- rhyme_prel_dl(V,R-[]).

3

Exercise 4.1. We want to make an experimental comparison between the various versions of rhyme prel/2 and need therefore a predicate that produces rhymes of any speciÔ¨Åed length. To be more speciÔ¨Åc, we will need a predicate long verse/1 which removes from the database the current version of verse/1 and replaces it by something of a repetitive structure and of a speciÔ¨Åed length as shown in the session below.
?- long verse(3), verse( V), show list( V). That interacts with the item ... That interacts with the item ... That interacts with the item ... ?- rhyme 2. This is the item ... This is the item ... That interacts with the item ... This is the item ... That interacts with the item ... That interacts with the item ...

DeÔ¨Åne the predicate long verse/1 .

We can now use long verse/1 in conjunction with the built-in predicate time/1 to assess the versions‚Äô performance; this is shown for the last three versions in Table 4.2 below.5 As expected, version seven, the impleVersion 5 Version 6 Version 7 length of CPU-time length of CPU-time length of CPU-time V [sec] V [sec] V [sec] 100 1.97 1,000 4.51 10,000 0.28 200 15.77 2,000 20.04 20,000 0.71 300 52.50 3,000 45.53 30,000 0.55 400 125.0 4,000 85.63 40,000 1.32 500 244.1 5,000 132.4 50,000 1.16

Table 4.2: CPU Times for Versions of the Query ?- rhyme prel( V, R). mentation based on diÔ¨Äerence lists, is by far the most eÔ¨Écient. Furthermore, perhaps surprisingly, version six
5 The Ô¨Årst entry in Table 4.2 for example may be obtained by ?- long verse(100), verse( V), time(rhyme prel 5( V, R)). % 176,749 inferences in 1.97 seconds (89720 Lips)

129 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

turns out to be better than its tail recursive counterpart, version Ô¨Åve. We turn to Prolog‚Äôs tracing facility to Ô¨Ånd out why this is the case:
?- trace([append/3,rhyme prel 5/2,rhyme prel 6/2]). % append/3: [call, redo, exit, fail] % rhyme_prel_5/2: [call, redo, exit, fail] % rhyme_prel_6/2: [call, redo, exit, fail] [debug] ?- rhyme prel 5([‚ÄôB‚Äô,‚ÄôA‚Äô],R). T Call: (6) rhyme_prel_5([‚ÄôB‚Äô, ‚ÄôA‚Äô], _G418) T Call: (7) append(_G506, [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], _G418) T Exit: (7) append([], [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], [[‚ÄôB‚Äô, ‚ÄôA‚Äô]]) T Call: (7) rhyme_prel_5([‚ÄôA‚Äô], []) T Call: (8) append(_G512, [[‚ÄôA‚Äô]], []) T Fail: (8) append(_G512, [[‚ÄôA‚Äô]], []) T Fail: (7) rhyme_prel_5([‚ÄôA‚Äô], []) T Redo: (7) append(_G506, [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], _G418) T Exit: (7) append([_G476], [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], [_G476, [‚ÄôB‚Äô, ‚ÄôA‚Äô]]) T Call: (7) rhyme_prel_5([‚ÄôA‚Äô], [_G476]) T Exit: (7) rhyme_prel_5([‚ÄôA‚Äô], [[‚ÄôA‚Äô]]) T Exit: (6) rhyme_prel_5([‚ÄôB‚Äô, ‚ÄôA‚Äô], [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]]) R = [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]] [debug] ?- rhyme prel 6([‚ÄôB‚Äô,‚ÄôA‚Äô],R). T Call: (6) rhyme_prel_6([‚ÄôB‚Äô, ‚ÄôA‚Äô], _G418) T Call: (7) rhyme_prel_6([‚ÄôA‚Äô], _G498) T Exit: (7) rhyme_prel_6([‚ÄôA‚Äô], [[‚ÄôA‚Äô]]) T Call: (7) append([[‚ÄôA‚Äô]], [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], _G418) T Exit: (7) append([[‚ÄôA‚Äô]], [[‚ÄôB‚Äô, ‚ÄôA‚Äô]], [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]]) T Exit: (6) rhyme_prel_6([‚ÄôB‚Äô, ‚ÄôA‚Äô], [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]]) R = [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]]

It is seen that version Ô¨Åve causes Prolog to backtrack on the search tree of append/3 until append([ G482],[[‚ÄôB‚Äô,‚ÄôA‚Äô]] succeeds. This is quite a contrast to rhyme prel 6 which does not cause backtracking but builds up a stack of subgoals all of which eventually are satisÔ¨Åed in turn. It is also easily veriÔ¨Åed that on backtracking version Ô¨Åve will not terminate whereas version six will fail to re-satisfy the goal and returns ‚ÄòNo‚Äô. Exercise 4.2. Modify the deÔ¨Ånition of rhyme prel 5/2 such that it won‚Äôt loop but fails on backtracking.

Exercise 4.3. DeÔ¨Åne cputime(+Predname,+Arglist,-Time) for obtaining the CPU seconds in Time for the predicate with name Predname and arguments in Arglist . Then, for example, the following is an alternative to the query in footnote 5 on p. 129:
?- long verse(100),verse( V),cputime(rhyme prel 5,[ V, R],Time). Time = 1.97

The predicate cputime/3 will be an improvement on time/1 since it will then be possible to produce for example the Ô¨Årst row of Table 4.2 in one sweep interactively as follows.
?- findall( Time,(member( L,[100,200,300,400,500,600,700]), long verse( L), verse( V), cputime(rhyme prel 5,[ V, R], Time)),

130 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

Times). Times = [2.03, 15.71, 52.29, 124.51, 242.5, 419.58, 667.78]

(Slight variations in the CPU times may be observed even when repeating the same query.) In your deÔ¨Ånition of cputime/3 you should use the built-in predicate statistics/2 .

Built-in Predicate: statistics(+Key,-Value) Unify system statistics determined by Key with Value . For example, we obtain the CPU seconds and number of inferences accumulated in the present Prolog session by ?- statistics(cputime,Time). Time = 18020.2 ?- statistics(inferences,Inf). Inf = 222054681

Exercise 4.4. We have created several versions of rhyme prel/2 and have indicated the version number by an appropriate suÔ¨Éx attached to the original predicate name. Let us now assume that this is the style for indicating predicates‚Äô versions in general. In this exercise, you are asked to deÔ¨Åne a predicate cputime/4 which is a generalization of cputime/3 from Exercise 4.3 in that the former will allow the version number to be speciÔ¨Åed by an extra (the third) argument. Example:
?- long verse(100),verse( V),cputime(rhyme prel,[ V, R],5,Time). Time = 1.97

The beneÔ¨Åt of cputime/4 is obvious: it will allow the timing of several versions of the same predicate in one sweep, as is illustrated below.
?- long verse(70000), verse( V), maplist(cputime(rhyme prel,[ V, R]),[1,2,3,4,7],Times). Times = [4.28, 3.19, 3.35, 1.54, 3.18]

Exercise 4.5. Using cputime/4 from Exercise 4.4, produce all entries of Table 4.2 interactively by one single query. Hint. As a Ô¨Årst step, you should revisit the problem of producing interactively a list comprising the Ô¨Årst row of entries in Table 4.2 (c.f. Exercise 4.3). This is now best achieved by using the built-in predicates findall/3 and between/3 and by observing that the last verse‚Äôs length is expressed in terms of the column number j = 1, . . . , 5 as length = j √ó 102 The general case is dealt with by nesting two such constructs. Version number and length are respectively generated by version = i + 3 length = j √ó 10i

131 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

with i = 2, 3, 4 and j = 1, . . . , 5.

4.2

Project: ‚ÄôOne Man Went to Mow . . .‚Äô

Another nursery rhyme with a similar recursive structure is the well-known song One man went to mow . . . whose three-verse version is as follows.6 One man went to mow, Went to mow a meadow, One man and his dog, Went to mow a meadow.
6 Source: The BBC web site http://www.bbc.co.uk/cbeebies/tweenies/songtime/ It is a cornucopia of songs and rhymes for pre-school children.

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

132 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Exploratory Code Development

Two men went to mow, Went to mow a meadow, Two men, one man and his dog, Went to mow a meadow. Three men went to mow, Went to mow a meadow, Three men, two men, one man and his dog, Went to mow a meadow, Went to mow a meadow. We want to outline here the way this rhyme can be produced in Prolog and formulate the stages of the detailed work as exercises. This song has a very similar recursive structure to that of This is the house that Jack built except that there is now no predeÔ¨Åned ‚Äòlast verse‚Äô from which we could unravel the entire rhyme. Our aim is to produce a ¬£ predicate ¬† ¬£ ¬† song/0 returning on the terminal a continuous stream of verses until stopped by the keystrokes +¬¢C ¬° . The intended behaviour is shown in Fig. 4.3.7 ¬¢Ctrl ¬°
?- song. One man went to mow, Went to mow a meadow, One man and his dog, Went to mow a meadow. Two men went to mow, Went to mow a meadow, Two men, one man and his dog, Went to mow a meadow. ... Seven men went to mow, Went to mow a meadow, Seven men, six men, five men, four men, three men, two men, one man and his dog, Went to mow a meadow. Action (h for help) ? abort % Execution Aborted

Figure 4.3: Desired Behaviour of song/0
7 Here we deliberately avoid asking for a Ô¨Åxed number of verses since otherwise the task would not be dissimilar enough to the one considered in Sect. 4.1: we could then produce a ‚Äòlast verse‚Äô with relative ease and then proceed as before.

133 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

The core of the implementation is a predicate song skeleton/1 which on backtracking returns the skeleton structure of each verse using numerals.
?- song Verse = Verse = Verse = ... skeleton(Verse). [1] ; [2, 1] ; [3, 2, 1] ;

Exercise 4.6. DeÔ¨Åne the predicate song skeleton/1 by recursion. Hint. You may model your deÔ¨Ånition of song skeleton/1 on that of the predicate int/1 , which on backtracking returns all natural numbers:
?- int(N). N = 1 ; N = 2 ; N = 3 ; ...

The predicate int/1 is deÔ¨Åned in terms of an auxiliary predicate int(+Int1,?Int2) by
int(N) :- int(1,N).

which on backtracking instantiates Int2 to all integers starting from Int1 :
?- int(5,I). I = 5 ; I = 6 ; I = 7 ; ...

The deÔ¨Ånition of int/2 is as follows.
int(I,I). int(Last,I) :- succ(Last,New), int(New,I).

Built-in Predicate: succ(?Int1,?Int2) Succeeds if Int1 = Int2 + 1. Incrementation by succ/2 is faster than by the usual arithmetic predicate.

There is in Prolog, as an alternative to recursion, the facility of failure driven, and repeat loops for the implementation of code with a repetitive behaviour. We want to illustrate this idea by way of a predicate nat/1 which has the same speciÔ¨Åcation as the predicate int/1 from above but is deÔ¨Åned in terms of a repeat loop rather than by recursion. Let nat/1 be deÔ¨Åned by

134 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

nat(N) :- first_nat, current_nat(N). nat(N) :- repeat, update_nat, current_nat(N).

with the auxiliary predicates
first_nat :- dynamic(current_nat/1), retractall(current_nat(_)), assert(current_nat(1)).

and
update_nat :- current_nat(N), retractall(current_nat(_)), NewN is N + 1, assert(current_nat(NewN)).

The predicate current nat/1 is used here to hold the current value of the natural number in the database as a fact. first nat/0 clears the database of all facts deÔ¨Åning current nat/1 (possibly originating from earlier invocations of nat/1 ) and writes to the database the Ô¨Årst natural number. update nat/0 retrieves the previous value, clears the database, and writes back the updated value. The generation of an inÔ¨Ånite stream of values by (the second clause of) nat/1 hinges on the built-in predicate repeat/0 which always succeeds on backtracking and is best thought of as returning a distinct (albeit invisible) ‚Äòsolution‚Äô each time it is re-invoked. The conjunction of subgoals to the right of repeat, i. e.

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

135 Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

Prolog Techniques

Exploratory Code Development

update_nat, current_nat(N)

is re-satisÔ¨Åed on backtracking, resulting in an update of N . The database serves here as a ‚Äòscratchpad‚Äô for intermediate results. Exercise 4.7. DeÔ¨Åne a second version of the predicate song skeleton/1 by a repeat loop. Your solution should be modelled on the deÔ¨Ånition of nat/1 .

There are of course other possibilities, too, for deÔ¨Åning song skeleton/1 . Take for example the one suggested by the following query.
?- current prolog flag(max integer, Largest), between(1, Largest, H), findall( I,between(1, H, I), R), reverse( R,L). L = [1] ; L = [2, 1] ; L = [3, 2, 1] ; ...

The list L is constructed here by: ‚Ä¢ Getting hold of the largest number Largest which can be represented in SWI‚ÄìProlog as an integer. ‚Ä¢ Obtaininig the head H of L by the built-in predicate between/3 . ‚Ä¢ Creating the reverse R of L by the all-solutions predicate findall/3 . ‚Ä¢ And, Ô¨Ånally, reversing R to get L . A new L is obtained each time the query‚Äôs second goal is re-satisÔ¨Åed. This solution is neither concise nor is it as elegant as the earlier ones, however. The remaining steps for the completion of song/0 are spelt out in the Exercises 4.8 to 4.11 below. Exercise 4.8. DeÔ¨Åne a predicate digits(+Number,-List) for converting a natural Number into the list of its digits in List :
?- digits(351,L). L = [3, 5, 1]

(As an optional task which, however, is not needed in the present context, you may extend the deÔ¨Ånition of digits/2 for the instantiation pattern digits(-Number,+List) .) Now deÔ¨Åne a predicate in words(+Num,-Atom) for converting a numeral Num to its plain English equivalent in Atom . (Allow for up to 9, 999 in Num .) Example:
?- in words(351,A). A = threehundredfiftyone8

Exercise 4.9. In the deÔ¨Ånition of the Ô¨Årst and third lines of each verse you will need a predicate capital/2 for converting the Ô¨Årst character of an atom to its upper case equivalent:
8 For

reasons of simplicity, the rules of hyphenation and separating spaces are ignored here.

136 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

?- capital(‚Äôsixteen men, fifteen men, fourteen men‚Äô,C). C = ‚ÄôSixteen men, fifteen men, fourteen men‚Äô

DeÔ¨Åne capital/2 . Note. Use the built-in predicate atom chars/2 to disassemble atoms into lists and vice versa; see, inset on p. 126. For a concise solution to converting single letters to upper case you will also need the built-in predicate char code/2 .9

Built-in Predicate: char code(?Char,?ASCII) Converts the single-character atom Char to its ASCII code in ASCII and vice versa. Example: ?- char code(a,ASCII). ASCII = 97 ?- char code(Char,65). Char = ‚ÄôA‚Äô

Exercise 4.10. DeÔ¨Åne a predicate line3/2 for generating the third line of each verse; for example, the third verse‚Äôs third line we get by
?- line3([3,2,1],Text), write(Text). Three men, two men, one man and his dog, Text = ‚ÄôThree men,\n two men,\n one man and his dog,‚Äô

In your work, you may be guided by the following query:
?- maplist(in words,[16,15,14],[H|T]), maplist(atom concat(‚Äô men, ‚Äô),T,L), concat atom([H|L],A), atom concat(A,‚Äô men‚Äô,A2). H = sixteen T = [fifteen, fourteen] L = [‚Äô men, fifteen‚Äô, ‚Äô men, fourteen‚Äô] A = ‚Äôsixteen men, fifteen men, fourteen‚Äô A2 = ‚Äôsixteen men, fifteen men, fourteen men‚Äô

9 A simpler but more tedious alternative is by using a predicate which is deÔ¨Åned by 26 facts ‚Äì one for each letter in the English alphabet.

137 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

Built-in Predicate: atom concat(?Atom1,?Atom2,?Atom3) Atom3 is the concatenation of Atom1 and Atom2 . At least two of the arguments must be instantiated. Alternatively, it suÔ¨Éces if the last argument is instantiated only. Examples: ?- atom concat(atom1,atom2,A). A = atom1atom2 ?- atom concat(A1,A2,atom3). A1 = ‚Äô‚Äô A2 = atom3 ; A1 = a A2 = tom3 Yes

Exercise 4.11. Complete the deÔ¨Ånition of song/0 by using your predicates from the Exercises 4.6 to 4.10.

AXA Global Graduate Program
Find out more and apply

138 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Exploratory Code Development

4.3

Chapter Notes

We have illustrated a practical Prolog development technique based on an incremental, exploratory and interactive working style. It is not dissimilar to the Incremental Development Model known from Software Engineering (e. g. [15]) the application of which in the commercial context results in prototypes at an early stage for evaluation and feedback. We have identiÔ¨Åed the following development stages in particular for predicates deÔ¨Åned by recursion : ‚Ä¢ Identify informally a recursive structure of the problem. ‚Ä¢ Experiment interactively to explore and conÔ¨Årm the above. ‚Ä¢ Identify a pattern and write pseudo‚Äìcode. ‚Ä¢ Write a preliminary (and perhaps incomplete) Prolog implementation. ‚Ä¢ ReÔ¨Åne details to arrive at a Ô¨Ånal Prolog implementation. The method discussed here won‚Äôt of course be a substitute for existing formal approaches to logic programming that are rooted in Mathematical Logic (e. g. [5]).

139 Download free eBooks at bookboon.com

Prolog Techniques

Exploratory Code Development

140 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Appendix A

Solutions of Selected Exercises
A.1 Chapter 1 Exercises

All Prolog source code for Chap. 1 is available in the Ô¨Åle accumulator.pl. Exercise 1.1. DeÔ¨Åne from to/3 and its auxiliary from to acc/3 by (P-A.1). Prolog Code P-A.1: DeÔ¨Ånition of from to/3
1 2 3 4 5 6 7

from_to(M,N,L) :- (var(L); is_list(L)), integer(M), integer(N), M =< N, from_to_acc(M,[N],L), !. from_to(H,N,[H|T]) :- last(N,[H|T]), !, H =< N.

% clause 0 % % % % % clause 1 %

8 9 10

from_to_acc(H,[H|T],[H|T]). % clause 2 from_to_acc(M,[H|T],L) :- NewHead is H - 1, !, % clause 3 from_to_acc(M,[NewHead,H|T],L). %

The annotated version of the hand computations from Fig. 1.4 is shown in Fig. A.1.

The idea suggested by

from to(6,9,L)

:; from to acc(6,[9],L) :; :; from to acc(6,[7,8,9],L) :; :; L = [6,7,8,9] :; success
2 0 3 3

0

3

from to acc(6,[8,9],L)

from to acc(6,[6,7,8,9],L)

Figure A.1: Annotated Hand Computations for from to/3

141 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

the hand computations is clearly reÔ¨Çected in the clauses 0, 2 and 3. It is instructive to consider the unexpected consequences of a slight (and perhaps innocent looking) change to clause 0. If we redeÔ¨Åne clause 0 as shown here,
from_to(M,N,L) :- var(L), integer(M), integer(N), M =< N, from_to_acc(M,[N],L), !. % new clause 0 % % % %

then the predicate‚Äôs pattern matching functionality will be corrupted:
?- from to(6,9,[ , ,E| ]). E = 9

(The third entry of the list [6,7,8,9] is clearly not 9 .) To explain this, we note that Prolog Ô¨Årst tries the modiÔ¨Åed clause 0 which will fail since [ , ,E| ] is not a variable but a compound term.1
?- var([ , ,E| ]). No
1 Lists

are compound terms with the functor ‚Äò. ‚Äô (dot). More on this will be found in Sect. 2.2.1.

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

142 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Next, clause 1 is tried, which then succeeds as indicated by the query below.
?- (6,9,[ , ,E| ]) = (H,N,[H|T]), last(N,[H|T]), !, H =< N. E = 9 H = 6 N = 9 T = [ G269, 9]

Why? Well, for the Ô¨Årst goal of this query to succeed, [H|T] has to have at least three entries, requiring T be of length at least two. The second goal then succeeds with T as a two-element list (whose Ô¨Årst entry is a system chosen internal variable):
?- last(9,[6|T]). 2 T = [9] ; T = [ G269, 9] ; T = [ G269, G272, 9] ; ...

Therefore, [H|T] will be uniÔ¨Åed with [6, G269,9] . Now, the uniÔ¨Åcation [ , ,E| ] = [H|T] (still in force from the Ô¨Årst goal) requires that E be uniÔ¨Åed with the third entry of [6, G269,9] , i.e. with 9 . We note in passing that the predicate numlist/3 in SWI-Prolog, Version 5.2.7, has almost the same functionality as our from to/3 . (The instantiation pattern numlist(-Low,-High,+List) has not been implemented there.) Exercise 1.2. The new version, nums/2 , is deÔ¨Åned in (P-A.2). Prolog Code P-A.2: DeÔ¨Ånition of nums/2
1 2

nums(Atom,N) :- atom_codes(Atom,Values), nums([47|Values],0,N), !. nums([],N,N). nums([_],N,N). nums([H,E|T],Acc,N) :- not(digit(H)), digit(E), NewAcc is Acc + 1, !, nums([E|T],NewAcc,N). nums([_,E|T],Acc,N) :- nums([E|T],Acc,N).

% clause 0 % % % % % % % clause 1 clause 2 clause 3

3 4 5 6 7 8

clause 4

‚Ä¢ We preÔ¨Åx in clause 0 with the ASCII Values with ‚Äò47‚Äô, an arbitrary non-digit code, in case the leftmost character was a digit. (Otherwise, the Ô¨Årst group of digits will be missed.) ‚Ä¢ The Ô¨Årst two goals of clause 3 provide the condition for incrementing the accumulator. Exercise 1.3. The pseudocode is shown as Algorithm A.1.1; the correspondence between the pseudocode‚Äôs statements and the Prolog clauses in Example 1.6 is displayed in Table A.1.
2 We are using SWI-Prolog, Version 3.4.5 here. In the latest version also available at the time of writing (Version 5.2.7), for some inexplicable reason the order of the arguments of last/2 is the other way round.

143 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Algorithm A.1.1: Numbers(Atom) V alues ‚Üê list of ASCII values of characters in Atom Acc ‚Üê 0 Switch ‚Üê nodigit while‚éß V alues = [] [H |T ] ‚Üê V alues ‚é™ ‚é™ ‚é™ ‚é™ if H is an ‚é™ ‚éß encoded digit ‚é™ ‚é™ ‚é™ (5) ‚é®if Switch = nodigit ‚é® (6) then Acc ‚Üê Acc + 1 then do ‚é© ‚é™ ‚é™ Switch ‚Üê digit (7) ‚é™ ‚é™ ‚é™ ‚é™ Switch ‚Üê nodigit (8) else ‚é™ ‚é™ ‚é© V alues ‚Üê T N ‚Üê Acc return (N ) (1) (2) (3) (4)

(9) (10)

Statement Clause

(1) 0

(2) 0

(3) 0

(4) 2, 3, 4

(5) 2

(6) (7) (8) 2 2, 3 4

(9) 2, 3, 4

(10) 1

Table A.1: Algorithm A.1.1 & Prolog Clause Correspondence (Example 1.6)

Exercise 1.4. A simple tail recursive deÔ¨Ånition for mult/3 is by (P-A.3). Prolog Code P-A.3: DeÔ¨Ånition of mult/3 by recursion
1 2 3

mult(_,[],[]). mult(C,[H|T],[P|Ps]) :- P is C * H, !, mult(C,T,Ps).

An alternative deÔ¨Ånition using accumulators is suggested by the hand computations in Fig. A.2, giving rise to (P-A.4).

mult(0.2,[5.0,10.5,2.5],L)

:; mult(0.2,[5.0,10.5,2.5],[],L) :; :; mult(0.2,[2.5],[2.1,1.0],L) :; :; reverse([0.5,2.1,1.0],L) :;
1 2 2

0

2

mult(0.2,[10.5,2.5],[1.0],L) mult(0.2,[],[0.5,2.1,1.0],L)
0

L = [1.0,2.1,0.5]

:; success

Figure A.2: Hand Computations for mult/3

144 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Prolog Code P-A.4: mult/3 by the accumulator technique
1

mult(C,List,L) :- mult(C,List,[],L).

% clause 0

2 3 4

mult(_,[],Acc,L) :- reverse(Acc,L). % clause 1 mult(C,[H|T],Acc,L) :- A is C * H, !, % clause 2 mult(C,T,[A|Acc],L).

Timing by time/1 will show that simple recursion delivers a better performance. mult/3 is an example of a mapping operation where each entry of the input list is mapped by some function to the corresponding entry of the output list. (add/3 is deÔ¨Åned analogously.) Exercise 1.5. Replace clause 1 in (P-1.13), p. 30, (the deÔ¨Ånition of pta/2 ) by the following two clauses.
pta(in(_,_,_,Ws,Acc),out(Ws,I)) :- integer(I), Acc =:= I, !. pta(in(_,Ps,Ds,Ws,Acc),out(Ws,I)) :- var(I), classify_all(Ps,Ws,Ds), I = Acc, !.

If a Ô¨Åxed number of iterations I is wanted, the stopping criterion requires that the accumulator be numerically equal to I . The alternative stopping criterion is, as before, that all points be correctly classiÔ¨Åed.

A.2

Chapter 2 Exercises

All Prolog source code for Chap. 2 is available in the Ô¨Åle dl.pl. Exercise 2.1. sharp/2 is deÔ¨Åned by recursion in (P-A.5). Prolog Code P-A.5: DeÔ¨Ånition of sharp/2
1 2 3 4 5

sharp(E,E) :- not(proper_list(E)), !. sharp([],[]). sharp([E],#(Term,[])) :- sharp(E,Term), !. sharp([H|T],#(Term1,Term2)) :- sharp(H,Term1), sharp(T,Term2).

Perhaps the order of the two boundary case clauses should be given some thought. As it stands, the sharpnotation of a list with a single entry of a free variable is correctly evaluated:
?- sharp([E],S). E = _G210 S = #(_G210, []) ; No

However, on interchanging the Ô¨Årst two clauses in (P-A.5), we get an incorrect response:
?- sharp([E],S). E = [] S = #([], []) ; No

145 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Exercise 2.2. lf/2 is deÔ¨Åned in (P-A.6). Prolog Code P-A.6: DeÔ¨Ånition of lf/2
1 2 3 4 5

lf(Term,Term) :- var(Term), !. lf(#(Term,_),Term) :- not(functor(Term,#,2)), Term \= []. lf(#(Term,_),Leaf) :- lf(Term,Leaf). lf(#(_,Term),Leaf) :- lf(Term,Leaf).

% % % % %

clause 1 clause 2 clause 3 clause 4

(P-A.6) admits the following declarative reading: ‚Ä¢ Clause 1: Variables are leaves.

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

146 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

‚Ä¢ Clause 2: Term is the left-hand leaf of #(Term, ) if Term is not a list3 of length at least 1 nor is Term the empty list. (Notice that in a more precise interpretation of clause 2, the phrase ‚Äòis not‚Äô should be replaced by ‚Äòcannot be uniÔ¨Åed with‚Äô. However, this change in interpretation makes a real diÔ¨Äerence only if lf/2 is invoked with an unbound variable in its Ô¨Årst argument, a case which will have been caught by clause 1.)4 ‚Ä¢ Clause 3: Leaf is a left-hand leaf of #(Term, ) if Leaf is a left-hand leaf of its (left-hand) branch Term . ‚Ä¢ Clause 4: Leaf is a left-hand leaf of #( ,Term) if Leaf is a left-hand leaf of its (right-hand) branch Term . Exercise 2.3. The deÔ¨Ånition of a Ô¨Årst version of flatten/2 is is shown in (P-A.7). Prolog Code P-A.7: A Ô¨Årst version of flatten/2
1

flatten_1(L,F) :- sharp(L,S), bagof(Leaf,lf(S,Leaf),F).

The discussion on p. 46 shows that the use of the dot-notation for displaying lists can be achieved by the predicate set prolog flag/2 . Close scrutiny of the Exercises 2.1 to 2.3 (and their solutions) will in fact reveal that we can implement flatten/2 also directly, i.e. without recourse to our sharp-notation; such a version is deÔ¨Åned in (P-A.8). Prolog Code P-A.8: A second version of flatten/2
1 2 3 4 5

leaf(Term,Term) :- var(Term), !. leaf(.(Term,_),Term) :- not(functor(Term,.,2)), Term \= []. leaf(.(Term,_),Leaf) :- leaf(Term,Leaf). leaf(.(_,Term),Leaf) :- leaf(Term,Leaf). flatten_2(L,F) :- bagof(Leaf,leaf(L,Leaf),F).

6

The above two versions of flatten/2 behave identically to the built-in one; for example,
?- flatten_1([a,[Y,[b,X]],c,f(X)],L). Y = _G339 X = _G345 L = [a, _G339, b, _G345, c, f(_G345)] ?- flatten_2([a,[Y,[b,X]],c,f(X)],L). Y = _G339 X = _G345 L = [a, _G339, b, _G345, c, f(_G345)] ?- flatten([a,[Y,[b,X]],c,f(X)],L). Y = _G330 X = _G336 L = [a, _G330, b, _G336, c, f(_G336)]
are understood here to be in terms of the sharp-notation. the absence of clause 1, however, a query like lf(#(X,[]),Leaf). will cause stack overÔ¨Çow since clause 2 will fail and clause 3 will cause looping as can be inferred from ?- #(Term, ) = X. Term = G219 X = #( G219, G220)
4 In 3 ‚ÄòLists‚Äô

147 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

It is seen in particular that a free variable occurring more than once in the nested list will be uniÔ¨Åed, as expected, with the same internal variable. This would not have been so, however, had we used the built-in predicate findall/3 (in lieu of bagof/3 ) for collecting the leaves from the list‚Äôs tree representation:
?- findall(Leaf,leaf([a,[Y,[b,X]],c,f(X)],Leaf),Leaves). Leaf = _G480 Y = _G456 X = _G462 Leaves = [a, _G641, b, _G629, c, f(_G617)]

Exercise 2.4. The deÔ¨Ånition of dot/1 in (P-A.9) follows the suggested route. Prolog Code P-A.9: DeÔ¨Ånition of dot/1
1 2 3 4 5 6

dot(List) :- sharp(List,Term), term_to_atom(Term,A1), atom_chars(A1,L1), sharps_to_dots(L1,L2), concat_atom(L2,A2), write_term(A2,[]).

The predicate sharps to dots/2 is deÔ¨Åned by the accumulator technique in (P-A.10). Prolog Code P-A.10: DeÔ¨Ånition of sharps to dots/2
1 2

sharps_to_dots(S,D) :- sharps_to_dots(S,[],R), reverse(R,D), !. sharps_to_dots([],L,L). sharps_to_dots([#|T],Acc,L) :- sharps_to_dots(T,[.|Acc],L). sharps_to_dots([H|T],Acc,L) :- sharps_to_dots(T,[H|Acc],L).

3 4 5

A more concise alternative is oÔ¨Äered by the use of the built-in maplist/3 ; this is shown in (P-A.11). Prolog Code P-A.11: Alternative deÔ¨Ånition of sharps to dots/2
1

sharps_to_dots(S,D) :- maplist(sharp_to_dot,S,D). sharp_to_dot(#,‚Äô.‚Äô) :- !. sharp_to_dot(C,C).

2 3

Exercise 2.5. The improved version is deÔ¨Åned in (P-A.12). Prolog Code P-A.12: DeÔ¨Ånition of flatten 4/2
1 2 3 4 5 6

flatten_4(X,[X]) :- var(X), !. % flatten_4([],[]). % flatten_4([H|T],L1) :- flatten_4(H,L2), % flatten_4(T,L3), % append(L2,L3,L1), !. % flatten_4(X,[X]). %

clause 0 clause 1 clause 2 cut added here clause 3

148 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Clauses 1 to 3 are essentially as in flatten 3/2 . (The cut in clause 2 has been added to achieve a unique solution.) To rectify the other problem with flatten 3/2 , we have to understand why it produces spurious solutions on backtracking. When flatten 3/2 arrives at a list entry which is a variable, it will Ô¨Årst unify the variable with the empty list and then on further backtracking with [H|T] where H and T are themselves variables. Because of the recursive deÔ¨Ånition, this will then give rise to further such erroneous uniÔ¨Åcations. To avoid this, we simply ‚Äòcatch‚Äô a variable Ô¨Årst argument by clause 0. flatten 4/2 thus deÔ¨Åned behaves as expected:
?- flatten 4([a,[Y,[b,X]],c,f(X)],L). Y = _G339 X = _G345 L = [a, _G339, b, _G345, c, f(_G345)] ; No

Exercise 2.6. The following additional clause (an analogue of clause 0 in the deÔ¨Ånition of flatten 4/2 ) will become the Ô¨Årst clause in flatten dl/2 :
flatten_dl(X,[X|T]-T) :- var(X), !.

Exercise 2.7. We deÔ¨Åne in (P-A.13) nested/2 in terms nested/4 whose second and third argument are a counter and an accumulator, respectively. Prolog Code P-A.13: DeÔ¨Ånition of nested/2
1

nested(M,L) :- nested(M,1,[1],L), !. nested(M,M,L,L). nested(M,N,Acc,L) :- NewN is N + 1, nested(M,NewN,[Acc,NewN],L).

2 3 4

The versions‚Äô relative performance is illustrated below. It is seen in particular that the one based on diÔ¨Äerence lists is nearly as good as the built-in version.
?- nested(8000, L), time(flatten( L, F)). % 95,999 inferences in 0.44 seconds (218180 Lips) ?- nested(8000, L), time(flatten 1( L, F)). % 216,004 inferences in 12.96 seconds (16667 Lips) ?- nested(8000, L), time(flatten 2( L, F)). % 144,007 inferences in 12.79 seconds (11259 Lips) ?- nested(8000, L), time(flatten 3( L, F)). % 335,514 inferences in 9.88 seconds (33959 Lips) ERROR: Out of global stack ?- nested(8000, L), time(flatten 5( L, F)). % 32,000 inferences in 0.93 seconds (34409 Lips)

Furthermore, it is seen that version 3, the implementation using list concatenation with append/3 , is not practically viable due to stack overÔ¨Çow. (This problem has been experienced even for a nesting depth of 1000.) Exercise 2.8. Your session will typically look like this:

149 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

?- findall(_N,between(1,2000,_N),_L), time(reverse_1(_L,_R)). % 2,003,001 inferences in 19.34 seconds (103568 Lips) ?- findall(_N,between(1,2000,_N),_L), time(reverse_2(_L,_R)). % 2,002 inferences in 0.00 seconds (Infinite Lips) ?- findall(_N,between(1,2000,_N),_L), time(reverse_3(_L,_R)). % 4,000 inferences in 0.06 seconds (66667 Lips) ?- findall(_N,between(1,2000,_N),_L), time(reverse_4(_L,_R)). % 2,002 inferences in 0.05 seconds (40040 Lips)

It is seen that the ‚Äòna¬® ƒ±ve‚Äô implementation is far less eÔ¨Écient than either of the other three. Furthermore, version 4 is seen to behave in the same way as the one using accumulators (which is the method used also to implement the built-in version). This is not surprising since these two implementations were shown to be identical in Sect. 2.3.2. Exercise 2.9. Declarative Reading. The diÔ¨Äerence list L-X is the reverse of the list [E1,E2|T] if the diÔ¨Äerence list L-[E2,E1|X] is the reverse of T . New Version. This is deÔ¨Åned in (P-A.14).

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

150 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Prolog Code P-A.14: DeÔ¨Ånition of reverse 5/2
1

reverse_5(L,R) :- rev_dl_3(L,R-[]). rev_dl_3([],L-L). % clause 0 rev_dl_3([X],[X|L]-L). % clause 1 rev_dl_3([E1,E2|T],L1-L2) :- rev_dl_3(T,L1-[E2,E1|L2]). % clause 2

2 3 4

Noteworthy is in (P-A.14) the fact that reversal is carried out in ‚Äòchunks of twos‚Äô resulting in fewer invocations of the auxiliary predicate. There are now two boundary clauses: if the list to be reversed has an even number of entries then clause 0 is used; otherwise, clause 1 applies. Unfolding. We are going to show here that the clauses 0‚Äì2 can be inferred from the clauses (b1)‚Äì(b2).5 The boundary clause 0 is identical to clause (b1). We infer clause 1 by an elementary unfolding operation on the only goal in clause (b2): we Ô¨Årst rewrite clause (b1) as
rev_dl([],L-L) :- true.

and then seek to unify its head with the goal in the body of clause (b2):
?- rev_dl([],L-L) = rev_dl(T,L1-[H|L2]). L = [_G360|_G361] T = [] L1 = [_G360|_G361] H = _G360 L2 = _G361 Yes

The uniÔ¨Åcation succeeds and gives rise to the clause
rev_dl([_G360|[]],[_G360|_G361]-_G361) :- true.

which is equivalent to clause 1. To infer now clause 2, we rewrite clause (b2) as
rev_dl([U|V],W1-W2) :- rev_dl(V,W1-[U|W2]).

and seek to unify the head of this new clause with the goal in clause (b2):6
?- rev_dl([U|V],W1-W2) = rev_dl(T,L1-[H|L2]). U = _G384 V = _G385 W1 = _G387 W2 = [_G393|_G394] T = [_G384|_G385]
6 This 5 For

the present purposes, the version number (i.e. the suÔ¨Éx ‚Äò 3 ‚Äô) is to be ignored. is an instance of self unfolding.

151 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

L1 = _G387 H = _G393 L2 = _G394 Yes

The uniÔ¨Åcation succeeds and gives rise to
rev_dl([H|T],L1-L2) :- rev_dl(V,W1-[U|W2]).

which in terms of Prolog‚Äôs internal variable names reads as follows.
rev_dl([_G393|[_G384|_G385]],_G387-_G394) :rev_dl(_G385,_G387-[_G384|[_G393|_G394]]).

The latter clause is readily recognized as clause 2. This second and Ô¨Ånal elementary unfolding operation concludes a complete one step unfolding, thus making clause (b2) redundant. Speed of Execution. The enhanced version is twice as fast as the previous one:
?- findall(_N,between(1,100000,_N),_L), time(reverse_5(_L,_R)). % 50,002 inferences in 0.61 seconds (81970 Lips) ?- findall(_N,between(1,100000,_N),_L), time(reverse_4(_L,_R)). % 100,002 inferences in 1.92 seconds (52084 Lips)

Further Enhancement. Modify the implementation by processing the input list in chunks of threes; this is shown in (P-A.15). Prolog Code P-A.15: DeÔ¨Ånition of reverse 6/2
1

reverse_6(L,R) :- rev_dl_4(L,R-[]). rev_dl_4([],L-L). rev_dl_4([E1],[E1|L]-L). rev_dl_4([E1,E2],[E2,E1|L]-L). rev_dl_4([E1,E2,E3|T],L1-L2) :- rev_dl_4(T,L1-[E3,E2,E1|L2]).

2 3 4 5

It is seen that three base cases are needed now, deÔ¨Åning explicitly the reversal of lists with up to two entries. The gain in speed is illustrated by the query below.
?- findall(_N,between(1,100000,_N),_L), time(reverse_6(_L,_R)). % 33,335 inferences in 0.50 seconds (66670 Lips)

Generalization. Provide n base cases catering for the reversal of lists with up to n ‚àí 1 entries and write a recursive clause for reversing lists with at least n entries. Exercise 2.10, part (a). We convert colour/4 to its diÔ¨Äerence lists based form by (P-A.16).

152 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Prolog Code P-A.16: DeÔ¨Ånition of colour dl/4
1 2 3 4 5 6 7 8 9 10

colour_dl([],R-R,W-W,B-B). colour_dl([col(Object,red)|T], [col(Object,red)|R1]-R2,W1-W2,B1-B2) :colour_dl(T,R1-R2,W1-W2,B1-B2). colour_dl([col(Object,white)|T], R1-R2,[col(Object,white)|W1]-W2,B1-B2) :colour_dl(T,R1-R2,W1-W2,B1-B2). colour_dl([col(Object,blue)|T], R1-R2,W1-W2,[col(Object,blue)|B1]-B2) :colour_dl(T,R1-R2,W1-W2,B1-B2).

The concatenation of the three output diÔ¨Äerence lists is accomplished by
dijkstra_dl(Items,L1-L4) :- colour_dl(Items,L1-L2,L2-L3,L3-L4).

dijkstra/2 is now deÔ¨Åned as in Sect. 2.4.3,
dijkstra(Items,Grouped) :- dijkstra_dl(Items,Grouped-[]).

Timing by time/1 will conÔ¨Årm that the diÔ¨Äerence list based version of each implementation is better (as measured by the number of inferences used) than its plain counterpart. The last version is the best as it uses diÔ¨Äerence lists and takes a single pass through the input list. Exercise 2.10, part (b). Add the clauses
colour([col(_,Colour)|T],R,W,B) :- Colour \= red, Colour \= white, Colour \= blue, colour(T,R,W,B).

and
colour_dl([col(_,Colour)|T],R1-R2,W1-W2,B1-B2) :Colour \= red, Colour \= white, Colour \= blue, colour_dl(T,R1-R2,W1-W2,B1-B2).

to the respective existing deÔ¨Ånitions. Exercise 2.11. Carry out a clause-by-clause ‚Äòtranslation‚Äô of averages/2 and allied predicates to get (P-A.17). Prolog Code P-A.17: DeÔ¨Ånition of averages dl/2
1

averages_dl(L1-L2,A1-A2) :- aver_dl([-1,1|L1]-L2,A1-A2), !. aver_dl([_,0,_|X]-Y,X-Y). aver_dl(X1-X2,ADL) :- av_rotate_dl(X1-X2,Y1-Y2), aver_dl(Y1-Y2,ADL). av_rotate_dl([H1,H2|Y]-[Last|Z],[H2|Y]-Z) :- Last is (H1 + H2)/2.

2 3 4

5

153 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

[H|L1] L1 H T [H|T] L2

Figure A.3: Illustrating the Second Clause of dl/2

Exercise 2.12. Clause 2 in (P-2.19) is illustrated by Fig. A.3. It admits the following declarative interpretation:

The diÔ¨Äerence list version of [H|T] is [H|L1]-L2 if the diÔ¨Äerence list version of T is L1-L2 . Exercises 2.13 & 2.14. The Ô¨Årst implementation is by (P-A.18).

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

154 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Prolog Code P-A.18: DeÔ¨Ånition of show matrix dl/1
1

show_matrix_dl(M-[]):- show_matrix(M), nl.

% clause 0

2 3 4

show_matrix([]). % clause 1 show_matrix([H-[]|T]) :- write(H), write(‚Äô ‚Äô), % clause 2 show_matrix(T). %

In clause 0, the argument of show matrix dl (which expects a diÔ¨Äerence list of diÔ¨Äerence lists) is converted to a proper list of diÔ¨Äerence lists. This then is diplayed entry-wise by show matrix/1 , deÔ¨Åned in the clauses 1 and 2. Noteworthy is clause 2 where the matrix head is uniÔ¨Åed with H-[] thereby making H a proper list which in turn is displayed on the terminal. Invoking show matrix dl(M1-M2) with a diÔ¨Äerence list M1-M2 will of course unify M2 with the empty list. This can‚Äôt be ‚Äòundone‚Äô later and therefore any subsequent attempt of using M1-M2 as a genuine diÔ¨Äerence list will fail. We solve this problem by not displaying the original diÔ¨Äerence list M1-M2 but a copy of it which we write to the database prior to the invokation of show matrix dl/2 . The improved version show matrix dl2/2 is deÔ¨Åned in (P-A.19). Prolog Code P-A.19: DeÔ¨Ånition of show matrix dl2/1
1 2 3 4 5

show_matrix_dl2(DLM):- dynamic(matrix/1), retractall(matrix(_)), assert(matrix(DLM)), matrix(M), show_matrix_dl(M).

It will behave as expected:
?- matrix a( A), dl2( A, DLA), show matrix dl2( DLA), rot matrix dl( DLA, DLR), show matrix dl2( DLR). [a11, a12, a13, a14] [a21, a22, a23, a24] [a31, a32, a33, a34] [a22, a23, a24, a21] [a32, a33, a34, a31] [a12, a13, a14, a11]

You will Ô¨Ånd more on database operations in Sect. 3.1. In the above approach, a copy of the term holding the matrix in diÔ¨Äerence list form was written to and later retrieved from the database. Subsequently, the new copy (or parts of it) may be uniÔ¨Åed with some other term without aÔ¨Äecting the original. There is a built-in predicate to achieve just that; it is copy term/2 (see inset).

Built-in Predicate: copy term(+TermIn,-TermOut) The term in TermIn is copied to TermOut . Each of the free variables in TermIn is given a new (internal) name and subsequently no link is maintained between the two terms. Example: ?- copy term(f(a,X),Y), X = b. X = b Y = f(a, G386) Yes

155 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

A new version of show matrix dl/1 is deÔ¨Åned in (P-A.20). Prolog Code P-A.20: DeÔ¨Ånition of show matrix dl3/1
1 2

show_matrix_dl3(DLM):- copy_term(DLM,M), show_matrix_dl(M).

It will be found to respond exactly as show matrix dl2/1 did. Exercise 2.15. Add to the database the clause
g_seidel(in([[First|Rest1]-Rest2|A1]-A2, [B|B1]-[B|B2],[_|T1]-[NewX|T2],[S|S1]-[S|S2]), out(NewAs,B1-B2,T1-T2,S1-S2)) :dot_product_dl(Rest1-Rest2,T1-[NewX|T2],P),7 NewX is B - P, rot_matrix_dl([[First|Rest1]-Rest2|A1]-A2,NewAs).

to enable g seidel/2 to work also with diÔ¨Äerence lists. (Notice that this new clause won‚Äôt interfere with the earlier deÔ¨Ånition.) No other changes are necessary since g seidel/7 will call this modiÔ¨Åed version of g seidel/2 as before:
?- a(A), b(B), x0(X), s(S), dl2(A,ADL), dl(B,BDL), dl(X,XDL), dl(S,SDL), g_seidel(ADL,BDL,XDL,SDL,50,NewX-[],NewS-[]). ... NewX = [62.5, 62.5, 87.5, 87.5] NewS = [3, 4, 1, 2]

To simplify the query, we may use the new version of g seidel/7 , deÔ¨Åned in (P-A.21). Prolog Code P-A.21: New version of g seidel/7
1 2 3 4 5 6

g_seidel_2(A,B,X,S,I,NewX,NewS) :dl2(A,ADL), dl(B,BDL), dl(X,XDL), dl(S,SDL), g_seidel(ADL,BDL,XDL,SDL,I,NewX-[],NewS-[]), !.

(This version uses the same pattern of proper list inputs as g seidel/7 but works internally with diÔ¨Äerence lists.)
7 The

dot product of vectors in diÔ¨Äerence list notation is deÔ¨Åned by the accumulator technique as follows dot_product_dl(DL1,DL2,Result) :- dot_product_dl(DL1,DL2,0,Result), !. dot_product_dl(L-_,_,Acc,Acc) :- var(L). dot_product_dl([HU|TU1]-TU2,[HV|TV1]-TV2,Acc,Result) :NewAcc is Acc + HU * HV, !, dot_product_dl(TU1-TU2,TV1-TV2,NewAcc,Result).

156 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Experiments will show that the new implementation always needs a lesser number of inferences. However, for the CPU‚Äìtime also to show a relative improvement, the problem has to be of a minimum size. (DiÔ¨Äerence lists carry a certain computational overhead worth paying for problems beyond a certain size only.)

A.3

Chapter 3 Exercises

Prolog source code: for Sect. 3.1, see party.pl, people.pl, arrange.pl and queue.pl; for Sect. 3.2, see transformations.pl; for Sect. 3.3, see dl.pl and transformations.pl. Exercise 3.1, part (f ). facing/3 is recursively deÔ¨Åned by
facing(X,L,R) :right_to(L,X), right_to(X,R), (L == R, !; true). facing(X,L,R) :facing(X,Y,Z), right_to(L,Y), right_to(Z,R), (L == R, !; true).

The declarative reading of this deÔ¨Ånition should be straightforward in conjunction with Fig. 3.2. Recursion stops when the last two arguments of facing/3 are instantiated to identical terms. For an odd number of guests, facing/3 will stop once the second and third arguments are identical to the Ô¨Årst:
?- listing(right to/2). right to(clara, adam). right to(adam, susan). right to(susan, clara). ?- facing(adam,Left,Righ). Left = clara Righ = susan ; Left = susan Righ = clara ; Left = adam Righ = adam ; No

DeÔ¨Åne now opposite to/2 by
opposite_to(X,Y) :- facing(X,Y,Y), X \== Y.

(The second goal ensures failure for an odd number of guests.) Exercise 3.2. (P-A.22) shows the deÔ¨Ånition of opposites/0 ; guests/0 is deÔ¨Åned analogously. Prolog Code P-A.22: DeÔ¨Ånition of opposites/0
1 2 3 4 5

opposites :- opposite_to(_,_), ((right_to(X,Y), opposite_to(X,Z), write(X), write(‚Äô, ‚Äô), write(Z), nl, fail); true).

Observations. opposites/0 will succeed iÔ¨Ä opposites to/2 does, i.e. if there are an even number of names in the database. From inside a failure driven loop all opposite pairs are displayed and success is enforced by disjunction with ‚Äòtrue ‚Äô.

157 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

(P-A.23) deÔ¨Ånes look right/1 in terms of an auxiliary predicate look right/2 . In the second argument of this predicate the list of names is accumulated until the person‚Äôs name reappears in the head. Prolog Code P-A.23: DeÔ¨Ånition of look right/1
1 2 3

look_right(Pers) :- look_right(Pers,[Pers|T]), reverse(T,List), write_list(List). look_right(Pers,[X,Pers]) :- right_to(Pers,X). look_right(Pers,[X,H|T]) :- right_to(H,X), look_right(Pers,[H|T]).

4 5 6

write list/1 is deÔ¨Åned by recursion (not shown here) and displays the entries of a list in a single line. Exercise 3.3, part (a). Don‚Äôt change the database if one or two people are at the table:
swap_neighbours(Pers1,Pers2) :- right_to(Pers1,Pers2), right_to(Pers2,Pers1).

Changes are due if more than two people are at the table:

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

158 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

swap_neighbours(Left,Right) :- right_to(Left,Right), right_to(L,Left), right_to(Right,R), retract(right_to(Left,Right)), retract(right_to(L,Left)), retract(right_to(Right,R)), assert(right_to(Right,Left)), assert(right_to(L,Right)), assert(right_to(Left,R)).

Exercise 3.3, part (b). Use swap neighbours/2 for swapping neighbours:
swap(Pers1,Pers2) :- swap_neighbours(Pers1,Pers2). swap(Pers1,Pers2) :- swap_neighbours(Pers2,Pers1).

And, do changes as necessary for swapping people who aren‚Äôt neighbours:
swap(Pers1,Pers2) :- right_to(Pers1,R1), right_to(L1,Pers1), right_to(Pers2,R2), right_to(L2,Pers2), retract(right_to(Pers1,R1)), retract(right_to(L1,Pers1)), retract(right_to(Pers2,R2)), retract(right_to(L2,Pers2)), assert(right_to(Pers1,R2)), assert(right_to(L2,Pers1)), assert(right_to(Pers2,R1)), assert(right_to(L1,Pers2)).

Exercise 3.4, part (a). Only one of the four cases in Table 3.1 will be discussed here: the last two customers swap places and there are more than two customers in the queue (Fig. A.4). The relations of interest which can behind(X,Y) behind(Y,Z) not(behind(Z, )) E Z Y X W V T¬© T  behind(X,Z) behind(Z,Y) not(behind(Y, )) E Y Z X W V ... E D C B A E ... E D C B A E

Figure A.4: The Last Two Customers Swap Places be inferred from the database before and after the swap are indicated in Fig. A.4. The corresponding clause of swap neighbours/2 is therefore

159 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

swap_neighbours(Y,Z) :not(behind(Z,_)), behind(Y,Z), behind(X,Y), retract(behind(Y,Z)), retract(behind(X,Y)), assert(behind(X,Z)), assert(behind(Z,Y)).

% % % % % % % %

swap Y and Z Z is the last in the queue Z is behind Y in the queue Y is behind X in the queue remove relation between Y and Z remove relation between X and Y establish relation between X and Z establish relation between Z and Y

(You should complete the remaining three clauses with reference to Table 3.1 and by using sketches similar to Fig. A.4.) Exercise 3.5. The intended database changes are achieved by a failure driven loop:
?- dynamic(lives in/2), ((lives in(london, Person), assert(lives in(york, Person)), fail); true), retractall(lives in(london, )).

Exercise 3.6. The deÔ¨Ånition of joins/1 is fairly straightforward: check Ô¨Årst that there aren‚Äôt any facts in the database for right to/2 ; then assert the appropriate fact for right to/2 ; Ô¨Ånally, augment the Ô¨Åle people.pl and report the job completed.
joins(Pers) :- not(right_to(_,_)), assert(right_to(Pers,Pers)), tell(‚Äôpeople.pl‚Äô), listing(right_to/2), told, write(Pers), write(‚Äô has joined the table.‚Äô), nl.

Exercise 3.7. The task is to enhance the deÔ¨Ånition of the second clause of save predicates to(+Filename,+List) . As a Ô¨Årst step, we translate the informal speciÔ¨Åcation as follows: Condition -> Action ; Alternative Action with Condition A(x) B (x) = ‚àÄx(A(x) ‚Üí B (x)) = x ‚àà List = my predicate(x, ) (A.2) (A.3) (A.4) (A.5) (A.6) (A.1)

Action = write to f ile Alternative Action = display error message

Since it is more diÔ¨Écult to implement in standard Prolog a universally quantiÔ¨Åed condition than an existentially quantiÔ¨Åed one, we write (A.1) in terms of the negation of (A.2), thereby getting Condition = ¬¨(‚àÄx(A(x) ‚Üí B (x))) (A.7) (A.8) (A.9)

Action = display error message Alternative Action = write to f ile

160 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Rewrite now the right-hand side of (A.7) as follows:8 Condition = ‚àÉx¬¨((A(x) ‚Üí B (x))) = ‚àÉx¬¨(B (x) ‚à® ¬¨A(x)) = ‚àÉx(A(x) ‚àß ¬¨B (x)) A Prolog implementation of save predicates to(+Filename,+List) based on (A.1), (A.3)‚Äì(A.4) and (A.8)‚Äì(A.10) is therefore
save_predicates_to(Filename,List) :(member(X,List), not(my_predicate(X,_))) -> (write(‚Äô...‚Äô), nl, fail); write_to_file(Filename,List).

(A.10)

where write to file/2 is deÔ¨Åned by a failure driven loop:
8 The rules hereby used are from Predicate and Propositional Calculus; they are in turn: a QuantiÔ¨Åer Equivalence Rule, Material Implication and DeMorgan‚Äôs Rule.

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

161 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

write_to_file(Filename,List) :- tell(Filename), ((member(Fun/Arity,List), listing(Fun/Arity), fail); true), told.

Alternative Solution of Exercise 3.7. The built-in SWI Prolog predicate forall(+Condition,+Action) allows a direct implementation of the Condition in (A.2). The resulting alternative deÔ¨Ånition of save predicates to/2 is then
save_predicates_to(Filename,List) :(forall(member(X,List), my_predicate(X,_)) -> write_to_file(Filename,List)); write(‚Äô...‚Äô), nl, fail.

(Two possibilities are discussed in [16] for deÔ¨Åning forall/2 .) Exercise 3.9. The directive :- dynamic(album/1). in the source Ô¨Åle will make album/1 a dynamic predicate. Now use the query
?- retractall(album([stamp(‚ÄôGermany‚Äô,‚ÄôKaiser‚Äô, , )| ])). Yes

to remove the clauses as required. Exercise 3.14. See Fig. A.5. Exercise 3.15. We unfold the second goal in clause two of flatten dl/2 :
?- unfold(flatten dl/2,2,2). Clause(s) used: Clause 1 of predicate flatten Clause 2 of predicate flatten Clause 3 of predicate flatten ... Clause removed: Clause 2 of predicate flatten

dl/2 dl/2 dl/2

dl/2

flatten dl([], A-A). flatten dl(A, [A|B]-B). flatten dl([A], B-C) :- flatten dl(A, B-C), true. flatten dl([A, B|C], D-E) :- flatten dl(A, D-F), flatten dl(B, F-G), flatten dl(C, G-E). flatten dl([A|B], C-D) :- flatten dl(A, C-[B|D]), true.

As shown above, flatten dl/2 is now deÔ¨Åned by Ô¨Åve clauses which, however, have to be rearranged to restore the ‚Äôoriginal order‚Äô: clauses 3‚Äì5 are a replacement for what was formerly clause 2; thus
?- clause arrange(flatten dl/2,[1,3,4,5,2]). Yes

162 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

9

?- consult(user). |: :- consult(transformations). % transformations compiled 0.06 sec, 9,584 bytes ‚é´ ‚é¨ Manual input |: rev dl([],L-L). ' :- rev dl(T,L1-[H|L2]). |: rev ¬†¬£ ¬† ¬£ dl([H|T],L1-L2) ‚é≠ of rev dl/2 |: ¬¢Ctrl ¬° +¬¢Z ¬° % user compiled 86.18 sec, 10,128 bytes Yes

6

?- unfold(rev dl/2,2,1). Clause(s) used: T Clause 1 of predicate rev dl/2 Clause 2 of predicate rev dl/2 rev rev rev rev

COSU on goal 1 of clause 2

c dl([], A-A). Old, redundant clause dl([A|B], C-D) :- rev dl(B, C-[A|D]). ' dl([A], [A|B]-B). dl([A, B|C], D-E) :- rev dl(C, D-[B, A|E]). ' New clauses

Clause removed: Clause 2 of predicate rev dl/2

‚é¨ New rev dl([], A-A). ' definition of rev dl([A], [A|B]-B). rev dl([A, B|C], D-E) :- rev dl(C, D-[B, A|E]). ‚é≠ rev dl/2 Yes 8 Figure A.5: Automated Solution of Exercise 2.9, Part (c) 7

‚é´

?- listing(flatten dl/2). flatten dl([], A-A). flatten dl([A], B-C) :- flatten dl(A, B-C), true. flatten dl([A, B|C], D-E) :- flatten dl(A, D-F), flatten dl(B, F-G), flatten dl(C, G-E). flatten dl([A|B], C-D) :- flatten dl(A, C-[B|D]), true. flatten dl(A, [A|B]-B).

The above is equivalent to the initial deÔ¨Ånition (both logically and procedurally). Clause 4 may be removed from the database, however, without aÔ¨Äecting the behaviour of flatten dl/2 since clause 2 won‚Äôt ever be made use of:9 ‚Ä¢ Clause 1 is invoked for Ô¨Çattening the empty list.
9 To be more precise, the Ô¨Årst solution found by flatten dl/2 won‚Äôt be aÔ¨Äected by the removal of this clause; further solutions found on backtracking may diÔ¨Äer. They are, however, of no concern here because of the cut used in flatten 5/2 .

163 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

‚Ä¢ Clause 2 is invoked for Ô¨Çattening lists with a single entry. ‚Ä¢ All other lists are covered by clause 3 which is used for Ô¨Çattening lists with at least two entries. Remove now the redundant clause:
?- clause arrange(flatten dl/2,[1,2,3,5]). Yes ?- listing(flatten dl/2). flatten dl([], A-A). flatten dl([A], B-C) :- flatten dl(A, B-C), true. flatten dl([A, B|C], D-E) :- flatten dl(A, D-F), flatten dl(B, F-G), flatten dl(C, G-E). flatten dl(A, [A|B]-B).

An experiment akin to the one in Exercise 2.7 conÔ¨Årms that Ô¨Çattening based on this version is more eÔ¨Écient than the built-in flatten/2 :
?- time(flatten 5([a,[b],[c,[d]],[e,[f],[g,[h]]], [i,[j],[k,[l]],[m,[n],[o,[p]]]]],F)). % 43 inferences in 0.00 seconds (Infinite Lips) F = [a, b, c, d, e, f, g, h, i|...] ?- time(flatten([a,[b],[c,[d]],[e,[f],[g,[h]]], [i,[j],[k,[l]],[m,[n],[o,[p]]]]],F)). % 191 inferences in 0.00 seconds (Infinite Lips) F = [a, b, c, d, e, f, g, h, i|...]

Further improvement may be achieved by carrying on unfolding in an analogous manner. Let us unfold goal 3 of clause 3:
?- unfold(flatten dl/2,3,3). ... ?- clause arrange(flatten dl/2,[1,2,4,5,6,3]). ?- listing(flatten dl/2). flatten dl([], A-A). flatten dl([A], B-C) :- flatten_dl(A, B-C), true. flatten dl([A, B], C-D) :- flatten dl(A, C-E), flatten dl(B, E-D), true. flatten dl([A, B, C], D-E) :- flatten dl(A, D-F), flatten dl(B, F-G), flatten dl(C, G-E), true. flatten dl([A, B, C, D|E], F-G) :- flatten dl(A, F-H), flatten dl(B, H-I), flatten dl(C, I-J), flatten dl(D, J-K), flatten dl(E, K-G). flatten dl(A, [A|B]-B).

164 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

The improvement in performance is gleaned from

?- time(flatten 5([a,[b],[c,[d]],[e,[f],[g,[h]]], [i,[j],[k,[l]],[m,[n],[o,[p]]]]],F)). % 35 inferences in 0.00 seconds (Infinite Lips) F = [a, b, c, d, e, f, g, h, i|...]

It is seen that as unfolding is carried further, longer and longer lists will be Ô¨Çattened by rules explicitly referring to their length and less is dealt with by the (penultimate) ‚Äògeneral rule‚Äô. Exercise 3.16. The initial and intended Ô¨Ånal arrangement of clauses are indicated in Fig. A.6. The predicate cosu/3 is deÔ¨Åned in (P-A.24).

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

165 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Initial Arrangement

After Applying unfold(...,i,...) (New clauses shaded dark .) clause 1 clause 2 ... clause (i ‚àí 1) clause i clause (i + 1) ... clause (c1 ‚àí 1) clause c1 clause (c1 + 1) ... clause c2

Final Arrangement

clause clause ... clause clause clause clause ... clause

1 2 (i ‚àí 1) i (i + 1) (i + 2) c1

E

E

... ... ... ... ... ... ... ... ... ... ... ...

X $ $$

¬†E ¬£

¬¢E ¬°

Figure A.6: Database Changes Brought About by cosu/3 Prolog Code P-A.24: DeÔ¨Ånition of cosu/3
1 2 3 4 5 6 7 8 9 10 11 12 13

cosu(Fun/Arity,I,J) :functor(Pred,Fun,Arity), predicate_property(Pred,number_of_clauses(C1)), unfold(Fun/Arity,I,J), predicate_property(Pred,number_of_clauses(C2)), A1 is 1, B1 is I - 1, A2 is I, B2 is C1 - 1, A3 is C1, B3 is C2, from_to(A1,B1,L1), from_to(A2,B2,L2), from_to(A3,B3,L3), concat3(L1,L3,L2,L), clause_arrange(Fun/Arity,L).

With reference to Fig. A.6, the steps performed by cosu/3 are: ‚Ä¢ Unify with C1 the number of clauses in the predicate‚Äôs original deÔ¨Ånition. The initial arrangement is shown Fig. A.6. ‚Ä¢ Unfold by using unfold/3 . The resulting state of the database is again shown in Fig. A.6. ‚Ä¢ Unify with C2 the number of clauses in the predicate‚Äôs new deÔ¨Ånition.

166 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

‚Ä¢ As seen from Fig. A.6, the pattern of intended rearrangement for the clauses is given by the permutation L = [1, 2, . . . , i ‚àí 1, c1 , c1 + 1, . . . , c2 , i, i + 1, . . . , c1 ‚àí 1] This list is then used to rearrange the clauses by clause arrange/2 . ‚Ä¢ The predicate from to/3 is used to generate integer lists with speciÔ¨Åed Ô¨Årst and last entries:
from_to(Low,High,List) :- bagof(N,between(Low,High,N),List), !. from_to(_,_,[]).

(The catch-all clause ensures that from to/3 always succeeds.) Exercise 3.17. Using the built-in predicate setof/3 , the predicate colours/2 collects the items‚Äô colours in alphabetical order.
colours(Items,Colours) :- setof(Colour, Object^(member(col(Object,Colour),Items)), Colours).

dijkstra/3 is then used to obtain the items‚Äô list.
dijkstra_st(Items,Grouped) :- colours(Items,Colours), dijkstra(Colours,Items,Grouped).

Exercise 3.19. The deÔ¨Ånition of def encolour pl/1 is not shown here as it is analogous to that of def encolour dl/1 . (The source code is found in the Ô¨Åle dl.pl.) The predicate def endijkstra pl/1 is deÔ¨Åned in (P-A.25). Prolog Code P-A.25: DeÔ¨Ånition of def endijkstra pl/1
1 2 3 4 5 6 7 8 9

def_endijkstra_pl(Colours) :- dynamic(endijkstra_pl/2), retractall(endijkstra_pl(_,_)), length(Colours,N), length(Vars,N), Head = endijkstra_pl(Items,Grouped), Goal1 =.. [encolour_pl,Items|Vars], Goal2 =.. [flatten,Vars,Grouped], Body = (Goal1, Goal2), assert((Head :- Body)).

length/1 is used here to create a list of the requisite number of unbound variables which then serve as arguments to both encolour pl and flatten/2 . (The former receives them as individual arguments whereas to the latter they are passed as a list.)

A.4

Chapter 4 Exercises

All Prolog source code for Chap. 4 is available in the Ô¨Åle rhyme demo.pl. Exercise 4.1. A predicate n times/3 will be needed which returns in a list a speciÔ¨Åed number of copies of any term:

167 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

?- n_times(3,any(term),L). L = [any(term), any(term), any(term)]

This we deÔ¨Åne by the accumulator technique as follows.
n_times_acc(0,_,L,L). n_times_acc(N,X,L1,L2) :- N1 is N - 1, n_times_acc(N1,X,[X|L1],L2). n_times(N,X,L) :- n_times_acc(N,X,[],L), !.

Now, we deÔ¨Åne long verse/1 by
long_verse(N) :- n_times(N,‚ÄôThat interacts with the item ...‚Äô,L), dynamic(verse/1), retract(verse(_)), assert(verse(L)).

Exercise 4.2. The second clause in the deÔ¨Ånition of rhyme prel 5/ (p. 128) should be augmented by a cut :
rhyme_prel_5([H|T],C) :- append(P,[[H|T]],C), rhyme_prel_5(T,P), !.

Exercise 4.3. Let us examine interactively, for example, how the query

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩ for Engin

M

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction M supervisor ina cons I was the North Sea supe advising and the N he helping foremen advi s solve problems Real work he helping International Internationa al opportunities ÔøΩree wo work or placements s solve p
Click on the ad to read more

168 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

?- cputime(rhyme_prel_5,[[‚ÄôB‚Äô,‚ÄôA‚Äô],R],Time).

could be dealt with. Obviously, we will want rhyme prel 5/2 to be invoked by call/1 and therefore we will have to create Ô¨Årst a term which will serve as the argument of call/1 . To achieve this, we use the built-in predicate univ.
?- T =.. [rhyme prel 5,[‚ÄôB‚Äô,‚ÄôA‚Äô],R]. T = rhyme prel 5([‚ÄôB‚Äô, ‚ÄôA‚Äô], G345) R = G345 Yes

We now submit T to call/1 , the latter sandwiched between two invocations of statistics/2 :
?- T =.. [rhyme prel 5,[‚ÄôB‚Äô,‚ÄôA‚Äô],R], statistics(cputime,Before), call(T), statistics(cputime,After), Time is Before - After. T = rhyme_prel_5([‚ÄôB‚Äô, ‚ÄôA‚Äô], [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]]) R = [[‚ÄôA‚Äô], [‚ÄôB‚Äô, ‚ÄôA‚Äô]] Before = 15124 After = 15124 Time = 0 Yes

(The CPU time for the above happens to be negligible hence the zero response.) This gives rise to the following deÔ¨Ånition.
cputime(Predname,Arglist,Time) :- T =.. [Predname|Arglist], statistics(cputime,Before), call(T), statistics(cputime,After), !, Time is After - Before.

As a consequence of the cut in the above deÔ¨Ånition, cputime/3 will Ô¨Ånd one solution only even if the underlying query could be re-satisÔ¨Åed on backtracking. Furthermore, and perhaps more importantly in our context, if the query has a solution but would be caught in an inÔ¨Ånite loop on trying to re-satisfy the goal, cputime/3 will still deliver this unique solution and respond with failure subsequently. This property of cputime/3 is essential when timing the same predicate with several sets of arguments using findall/3 , as seen on p. 131 for rhyme prel 5/2 . Exercise 4.4. Prior to applying cputime/3 from Exercise 4.3, we construct the predicate‚Äôs name by using concat atom/2 (see, inset on p. 126):
cputime(Predname,Arglist,Version,Time) :- concat_atom([Predname,‚Äô_‚Äô,Version],Pred), cputime(Pred,Arglist,Time).

Exercise 4.5. We Ô¨Årst show how the Ô¨Årst row of Table 4.2 is produced interactively.10
?- findall(_Time, (between(1,7,_J), _L is _J * 10 ** 2, long_verse(_L),
10 The

Java/C‚Äìstyle code layout is of course not the actual one but is employed here for better readability only.

169 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

verse(_V), cputime(rhyme_prel,[_V,_R],5,_Time) ), Row ). Row = [1.98, 15.71, 52.23, 124.19, 241.95, 418.81, 666.96]

Now, after some modiÔ¨Åcations (involving the introduction of the variables I and Version ), we embed this query into another findall to collect all the rows of Table 4.2 in the variable Rows which, as a list (of lists), we then display by using show list/1 :
?- findall(_Row, (between(2,4,_I), findall(_Time, (between(1,7,_J), _Version is _I + 3, _L is _J * 10 ** _I, long_verse(_L), verse(_V), cputime(rhyme_prel,[_V,_R],_Version,_Time) ), _Row ) ), _Rows ), show_list(_Rows). [1.97, 15.77, 52.35, 124.51, 242.6, 419.9, 666.41] [4.23, 19.99, 45.59, 85.74, 135.45, 194.44, 276.88] [0.11, 0.44, 0.99, 1.2, 1.37, 1.48, 1.76]

Alternative Solution. For a perhaps simpler solution by using a single instance of bagof/3 , we revisit the Ô¨Årst query above with findall replaced by bagof .
?- bagof(_Time, _J^_L^_V^_R^(between(1,7,_J), _L is _J * 10 ** 2, long_verse(_L), verse(_V), cputime(rhyme_prel,[_V,_R],5,_Time) ), Row). Row = [1.98, 15.76, 52.24, 124.29, 242.11, 419.08, 666.96]

How should the above be augmented to display on backtracking all three rows of Table 4.2? We inroduce new variables Version and I as before but won‚Äôt preÔ¨Åx the goal inside bagof by Version^ thus allowing Prolog to Ô¨Ånd solutions corresponding to each particular value of Version . Finally, backtracking is accomplished by a failure-driven loop.
?- bagof(Time, I^J^L^V^R^(between(2,4,I), between(1,7,J),

170 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

Version is I + 3, L is J * 10 ** I, long_verse(L), verse(V), cputime(rhyme_prel, [V,R], Version, Time ) ), Row ), write(Version), write(‚Äô - ‚Äô), write(Row), nl, fail. 5 - [1.98, 15.76, 52.29, 124.46, 242.67, 419.58, 667.4] 6 - [4.28, 20.05, 45.65, 85.79, 135.62, 194.5, 278.85]

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

171 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix A: Solutions of Selected Exercises

7 - [0.11, 0.44, 0.77, 1.21, 1.43, 1.48, 1.7] No

Exercise 4.6. The deÔ¨Ånition of song skeleton/1 is fairly obvious if we use int/1 and int/2 as ‚Äòtemplates‚Äô:
song_skeleton(L) :- song_skeleton([1],L). song_skeleton(L,L). song_skeleton([H|T],L) :- succ(H,N), song_skeleton([N|[H|T]],L).

A more interesting question is perhaps how the deÔ¨Ånition of int/2 (p. 134) came about in the Ô¨Årst place. To examine this, we Ô¨Årst consider the following partial implementation of int/2
int(I,I). int(1,I) :- int(2,I). % clause 1 % clause 2

The query ?- int(1,I). will be Ô¨Årst satisÔ¨Åed by virtue of clause 1 with I = 1 and on backtracking re-satisÔ¨Åed by clause 2 which succeeds with I = 2 since its only subgoal (i.e. int(2,I)) uniÔ¨Åes with clause 1. If we now take also the clause
int(2,I) :- int(3,I). % clause 3

aboard, everything said thus far still applies; moreover, the body of clause 2 now succeeds also by clause 3 with I = 3 since the body of the latter uniÔ¨Åes with clause 1. Clearly, any number of new clauses could be added in this manner to the database. (The resulting search tree is shown in Fig. A.7 below.) Now, the second clause ?- int(1,I). 4 4 ¬Ñ 4 ¬Ñ 4 ¬Ñ 4 4 ¬Ñ 4 4 ¬Ñ I =1 ?- int(2,I). D¬Ñ D ¬Ñ D ¬Ñ D ¬Ñ D D ¬Ñ I=2 ?- int(3,I). ¬°¬Ñ ¬° ¬Ñ ¬° ¬Ñ ¬° ¬Ñ ¬° ¬Ñ I=3 ... Figure A.7: Search Tree of the Query ?- int(1,I). in the deÔ¨Ånition of int/2 on p. 134 can be considered a subsumption of all possible such augmentations of the database.

172 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

It is also instructive to observe that int/1 is deÔ¨Åned by solving another problem (the deÔ¨Ånition of int/2 ) of which the original problem is a special case. This approach is often successful in Prolog programming. Exercise 4.7. Our deÔ¨Ånition of song skeleton/1 very closely models that of nat/1 :
song_skeleton(L) :- first_verse, current_verse(L). song_skeleton(L) :- repeat, update_verse, current_verse(L).

with the predicates first verse/0 and update verse/0 deÔ¨Åned by
first_verse :- dynamic(current_verse/1),11 retractall(current_verse(_)), assert(current_verse([1])). update_verse :- current_verse([H|T]), retractall(current_verse(_)), NewH is H + 1, assert(current_verse([NewH,H|T])).

Exercise 4.8. We calculate the digits of a natural number by applying the built-in arithmetic functions mod (the modulo )12 and // (the integer division ) in an alternate fashion; the digits of 351, for example, may be obtained by
?- N0 is D1 is D2 is D3 is D1 = 1 D2 = 5 D3 = 3 351, N0 mod 10, N1 is N0 // 10, N1 mod 10, N2 is N1 // 10, N2 mod 10.

suggesting a predicate digits/3 with
digits(N,Acc,[N|Acc]) :- N < 10, !.13 digits(N,Acc,D) :- H is N mod 10, NewN is N // 10, digits(NewN,[H|Acc],D).

which then behaves as expected:
?- digits(351,[],D). D = [3, 5, 1]
11 As

an alternative, the predicate current verse/1 may be declared dynamic also by the directive :- dynamic(current verse/1).

This is usually placed at the head of the source Ô¨Åle. 12 mod computes the remainder of an integer division. It is not to be confused with Prolog‚Äôs built-in arithmetic function rem which returns the fractional part of a quotient: ?- Frac is 3896 rem 100. Frac = 0.96 13 Without this cut some spurious solutions are returned on backtracking: ?- digits(98,[],L). L = [9, 8] ; L = [0, 9, 8] Yes

173 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

We deÔ¨Åne the predicate digits(+Number,-List) thus by
digits(N,D) :- integer(N), digits(N,[],D).

(This deÔ¨Ånition works for the instantiation pattern digits(+Number,+List) , too.) With a view to the instantiation pattern digits(-Number,+List) , we observe that any number can be written in terms of its digits as in 4351 = 10 √ó (10 √ó (10 √ó (10 √ó 0 + 4) + 3) + 5) + 1 suggesting Algorithm A.4.1.

Algorithm A.4.1: Value(List) Accumulator ‚Üê 0 List ‚Üê list of digits, e.g. [4, 3, 5, 1] while‚éß List = [] ‚é™[H |T ] ‚Üê List ‚é™ ‚é® Accumulator ‚Üê 10 ‚àó Accumulator do ‚é™Accumulator ‚Üê Accumulator + H ‚é™ ‚é© List ‚Üê T N umber ‚Üê Accumulator return (N umber) (1) (2) (3)

(4)

We implement (3)‚Äì(4) by value/3 ,
value([],N,N). value([H|T],Acc,N) :- integer(H), H < 10, AccNew is H + 10 * Acc, value(T,AccNew,N).

while (1) and (2) will take eÔ¨Äect when value/3 is invoked:
?- value([4,3,5,1],0,V). V = 4351

The deÔ¨Ånition of digits(-Number,+List) is now straightforward:
digits(N,D) :- var(N), value(D,0,N).

The predicate in words/2 Ô¨Ånally is deÔ¨Åned by
in_words(N,Text) :- digits(N,D), number(D,Text).

with a predicate number/2 which assembles from a list of digits the corresponding number in plain English:
?- number([3,5,1],Text). Text = threehundredfiftyone

174 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

We won‚Äôt spell out here the deÔ¨Ånition of number/2 . The idea for a Ô¨Årst rough version can be gleaned, however, from the following query:
?- maplist(units,[4,3,5,1],[ Th, H, T, U]), concat_atom([ Th,thousand, H,hundred, T,ten, U],Text). Text = fourthousandthreehundredfivetenone

where units/2 is deÔ¨Åned by a collection of facts in the database:
units(0,‚Äô‚Äô). units(3,three). ... units(1,one). units(4,four). units(2,two). units(5,five).

Exercise 4.9. The deÔ¨Ånition of capital/2 in (P-A.26) is self-explanatory. Prolog Code P-A.26: DeÔ¨Ånition of capital/2
1 2 3 4

capital(Atom1,Atom2) :atom_chars(Atom1,[H|T]), to_upper(H,Upper), atom_chars(Atom2,[Upper|T]).

% disassemble Atom % convert H to upper case % re-assemble Atom

5 6 7

to_upper(Lower,Upper) :- char_code(Lower,L), U is L - 32, char_code(Upper,U).

Exercise 4.10. The following deÔ¨Ånition of line3/2 is derived from the sample query on p. 137.
line3(Numbers,Text) :- maplist(in_words,Numbers,[H|T]), maplist(atom_concat(‚Äô men,\n ‚Äô),T,L1), capital(H,C), concat_atom([C|L1],Text1), atom_concat(Text1,‚Äô man and his dog,‚Äô,Text).

Notice the partial application of atom concat/3 here in that its Ô¨Årst argument is Ô¨Åxed, thereby becoming a predicate of two arguments, ready to be used by maplist/3 . Exercise 4.11. The top level predicate song/0 is Ô¨Ånally deÔ¨Åned by a failure driven loop thus
song :- song_skeleton([H|T]), line1(H,L1), line2(L2), line3([H|T],L3), line4(L4), nl, write(L1), nl, write(L2), nl, write(L3), nl, write(L4), nl, fail.

The only building block of song/0 perhaps in need of some comment is line1/2 which is expected to behave as follows.

175 Download free eBooks at bookboon.com

Prolog Techniques

Appendix A: Solutions of Selected Exercises

?- line1(1,L). L = ‚ÄôOne man went to mow,‚Äô ?- line1(351,L). L = ‚ÄôThreehundredfiftyone men went to mow,‚Äô

We use the predicates in words/2 and capital/2 (from Exercise 4.8 and (P-A.26) in Exercise 4.9, respectively) to deÔ¨Åne line1/2 :
line1(N,Text) :- in_words(N,HowMany), capital(HowMany,C), ((N =:= 1, atom_concat(C,‚Äô man went to mow,‚Äô,Text)); (N > 1, atom_concat(C,‚Äô men went to mow,‚Äô,Text))).

A simpler alternative deÔ¨Ånition is as follows.
line1(1,‚ÄôOne man went to mow,‚Äô) :- !. line1(N,Text) :- in_words(N,HowMany), capital(HowMany,C), atom_concat(C,‚Äô men went to mow,‚Äô,Text).

This is the preferred version as it does not involve any arithmetic operations nor a choice of case by the disjunction operator; it uses Prolog‚Äôs search and uniÔ¨Åcation mechanisms instead.

176 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix B: Software

Appendix B

Software
Below are listed the Prolog source Ô¨Åles referenced in the various chapters. They are available on the Ventus website. Referred to in Chap. 1. accumulator.pl Referred to in Chap. 2. dl.pl Referred to in Chap. 3. arrange.pl committee.pl dl.pl party.pl people.pl queue.pl stamps.pl transformations.pl

Referred to in Chap. 4. rhyme_demo.pl

177 Download free eBooks at bookboon.com

Prolog Techniques

Appendix B: Software

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

178 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Appendix C: Glossary

Appendix C

Glossary
Note. You will Ô¨Ånd a more complete collection of Prolog terms deÔ¨Åned in the SWI‚ÄìProlog manual [18]. Accumulator. An auxiliary argument whose Ô¨Ånal value is calculated by repeated updating. It plays the rÀÜ ole of an accumulator variable in a loop in imperative progranmming. Anonymous variable. It is a variable with no user-deÔ¨Åned name and it is denoted by the underscore (_). It is used to replace singleton variables (i.e. variables occurring once only in a clause). Several anonymous variables in the same clause will be unrelated, i.e. their system-chosen names will be diÔ¨Äerent. Argument. One of the positions of a predicate if this has arity at least one. Argument pattern. This is a way of describing the modes in which a predicate can be called. The name of an input argument is preÔ¨Åxed by a plus sign (+); the name of an output argument is preÔ¨Åxed by a minus sign (‚àí); and, the name of an argument which can be used in both modes is preÔ¨Åxed by a question mark (?). Example. The inset for between/3 (p. 41) says that the Ô¨Årst two arguments of between/3 are for input only while the third one can be used for input or output (depending on whether the predicate is used to test or to generate values thereof). Arity. The number of arguments of a predicate, or more generally, of a compound term. Example. The term parents of(F, M, joe) has arity 3. Atom. A constant value which is assigned to a variable. Example. Strings starting with a lower case character such as joe . Backtracking. A way of Ô¨Ånding values of the variables in a predicate such that this succeeds. This is accomplished by traversing the associated search tree using Depth First search. Binding. Assignment of a term as a value to a variable. Body of a clause. The conjunction of the goals which have to be satisÔ¨Åed for the head of the clause to be ‚Äôtrue‚Äô. Bound variable. A variable which has been assigned a value.

179 Download free eBooks at bookboon.com

Prolog Techniques

Appendix C: Glossary

Clause. A fact or a rule in the database. Closed World Assumption. Any goal that cannot be inferred from the database is assumed ‚Äôfalse‚Äô. Therefore, the negation of such a goal will succeed. Cut (! ). A built-in predicate for ‚Äôfreezing‚Äô the assignment of values to variables in goals to the left of the cut. Variables in goals to the right will be assigned new values on backtracking. Database. The collection of all facts and rules loaded in memory. Declarative reading. A program (a predicate) is viewed as a collection of declarative assertions about the problem to be solved. DiÔ¨Äerence list. A way of representing a list as a ‚ÄôdiÔ¨Äerence‚Äô of two lists. Implicitly, its use involves uniÔ¨Åcation and is equivalent to the accumulator technique. Fact. A clause with no body. More precisely, a clause whose body is assumed true. Failure. A predicate is said to fail if its truth value inferred from the database is ‚Äôfalse‚Äô. Free variable. A variable with no value assigned to it. Functor. The name of a predicate, or more generally, the name of a compound term. Example. In parents of(george, susan, joe) the functor is parents of . Goal. An atom or a compound term which will be assigned a truth value by the Prolog system. Ground term. A term with no free variables in it, i.e. a one where all variables are bound. Head of a clause. The part of a clause which follows from the conjunction of the other goals of the clause, the body. Head of a list. The Ô¨Årst entry if we use the square bracket notation. The Ô¨Årst argument if we use the dot (.) functor to denote lists. Higher order predicate. A predicate which uses another predicate by expecting in one of its arguments the name of this predicate; or, which deÔ¨Ånes or modiÔ¨Åes another predicate. Example. The built-in predicate bagof/3 is a higher order predicate of the former kind as it uses the predicate named in its second argument. unfold/3 (see Fig. 3.9, p. 97) is a higher order predicate of the latter kind as it modiÔ¨Åes the deÔ¨Ånition of the predicate named in its Ô¨Årst argument. Instantiation. The assignment of a value to a variable. List. It is a recursively deÔ¨Åned built-in binary predicate with the dot functor (.). Its second argument is either the empty list or a list. The user friendly notation uses square brackets to denote lists. Predicate. A Prolog structure for representing an n‚Äìary relation. Example. The ternary relation parents of/3 is a relation on (i.e. a subset of) the Cartesian product C = P eople √ó P eople √ó P eople. A triplet in C which can be inferred to satisfy the relation parents of/3 is said to succeed; otherwise it is said to fail. Predicate Calculus. PC is a system for formalizing arguments with a view to establishing their validity. It is an extension of Propositional Calculus using predicates, constants and variables which are universally or existentially

180 Download free eBooks at bookboon.com

Prolog Techniques

Appendix C: Glossary

quantiÔ¨Åed. Predicate. The collection of clauses whose heads have the same functor. Propositional Calculus. PC is the simplest system for formalizing arguments with a view to establishing their validity. Its smallest units are the sentence letters that are assigned the values ‚Äôtrue‚Äô or ‚Äôfalse‚Äô. These then are strung together with connectives according to certain rules to form well‚Äìformed formulae. Finally, the latter are built up to argument forms; PC is concerned with establishing the validity of these. Recursion. DeÔ¨Åning a predicate in terms of itself. Rule. An assertion that a certain goal, the head of the clause, is ‚Äôtrue‚Äô provided that all the goals in its body are ‚Äôtrue‚Äô. Success. A predicate is said to succeed if it can be inferred from the database. Switch. A predicate argument which can take two values only. Used as a programming tool. Tail. The latter part of a list: the list comprising all entries except its Ô¨Årst entry.

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

181 Download free eBooks at bookboon.com

22-08-2014 12:56:57

Click on the ad to read more

Prolog Techniques

Appendix C: Glossary

Tail recursion. A tail recursive clause deÔ¨Ånes a predicate in terms of itself where the predicate is called as the last goal in the body. Term. The most general data object in Prolog. It can be one of the following: a constant, a variable, or a compound term. UniÔ¨Åcation. A pattern matching algorithm returning a set of values assigned to the variables of two terms such that these become equal. The assignment is most general in that any other such assignment can be obtained by specialization of the variables after uniÔ¨Åcation. Variable. A named location in the memory which may be assigned a value.

182 Download free eBooks at bookboon.com

Prolog Techniques

References

References
[1] W. F. Clocksin. Clause and EÔ¨Äect ‚Äì Prolog Programming for the Working Programmer. Springer, London, 1997. [2] W. F. Clocksin and C. S. Mellish. Programming in Prolog. Springer, London, fourth edition, 1994. [3] M. A. Covington, D. Nute, and A. Vellino. Prolog Programming in Depth. Prentice Hall, Upper Saddle River, NJ, 1997. [4] A. Csenki. Rotations in the plane and Prolog. Science of Computer Programming, 66:154‚Äì161, 2007. [5] Y. Deville. Logic Programming ‚Äì Systematic Program Development. Addison‚ÄìWesley, Wokingham, 1990. [6] DIN Deutsches Institut f¬® ur Normung e.V., Berlin. DIN 66 261 : Nassi‚ÄìShneiderman‚ÄìDiagramm, eine Entwurfsmethode f¬® ur die strukturierte Programmierung, 1985. [7] A. HoÔ¨Ämann. Paradigms of ArtiÔ¨Åcial Intelligence ‚Äì A Methodological & Computational Analysis. Springer, Singapore, 1998. [8] C. J. Hogger. Introduction to Logic Programming. Academic Press, London, 1984. [9] C. J. Hogger. Essentials of Logic Programming. Clarendon Press, Oxford, 1990. [10] E. Kreyszig. Advanced Engineering Mathematics. Wiley, New York, eighth edition, 1998. [11] J. Mulherin. Popular Nursery Rhymes. Grosset & Dunlap, New York, eighth edition, 1983. [12] I. Nassi and B. Shneiderman. Flowchart Techniques for Structured Programming. SIGPLAN Notices, 8, August 1973. [13] M. Negnevitsky. ArtiÔ¨Åcial Intelligence ‚Äì A Guide to Intelligent Systems. Addison‚ÄìWesley, Harlow and London and New York, 2002. [14] N. J. Nilsson and P. Norvig. ArtiÔ¨Åcial Intelligence ‚Äì A Modern Approach. Prentice Hall, Upper Saddle River, NJ, 1995. [15] I. Sommerville. Software Engineering. Addison‚ÄìWesley, Harlow and London and New York, sixth edition, 2001. [16] L. Sterling and E. Shapiro. The Art of Prolog ‚Äì Advanced Programming Techniques. MIT Press, Cambridge Ma, London, 1986.

183 Download free eBooks at bookboon.com

Prolog Techniques

References

[17] S. Todd. Basic Numerical Mathematics, volume 2. Academic Press, Harlow and London and New York, 1978. Basic Numerical Algebra. [18] J. Wielemaker. SWI‚ÄìProlog 5.1 Reference Manual. Amsterdam, 2003. http://www.wsi-prolog.org.

This e-book is made with

SetaPDF

SETA SIGN

PDF components for PHP developers

www.setasign.com
184 Download free eBooks at bookboon.com

Click on the ad to read more

Prolog Techniques

Index

Index
->/2 , 91 ./2 , 43 // , 173 =../2 , 43 \=/2 , 58 accumulators, 13‚Äì36 diÔ¨Äerence lists as acc‚Äôs, 57 arg/3 , 43 assert/1 , 80 asserta/1 , 81 atom chars/2 , 126 atom codes/2 , 19 atom concat/3 , 138 bagof/3 , 41 between/3 , 41 char code/2 , 137 clause/3 , 102 Closed World Assumption, 54 concat atom/2 , 126 copy term/2 , 156 current predicate/2 , 88 current prolog flag/2 , 16, 46, 136 DeMorgan‚Äôs Rule, 161 diÔ¨Äerence lists, 37‚Äì73, 97, 98, 107‚Äì115, 129 Dijkstra‚Äôs Dutch Flag Problem, 57‚Äì60, 108‚Äì116 directive, 38 dynamic/1 , 79 erase/1 , 105 fail/0 , 77 failure driven loop, 77, 104, 105, 161 findall/3 , 56 flatten/2 , 42‚Äì49 folding, 54 forall/2 , 162 functor/3 , 43 Gauss‚ÄìSeidel Method, 69‚Äì73 hand computations, 14‚Äì23 Implication Introduction Rule, 56 integer/1 , 17 is list/1 , 17 last/2 , 17, 143 listing/1 , 86 maplist/3 deÔ¨Ånition of, 127 Material Implication, 161 member/2 , 90 mod , 173 nth1/3 , 107 nth clause/3 , 102 numlist/3 , 143 op/3 , 38 operator, 38 partial application, 127, 175 pattern matching, 121 Perceptron Training Algorithm, 27‚Äì36, 64‚Äì65 predicate property/2 , 88, 108 proper list/1 , 45, 145 pseudocodes, 23‚Äì26 QuantiÔ¨Åer Equivalence Rule, 161 rem , 173 repeat loop, 134‚Äì136, 173

185 Download free eBooks at bookboon.com

Prolog Techniques

Index

repeat/0 , see repeat loop repeat loop, 173 retract/1 , 79 retractall/1 , 80 reverse/2 , 50‚Äì57 rotation list rotation, 61‚Äì64 planar rotation, 65‚Äì69 self-unfolding, 52, 105‚Äì106 set prolog flag/2 , 33, 46, 109, 147 setof/3 , 41 statistics/2 , 131 succ/2 , 134 switch, 21 tail recursion, 13 tell/1 , 86 term to atom/2 , 47 time/1 , 41 told/0 , 86 torus, 66 trace/1 , 130 true/0 , 77 unfolding, 52‚Äì53, 95‚Äì108 univ , see =../2 var/1 , 17 write term/2 , 46

186 Download free eBooks at bookboon.com

