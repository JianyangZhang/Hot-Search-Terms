PaulOS	F020:	An	RTOS	for	the C8051F020
Paul	P.	Debono

Download	free	books	at

﻿

Paul P. Debono

PaulOS F020: An RTOS for the C8051F020

2
Download free eBooks at bookboon.com

﻿

PaulOS F020: An RTOS for the C8051F020 1st edition © 2015 Paul P. Debono & bookboon.com ISBN 978-87-403-1047-4 Peer reviewed by Prof. Victor Buttigieg, University of Malta

3
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

Contents
	Preface	 	Acknowledgements	 	Dedications	 	 	 1	 1.2	 1.3	 1.4	 1.5	 1.6	 List of Figures	 List of Tables	 C8051F020 Basics	 Memory Types	 Program/Data Memory (Flash)	 External Data Address Space (XRAM)	 Register Banks	 Bit Memory	 7 9 10 11 12 13 14 15 16 17 20 21

1.1	Introduction	

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

4
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Contents

1.7	 1.8	

Special Function Register (SFR) Memory	 SFR Descriptions	

23 28 43 44 47 49 62 64 67 67 71 74 78 78 78 79 80

2	 PaulOS F020: a co-operative RTOS	 2.1	 2.2	 2.3	 2.4	 2.5	 3	 3.1	 Description of the RTOS Operation	 PaulOS_F020.C System Commands	 Descriptions of the commands	 PaulOS_F020_Parameters.h header file	 Example using PaulOS_F020 RTOS	 Master – Slave RTOS	 Multi-controller RTOSs	

3.2	Master	 3.3	Slave	 4	 4.1	 4.3	 4.4	 Programming Tips and Pitfalls	 RAM size	 Setup faults	 Serial ports (UART0 and UART1)	

4.2	SFRs	

5
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Contents

4.5	Interrupts	 4.6	 4.7	 	 RTOS pitfalls	 C Tips	 Appendix A: PaulOS_F020.C Source Listing	

81 84 84 86 86 89 100 105 154 172 172 180 190 200 201 203

A.1	PaulOS_F020_Parameters.h	 A.2	PaulOS_F020.h	 A.3	Startup_PaulOS_F020.A51	 A.4	PaulOS_F020.c	 A.5	C8051F020.H	 	 B.1	 B.2	 Appendix B Further Examples	 Timer 0 in Mode 3 (split timer) and Timer 1 as a baud rate generator	 UART0 and UART1	

B.3	Clock	 	Bibliography	 	Index	 	Endnotes	
Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

6
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Contents

Preface
This text book is intended to be used as a reference book for those whose work requires familiarity with micro-controllers and real-time operating systems (RTOSs). Ideally it should be used in conjunction with my previous books (Debono, 2013a, 2013b) and with the C8051F020 data sheet (Silicon Labs, 2003b), where various simple RTOSs were fully explained. This book deals particularly with a modified version of the PaulOS co-operative RTOS so as to be able to work with the C8051F020 device, with its increased number of timers and interrupts. It would be helpful if the reader has already got some familiarity with personal computers and has taken introductory courses in digital devices and some experience with assembly language programming. It is assumed that the reader is familiar with binary and hexadecimal numbers. Learning to write programs is like learning to ride a bicycle in that reading alone is not enough. Handson practical experience is essential. Therefore, to enhance the usefulness of this book as a learning tool, the reader is encouraged to test some of the example programs given throughout this book using easily available free software, such as the latest version of the KEIL IDE (Simplicity Studio from http://www.silabs.com). The Silicon driver program SiC8051F_µVision.exe, which is also available from the Silicon Labs site should be installed so that the program would be downloaded on the development board once it is compiled for debugging. The book is structured into 4 chapters and appendices with full source code listings of the PaulOS_F020 RTOS and a number of example programs. A brief outline of the contents of each chapter is given below: Chapter 1: This chapter describes the C8051F020 micro-controller and explains its internal organisation and lists the special function registers used to set the mode of operation of the various peripherals which are present on this versatile mixed-signal (Analogue and Digital) micro-controller device.

7
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

Chapter 2: The PaulOS_F020 co-operative RTOS is described here. This is the ‘flagship’ RTOS which we regularly use during the year with our students. It is heavily used also for their final year theses and it has been regularly refined to reflect the changes and upgrading requested by the students as they became more and more familiar with the performance and limitations of this co-operative RTOS. In this RTOS, each task is free to run for as long as it wishes. The task itself can control when to give up the processor time to allow other tasks to run. The modified version, based on the PaulOS for the basic 8051 described in (Debono, 2013a) now runs on the much faster Silicon Labs C8051F020 at over 20 million instructions per second (MIPS), is ideally suited for small project applications and for getting important familiarisation with the techniques (and pit-falls) encountered when using an RTOS on such a device. Chapter 3: This chapter deals with multi-processor applications running under RTOS. An example is given of a serial network of boards where each Slave board runs its own PaulOS RTOS but each RTOS itself is synchronised with the other slave boards by means of serial transmissions originating from the Master. Chapter 4: In this chapter we discuss some programming tips and common pitfalls which should be avoided when programming such micro-controllers. It would be a good idea to read and understand this chapter before attempting to write the first program. Appendices: Finally in the appendices we can find the full program source code listings (C language format) of the C8051F020 version of the PaulOS RTOS described in chapter 2. Whilst hoping that you will find this book useful, please feel free to contact me if you have any queries or suggestions. (e-mail: pawlu.debono@yahoo.co.uk)

8
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

Acknowledgements
I would like to acknowledge the assistance given by my students who helped me test some of the examples and pointed out some mistakes and omissions. I am also very grateful for the contributions made by my son Luke who proof read the first draft. I would also like to thank my nephew Conrad Micallef for his suggestions and constructive comments. Finally I am deeply grateful to Prof. Ing. Victor Buttigieg who kindly accepted to review the final version of the book. He also put forward valuable and much appreciated suggestions. PAUL DEBONO

9
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

Dedications
To my wife Maria for being so supportive and patient with me and to my two sons Neil and Luke for their continuous encouragement, and to my grand-daughter baby Mila for her adorable smile.

10
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

List of Figures
Figure 1-1 The C8051F020TB Development Board	 Figure 1-2 C8051F020 System Overview	 Figure 1-3 SYSCLK initialisation routine	 Figure 1-4 WDTCN: Watchdog Timer Control register	 Figure 1-5 Routine used to disable the watchdog timer	 Figure 1-6 Routine to Enable the watchdog timer, with a 47.4ms interval	 Figure 1-7 RTOS task used to ‘feed’ the watchdog every 40ms	 Figure 1-9 Lower Port I/O Functional Block Diagram	 Figure 1-10 XBR0: Port I/O Crossbar Register 0	 Figure 1-11 XBR1: Port I/O Crossbar Register 1	 Figure 1-12 XBR2: Port I/O Crossbar Register 2	 13 14 28 29 30 31 32 35 36 37 38

Figure 1-8 Part of the main program showing priority allocation for the watchdog feeder task	33

Figure 1-13 P0	39 Figure 1-14 P0MDOUT	40 Figure 1-15 P1MDIN	 Figure 2-1 RTOS Task states diagram	 Figure 2-2 Part listing of a periodic task	 Figure 2-3 Example of a stand-alone ISR, interrupting the RTOS and executing immediately when the interrupt occurs	 Figure 3-1 Networked micro-controllers using the UARTs to synchronise their RTOSs	 Figure 3-3 Listing of the UART0 9-bit mode initialisation routine for the Master	 Figure 3-4 Part of the Master RTOS Tick Interrupt routine, showing the add-ons required for multi-board operations	 enable bit is set.	 Figure 3-6 Part of the RTOS_Timer_Int routine for the Slaves, running under Serial interrupt. This code could hang up if no data is received.	 Figure 3-7 Part listing of the RTOS_Timer_Int slave routine showing the timeout modification during data reception	 Figure 3-8 OS_PAUSE_RTOS( ) and OS_RESUME_RTOS( ) modification for the slave RTOS since it uses the serial interrupt as the tick generator.	 Figure 4-1 Screen shot of the Target Options setup	 Figure 4-2 UART0: Serial initialisation routine, not under interrupt control	 77 78 80 76 76 74 75 Figure 3-5 Listing of the UART0 initlisation routine for the Slaves. Note that the serial interrupt 62 67 71 41 46 56

Figure 3-2 Serial communication between Master and two Slaves to synchronise the RTOSs	 70

11
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Contents

List of Tables
Table 1-1 C8051F020 memory map	 Table 1-2 C8051F020 Internal Data Address Space	 Table 1-3 C8051F020 Special Function Registers (SFRs)-DIRECT addressing ONLY	 Table 1-4 Priority Crossbar decode table (and use of XBR0, XBR1 and XBR2)	 Table 1-5 Interrupt Summary	 16 19 26 36 43

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

12
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1	 C8051F020 Basics
This chapter describes the C8051F020 micro-controller and explains its internal organisation and the way its special function registers can be used to setup the various peripherals. Many web pages, books (see bibliography list) and tools are available for the 8051 developer, and many of them are free! This chapter will assist the reader in mastering basic 8051 programming (using both assembly language and C language) and should eliminate the need to have an additional book specifically on the 8051. The use of the C8051F020 datasheet/manual (Silicon Labs, 2003b) and (Chew & Gupta, 2005) in conjunction with this book is highly recommended whilst following the source code examples listed throughout the book. Other good reference books are (Huang, 2009) and (Schultz, 2004) which also deal with the Silicon Labs C8051 family of micro-controllers in some of their chapters. When using the KEIL IDE as stated in the Preface section, the Silicon Labs µV3/µV4 driver program SiC8051F_µVision.exe, which is freely available from the Silicon Labs site should be installed. This would enable the compiled program to be downloaded on the development board via the JTAG once the debug tab is pressed. Lately, a new software package from Silicon Labs (http://www.silabs.com) is also available. The ‘Simplicity Studio’ application program provides one-click access to design tools, documentation, software and support resources for EFM32, EFM8, 8051, Wireless MCUs and Wireless SoCs. At the University we use the Silicon Labs development boards shown in Figure 1-1. At the time of writing, it is one of a series of super-charged versions of the 8051 family from Silicon Labs.

Figure 1-1 The C8051F020TB Development Board

Further details, manuals, integrated development packages and example programs can be found at the Silicon Labs site, http://www.silabs.com.

13
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.1	Introduction
Despite its relatively old age, the 8051 (developed by Intel Corporation in the early 1980s) is one of the most popular micro-controllers in use today. Many derivative micro-controllers have since been developed that are based on and compatible with the 8051. Thus, the ability to program an 8051 is still an important skill for anyone who plans to develop products that will take advantage of most micro-controllers. The various sections of the first chapter will explain such a derivative, the Silicon Laboratories C8051F020 micro-controller. The sections in these chapters are targeted at students and readers who already have some knowledge of the basic 8051 micro-controller and are attempting to move on to something more powerful and learn to program the C8051F020 multi-signal device. The appendices provide a useful reference tool that will assist both the novice programmer as well as the experienced professional developer, since they provide a wide range of programs complete with source code. Throughout this book, it is therefore assumed that the reader has got some amount of programming knowledge in C and that he has a basic understanding of the hardware. The C8051F020 is a 64 or 100-pin IC as shown in Figure 1-2.

Figure 1-2 C8051F020 System Overview

We shall now deal with the internal organisation of the C8051F020 micro-controller.

14
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.2	

Memory Types

The C8051F020 has three types of memory and each type has to be addressed in a different way. To effectively program the device it is therefore necessary to have a basic understanding of these memory types and how to address them, especially when programming directly in assembly language. The memory types found on the C8051F020 are illustrated Table 1-1 and they are classified as the Data Memory (RAM) which is itself organised in two separate areas, namely the Internal Data Address Space which is identical with all the basic 8052/8032 devices, and External Data Address Space which has 4096 bytes present on-chip with the ability to have extra additional storage space added externally. Then there is the Program Code/Data Memory (Flash). Addresses throughout this book are shown suffixed either with a lower case h (i.e. 0Fh) or with a upper case H (i.e. 0FH) or pre-fixed with a ‘0x’ (i.e. 0xFF) to signify that they are hexadecimal numbers.

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

15
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Table 1-1 C8051F020 memory map

1.3	

Program/Data Memory (Flash)

The flash memory is the part of memory that holds the actual code or program that is to be executed. This memory is limited to 64KB but being a flash memory, code can be re-written to it many times, so as to change/update the program. Also because it is a flash memory, it can also be used to store data which needs to be updated and stored for re-use. For example you might need to store some settings (variables), which although they can be varied whilst running the program, you would still need to store their value, so that when the program runs again (after having been switched off), it would start off again using those previously updated and stored values. Example routines of writing to and reading from flash memory are widely available on the internet and these can be easily integrated in your project. In the IDE, this memory would be denoted by the ‘CODE’ keyword, and apart from storing the code (program) you can/should use this memory area also to store fixed constants so as not to waste valuable RAM and XRAM.

16
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 PaulOS F020

C8051F020 Basics

1.4	 1.4

External Data Address Space (XRAM)

As an obvious opposite of Internal RAM, the C8051F020 also supports what is called External Data Address Space (XRAM). This is accessible using the MOVX assembly code instruction. For example, to increment an Internal RAM location by 1 (such as INC R1) requires only one instruction which is executed in one instruction cycle. To increment a 1-byte value stored in External RAM requires four assembly language instructions, namely:

029'375$''5(66 029;$#'375 ,1&$   029;#'375$   

LQVWUXFWLRQF\FOHV LQVWUXFWLRQF\FOHV LQVWUXFWLRQF\FOH LQVWUXFWLRQF\FOHV

These are executed in seven instruction cycles and in this case, external memory is seven times slower! What External RAM loses in speed and flexibility it gains in quantity. While the Internal RAM is limited to 128 bytes (256 bytes with an 8032/8052), the 8051 supports an External RAM of up to 64KB. Modern devices now also have this so-called external RAM actually residing physically on the same chip, but it is still referred to as external (or XDATA) RAM and as such it is still compatible with the basic 8051 in this respect. 1.4.1	 1.4.1 Internal Data Address Space (RAM)

The on-chip internal memory data address space can be Directly or Indirectly addressable, or both. Internal RAM is usually used to store variables, where the lower 128 bytes can be addressed in both modes (Direct and Indirect), while the upper 128 bytes, address range 80H to FFH can be only accessed by the Indirect Addressing. The Special Function Register (SFR) memory, which also lies in the address range 80H to FFH, can only be accessed by Direct addressing, so as to enable these locations to be discriminated from the other RAM bytes with the same address. It is used to store the system SFRs which control the mode of operation of the various built-in peripherals. The layout of the C8051F020’s internal memory is presented in the memory map shown in Table 1-2 which is identical with that of the basic 8051 except of course that it now has more SFRs since this device is much more capable that the basic 8051, with a much larger list of peripherals. The C8051F020 has a bank of 256 bytes of Internal RAM. This Internal RAM is found on-chip on the device itself so it is the fastest RAM available, and it is also the most flexible in terms of reading, writing, and modifying its contents. Internal RAM is volatile, so that when the device is reset or powered off this memory is lost.

17
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

The 256 bytes of internal ram is subdivided as shown on the memory map in Table 1-2. The first eight bytes (00h–07h) are referred to as register bank 0. By manipulating certain SFR bits (in the PSW special function register), a program may choose to use register banks 1, 2, or 3. These alternative register banks, each bank having a set of 8 registers R0 to R7, are located in internal RAM occupying addresses 08h through 1Fh. We will discuss register banks in more detail in section 1.5. For now it is sufficient to know that they are part of the internal RAM. Bit Memory is also another part of internal RAM, which as the name implies is able to store and manipulate bit variables. We will say more about the bit memory area later (see section 1.6), but for now we just have to keep in mind that the bit memory actually resides in internal RAM, ranging from address 20h through address 2Fh. The 80 bytes that remain in Direct and Indirectly addressable Internal RAM, from address 30h through address 7Fh, and the other 128 Indirectly addressable bytes may be used to store any user variables that need to be accessed frequently or at high-speed during the execution of the program. This area is also utilised by the micro-controller as a storage area for the operating stack, which is always accessed indirectly using the Stack Pointer (SP) SFR to store the address of the location to be read/written.

18
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Hex Byte Address
FFH

Hex Bit Address
Indirectly Addressable General Purpose RAM

Notes

80H 7FH

Used as a STACK Area and to store user variables

30H 2FH 2EH 2DH 2CH 2BH 2AH 29H 28H 27H 26H 25H 24H 23H 22H 21H 20H 1FH 18H 17H 10H 0FH 08H 07H 00H 7F 77 6F 67 5F 57 4F 47 3F 37 2F 27 1F 17 0F 07 7E 76 6E 66 5E 56 4E 46 3E 36 2E 26 1E 16 0E 06 7D 75 6D 65 5D 55 4D 45 3D 35 2D 25 1D 15 0D 05

Directly and Indirectly Addressable General Purpose RAM 7C 74 6C 64 5C 54 4C 44 3C 34 2C 24 1C 14 0C 04 7B 73 6B 63 5B 53 4B 43 3B 33 2B 23 1B 13 0B 03 7A 72 6A 62 5A 52 4A 42 3A 32 2A 22 1A 12 0A 02 79 71 69 61 59 51 49 41 39 31 29 21 19 11 09 01 78 70 68 60 58 50 48 40 38 30 28 20 18 10 08 00

Used as a STACK Area and to store user variables

Bit Addressable Section (Bit Addresses shown are in hex)

Register Bank 3 (R0 – R7) Register Bank 2 (R0 – R7) Register Bank 1 (R0 – R7) Register Bank 0 (R0 – R7)

Bank is Selected Using RS0 and RS1 In the PSW Register. See SFRs.

Table 1-2 C8051F020 Internal Data Address Space

19
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

The stack is used automatically by the processor in order to save the return addresses when functions and subroutines are called by the program either directly or indirectly via an interrupt in the case of an Interrupt Service Routine (ISR). It is also used to store some temporary values of registers or variables until they are retrieved again when needed. It should be noted, as illustrated in the memory map of Table 1-2, the area used for the stack is also shared with any user variables stored in ‘DATA’. If more stack space is required, the variables can be moved to ‘XDATA’ area either when declaring the variable or by setting the global default in the ‘Target Option’ tab of the IDE as explained in (Debono, 2013a, pp. 174,175,180).

1.5	

Register Banks

This device uses eight so-called R registers which are used in many of its instructions. These R registers are numbered from 0 through 7 (R0, R1, R2, R3, R4, R5, R6, and R7) and are generally used to assist in manipulating values and moving data from one memory location to another. For example, to add the value of R4 to the Accumulator, we would execute the following instruction:
ADD A, R4

Thus if the Accumulator (A) contained the value 6 and R4 contained the value 3, the Accumulator would contain the value 9 after this instruction was executed. However, as the memory map of Table 1-2 shows, register R4 is really part of Internal RAM. Specifically, R4 (of bank 0) is located at address 04h. Thus the above instruction accomplishes the same thing as the following operation:
ADD A, 04h

This instruction adds the value found in Internal RAM address 04h (the contents of location 04h) to the value of the Accumulator, leaving the result in the Accumulator. Since R4 is really residing in Internal RAM address 04h, the above instruction has therefore effectively accomplished the same thing as the ADD A, R4 instruction. But we must be careful since as the memory map shows, the 8051 has four distinct register banks. When the 8051 is first booted up, register bank 0 (addresses 00h through 07h) is used by default. However, our program may instruct the 8051 to use one of the alternate register banks; i.e., register banks 1, 2, or 3. In this case, R4 will no longer be in Internal RAM address 04h but somewhere else. For example, if our program instructs the 8051 to use register bank 3, register R4 will now be located at Internal RAM address 1Ch (see Table 1-2). The concept of register banks adds a great level of flexibility to the 8051, especially when dealing with interrupts, where we can allocate a specific register bank to a particular interrupt, so as not to corrupt other main program information stored in another bank of registers. However we must always remember that the register banks really reside in the first 32 bytes of Internal RAM.
20
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.6	

Bit Memory

The C8051F020, being a communications and control oriented micro-controller, gives the user the ability to access a number of bit variables. These variables may only take the value of either a 1 or a 0. There are 128 bit variables available to the user (see Table 1-2); individually have an address 00h through 7Fh. We may make use of these variables with assembly language commands such as SETB bit address and CLR bit address. For example, to set bit number 24 (hex) to 1 we would execute the instruction:
SETB 24h

It is important to note that the Bit Memory area is really a part of the Internal RAM. In fact, the 128 bit variables occupy the 16 bytes of Internal RAM from address 20h through address 2Fh. Thus, if we write the value FFh to Internal RAM address 20h we have effectively set bits 00h through 07h to 1 with just one instruction. For example we can use:
MOV 20h, #0FFh

21
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

This is equivalent to the following 8 instructions, where we are setting the bits one at a time:
SETB 00h SETB 01h SETB 02h SETB 03h SETB 04h SETB 05h SETB 06h SETB 07h

To use bit variables in C, there is a special operator bit which is used to declare a bit variable. The bit type may be used for variable declarations, argument lists, and function-return values. A bit variable is declared like other C data types. For example:
static bit ready_flag = 0; /* bit variable */

Another possibility would be to declare a byte variable in the bit addressable area, and then we also have the capability to name and address the individual bits of this variable. For example:

Alarm, is named ‘fire’ and can be used */

As illustrated in Table 1-2, the bit memory is not a new type of memory but it is just a subset of Internal RAM. Since the 8051 provides special instructions to access these 16 bytes (or 128 bits) of memory on a bit by bit basis it is useful to think of it as a separate type of memory. However, since it is just a subset of Internal RAM then we must remember that any operations performed on the Internal RAM can change the values of these bit variables.

22
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Bit variables 00h through 7Fh are mainly intended for user-defined bit variables used in the program. These are not the only bit variables available on the 8051. Other bits in certain SFRs (those which have their address ending with a 0 or an 8) can also be addressed individually as explained in the next section. These bits variables have an address of 80h or higher and are actually used to access certain Special Function Registers (SFRs) on a bit-by-bit basis so as to program and control certain peripherals of the 8051. For example, if output lines P0.0 through P0.7 are all cleared (0) and we want to turn on the P0.0 output line (set bit 0 of port 0 to logic 1) we may either execute:

MOV P0, #01h or ORL P0, #01h or SETB 80h or even SETB P0.0 ; the assembler knows that P0.0 = 80h sbit P0_1 = P0^0; or sbit P0^1 = 0x80; ; logically OR P0 with 00000001 binary

or in C: or in C: or in C: or in C:

P0 = 1; P0 | = 1; P0_1 = 1; //** P0_1 = 1; //**

** assuming that that you declare in C the following: // name bit 0 of port P0 as P0_1

All these instructions listed above accomplish the same thing, although there are some slight differences. Using the SETB or the ORL command will turn on (set to 1) the P0.0 line without affecting the status of any of the other P0 output lines. The MOV command effectively would indeed turn on (1) the P0.0 line but it would also turn off (0) all the other seven output lines (P0.1 to P0.7) which in some cases, may not be what is actually required. Hence caution has to be taken to ensure that we use the correct and most efficient method when setting or clearing bits. Naturally, if no bit variables are required this bit-addressable area can be used to store other variables (bytes, integers etc). It is not restricted to storing just bits!

1.7	

Special Function Register (SFR) Memory

Special Function Registers (SFRs) reside in areas of internal memory that control specific functionality of the C8051F020 chip, as shown in Table 1-3. For example, eight SFRs permit access to the 8 I/O port P0-P7. Another two SFRs (SBUF0 and SBUF1) allow a program to read from or write to its two serial ports which are called UART0 and UART1 (Universal Asynchronous Receiver/ Transmitter). Other SFRs allow the user to set the serial baud rates, control and access timers, ADC, DAC etc. and also configure the 8051’s interrupt system.

23
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

When programming, we may get the illusion that the SFRs are Internal Memory. This is because they are directly addressable. For example, if we want to write the value 1 to Internal RAM location 50 hex we would execute the instruction:
MOV 50h, #01h

Similarly, if we want to write the letter ‘A’ to its UART0 we would write this value to the SBUF0 SFR, which has an SFR address of 99 Hex. Thus, to write the value ‘A’, which has an ASCII code of 65 decimal; to the serial port we would execute the instruction:
MOV 99h, #41h or MOV SBUF0, #41h or MOV SBUF0, ‘A’

When using this method of memory access (called direct addressing mode), any instruction that has an address of 00h through 7Fh refers to an Internal RAM memory address while any instruction with an address of 80h through FFh refers to an SFR control register. Quoting from the KEIL uV4 IDE online user manual: …….. The Cx51 Compiler provides access to SFRs with the sfr, sfr16, and sbit data types. SFRs are declared in the same fashion as other C variables. The only difference is that the type specified is sfr rather than char or int. For example:
sfr P0 = 0x80; /*	 sfr P1 = 0x90; /*	 sfr P2 = 0xA0; /*	 sfr P3 = 0xB0; /*	 Port-0, address 80h */ Port-1, address 90h */ Port-2, address 0A0h */ Port-3, address 0B0h */

…….. end of quote. P0, P1, P2, and P3 are the SFR name declarations. Names for sfr variables are defined just like other C variable declarations. Any symbolic name may be used in an sfr declaration. The address specification after the equal sign (‘=’) must be a numeric constant. Expressions with operators are not allowed. Classic 8051 devices support the SFR address range 0x80-0xFF. The Cx51 Compiler is a ‘big endian’ compiler in the sense that it stores the variables with the high byte occupying the lowest memory address. However, since the 8051 has some SFRs (such as TL2 and TH2) stored in ‘little endian’ format, the Keil compiler provides the sfr16 data type to access two consecutive 8-bit SFRs as a single 16-bit SFR in ‘little endian’ style.

24
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Access to 16-bit SFRs using sfr16 is possible only when the low byte immediately precedes the high byte (little endian) and when the low byte can be written last without affecting the functionality of the device. Certain devices might require the low byte to be written first when setting up the particular peripheral. The low byte is used as the address in the sfr16 declaration. For example:
sfr16 T2REG = 0xCC; /*	 sfr16 RCAP2 = 0xCA; /*	 comprising the 2 SFRs TL2 at 0CCh, TH2 at 0CDh */ RCAP2L at 0CAh, RCAP2H at 0CBh */

Elsewhere in the program, we can then write and execute:
T2REG = 0x1234;	 /* resulting in TH2=0x12, TL2=0x34 with TL2 written last */ RCAP2 = 0x5678;	 /* resulting in RCAP2H=0x56, RCAP2L=0x78 with RCAP2L written last */

The sbit type defines a bit within a special function register (SFR) or any variable in the bit addressable area. It is used in one of the following ways, taking an SFR as an example:
sbit name = sfr-name ^ bit-position; sbit name = sfr-address ^ bit-position; sbit name = sbit-address;

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

25
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

where: name		 sfr-name	 sfr-address	 is the name of the SFR bit is the name of the previously-defined SFR is the address of the SFR

bit-position	 is the position of the bit with the SFR sbit-address	 is the address of the SFR bit. 1.7.1	 SFR Addresses

The C8051F020 is a flexible micro-controller with a relatively large number of peripherals having different modes of operation. In order to be able to make full use of these different modes or ways of using the built in peripherals of this versatile micro-controller, our program may inspect and/or change their operating mode by manipulating the values of some specific SFRs. They are accessed just as if they were normal Internal RAM. The only difference is that Internal RAM for the 8051 resides from address 00h through 7Fh whereas the SFR registers exist in the address range of 80h through FFh. Each SFR has an address (80h through FFh) and a name. Table 1-3 provides a tabular representation of the 8051’s SFRs, their name, and their address in hexadecimal. Although the address range is from 80h through FFh, thus offering 128 possible addresses, there are 6 locations which are not used. Moreover, reading data from these empty addresses will in general return some meaningless random data while writing data to these addresses will have no effect at all. In fact the actual memory cell of these free locations might not be physically present on the chip. These free locations are reserved for future enhanced and upgraded versions of this family of microcontrollers, and certain versions (such as the C8051F040) need much more SFRs than can be fitted in 128 bytes. These therefore make use of more than one 128-byte page of SFRs thus having to switch SFR pages in order to set the correct SFR


Table 1-3 C8051F020 Special Function Registers (SFRs)-DIRECT addressing ONLY

26
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

We should therefore stick to the rule that any user developed software should not write anything to these unimplemented locations, since they may be used in future products to invoke new features. All unimplemented addresses in the SFR range (80h through FFh) are considered invalid and writing to or reading from these non-existent register locations may produce undefined values or behaviour. 1.7.2	 SFR Types

In this section we shall only mention some special SFRs which are appreciably different from the basic 8051 SFR. The standard 8051 SFRs are still available and work in exactly the same way even on this device, and details about these ‘old’ SFRs can be found in an earlier book (Debono, 2013a). In general, as mentioned in Table 1-3 itself, some SFRs are used to control the operation or the configuration of some aspect of the 8051. For example, TCON and TMOD control the timers while SCON0 controls serial port (UART0) operations. The other SFRs can be thought of as auxiliary SFRs in the sense that they do not directly configure the 8051 but obviously the 8051 cannot operate without them. For example, once the serial port UART0 has been configured using SCON0, the program may read or write data characters or bytes to the serial port using the SBUF0 register.

.

27
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

The SFRs whose address has an asterisk (*) in the Table 1-3 above, are special SFRs that may also be accessed via bit operations (i.e., using the SETB and CLR instructions). The other SFRs cannot be accessed using bit operations but have to be handled using byte operations. As we can see, all SFRs whose addresses are divisible by 8 (having an address ending with a 0h or an 8h) can be accessed with bit operations, meaning that they are bit-addressable.

1.8	

SFR Descriptions

As already mentioned in section 1.7.2 the basic 8051 SFRs were all fully described in a previous book (Debono, 2013a) and will not be covered here. Instead we shall mainly deal here with some important new SFRs specific to the C8051F020. For a full description of all the SFRs, such as those dealing with the ADC, DAC, etc it would be best to consult the manual/data sheet (Silicon Labs, 2003b). 1.8.1	 System Clock (OSCXCN, OSCICN) registers

SFRs OSCXCN and OSCICN are used to select and configure the system clock. The routine listed in Figure 1-3 SYSCLK initialisation routine sets the system clock to use a 22.1184MHz crystal as its clock source.
void SYSCLK_Init (void) { unsigned int i;			 OSCXCN = 0x67;			 for (i=0; i < 256; i++) ;		 while (!(OSCXCN & 0x80)) ;		 OSCICN = 0x88;			 				 }
Figure 1-3 SYSCLK initialisation routine

// delay counter // start external oscillator with 22.1184MHz crystal // wait for oscillator to start // Wait for crystal osc. to settle, not need if in simulator mode // select external oscillator as SYSCLK // source and enable missing clock detector

Note that the
while (!(OSCXCN & 0x80)) ;

is a delay instruction, waiting for the crystal oscillator to settle is not required if running the KEIL IDE in simulation mode and in certain cases the simulation would hang on this line if the simulation is not emulating the oscillator function perfectly. It could be conditionally compiled by defining SIMULATOR in the C51 Target tab when running in simulation mode and then using:

28
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

#ifndef SIMULATOR 	 #endif while (!(OSCXCN & 0x80)) ;

Thus the oscillator will be tested only when running on the actual board (without the SIMULATOR definition) and the test will be ignored when running in simulation mode. 1.8.2	 Watchdog Timer (WDT)

The micro-controller has a programmable Watchdog Timer (WDT) which runs off the system clock. An overflow of the WDT forces the micro-controller into the reset state. Before the WDT overflows, using certain commands as explained in section 1.8.2.2 the application program must restart it so as the WDT starts counting again from zero. WDT is useful in preventing the system from running out of control, especially in critical applications. If the system experiences a software or hardware malfunction which prevents the software from restarting the WDT, then the WDT will overflow and cause a controller reset. After a reset, the WDT is automatically enabled and starts running at the default maximum time interval which is 524 ms for a 2 MHz system clock or approximately 47ms in the case of a 22.1184 MHz clock. The WDT consists of a 21-bit timer running from the programmed system clock. A WDT reset is generated when the period between specific writes to its control register exceeds the programmed limit as given in equations (1-1) and (1-2). The WDT may be enabled or disabled by software as explained in section 1.8.2.1 and in section 1.8.2.2. It may also be locked to prevent accidental disabling. Once locked, the WDT cannot be disabled until the next system reset. It may also be permanently disabled. The watchdog features are controlled by programming the Watchdog Timer Control Register (WDTCN), details of which are shown in Figure 1-4, which is taken from (Silicon Labs, 2003, p. 131).

Figure 1-4 WDTCN: Watchdog Timer Control register

29
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.8.2.1	 Disabling the WDT This is usually disabled at the very beginning of the main program so as not to give time for the watchdog timer to overflow and reset the micro-controller. In certain cases, if there are a lot of initialisations being done in the Startup.a51 code (which is actually executed even before the main( ) function in the application program), the ‘disable_watchdog’ code would even need to be written directly in the Startup.a51 so as to be executed right at the beginning, immediately after a reset or switch-on. As seen in Figure 1-5 the interrupts are disabled immediately in the ‘disable_watchdog’ code so that nothing interferes with this process. The two write instructions to the WDTCN register should be made within 4 clock cycles of each other as suggested in (Silicon Labs, 2003, p. 130) and the interrupts are enabled before exiting the routine.
void DISABLE_Watchdog (void) { EA = 0; WDTCN = 0xDE; WDTCN = 0xAD; EA = 1; }
Figure 1-5 Routine used to disable the watchdog timer

1.8.2.2	 Enabling and Setting WDT Interval Bits 2-0 of WDTCN, treated as a 3-bit binary number, control the watchdog timeout interval (WDTI). The time interval is given by the following equation:
WDTI = 4�������[���] × T������ (1-1)

where TSYSCLK is the system clock period or the reciprocal of the system clock frequency SYSCLK. Hence we may also write the time interval equation as:
WDTI =

For a 22.1184 MHz system clock, the interval range that can be programmed up to a maximum of 47.4 ms, with the lower three bits WDTCN[2-0] set to 111 binary (equivalent to 7 decimal) as shown in equation (1-3). When the watchdog timeout interval bits are written to the WDTCN register, the WDTCN.7 bit must be held at logic 0. The programmed interval may be read back by reading the WDTCN register. After a reset, WDTCN[2-0] reads 111b.
WDTI = 4��� 4�� = = 4�.4 �� (1-3) ������ 22. 1184 x 10�

4�������[���] (1-2) ������

30
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

With this information, we can therefore write our routine to enable the watchdog timer, which is listed in Figure 1-6. Assuming that we are using a 22.1184MHz oscillator, then this initialisation routine would set the watchdog timer to overflow and thus causing a micro-controller reset every 47.4ms unless the watchdog timer itself is reset by ‘feeding’ the watchdog before overflowing.
// Enables the watchdog timer // void ENABLE_Watchdog (void) { EA = 0; // set bit 7 to 0 in order to write count and // set WDTCN[2.0] to 111b giving a WDT timeout interval = ( 4(3+7) ) x Tsysclock // This would give the maximum timeout interval. // At 22.1184 MHz, this would be equal to 47.4 ms WDTCN = 0x07; // set the timeout interval bits WDTCN = 0xA5; // enable WDT EA = 1; }
Figure 1-6 Routine to Enable the watchdog timer, with a 47.4ms interval

The watchdog timer would have to be reset to start counting up again from 0, before giving it a chance to overflow. This is done by means of the ‘FeedWDT’ task shown in Figure 1-7running under the PaulOS RTOS, which is a periodic function, executing every 40ms (which is less than the 47.4ms WDT interval). The PaulOS RTOS would be fully explained in chapter 2, but the commands and functions are the same as in the earlier book (Debono, 2013a).

31
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

/* Task ‘FeedWDT’ – created as Task 0 to give it highest priority when RTOS sorts the ‘ready’ tasks – as explained in section 2.3.3 – Periodicity must be less than 47.4 ms as calculated above in the – ENABLE_Watchdog function to avoid WDT reset */ void FeedWDT_Task (void) { OS_PERIODIC_A(0,0,40);		 while(1)			 { WDTCN = 0xA5;		 OS_WAITP( ); } }
Figure 1-7 RTOS task used to ‘feed’ the watchdog every 40ms

/* Execute every 40 ms */ // endless loop

// reloads WDT // wait for the periodic interval

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

32
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

In order to give it preferential treatment, this task is allocated a task number of 0 and the priority sorting is enabled in the OS_RTOS_GO(1) command as shown in the partial listing shown in Figure 1-8. Thus if there are other tasks ready to execute, Task 0 would be selected instead of the normal first in-first out selection if no priority sorting was implemented.
void main (void) { DISABLE_Watchdog( ); SYSCLK_Init( );	 SetUpUART(0, 115200, 1); /* Set up UART 0, at 115200 baud using Timer 1 */ PORT_Init( );

OS_INIT_RTOS(0);	

/* initialise RTOS, variables and stack */

OS_CREATE_TASK(0, FeedWDT_Task); /* CREATE task0, 0 being the highest priority */ OS_CREATE_TASK(1, Blink_Task); OS_CREATE_TASK(2, Clock_Task);

ENABLE_Watchdog( ); OS_RTOS_GO(1);		 while (1) {.. … …} }
Figure 1-8 Part of the main program showing priority allocation for the watchdog feeder task

/* Start multitasking, with priority sorting */

In the example above, if the periodicity of Task 0 is set to be greater than 47.4ms, then the WDT would overflow and cause a system reset, since WDT would not be restarted in time to count from zero before overflowing. 1.8.3	 Crossbar Decoder (XBR0, XBR1 and XBR2)

The user controls which digital functions are assigned to any IC pins1 which can then be accessed by the user. This flexibility is limited only by the number of pins available on the IC. The Port pins on Port 1 can be used as Analogue Inputs to ADC1. The Priority Crossbar Decoder, or “Crossbar”, allocates and assigns Port pins on Port 0 through Port 3 to the digital peripherals (UARTs, SMBus, PCA, Timers, etc.) on the device using a priority order. The Port pins are allocated in order starting with P0.0 and continue through P3.7 if necessary. The (Silicon Labs, 2003b) manual is used as a reference for this section and all the figures and tables from section 1.8.3 to section 1.8.7 are taken from it. The digital peripherals shown in Figure 1-9 are assigned Port pins in a priority order which is listed in Table 1-4, with UART0 having the highest priority and CNVSTR having the lowest priority.
33
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Again using (Silicon Labs, 2003b), the Crossbar assigns Port pins to a peripheral if the corresponding enable bits of the peripheral are set to logic 1 in the Crossbar configuration registers XBR0, XBR1, and XBR2, shown in Figure 1-10, Figure 1-11 and Figure 1-12. For example, if the UART0EN bit (XBR0.2) is set to logic 1, the TX0 and RX0 pins will be mapped to P0.0 and P0.1 respectively. Because UART0 has the highest priority, its pins will always be mapped to P0.0 and P0.1 when UART0EN is set to logic 1. If a digital peripheral’s enable bits are not set to logic 1, then its ports are not accessible at the Port pins of the device. Also note that the Crossbar assigns pins to all associated functions when a serial communication peripheral is selected (i.e. SMBus, SPI, UART). It would be impossible, for example, to assign TX0 to a Port pin without assigning RX0 as well. Each combination of enabled peripherals results in a unique device pin-out. Once the Crossbar registers have been properly configured, the Crossbar is enabled by setting XBARE (XBR2.6) to logic 1. Until XBARE is set to logic 1, the output drivers on Ports 0 through 3 are explicitly disabled in order to prevent possible contention on the Port pins while the Crossbar registers and other registers which can affect the device pin-out are being written. The output drivers on Crossbar-assigned input signals (like RX0, for example) are explicitly disabled; thus the values of the Port Data registers and the PnMDOUT registers have no effect on the states of these pins.


Figure 1-9 Lower Port I/O Functional Block Diagram

34
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Table 1-4 Priority Crossbar decode table (and use of XBR0, XBR1 and XBR2)

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel – as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

35
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Figure 1-10 XBR0: Port I/O Crossbar Register 0

Figure 1-11 XBR1: Port I/O Crossbar Register 1

36
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Figure 1-12 XBR2: Port I/O Crossbar Register 2

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

37
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.8.4	

Input/Output ports and pin outs allocation

The C8051F020/1/2/3 devices have a wide array of digital resources which are available through the four lower I/O Ports: P0, P1, P2, and P3. As described in (Silicon Labs, 2003, pp. 162–181) each of the pins on P0, P1, P2, and P3, can be defined as a General-Purpose I/O (GPIO) pin or can be controlled by a digital peripheral or function (like UART0 or /INT1 for example), as shown in Figure 1-9. These pages of the Silicon Labs manual cover a very important section which should be fully understood by the user so as to be able to configure the device and its peripherals properly. There are also software aids which are also freely supplied by Silicon Labs where you select the devices that you want to use, and the correct register configurations are displayed, ready to copy and paste on to your program. The Simplicity Studio package, for example provides one-click access to design tools, documentation, software and support resources for EFM32, EFM8, 8051, Wireless MCUs and Wireless SoCs devices. 1.8.4.1	 Configuring the Output Modes of the Port Pins The output drivers on Ports 0 through 3 remain disabled until the Crossbar is enabled by setting XBARE (XBR2.6) to logic 1. The output mode of each port pin can be configured as either Open-Drain or PushPull; the default state is Open-Drain. In the Push-Pull configuration, writing logic 0 to the associated bit in the Port Data register will cause the Port pin to be driven to GND, and writing logic 1 will cause the Port pin to be driven to VDD. In the Open-Drain configuration, writing logic 0 to the associated bit in the Port Data register will cause the Port pin to be driven to GND, and logic 1 will cause the Port pin to assume a high-impedance state. The Open-Drain configuration is useful to prevent contention between devices in systems where the Port pin participates in a shared interconnection in which multiple outputs are connected to the same physical wire (like the SDA signal on an SMBus connection). The output modes of the Port pins on Ports 0 through 3 are determined by the bits in the associated PnMDOUT registers (see Figure 1-14 giving the register related to Port 0. Similar registers are available for the other ports). For example, logic 1 in P0MDOUT.7 will configure the output mode of P0.7 to Push-Pull; logic 0 in P0MDOUT.7 will configure the output mode of P0.7 to Open-Drain. All Port pins default to Open-Drain output. The PnMDOUT registers control the output modes of the port pins regardless of whether the Crossbar has allocated the Port pin for a digital peripheral or not. The exceptions to this rule are that the Port pins connected to SDA, SCL, RX0 (if UART0 is in Mode 0), and RX1 (if UART1 is in Mode 0) are always configured as Open-Drain outputs, regardless of the settings of the associated bits in the PnMDOUT registers.

38
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Figure 1-13 P0

Figure 1-14 P0MDOUT

1.8.4.2	 Configuring Port Pins as Digital Inputs A Port pin is configured as a digital input by setting its output mode to “Open-Drain” and writing a logic 1 to the associated bit in the Port Data register. For example, P0.7 is configured as a digital input by setting P0MDOUT.7 to logic 0 and P0.7 to logic 1. If the Port pin has been assigned to a digital peripheral by the Crossbar and that pin functions as an input (for example RX0, the UART0 receive pin), then the output drivers on that pin are automatically disabled.

Figure 1-15 P1MDIN

39
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.8.4.3	 Weak Pull-ups By default, each Port pin has an internal weak pull-up device enabled which provides a resistive connection (about 100 kΩ) between the pin and VDD. The weak pull-up devices can be globally disabled by writing logic 1 to the Weak Pull-up Disable bit, (WEAKPUD, XBR2.7). The weak pull-up is automatically deactivated on any pin that is driving logic 0; that is, an output pin will not contend with its own pullup device. The weak pull-up device can also be explicitly disabled on a Port 1 pin by configuring the pin as an Analogue Input. 1.8.5	Additional External Interrupts (IE6 and IE7) In addition to the external interrupts /INT0 and /INT1, whose Port pins are allocated and assigned by the Crossbar, P3.6 and P3.7 can be configured to generate edge sensitive interrupts; these interrupts are configurable as falling- or rising-edge sensitive using the IE6CF (P3IF.2) and IE7CF (P3IF.3) bits. When an active edge is detected on P3.6 or P3.7, a corresponding External Interrupt flag (IE6 or IE7) will be set to logic 1 in the P3IF register (See Fig). If the associated interrupt is enabled, an interrupt will be generated and the CPU will vector to the associated interrupt vector location.

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

40
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

1.8.6	

IE, EIE1 and EIE2 (Interrupt Enable)

The Interrupt Enable SFRs are used to enable and disable specific interrupts. Since this controller has 21 interrupt sources, apart from the reset, there are three separate registers available to handle the interrupt enabling system and these are the IE, EIE1 and EIE2 SFRs. The bits controlling the interrupts are listed in the Enable flag column of Table 1-5. 1.8.7	 IP (Interrupt Priority)

The Interrupt Priority SFRs are used to specify the relative priority of each interrupt. Three SFRs (IP, EIP1 and EIP2) are available to handle the priority settings as shown in Table 1-5. On the 8051, an interrupt can be of any one of two types. It may either be of a low (0) priority or a high (1) priority. An interrupt may only interrupt other interrupts of lower priority. For example, if we configure the 8051 so that all interrupts are of low priority except the serial interrupt, the serial interrupt will always be able to interrupt the system, even if another interrupt (at a low priority setting) is currently executing its service routine. However, if a serial interrupt service routine is executing then no other interrupt will be able to interfere with the serial interrupt service routine since the serial interrupt has the highest priority. The priority order column is used to discriminate between interrupts with the same high/low priority setting which happen to occur exactly at the same time2.

AXA Global Graduate Program
Find out more and apply

41
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

C8051F020 Basics

Table 1-5 Interrupt Summary

42
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2	 PaulOS F020: a co-operative RTOS
The PaulOS (PAUL’s Operating System) F020 is the same co-operative RTOS as described in (Debono, 2013a) but with some modifications in order to work with the Silicon Laboratories C8051F020 microcontroller. This RTOS can easily be modified to accommodate other types of devices from the wide range of mixed-signal microcontroller units (MCUs) produced by Silicon Labs. Mainly it would involve checking the availability of the timers and interrupts present on the device and modifying the RTOS accordingly. This is the main RTOS which we regularly use during the year with our students. It is also heavily used for the students’ final year theses and it has therefore been regularly refined to reflect the changes and upgrading requested by the students as they became more and more familiar with the performance and limitations of this co-operative RTOS. In this RTOS, each task is free to run for as long as it wishes. The task itself controls when to give up the processor time to allow other tasks to run by issuing certain operating system (OS) commands to cause it to go to the WAIT state. The idea for writing an RTOS for the 8051 had been brewing in my mind for quite some time, prompted by the desire to provide a simple RTOS for student use. It was further given a boost after coming across a book on C and the 8051 (Schultz, 1999)3.This RTOS is a direct adaptation of my previous PaulOS assembly language program, re-written in C so as to make it more versatile and more easily portable to other micro-controllers. In fact it was even successfully ported to the Intel 8086 microprocessor and other micro-controllers. The main task of translating it from assembly to C was undertaken years ago as a final year engineering degree thesis (Blaut, 2004), then a student under my supervision. It was further developed and improved throughout the years by myself, thanks also to input and suggestions from other students taking my study-units during their degree program, into the version shown here. I consider this RTOS as providing a good basis to the study of a real-time operating system for the 8051 family of micro-controllers. Naturally there are some memory space and speed penalties to pay for the versatility obtained with an RTOS written in C rather than directly in assembly language. However the improvements are more than worth the penalties, especially as far as student understanding of the RTOS is concerned. In the next paragraph we now list once again the RTOS commands, including the improvements, mainly achieved with the use of MACROS which are listed in section 2.3.14. The full source program can be found in appendix D.

43
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.1	

Description of the RTOS Operation

The PaulOS_F020 RTOS is a co-operative RTOS and hence, as explained in the RTOS chapter (Debono, 2013a), each task has to take the initiative to give up its own time so as to allow other tasks to run. It has to be kept in mind that this OS is running on an 8051-based micro-controller which can only run one program (or task) at a time and hence this task swapping RTOS only gives the impression of having tasks running simultaneously or concurrently. In actual fact we can only have one task actually running, and at the time that the RTOS is doing its own checks, no tasks at all would be running. This time ideally should be kept as short as possible. The operation of the RTOS is as follows: Each task, when created, would have its own memory area in external memory where there would be stored all the registers (R’s, A, B, DPTR, PSW), stack area (including the return address of the task or function). Once a change of task is required, the RTOS would take care to swap the relevant registers and stack areas so that the micro-controller would have the correct data for the new task in its own internal RAM.

 5XQQLQJ

:DLWLQJ 4XHXH

5HDG\ WRH[HFXWH 4XHXH

Figure 2-1 RTOS Task states diagram

44
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

The RTOS tick-timer can be chosen by the user who can select from the different timers available on the controller. Once set, at every timer overflow, an interrupt call is made to the main RTOS tick timer interrupt service routine. This is the most important routine in the RTOS program since at every interrupt the RTOS has to check the status of all the tasks so as to be able to decide whether a task can be moved from the Waiting queue on to the Ready queue (see Figure 2-1) or whether a task swap is required if the main( ) was running is required. The RTOS achieves this by counting down the parameter variables holding the individual waiting time required for those tasks in the waiting queue. When anyone of these timeout parameters reaches 0, it means that the time to move on has arrived. Once again, being a co-operative RTOS, the scheduler cannot swap tasks on its own accord. Only the main( ) code can be forced to give up its time, so that if at any time whilst the main( ) code is running, there is a task which moves into the Ready queue, then that task takes over. On the other hand, when one of the OS commands which forces a task change is encountered in a task then it is only at that instance that a task swap is initiated by the RTOS. The currently running task is then usually marked as being in the Waiting queue (waiting for one or two ticks say) and the first task in the Ready queue takes over, with its stack and registers environment being copied into the working area. The environment of the old task is copied to the external memory store area for later retrieval.

45
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

The idea behind the PaulOS RTOS is that any task (a function or a routine in a program, which is normally an endless loop) can be in any one of three states as shown in Figure 2-1, Running, Waiting (for some event or time delay) or Ready (to execute) state. RUNNING A task can be RUNNING, (obviously in the single 8051 environment, there can only be one task which is actually in the running state). If there are no tasks which are ready to execute, then the RTOS will set the main( ) function as the running task, which in most case would be actually doing nothing, just putting the micro-controller in the idle or sleep state so as to conserve power. This will be interrupted at any time by the RTOS, taking it out of the idle mode, as soon as a task becomes ready to run and the RTOS then executes the swap. WAITING A task can be in the WAITING (sometimes also referred to as SLEEPING) queue. Here a task could be waiting for any one of the following time delays or events to occur: •	 a specified amount of time delay, selected by the user with OS_WAITT (or OS_WAITT_A(min, sec, msec)) command. •	 an OS_DEFER command which is actually just the normal OS_WAITT(..) with 2 ticks as the parameter, i.e. OS_WAITT(2) – wait for 2 ticks. •	 a specified amount of time delay, selected by the user with OS_PERIODIC (or OS_PERIODIC_ (min, sec, msec)) command. The actual task is placed in the waiting queue when the OS_WAITP (wait for periodic interval) is encountered. •	 a specified interrupt to occur within a specified time, selected by the user with the OS_WAITI command. •	 a signal from some other task within a specified timeout, selected by the user with the OS_WAITS(ticks) (or OS_WAITS_A(min, sec, msec)) command. •	 a signal from some other task indefinitely, selected by the user with the OS_WAITS(0) command. •	 a never-ending waiting period. A task could be put in a state to wait indefinitely, effectively behaving as if the task did not exist. This is specified by the OS_KILL_IT command.

46
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

READY It can also be in the READY QUEUE where it would be waiting for its turn to execute. This can be visualised in Figure 2-1 which shows how the tasks can move from one state to another. The RTOS, when permitted to do so, will select the top task (first in – first out) from this queue to execute instead of the currently running task, which would then be placed in the waiting queue. This RTOS also has the capability, if it is enabled, to sort the tasks in the Ready Queue according to their task number, so as to place the task with the lowest number (highest priority) at the top of the queue, so that it would be the chosen task to run at the first opportunity. This is further explained when discussion the OS_RTOS_ GO(priority) command in section 2.3.3. The RTOS itself always resides in the background, and comes into play: •	 At every RTOS TIMER interrupt (usually when Timer 2 or Timer 0 overflows, say every one millisecond) so as to update the waiting time left for any tasks. •	 At any other device interrupt from other timers, UARTs, ADCs etc or external inputs so as to check whether it needs to move to the ready queue any tasks which were waiting for such events or interrupts. •	 Whenever an RTOS system command is issued by the main program or tasks, to perform that system command. The RTOS which is effectively supervising and scheduling all the other tasks then has to make a decision whether it has to pause the current task and resume a new one or whether it can let the current task run on. There could be various reasons for changing tasks, as explained further on, but in order to do this task swap smoothly, the RTOS has to save all the environment of the presently running task and substitute it with the environment of the next task which is about to run. This is accomplished by saving all the BANK 0 registers, the ACC, B, PSW, and DPTR registers. The STACK and the stack pointer SP too have to be saved since the task might have pushed some data on the stack (apart from the address at the point that the task was interrupted, where it has to return to after the interrupt). This is the crux of the PaulOS F020 RTOS.

2.2	

PaulOS_F020.C System Commands

We now list and explain all the 14 PaulOS_F020 RTOS system commands. These are first listed or grouped according to whether or not they take any parameters. The list is then repeated, this time sorted according to whether the command causes a task swap or not.

47
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

The following RTOS system calls do not receive any parameters: •	 OS_DEFER (void);	 •	 OS_KILL_IT (void);	 	 	 // Stops current task and passes control to next task in queue // Kills a task – sets it waiting forever

•	 OS_RUNNING_TASK_ID(void); // Returns the task number of the currently executing task •	 OS_SCHECK (void); 		 // Checks if running task’s signal bit is set, returns a bit value // of 1 if signal is already present. •	 OS_WAITP (void); 		 // Waits for end of task’s periodic interval, set by // the OS_PERIODIC command. The following RTOS system calls do receive parameters: •	 OS_CREATE_TASK (uchar tasknum, uint taskadd); 	 •	 OS_INIT_RTOS (uchar blank);	 •	 OS_PERIODIC (uint ticks);	 •	 OS_RTOS_GO (uchar prior);	 •	 OS_WAITI (uchar intnum);	 •	 OS_WAITS (uint ticks);	 •	 OS_WAITT (uint ticks);	 // Creates a task

// Initialises RTOS variables, parameter blank is not used at all // Tasks run periodically every number of ticks // Starts the RTOS with priorities if required // Waits for an event (interrupt) to occur // Waits for a signal within a number of ticks // Waits for a timeout defined by number of ticks

•	 OS_RESUME_TASK (uchar tasknum);	// Resumes a task which was previously KILLed •	 OS_SIGNAL_TASK (uchar tasknum);	// Signals a task

I’M WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

48
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

The list of commands can also be grouped as those which cause a change of task, might cause a change of task and those which do not cause a task swap. The following RTOS system calls force a task change after executing this command: •	 OS_DEFER (void);	 •	 OS_KILL_IT (void);	 	 	 // Stops current task and passes control to next task in queue // Kills a task – sets it waiting forever // Waits for a timeout defined by number of ticks // Waits for the end of the task’s periodic interval

•	 OS_WAITI (uchar intnum);	 // Waits for an event (interrupt) to occur •	 OS_WAITT (uint ticks);	 •	 OS_WAITP (void); 		

The following RTOS system call might force a task change after executing this command: •	 OS_WAITS (uint ticks);	 // Waits for a signal within a number of ticks

If the signal is already present when the command is issued, then no task swap is made, otherwise a task change is performed. The following RTOS system calls do not force a task change, and the task using any of these commands would continue to run after executing the command: •	 OS_CREATE_TASK (uchar tasknum, uint taskadd); 	 •	 OS_INIT_RTOS (uchar blank); 	 •	 OS_PERIODIC (uint ticks);		 •	 OS_RTOS_GO (uchar prior);	 	 •	 OS_SCHECK (void); 			 						// actually used // Tasks run periodically every number of ticks // Starts the RTOS with priorities if required // Checks if running task’s signal bit is set •	 OS_RESUME_TASK (uchar tasknum);	// Resumes a task which was previously KILLed •	 OS_RUNNING_TASK_ID(void); // Returns the task number of the currently running task •	 OS_SIGNAL_TASK (uchar tasknum);	 // Signals a task // Creates a task

// Initialises all RTOS variables, parameter not

2.3	

Descriptions of the commands

The F020 version of this RTOS provides some variations from the previous basic PaulOS RTOS, described on (Debono, 2013a, page 200). The detailed description of the commands is once again being give here, which would completely describe the PaulOS F020 RTOS. The complete source program can be found in the Appendix A and examples are given at the end of this chapter which should make it easier to understand. The variables mentioned in the explanations of the various RTOS commands can all be found in the Appendix A listings.

49
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.1	OS_INIT_RTOS(0) This system command must be the first command to be issued in the main program in order to initialise the RTOS variables and parameters. It is called from the main program and takes an unsigned char parameter just for the sake of keeping the same format as that used in the previous basic PaulOS RTOS. The parameter as such is not used in the OS_INIT_RTOS function, and is therefore normally given a value of zero. An example of the syntax used for this command is:
OS_INIT_RTOS(0);

which would initialise all the required RTOS system parameters. This system command performs the following operations: •	 Clears the external memory area which is going to be used to store the stack of each task. •	 Sets up the Interrupt Enable registers, depending on the TICK_TIMER parameter set in the parameter header file. •	 Selects edge triggering on the external interrupts. This can be amended if a different triggering is required by changing directly the default initialisation in the RTOS source code listing found in Appendix A or by re-setting the correct triggering mode after having initialised the RTOS so as to override the default value. This is done by setting the correct bit value for IT0 and IT1 residing in the TCON SFR. •	 Loads the Ready Queue with the main idle task number, so that initially only the main task will execute. •	 Initialises all tasks as being not waiting for a timeout. •	 Sets up the Stack Pointer (SP) variable of each task to point to the correct location in the stack area of the particular task. The stack pointer, initially, is made to point to an offset of 14 bytes above the base of the stack [(MAIN_STACK – 1) + NOOFPUSHES + 2] since NOOFPUSHES in this case is 13. The first 13 locations would initially all contain a zero. This is done so as to ensure that when the first RET instruction is executed after transferring the stack from external RAM on to the internal RAM, the SP would be pointing correctly to the address of the task to be started. This is seen in the QSHFT routine, where before the last RET instruction, there is the Pop_Bank0_Reg macro which effectively pops 13 registers. The RET instruction would then read the correct address to jump to from the next 2 locations.

50
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.2	

OS_CREATE_TASK(Task No:, Task Name)

This system command is used in the main program for each task to be created. It takes two parameters, namely the task number (the first task is normally numbered as task 0), and the task address, which in the C environment, would simply be the name of the procedure or function. An example of the syntax used for this command is:
OS_CREATE_TASK(0, MotorOn);

This would create a task, numbered 0 which would refer to the MotorOn( ) procedure or function. This system command performs the following operations: •	 Places the task number in the next available location in Ready Queue, meaning that this task is ready to execute. The location pointer in Ready Queue is referred to as READYQTOP in the program, and is incremented every time this command is issued. •	 Loads the address of the start of the task at the bottom of the stack area in external ram allocated to this task. The SP for this task would have been already saved, by the INIT_RTOS command, pointing to an offset 13 bytes above this, so as to compensate for the pops. 2.3.3	 OS_RTOS_GO(Priority)

This system command is used only ONCE in the main program, when the RTOS would be required to start supervising the processes. It takes one Priority bit parameter. The Priority bit parameter (0 or 1) if set to 1, implies that those tasks placed in the Ready Queue (meaning those tasks which are ready to execute, just waiting for the currently running task to give up its place), would be sorted in descending order before the RTOS selects the next task to run. A task number of 0 is taken to mean by this RTOS as the highest priority task, and would obviously be given preference during the sorting. The main( ) task or function is automatically given the highest task number (thus meaning the lowest priority) by this RTOS, so as all the other tasks in the Ready Queue would be sorted above it. An example of the syntax used for this command is:
OS_RTOS_GO(1);

This would start the RTOS ticking with priority enabled. The tick time interval is determined by the parameter TICKTIME set in the parameters header file (say 1ms, 5ms or 10ms). This value would then become the basic reference unit for other system commands which use any timeout parameter.

51
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

The RTOS would also be required to execute ‘ready-tasks’ sorting prior to any task change, since the priority parameter was set to 1. Depending on which timer is being used to generate the ticktime, this system command performs the following operations: •	 Loads the variable DELAY (LO and HI bytes), with the number of BASIC_TICKS required to obtain the required ticktime delay. •	 Sets the PRIORITY bit according to the priority parameter supplied. •	 Loads the reload values of the tick timer in use with the calculated value in order to obtain the required delay between timer overflow interrupts. The value used depends on the crystal frequency used on the board. Stores the reference time signal parameter in GOPARAM and TICKCOUNT. •	 Starts the timer. •	 Enables interrupts. •	 Sets the timer overflow interrupt flag, thus causing the first interrupt immediately, and hence the timer counter registers are then loaded with the correct values in the timer ISR. If the system is using a different clock setting, the values would be adjusted accordingly by the RTOS.

If it really matters, make it happen – with a career at Siemens.

siemens.com/careers

52
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.4	

OS_RUNNING_TASK_ID( )

This system command is used by a task to get the number of the task itself. It returns an unsigned character (1 byte) value and the same task continues to run after executing this system command. An example of the syntax used for this command is:
X = OS_RUNNING_TASK_ID( ); 	 /* where X would be an unsigned character */

2.3.5	

OS_SCHEK( )

This system command is used by a task to test whether there was any signal sent to it by some other task. •	 It returns a bit value of: οο 0 if Signal is not present οο 1 if Signal is present •	 If the signal was present, the signal flag (bit) is also cleared before returning to the calling task. The same task continues to run, irrespective of the returned value. An example of the syntax used for this command is:
X = OS_SCHEK( ); 	 /* where X would be a bit-type variable */

or one may use it as in the following example to test the presence of the signal bit:
if (OS_SCHEK( ) == 1) { /* do these instructions if a signal was present */ }

2.3.6	

OS_SIGNAL_TASK(Task No:)

This system command is used by a task to send a signal to another task. If the other task was already waiting for a signal, then the other task is placed in the Ready Queue and its waiting for signal flag is cleared. The task issuing the OS_SIGNAL_TASK command continues to run, irrespective of whether the called task was waiting or not waiting for the signal. If we need to halt the task after the OS_SIGNAL_ TASK command to give way to other tasks, we must use the OS_DEFER( ) system command after the OS_SIGNAL_TASK command.

53
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

This system command performs the following operations: •	 It first checks whether the called task was already waiting for a signal. •	 If the called or signalled (the intended destination task of the signal) task was not waiting, it sets its waiting for signal (SIGW) flag and exits to continue the same task. •	 If the signalled task was already waiting, it places the called task in the Ready Queue and it clears both the waiting for signal (SIGW) and the signal present (SIGS) flags. •	 It also sets a flag (TINQFLAG) to indicate that a new task has been placed in the Ready Queue. This flag is used by the RTOS_TIMER_INT routine (every half a millisecond) in order to be able to decide whether there has to be a task change. It then exits the routine to continue the same task. An example of the syntax used for this command is:
OS_SIGNAL_TASK(1);		 // send a signal to task number 1 OS_DEFER( );			 // give CPU time to other tasks, if necessary

2.3.7	

OS_PERIODIC(Ticks) or OS_PERIODIC_A(min, sec , msec)

This command initialises the task so as to make it repeat periodically every certain number of ticks. This number is given as a parameter in the command. It is used at the beginning of a task, outside of the endless loop, as shown in the next sub-section 2.3.8. An example of its usage is also given in that same sub-section. The command OS_PERIODIC_A(min, sec, msec) is a macro which makes the command OS_ PERIODIC(ticks) more user-friendly. It is explained in section 2.3.14. We now deal with the commands that do perform a voluntary (co-operative) change of task: 2.3.8	 OS_WAITP( )

This command sets the task waiting for the preset periodic interval (set previously by the OS_ PERIODIC(ticks) command. The task goes into a waiting state and the next ready task takes over. If the interval has already passed when this command is executed, then the task would continue to execute. This is not normally the case, and only happens when there is a programming logic or algorithm mistake, since it would generally mean that the task is actually taking longer to execute than the requested periodic interval between executions.

54
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

It performs the following operations: •	 Saves task environment in preparation for the expected task swap. •	 If the periodic interval has not yet passed, as is generally the case, it sets the periodic interval flag to indicate that it is waiting for the periodic interval and issues a voluntary task change. •	 If however the periodic interval has already elapsed (this is usually due to bad programming, in cases where the code of the task itself takes a longer time to execute than the required periodic interval), then it clears the periodic interval flag and exits. Such a command is used in a task, in conjunction with the OS_PERIODIC( ) or OS_PERIODIC_A(min, sec, ms) command and an example of its usage is shown below in Figure 2-2:

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

55
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

OS_PERIODIC(50);				 // or OS_PERIODIC_A(0,0,300);;		 while(1)			 { ….				 ….			 ….			 OS_WAITP( );		 }
Figure 2-2 Part listing of a periodic task

// declare task as wishing to execute every 50 ticks

// declare task with a periodicity of 300ms

// repeat forever

// code to be executed every 50 ticks

// which should not take longer than // 50 ticks to execute. // wait for the periodic interval to pass

2.3.9	

OS_WAITI(Interrupt No:)

This system command is called by a task to sleep and wait for an interrupt to occur. Another task, next in line in the Ready Queue would then take over. If the interrupt never occurs, then the task will effectively sleep for ever. This is one way of writing Interrupt Service Routines under PaulOS RTOS control. ISRs can also be written in such a way as to run independently, as describe in section 2.3.15. If required, this command can be modified to allow another timeout parameter to be passed, so that if the interrupt does not arrive within the specified timeout, the task would still resume execution. A timeout of 0 would on the other hand still leave the task forever waiting for the interrupt. The modification required to the RTOS source listing would be similar to the OS_WAITS command, and the operation would then be as explained further down in sub-section 2.3.10. This system command performs the following operations: •	 It sets the bit which corresponds to the interrupt number passed on as a parameter. •	 It then calls the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is:
OS_WAITI(0);			 // wait for an interrupt from external int 0

The task would then go into the sleep or waiting mode and a new task would take over.

56
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.10	

OS_WAITS(Timeout) or OS_WAITS_A(min, sec, msec))

This system command is called by a task to sleep and wait for a signal to arrive from some other task. If the signal is already present (previously set or signalled by some other task), then the signal is simply cleared and the task continues on. If the signal does not arrive within the specified timeout period, the task resumes just the same. However, a timeout number of 0 would force the task to keep on waiting for a signal indefinitely. If the signal does not arrive, then the task never resumes to run and effectively the task is killed. This system command performs the following operations: •	 It first checks whether the signal is already present. •	 If the signal is present, then it clears the signal flag, exits and continues running. •	 If the signal is not present, then: οο It sets its own waiting for signal (SIGW) flag. οο It also sets the waiting for timeout variable according to the supplied parameter. οο It then jumps to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is:
OS_WAITS(50); // wait for a signal within 50 units or ticks, the value of the unit depends on // the TICKTIME parameter used. // or OS_WAITS_A(0,0,250); // wait for a signal within 250ms

If for example, the TICKTIME was set to 10 milliseconds in the header file, an OS_WAITS(50) would then imply waiting for a signal to arrive within 500 milliseconds. or you can use:
OS_WAITS(0); // this would wait for a signal for ever

In both examples, if the signal is not already present, the task would then go into the sleep or waiting mode and a new task would take over. The OS_WAITS_A(min, sec, msec) is a macro which makes the command OS_WAITS(ticks) more user friendly. It is explained in section 2.3.14.

57
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.11	

OS_WAITT(Timeout) or OS_WAITT_A(min, sec, msec))

This system command is called by a task to sleep and wait for a specified timeout period. In the case of OS_WAITT(timeout) the timeout period is in units whose value depends on the TICKTIME parameter used. Valid values for the timeout period are in the range of 1 to 65535. A value of 0 is reserved for the OS_KILL_IT command, meaning permanent sleep, and therefore it is not allowed for this command. The OS_WAITT system command therefore performs the required check on the parameter before accepting the value. If by mistake a value of 0 is given as a timeout parameter, then it is automatically changed to a 1. Once the timeout period passes, the task which had issued this command would be moved from the waiting to the ready queue. This system command performs the following operations: •	 If the parameter is 0, then set it to 1, to avoid permanent sleep. •	 Save the correct parameter in its correct place in the TTS table. •	 Jump to the QSHFT routine in order to start the task next in line.

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It’s not what we do. It’s how we do it.

Impact matters.
navigant.com

©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

58
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

An example of the syntax used for this command is:
OS_WAITT(60); // Wait for a timeout for 60 units, the value of the unit depends on // the TICKTIME parameter used. // or OS_WAITT_A(0,1,0); // Wait for 1 second

If for example, the command TICKTIME was set to 10, the reference unit would be 10 milliseconds, and OS_WAITT(60) would then imply waiting or sleeping for 600 milliseconds. The task would then go into the sleep or waiting mode for 600ms and a new task would take over. After 600ms it would move to the ready queue. The OS_WAITT_A(min, sec, msec) is a macro which makes the command OS_WAITT(ticks) more user-friendly by specifying the timeout in familiar minutes, seconds and milliseconds rather than in ticks. It is further explained in section 2.3.14. 2.3.12	 OS_KILL_IT( )

This system command is used by a task in order to stop or terminate the task. As explained earlier in OS_WAITT, this is simply the command OS_WAITT with an exceptionally allowed timeout value of 0. The task is then placed permanently waiting and never resumes execution. This system command performs the following operations: •	 First it clears any waiting for signal or waiting for interrupt flags, so that that task would definitely never restart. •	 Then it sets its timeout period in the TTS table to 0, which is the magic number the RTOS uses to define any non-timing task. •	 Then it sets the INTVLRLD and INTVLCNT to 0, again implying that it is not a periodic task. •	 Finally it jumps to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is:
OS_KILL_IT( ); /* The task simply stops to execute (waits forever) and a new task (or main( ) would take over.*/

59
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.13	

OS_DEFER( )

This system command is used by a task in order to hand over processor time to another task. The task is simply placed in the Waiting Queue to wait for two ticks while a new task (if ready) resumes execution. This system command performs the following operations: •	 It sets its timeout period in the TTS table to 2, which is the magic number the RTOS uses to describe any non-timing task. •	 It places the task in the Waiting Queue. •	 It then flows on to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is:
OS_DEFER( ); /* The task simply stops execution and is placed in the Waiting Queue.*/ /* A new task would then take over. */

2.3.14	

Enhanced event-waiting and other add-on MACROS

OS_WAITT, OS_WAITS and OS_PERIODIC functions are easily modified to make them accept absolute time, in minutes, seconds and milliseconds rather than ticks as a parameter. These macros (#define statements) perform the same functions of the OS_WAITT, OS_WAITS and OS_PERIODIC calls but rather than a tick parameter, they accept absolute time values as three parameters in terms of minutes, seconds and milliseconds, thus making the commands more user-friendly. This difference is denoted by the _A suffix (the A standing for Absolute) – e.g. OS_WAITT_A(0, 0, 300) would cause a task to wait for 300ms and is the absolute-time version of OS_WAITT(x), where x would have to be calculated depending on the TICKTIME value chosen to give the required number of ticks equivalent to a 300ms delay. These macro-commands make the conversion from absolute time to ticks. The range of possible values (65535 TICKTIMES) accepted is listed below, showing the maximum time in minutes:seconds.milliseconds: Using a minimum TICKTIME of 1ms: Range from 0:00.001 to 1:05.535 in steps of 1ms. Using a TICKTIME of 10ms: Range from 0:00.010 to 10:55.350 in steps of 10ms. Using a maximum TICKTIME of 50 ms: Range from 0:00.050 to 54:36.750 in steps of 50ms

60
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

If the conversion from absolute time to ticks results in 0 (all parameters being 0 or overflow) this result is only accepted by OS_WAITS(ticks) by virtue of how the OS_WAITT(ticks), OS_WAITS(ticks) and OS_PERIODIC(ticks) calls were written. In the case of the OS_WAITT(ticks) and OS_PERIODIC(ticks) calls, the tick count would automatically be changed to 1 meaning an interval of 1 ticktime. OS_WAITT_A(M,S,ms)		 OS_WAITS_A(M,S,ms)		 OS_PERIODIC_A(M,S,ms)	 OS_PAUSE_RTOS( )		 OS_RESUME_RTOS( )		 OS_CPU_IDLE( ) )		 				 				 OS_CPU_DOWN( )		 // Absolute OS_WAITT for minutes, seconds and milliseconds // Absolute OS_WAITS for minutes, seconds and milliseconds // Absolute OS_PERIODIC for minutes, seconds and milliseconds // Disable the RTOS. Can be used at the start of a stand-alone ISR // Re-enable the RTOS. Can be used at the end of a stand-alone ISR // Sets the µC in idle mode in PCON SFR. This is usually used // in the main program endless loop after initialising and starting the // RTOS. CPU wakes up at every interrupt, timers still running // Sets the µC in power-down mode in PCON SFR

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There’s no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives — and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It’s why we employ 135 different nationalities. It’s why we’ve taken proactive steps to increase female representation at the highest levels. And it’s just one of the reasons why you’ll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

61
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.3.15	

Stand-alone Interrupt Service Routines

In the PaulOS_F020 RTOS, a simple method of having one or more stand-alone interrupt service routines (ISRs) which would run whenever some interrupt is generated has been included. All we have to do is to set to ‘1’ the corresponding interrupt in the PaulOS_F020_Parameters.H file. For example if we intend to have an ISR running under the EXT 0 (i.e. INT0) interrupt (and not under RTOS control as a task with an OS_WAITI(0) command), then we have to make sure to set to ‘1’ the corresponding #define statements in PaulOS_F020_Parameters.H file.
#define STAND_ALONE_ISR_00 1 // EXT0 – set to 1 if using this interrupt as a stand alone ISR

Then as shown in Figure 2-3 the INT0 ISR itself also includes the commands OS_PAUSE_RTOS( ) when starting the ISR and then OS_RESUME_RTOS( ) at the end in order to resume the RTOS before exiting the ISR. This would ensure that the RTOS does not interfere with the stand-alone ISR. It is also best to use register banks 2 or 3 for these ISRs.
void ISR_EXT0 (void) interrupt 0 using 2 // using register bank 2 { OS_PAUSE_RTOS( )		 // Disable the RTOS, used in a stand-alone ISR

/* Our service routine code goes in here */ /* Our service routine code goes in here */ /* Our service routine code goes in here */ OS_RESUME_RTOS( )		 }
Figure 2-3 Example of a stand-alone ISR, interrupting the RTOS and executing immediately when the interrupt occurs

// Re-enable the RTOS, before exiting the stand-alone ISR

2.4	

PaulOS_F020_Parameters.h header file

This is the RTOS parameters header file. We would mainly just need to set the TICK_TIMER, TICKTIME and NOOFTAKS parameters to reflect out particular application program. If we intend to use some stand-alone ISR, then that particular interrupt has to be selected (set to ‘1’) in this header file as explained earlier on in section 2.3.15. Note that the C8051F020.h used in these programs is a modified version of the standard C8051F02x header file. A complete listing is given in (A.5 C8051F020.H) which includes extra sfr16 declarations4 and name definitions of individual bits of all the SFRs, even those that are not bit addressable. With these extra definitions, these ‘non-addressable’ bits can be set or cleared using bit-wise OR and bit-wise AND. Using the standard header file, certain instructions would not work since the named bit or SFR would not have been pre-defined.

62
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

#ifndef _PaulOS_F020_Parameters_H_ #define _PaulOS_F020_Parameters_H_ /* ********************************************************************************************* * RTOS KERNEL HEADER FILE * * PaulOS_F020_Parameters.H * * For use with PaulOS_F020.C - Co-Operative RTOS written in C * based on PaulOS by Ing. Paul P. Debono * for use with the 8051 family of micro-controllers * * File : PaulOS_F020_Parameters.H * Revision : 10 * Date : Revised for C8051F020 February 2015 * By : Paul P. Debono * * University Of Malta * ********************************************************************************************* */

/* ********************************************************************************************* * DATA TYPE DEFINITIONS ********************************************************************************************* */ #define TICK_TIMER 2 // Set to 0,1,2 or 3, make sure not to clash with UART baud rate timer #define TICKTIME 1 // Length of RTOS basic tick in ms - refer to the RTOS timing definitions // suitable values are: 1, 2, 4, 5, 8, 10, 20, 25 #define NOOFTASKS 65 // Number of tasks used in application

#define STACKSIZE 0x0F // Number of bytes to allocate for the stack // There is usually no need to change this parameter /* ********************************************************************************************* */ /* Interrupt routines running as TASKS or as STAND-ALONE ISRa */ #define STAND_ALONE_ISR_00 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_01 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_02 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_03 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_04 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_05 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_06 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_07 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_08 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_09 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_10 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_11 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_12 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_13 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_14 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_15 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_16 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_17 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_18 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_19 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_20 0 // set to 1 if using this interrupt as a stand alone ISR #define STAND_ALONE_ISR_21 0 // set to 1 if using this interrupt as a stand alone ISR /* ********************************************************************************************* */ #endif

63
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

2.5	

Example using PaulOS_F020 RTOS

Finally, we now present an example to show the use of the RTOS in a simple program. This example using the PaulOS_F020 RTOS is partly taken from the Blinky example included with the KEIL IDE. It is implemented here with the modifications required in order to use the PaulOS_F020 RTOS. One task blinks the LED and a second task which keeps displaying the time every second via UART0.

//-----------------------------------------------------------------------------------// Blinky.c //-----------------------------------------------------------------------------------// // AUTH: PD // DATE: 21 FEB 15 // // This program flashes the green LED on the C8051F020 target board // and send Clock time via UART0 // Target: C8051F02x // // //-----------------------------------------------------------------------------------// Includes //-----------------------------------------------------------------------------------#include "C8051F020.h" /* special function registers for C8051F020 */ #include "DualUarts.h" /* Uarts header file */ #include "PaulOS_F020.h" /* PaulOS system calls definitions */ #include <stdio.h> #include <stdlib.h> //-----------------------------------------------------------------------------------// Global CONSTANTS //-----------------------------------------------------------------------------------bit sio_port = 0; sbit LED = P1^6; /* /* /* /* 0, 0 }; /* SIO port to use (0 = UART0, 1 = UART1) */ // green LED: '1' = ON; '0' = OFF structure of the time record hour minute second */ */ */ */ */

struct time { unsigned char hour; unsigned char min; unsigned char sec; }; struct time ctime = { 12,

/* storage for clock time values

//-----------------------------------------------------------------------------------// Function PROTOTYPES //-----------------------------------------------------------------------------------void SYSCLK_Init (void); void PORT_Init (void); void DISABLE_Watchdog (void); //----------------------------------------------------------------------------// SYSCLK_Init //----------------------------------------------------------------------------// // This routine initializes the system clock to use the 22.1184MHz crystal // as its clock source. // void SYSCLK_Init (void) {

64
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

unsigned int i; OSCXCN = 0x67; for (i=0; i < 256; i++) ; #ifndef SIMULATOR while (!(OSCXCN & 0x80)) ; #endif OSCICN = 0x88; }

// delay counter // start external oscillator with // 22.1184MHz crystal // wait for oscillator to start // // // // // Wait for crystal osc. to settle not required during simulation select external oscillator as SYSCLK source and enable missing clock detector

//-----------------------------------------------------------------------------------// DISABLE_Watchdog //-----------------------------------------------------------------------------------// // Disables the watchdog timer // void DISABLE_Watchdog (void) { EA = 0; WDTCN = 0xDE; WDTCN = 0xAD; EA = 1; }

//-----------------------------------------------------------------------------------// PORT_Init //-----------------------------------------------------------------------------------// // Configure the Crossbar and GPIO ports // void PORT_Init (void) { XBR0 = 0x04; // Enable UART 0 XBR1 = 0x00; XBR2 = 0x40; // Enable crossbar and weak pull-ups P0MDOUT |= 0x01; // enable TX0 as a push-pull output P1MDOUT |= 0x40; // enable P1.6 (LED) as push-pull output } /* ************************************************************************************ */

/****************************************************************************/ /* Task 0 'Blink' */ /****************************************************************************/ void BlinkTask (void) { OS_PERIODIC_A(0,0,500); /* Repeat every 500 ms */ while(1) { LED = !LED; OS_WAITP(); } } /****************************************************************************/ /* Task 1 'clock' */ /****************************************************************************/

65
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

PaulOS F020: a co-operative RTOS

void clock (void) { OS_PERIODIC_A(0,1,0); while (1) { if (++ctime.sec == 60) { ctime.sec = 0; if (++ctime.min == 60) { ctime.min = 0; if (++ctime.hour == 24) ctime.hour = 0; } } }

/* Repeat every 1 second */ /* clock is an endless loop /* calculate the second /* calculate the minute { /* calculate the hour */ */ */ */

}

}

printf ("Clock Time: %02bu:%02bu:%02bu\r", /* display time ctime.hour, ctime.min, ctime.sec); OS_WAITP(); /* wait for 1 second */

*/

//-----------------------------------------------------------------------------------// MAIN Routine //-----------------------------------------------------------------------------------void main (void) { DISABLE_Watchdog (); SYSCLK_Init (); SetUpUART(0, 115200, 1); /* Set up UART 0, at 115200 baud using Timer 1 */ PORT_Init (); OS_INIT_RTOS(0); /* initialise RTOS, variables and stack /* CREATE task */ */ */

OS_CREATE_TASK(0,BlinkTask); OS_CREATE_TASK(1,clock); OS_RTOS_GO(0); while (1) {

/* Start multitasking, no priorities

} }

#ifndef SIMULATOR OS_CPU_IDLE(); /* Go to idle mode if doing nothing, to conserve energy */ #else ; #endif

The LED blinking is handled by Task 0 or the ‘BlinkTask’ routine. Note that ant task has to be written as an endless routine. In this case, the task is declared as a periodic task with the OS_PERIODIC_A() command which is outside the endless loop and is thus executed only one at the beginning. In the ‘while(1)’ endless loop the LED is simply toggled on/off and then the task placed in the waiting queue waiting for the periodic interval to pass by issuing the OS_WAITP() RTOS command. The second task is the ‘clock’ task which also runs periodically every one second. The endless loop handles the updating of the seconds, minutes and hours and sends the ‘Clock Time:’ string via UART0. The actual UART0 setup is not listed here but can be found in appendix B.2 UART0 and UART1. The ‘main’ routine disables the watchdog timer, initialises the system clock, the UART0 and the RTOS. It then creates the task and then starts the multi-tasking by starting the RTOS. The main program then simply loops in the idle state.
66
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

3	 Master – Slave RTOS
3.1	 Multi-controller RTOSs
A number of micro-controllers can be networked together, each of them running its own RTOS but at the same time they would all be synchronised together. One controller would be acting as the master and all the others would be the slaves. The transmit pin from the master would be connected to all the receive pins of the slaves, while the transmit pins from the slaves would be connected to the master receive pin (normally via a diode). The drawing shown in Figure 3-2 represents the case where we have two slaves connected to the master. The number of slaves can be increased as required.

Figure 3-1 Networked micro-controllers using the UARTs to synchronise their RTOSs

Serial transmission between the master and the slave micro-controllers is used to synchronise the separate RTOSs running on the slaves with the RTOS running on a master board. The UART has a special mode dedicated for such board networking. Modes 2 (the baud rate is determined by the oscillator frequency) and 3 (the baud rate is determined by the timer overflows) of the UART provide asynchronous, fullduplex multiprocessor communications using 11 bits which are made up of 1 start bit, 8 data bits, 1 programmable additional 9th bit and a stop bit. Mode 3 is used more frequently since the baud rate can be easily programmed to one of the standard baud rates by loading the timer with the correct register reload value. For this explanation we shall use UART0 (UART1 does not support mode 2).

67
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

The 9th bit can be set to ‘1’ or ‘0’ by programming bit TB8 in register SCON0. Moreover, another bit in SCON0, called SM20, when set enables multiprocessor communications in modes 2 or 3. The slave boards would normally be programmed in mode 3 with UART0 interrupt enabled. When SM20 is set to ‘1’, the receiver interrupt flag RI0 will only be set if the received 9th bit was a ‘1’. This particular behaviour is what makes this mode ideal for multiprocessor communications and in particular in our case for synchronising the RTOSs. Usually a 9th bit of 1 indicates an address byte and a 0 would indicate a data byte. The network protocol is best explained in the following points: •	 The master and the slaves would all be programmed in mode 3 at the same baud rate. •	 All the slaves would initially be set up so as to have their SM20 set to 1 so as to be in the socalled address listening mode and with their serial UART0 interrupt enabled. With this set up, all the slaves would have their RI0 set (meaning a serial interrupt request) only if and when they receive a character with the 9th bit set to 1. •	 The master UART0 SM20 bit would be cleared to 0 and it would not be running under serial interrupt. •	 Each slave would have a different address, stored in some variable. •	 The master directs the activities of the slaves and therefore initiates the transmission. •	 The master would set its 9th bit to 1 and starts the networking protocol by sending an address, normally of the first slave in the loop.

Real drive. Unreal destination.

As an intern, you’re eager to put what you’ve learned to the test. At Ernst & Young, you’ll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You’ll also get to test what you learn. Even better, you’ll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

© 2012 Ernst & Young LLP. All Rights Reserved.

68
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

•	 All the slaves would receive this address and all would be requesting a serial interrupt. Their own serial ISR would then check and compare the received address byte with their own stored address. •	 Only the slave whose address agrees with the received address would then clear its own SM20 bit to 0. From now on, its RI0 would still be set even if the received 9th bit is 0. If the serial interrupt is still left enabled, then only this particular slave would be ‘serially interrupted’ with any received bytes from now on, even though the received 9th bit of the data bytes would 0. The other slaves would still be expecting and address with a 9th bit set to 1. •	 In most protocols, the addressed slave would normally then send an acknowledgement byte to the master as an 11-bit character with a 9th bit set to 0. •	 The master can then send any required data bytes to this slave, always with the 9th bit cleared (=0) so that the other non-addressed slaves would not be getting any serial interrupt requests. •	 A special pre-arranged end-of-message character, such as a ‘$’ or ‘£’ would be sent by the master at the end of the data transmissions, or else a previously agreed number of data bytes would be sent. •	 Once the addressed slave receives the end-of-message character or the agreed number of data bytes, it would then set its SM2 back to 1 ready for the next address byte sent by the master. •	 The master can then restart the sequence by sending the next slave address (again with the 9th bit set to 1). For our particular case of RTOS synchronisation, some slight modification of the above protocol is made. The master RTOS would be running under its own timer generated ticks. Its own RTOS timer interrupt routine would have some additional code so as to send and receive bytes (or messages) to/from the slaves over a serial link. The slaves on the other hand would have their tick interrupt routine tied to the serial interrupt. As shown in the messaging sequence in Figure 3-2, this is a slightly different adaptation of the method described by (Pont, 2002, chapter 27) in the excellent book on time-triggered applications. At every master tick, the master would send an address of a slave (the slave address number changing at every tick). All the slaves would receive this address and their own UART setup would generate an interrupt which would be used as their RTOS tick generator routine. Hence all the slaves would have their own RTOSs synchronised with each other but they would be running one byte late relative to the master since the serial interrupt occurs after a byte is received, whereas the master’s tick is generated before it transmits the address.

69
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

In the RTOS synchronisation protocol which could be changed as required according to the application, we also opt to disable serial interrupts in the addressed slave at this point. This is because the serial interrupts are being interpreted as the tick synchronisation pulse and only messages which could interrupt all the slaves would be treated as such. The same slave would clear its SM20 bit and then send an acknowledgement to the master (always as an 11-bit character with the 9th bit set to 0) and the slave would then stay waiting for further data transmissions from the master. The master, after receiving this acknowledgement from the addressed slave would then send a data byte or more to this same slave as required by the application (bit 9 still 0). After the agreed number of data bytes are sent, the addressed slave would revert back to the address listening mode by setting its SM20 bit back to 1. The periodic interval between the ticks must be long enough to enable all serial transmissions of the 3 bytes to take place and leave additional free time for the slave (and master) to do some other work connected with other tasks in the application in-between ticks. All these serial transmissions would be made using the 11-bit byte master-slave operation mode of the UART as described above and in (Debono, 2013a, p. 107). More detailed explanations of this protocol are given in the following sections of this chapter.

Figure 3-2 Serial communication between Master and two Slaves to synchronise the RTOSs

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

70
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

3.2	Master
The UART0 initialisation routine for the Master board is listed in Figure 3-3
/********************************************************************************/ /* Initialise the F020 8051 UART for multi-processor comms operations */ /* For the MASTER, it will not run under interrupt control */ void mp_UART_Master_init (unsigned long baudrate) { ES0 = 0; /* Disable Serial Interrupt */

/* For baud rates 1200 to 460800 use Timer 1 as the baud rate generator */ /* We use the 22.1184 MHz Crystal */ /* /* /* /* Setup serial port control Mode 3: 9-bit UART, using SM00=1, SM10=1, SM20 = 0, 1 1 0 1 1 0 1 0 = DA hex register SCON0 = 0xDA, not under interrupt control */ timer 1 */ REN0 = 1, TB80 = 1, RB80 = 0, TI0 = 1, RI0 = 0 */ */

// A very fast baud rate might create problems when receiving data from the slaves, // if we are using the diodes at the TxD pins of the slaves. // Depends on diode quality. Length of cable also becomes critical. /* For the MASTER program, TB80 will be set to 1 when sending an address, and set to 0 when sending data. */ SCON0 = 0xDA; // SCON0: mode 1, 9-bit UART, see above TMOD &= 0x0F; TMOD |= 0x20; // TMOD: timer 1, mode 2, 8-bit reload TH1 = -(SYSTEMCLK/baudrate/16UL); // set Timer1 reload value for baud rate TL1 = TH1; TR1 = 1; // start Timer1 CKCON |= 0x10; // Timer1 uses SYSCLK as time base PCON |= 0x80; // SMOD00 = 1 #message "Using Timer 1 for F020 UART0 baud rate generator as the RTOS slave tick" #message "UART0 running in 9-bit multi-processor comms mode,” #message “baud parameter in PaulOS_F020_Master_Parameters.h" } /********************************************************************************/

Figure 3-3 Listing of the UART0 9-bit mode initialisation routine for the Master

The baud rate for the multi-processor communication serial port is usually set at a high baud rate so as not to waste much time in the transmission or reception of the address and data bytes. The Master UART0 would not be running under serial interrupt control and transmission is immediately started whenever an address or data is loaded into SBUF0.

71
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

The add-ons required in the Master RTOS tick-timer interrupt routine (executed for Timers 0, 1, 2 or 3 overflows depending on the TICK_TIMER selected) in order to handle this protocol are listed in Figure 3-4. These add-ons perform the sending of the Address (with bit 8 [meaning the 9th bit] set to 1) which causes a serial interrupt in ALL the slaves, thus triggering the RTOS interrupt routine in the slaves. This is the RTOS synchronising signal which would be received simultaneously by all the slaves. The master then waits for the acknowledgement from the addressed slave within a set timeout, marking it as dead if no acknowledgement is received. On receiving this acknowledgement, the master sends a byte of data (with bit 8 [meaning the 9th bit] set to 0) to the addressed slave which can contain any information as required by the application. This data byte will not cause any interrupt in any slave, because of the fact that the 9th bit is set to zero whenever sending data. The sequence would then be repeated for the next slave and so on until it will loop back to the initial slave number to repeat the ‘polling’ ad infinitum.
/* ******************************************************************************** * * Function name : RTOS_Timer_Int * * Function type : Scheduler Interrupt Service Routine * * Description : This is the RTOS scheduler ISR. It generates system ticks and calculates any remaining * waiting and periodic interval time for each task. * * Arguments : None * * Returns : None * ******************************************************************************** */ #if (TICK_TIMER == 0) /* If Timer 0 is used for the scheduler */ void RTOS_Timer_Int (void) interrupt 1 using 1 { uchar data k,s; /* Timer 0 is used, s is the slave address variable*/ ulong data t; /* used for acknowledge timeout period */ uchar data * idata q; /* for scheduling. */ bit data On_Q; TH0 = BASIC_TICK / 256; /* Timer registers reloaded */

72
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

TL0 = BASIC_TICK % 256; #elif (TICK_TIMER == 1) /* If Timer 1 is used for the scheduler */ void RTOS_Timer_Int (void) interrupt 3 using 1 { uchar data k,s; /* Timer 1 is used ulong data t; /* used for acknowledge timeout period */ uchar data * idata q; /* for scheduling. bit data On_Q; TH1 = BASIC_TICK / 256; TL1 = BASIC_TICK % 256; /* Timer registers reloaded */

*/ */

#elif (TICK_TIMER == 2) /* If Timer 2 is used for the scheduler */ void RTOS_Timer_Int (void) interrupt 5 using 1 { uchar data k,s; /* Timer 2 is used */ ulong data t; /* used for acknowledge timeout period */ uchar data * idata q; /* for scheduling. bit data On_Q; TF2 = 0;

*/

/* Timer 2 interrupt flag is cleared */

#elif (TICK_TIMER == 3) /* If Timer 3 is used for the scheduler */ void RTOS_Timer_Int (void) interrupt 14 using 1 { uchar data k,s; /* Timer 3 is used */ ulong data t; /* used for acknowledge timeout period */ uchar data * idata q; /* for scheduling. bit data On_Q; TMR3CN &= ~TF3; #endif // start of Master/Slave add-ons

*/

/* Timer 3 interrupt flag is cleared */

// Master sends address (0 to NOOFSLAVES which is stored in parameters_master.h, // incremented each time) // Master receives ACK from the addressed slave // Master sends a byte of data to this slave /*******************************************************************************/ // Add-on to send address to slaves - reply expected within timeout, for this version // s range is from 0 to (NOOFSLAVES - 1) // TB80 initially set to one, when UART0 was initialised while(!TI0){} // wait for any previous transmission to finish just in case. // TI0 = 1, means ready to load new character in SBUF0 for Tx TB80 = 1; // set bit 8 (9th bit), for address transmission TI0 = 0; // clear TI0 since we are going to transmit SBUF0 = s; // send slave address // TB80 will be set to one, once the transmission is ready while(!TI0){} // wait for transmission to finish. /*******************************************************************************/ /*******************************************************************************/ // Add-on to receive acknowledgement from addressed slave // If no acknowledgement is received within timeout period, then mark it with an * as dead t = 1000UL; while((!RI0) && (t != 0)){t--;} // wait a while for acknowledgement within // timeout period if(RI0 == 1) // RI0 = 1, means received character in SBUF0 { RI0 = 0; // clear RI0 ack[s] = SBUF0; // read acknowledgement from slave, stored in array } // sorted and used also in application program else if(t==0) // no acknowledgement received within timeout period

73
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

ack[s] = '*';

// hence mark it as dead

/*******************************************************************************/ /*******************************************************************************/ // Add-on to send data to addressed slave TB80 = 0; // set bit 8 (9th bit), for data transmission // thus no interrupt will be generated on slaves, with their SM2 set to 1 TI0 = 0; // clear TI0 since we are going to transmit SBUF0 = NetworkData[s]; // send slave some data, stored in the application program // TB80 will be set to one, once the transmission is ready s = (++s)%NOOFSLAVES; // prepare address for next slave /*******************************************************************************/ // end of Master/Slave add-ons

Figure 3-4 Part of the Master RTOS Tick Interrupt routine, showing the add-ons required for multi-board operations

A value of ack[s] equal to ‘*’ would then be recognised by some task in the Master program to mean that the particular slave is not responding and can be acted upon accordingly.

3.3	Slave
The UART0 initialisation routine for the Slaves board is listed in Figure 3-5 which is very similar to the Master setup routine. However the Serial UART0 would in this case be running under serial interrupt control and an interrupt would be called whenever an address (with its 9th bit set to 1) is received into SBUF0.

I joined MITAS because I wanted real responsibili� I joined MITAS because I wanted real responsibili�

Maersk.com/Mitas www.discovermitas.com

�e Graduate Programme for Engineers and Geoscientists

�e G for Engine

Ma

Real work International Internationa al opportunities �ree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities �ree wo work or placements s solve pr
Click on the ad to read more

74
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

/* Initialise the F020 8051 UART for multi-processor comms operations */ /* Uses timer 1 as the baud rate generator – under interrupt control for the SLAVE */ void mp_UART_Slave_init (unsigned long baudrate) // Set up internal UART under interrupt control { /* For baud rates 1200 to 460800 use Timer 1 as the baud rate generator */ /* We use the 22.1184 MHz Crystal */ /* /* /* /* /* Using Timer 1 for standard baud rate generation */ Setup serial port control register SCON = 0xF0 */ Mode 3: 9-bit UART var. baud rate */ SM00=1, SM10=1, SM20=1, REN0 = 1, TB80 = RB80 = TI0 = RI0 = 0 */ 1 1 1 1 0 0 0 0 = F0 hex, under interrupt control */

// A faster baud rate might create problems when receiving data from the slaves, // since we are using the diodes at the TxD pins of the slaves. // Depends on diode quality. Length of cable becomes critical. /* For the SLAVE program, SM2 will be set to 1 when expecting an address, and set to 0 when expecting data. */ SCON0 = 0xF0; // TMOD &= 0x0F; TMOD |= 0x20; // TH1 = -(SYSTEMCLK/baud rate/16UL); TL1 = TH1; TR1 = 1; // CKCON |= 0x10; // PCON |= 0x80; // ES0 = 1; SCON0: mode 1, 9-bit UART, see above TMOD: timer 1, mode 2, 8-bit reload // set Timer1 reload value for baud rate start Timer1 Timer1 uses SYSCLK as time base SMOD00 = 1

/* Enable Serial Interrupts */

#message "Using Timer 1 for F020 UART0 baud rate generator” #message “UART0 serial interrupt is used as the slave tick generator" } /******************************************************************************/

Figure 3-5 Listing of the UART0 initlisation routine for the Slaves. Note that the serial interrupt enable bit is set.

This serial interrupt would be acting as the main Tick interrupt for the slaves, and thus all the slaves would be initiating their RTOS_Interrupt routine at the same time, whenever any address is received. This routine, part of which is listed in Figure 3-6 would first check whether the address received corresponds to this particular slave. If the address is different, then the ISR would move on to the normal RTOS house-keeping chores. If however, the address is its own, then an acknowledgement is sent to the Master and data is then received from the Master. As it is written, if the connection is lost and no data is received, the program hangs up, waiting for this never-coming data!

75
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

// Add-on for ticks arriving via UART0 from Master #elif (TICK_TIMER == 999) /* If Serial Receiver Interrupt is used for the scheduler */ void RTOS_Timer_Int { uchar data uchar data bit data (void) interrupt 4 using 1 k; * idata q; On_Q;

if ( (RI0 == 1) && (RB80 == 1)) // react to reception of an address { RI0 = 0; // reset the receiver interrupt flag RxAddress = SBUF0; // read received address if (RxAddress == MyAddress) // If master is polling this slave { SM20 = ES0 = 0; // disable serial interrupt and set SM20 to 0 // so that although RI0 would still be set when data from Master is received // no interrupt will be generated in any other slave TI0 = 0; // Set transmitter busy SBUF0 = MyAck; // send acknowledgement to Master, value declared in user program while(!TI0){} // wait for transmission to finish // now receive incoming data from Master while(!RI0){} // wait for incoming data from Master // RI0 = 1, means received data character in SBUF0 // Clear all serial interrupts flags // Read Data, used in application program

}

RI0 = TI0 = 0; MyData = SBUF0; SM20 = ES0 = 1; // Prepare for next address tick, enabling serial interrupts once again

#endif
Figure 3-6 Part of the RTOS_Timer_Int routine for the Slaves, running under Serial interrupt. This code could hang up if no data is received.

A timeout check can be added if required to eliminate this hang-up possibility, as adopted in the Master source code and shown in Figure 3-7 Part listing of the RTOS_Timer_Int slave routine showing the timeout modification during data reception Figure 3-7.
// now receive incoming data from Master // If no data is received within timeout period, then mark it with an ~ as ‘data not valid’ t = 1000UL; while((!RI0) && (t != 0)){t--;} // wait a while for data arrival within // timeout period if(RI0 == 1) // RI0 = 1, means received character in SBUF0 { RI0 = TI0 = 0; // clear RI0 MyData = SBUF0; // Read Data, used in application program SM20 = ES0 = 1; // Prepare for next address tick, enabling serial interrupts once again } else if(t==0) // nothing received within timeout period MyData = '~'; // hence mark it as invalid data

Figure 3-7 Part listing of the RTOS_Timer_Int slave routine showing the timeout modification during data reception

A value of MyData equal to ‘~’ would then be recognised by some other task to mean that the data received is invalid and can be acted upon accordingly.

76
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Master – Slave RTOS

Finally, in the RTOS Macros section of the slave header file PaulOS_F020_Slave.H, the following should be added:
#elif (TICK_TIMER == 999) #define OS_PAUSE_RTOS() #define OS_RESUME_RTOS()

ES0 = 0x00 ES0 = 0x01

Figure 3-8 OS_PAUSE_RTOS( ) and OS_RESUME_RTOS( ) modification for the slave RTOS since it uses the serial interrupt as the tick generator.

so that the ‘pause’ and ‘resume’ OS commands will disable and enable the UART0 interrupt. Use of the OS_PAUSE_RTOS( ) command will naturally cause some temporary loss of synchronisation with the other slaves since the serial ISR would be delayed.

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

77
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

4	 Programming Tips and Pitfalls
In this final chapter we discuss some programming tips and common pitfalls which should be avoided when programming such micro-controllers.

4.1	

RAM size

The C8051F020 development target board has 64KB of flash memory (On-chip ROM) for code and constants and a 4K of RAM (On-chip XRAM). Thus the KEIL IDE should be setup as shown in Figure 4-1 to make use of this on board memory.


Figure 4-1 Screen shot of the Target Options setup

4.2	SFRs
SFRs are used to control the way the 8051 peripherals functions. Not all the addresses above 80h are assigned to SFRs. However, this area may not be used as additional RAM memory even if a given address has not been assigned to an SFR. Free locations are reserved for future versions of the micro-controller and if we use that area, then our program would not be compatible with future versions of the microcontroller, since those same locations might be used for special additional SFRs in the upgraded version. Moreover, certain unused locations may actually be non-existent, in the sense that the actual cells for that memory would not form part of the memory mask when being manufactured, and hence even if we do write the code to use these locations, no actual data would be stored!

78
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

It is therefore recommended that we do not read from or write to any SFR addresses that have not been actually assigned to an SFR. Doing so may provoke undefined behaviour and may cause our program to be incompatible with other 8051 derivatives that use those free addresses to store the additional SFRs for some new timer or peripheral included in the new derivative. If we write a program that utilizes the new SFRs that are specific to a given derivative chip (and which therefore were not included in the standard basic 8051 SFR list), our program will not run properly on a standard 8051 where those SFRs simply did not exist. Thus, it is best to use non-standard SFRs only if we are sure that our program will only have to run on that specific micro-controller. If we happen to write code that uses non-standard SFRs and subsequently share it with a third-party, we must make sure to let that party know that our code is using non-standard SFRs and can only be used with that particular device. Good remarks, notes and warnings within the program source listing would help.

4.3	

Setup faults

The setup during the initialisation is very critical and basically we would need to initialise the system clock, watchdog timer, crossbar registers, any input/output ports and whether we need to use them for digital or for analogue signals. And then of course, any timers, serial ports, ADC, DAC, SPIs etc would need to be initialised if they are going to be required in our application program. We now list some common faults which are easily made during this setup process. 4.3.1	 System Clock Setup

The System clock should be setup and initialised at the start of your program. Forgetting to set it up is a common fault and also checking for the clock stabilisation during a simulation run can cause problems in cases where the simulation of the clock is not well implemented as mention in section 1.8.1. 4.3.2	 Watchdog Timer Setup

Forgetting to disable the watchdog timer or disabling it late is a common fault with beginners to this device. The effect would be for the micro-controller to keep on resetting itself while executing the few initial commands in the main program. 4.3.3	 Crossbar Setup

Another very common fault with newcomers to this device is setting the wrong configuration of the crossbar SFRs: XBR0, XBR1 and XBR2. Consulting the manual and reviewing the examples would help a lot to enable the user to become familiar with the initialisations required, and at which pins to expect the input or output signal to be available. (See Table 1-4, Figure 1-10, Figure 1-11 and Figure 1-12)

79
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

4.4	

Serial ports (UART0 and UART1)

To use the ‘printf ’ command, the on-board serial port or UART0 must be correctly setup at the required baud rate. It is generally necessary to initialise at least the following four SFRs: SCON0, PCON, SCON0, and TMOD. This is because SCON0 on its own does not fully control the serial port. However, in most cases the program will need to use one of the timers to establish the serial port baud rate. In this case, it would be necessary to configure Timer 1 by setting TH1, TL1 and TMOD. Another bit PCON.7 (known also as SMOD00 bit, but we should note that PCON is not a bit-addressable register), can be set to double the baud rate. In this case therefore, we would also need to program bit 7 of register PCON. This is shown in the example of Figure 4-2.
//----------------------------------------------------------------------------// UART0_Init //----------------------------------------------------------------------------// // Configure the UART0 using Timer1, for <baud rate> and 8-N-1. // void UART0_Init (void) { SCON0 = 0x50; // SCON0: mode 1, 8-bit UART, enable RX TMOD &= 0x0F; // clear Timer 1 control bits only TMOD |= 0x20; // TMOD: set Timer 1: mode 2, 8-bit reload TH1 = -(SYSCLK/BAUDRATE/16); // set Timer1 reload value for required baud rate TR1 = 1; // start Timer1 CKCON |= 0x10; // Timer1 uses SYSCLK as time base PCON |= 0x80; // SMOD00 = 1 TI0 = 1; // Indicate TX0 ready to transmit }

Figure 4-2 UART0: Serial initialisation routine, not under interrupt control

80
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

A common mistake is to forget to set TI0 to ‘1’. This indicates that the transmitter is ready to transmit. Failing to do so, the serial transmission would never start since the UART would think that it is still busy with some previous transmission. The TI0 bit would then be cleared in the putchar( ) routine. Moreover, if the serial handling routine is to run under interrupt control, then the appropriate interrupt enable bits (ES and EA in the IE SFR) and sometimes even the interrupt priority bit (PS in the IP SFR) have also to be set. This would bring to six the number of SFRs which we may need to set in order to use the UART in interrupt mode. Taking UART0 as an example, this time the TI0 flag is initialized to 0 if using serial interrupt routines to transmit characters stored in some software buffer. Once SBUF0 is loaded directly with the first character to be transmitted, the transmission would start, with the start bit, followed by eight bits 0 to 7 of the data, any parity bit (usually none), followed by the stop bit. TI0 would then be set to 1 automatically when this first character transmission is done and the ISR routine is then triggered which would continue to send any remaining characters in the software buffer (TI0 would need to be reset to 0 every time in the ISR code). If however we are not using serial interrupt routines to transmit data, TI0 would be intialised to 1 in the first place, since it is usual practice to start the ‘putchar( )’ routine with: while (TI0==0);	 SBUF0 = c;		 			 // wait for the transmitter to be ready (TI0=1) // store character in SBUF0 and start transmitting character // TI0 would be automatically set to 1 once transmission is done

A more thorough example is given in the serial routines in Appendix B.2 UART0 and UART1. The example in the appendix gives the option to setup any one of the two available UARTs.

4.5	Interrupts
Some common problems encountered with interrupts when using assembly language are addressed here: Forgetting to protect the PSW register: If we write an interrupt handler routine in assembly language, it is a very good idea to always save the PSW SFR on the stack and restore it when our interrupt service routine (ISR) is complete. Many 8051 instructions modify the bits within PSW. If our ISR does not guarantee that PSW contains the same data upon exit as it had upon entry, then our program is bound to behave rather erratically and unpredictably. Moreover it will be tricky to debug since the behaviour will tend to vary depending on when and where in the execution of the program, the interrupt happened.

81
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

Forgetting to protect a Register: We must protect all our registers as explained above. If we forget to protect a register that we will use in the ISR and which might have been used in some other part of our program, very strange results may occur. If we are having problems with registers changing their value unexpectedly or having some arithmetic operations producing wrong answers, it is very likely that we have forgotten to protect some registers. Forgetting to restore protected values: Another common error is to push registers onto the stack to protect them, and then we forget to pop them off the stack (or we pop them in the wrong order) before exiting the interrupt. For example, we may push ACC, B, and PSW onto the stack in order to protect them and subsequently pop only PSW and ACC off the stack before exiting. In this case, since the value of register B was not restored (popped), an extra value remains on the stack. When the RETI instruction is then executed at the end of the ISR, the 8051 will use that value as part of the return address instead of the correct value. In this case, the program will almost certainly crash. We must always ensure that the same number of registers are popped off the stack and in the right order: PUSH PSW PUSH ACC PUSH B … … … POP B POP ACC POP PSW RETI Using the wrong register bank: Another common error occurs when calling another function or routine from within an ISR. Very often the called routine would have been written with a particular register bank in mind, and if the ISR is using another bank, there might be problems when referring to the registers in the called routine. If we are writing our own routine, then in the ISR we could save the PSW register, change the register bank and then restore the PSW register before exiting from the called routine. However, particularly if we are using the C compiler, we might be using functions and procedures prewritten in the compiler and which we do not have any control on, and therefore can result in program not functioning as intended.

82
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

This problem is particularly serious when using pre-emptive RTOSs, such as SanctOS or MagnOS described in (Debono, 2013a), where a forced change of task might occur, switching from task A (which was using for example using register bank 1) on to task B which uses say bank 2. For the case of cooperative RTOSs (such as PaulOS), we would be in control where the task changes occur and we would be able to take the necessary precautions. Using RET instead of RETI: Remember that ISRs in assembly language are always terminated with the RETI instruction. It is easy to inadvertently use the RET instruction instead. However the RET instruction will not end our interrupt smoothly. Usually, using RET instead of RETI will cause the illusion of the main program running normally, but the interrupt will only be executed once. If it appears that the interrupt mysteriously stops executing, we must verify that RETI is being used. Certain assemblers contain special features which will issue a warning if the programmer fails to protect registers or commit some other common interrupt-related errors. The above are all taken care of by the compiler when using C as the programming language. Common problems in C or assembly language:

Brain power

By 2020, wind could provide one-tenth of our planet’s electricity needs. Already today, SKF’s innovative knowhow is crucial to running a large proportion of the world’s wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

83
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

Forgetting to re-start a timer: We might turn off a timer to re-load the timer register values or to read the counter in an interrupt service routine (ISR) and then forget to turn it on again before exiting from the ISR. In this case, the ISR would only execute once. Forgetting to clear the interrupt flag: Certain interrupt are not cleared automatically when the ISR is called. For example, when using Timer 2 interrupts, the Timer 2 overflow flag TF2 is not cleared automatically when the ISR is serviced. We have to clear it in the ISR software. The same problem occurs if we forget to clear the RIx or the TIx flags when using the Serial Interrupt. In this case, the ISR keeps on being called repeatedly. Other devices may also exhibit this non-clearing flag situation and should therefore be taken care of when they are used.

4.6	RTOS pitfalls
The PaulOS_F020 co-operative RTOS is a robust and secure RTOSs which we have used extensively throughout the years with our students. This is mainly due to the fact that being a co-operative RTOS, the task changes occur when we want them since there cannot be any forced pre-emptive task changes. However there can still be hidden problems. We should take special care when handling global variables which are accessible to all the tasks. We have to make sure that these variables are allowed to be manipulated only when we want them to. Otherwise it might happen that a task starts with one value of a global variable, then it goes on to a wait state, and when it later on resumes to run, it might end up using the wrong value of the same variable simply because it was modified in the mean time by another task. The same problem exists in the RTOS with register banks and tasks which use the same functions which are non re-entrant.

4.7	

C Tips
•	 We should always try to keep functions (or tasks) as simple as possible. •	 Use the correct required types for the variables; do not use int type if we really need byte or bit type. Naturally, the corresponding conversion character (%c, %bu, %d etc) should then be used with ‘printf ’ or ‘scanf ’ commands. •	 Use signed or unsigned types correctly. •	 Use specified locations for storing pointers by using declarations such as:
char data * xdata str;	 int xdata * data numtab;	 /* pointer stored in xdata, pointing to char stored in data */ /* pointer stored in data, pointing to int stored in to xdata */

long code * idata powtab;	 /* pointer stored in idata, pointing to long stored in code */

84
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Programming Tips and Pitfalls

•	 In order to improve the performance during code execution or to reduce the memory size requirement for our code, we should analyse the generated list files and assembly code so as to determine which routines can be improved in speed or reduced in size. •	 We should always try to minimize the variable usage. •	 Set the NUMBER_OF_TASKS, TICKTIME and TICK_TIMER definitions in the PaulOS_ F020_Parameter.h header file to correspond to your application program. This is often a common mistake to make. •	 Ensure that if you are using interrupts, make sure that they are enabled. •	 Remember that the timer used for the RTOS tick timer cannot be used also for say the baud rate generation of a UART. •	 Remember to use the correct ISR parameter in PaulOS_F020_Parameter.h header file when you are using a stand-alone ISR.

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT… RUN FASTER. RUN LONGER.. RUN EASIER…
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

85
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

Appendix A: PaulOS_F020.C Source Listing
This is the program source listing for the C version of PaulOS RTOS. It consists of: •	 The header file PaulOS_F020_Parameters.h •	 The header file PaulOS_F020.h •	 The start-up file Startup_PaulOS_F020.A51 •	 The main source program PaulOS_F020.C •	 The modified C8051F020 header file

A.1	

PaulOS_F020_Parameters.h

#ifndef _PaulOS_F020_Parameters_H_ #define _PaulOS_F020_Parameters_H_

/* ********************************************************************************************** *					RTOS KERNEL HEADER FILE * * 					PaulOS_F020_Parameters.H * *  For use with PaulOS_F020.C * by Ing. Paul P. Debono * for use with the 8051 family of micro-controllers * * File	 * Revision	 * Date	 * By	 * * 	 * ********************************************************************************************** */ University Of Malta : PaulOS_F020_Parameters.H : 10 : Revised for C8051F020 February 2015 : Paul P. Debono

–

Co-Operative RTOS written in C based on PaulOS

86
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** * 	 DATA TYPE DEFINITIONS

********************************************************************************************** */

#define TICK_TIMER	

2

// Set to 0, 1, 2 or 3, making sure tick timer does not to clash with UART baud rate timer

#define TICKTIME 1 // Length of RTOS basic tick in ms // suitable values are: 1, 2, 4, 5, 8, 10, 20, 25

–

refer to the RTOS timing definitions

#define NOOFTASKS		

65	

// Number of tasks used in the application

#define STACKSIZE		

0x0F	

// Number of bytes to allocate for the stack

// There is usually no need to change this parameter

/* ********************************************************************************************** */

/* Interrupt routines running as TASKS or as STAND-ALONE ISRs */

# define STAND_ALONE_ISR_00 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_01 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_02 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_03 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_04 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_05 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_06 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_07 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_08 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_09 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_10 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_11 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_12 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_13 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_14 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_15 0 // set to 1 if using this interrupt as a stand alone ISR

87
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

# define STAND_ALONE_ISR_16 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_17 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_18 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_19 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_20 0 // set to 1 if using this interrupt as a stand alone ISR # define STAND_ALONE_ISR_21 0 // set to 1 if using this interrupt as a stand alone ISR

/* ********************************************************************************************** */

#endif

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
88
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

A.2	

PaulOS_F020.h

#ifndef _PaulOS_F020_H_ #define _PaulOS_F020_H_

/* ********************************************************************************************** *			 * * 						PaulOS_F020.H * *  For use with PaulOS_F020.C * by Ing. Paul P. Debono * for use with the 8051 family of micro-controllers * * File 	 * Revision * Date 	 * By	 * * 	 * 	 * ********************************************************************************************** */ B. Eng. (Hons.) Elec. University Of Malta 	 : PaulOS_F020.H : 10 : Revised for C8051F020 February 2015 : Paul P. Debono 	 RTOS KERNEL HEADER FILE

–

Co-Operative RTOS written in C based on PaulOS

/* ********************************************************************************************** * 	 DATA TYPE DEFINITIONS

********************************************************************************************** */

typedef unsigned char uchar; typedef unsigned int uint; typedef unsigned long ulong; #include “PaulOS_F020_Parameters.H”

89
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

/* ********************************************************************************************** * 	 FUNCTION PROTOTYPES

********************************************************************************************** * * * The following RTOS system calls do not receive any parameters: * ---------------------------------------------------------------*/

void	 void	 bit	 void	

OS_DEFER (void);

//  Stops current task and passes control to next task in queue

OS_KILL_IT (void); // Kills a task OS_SCHECK (void); OS_WAITP (void);

–

sets it waiting forever

//  Checks if running task’s signal bit is set // Waits for end of task’s periodic interval

uchar	 OS_RUNNING_TASK_ID(void); //  Returns the number of the currently executing task

/* The following commands are simply defined as MACROS below OS_CPU_IDLE()		 Set the microprocessor into a sleep mode (awakes every interrupt) OS_CPU_DOWN()		 Switch off microprocessor, activated again only by a hardware reset OS_PAUSE_RTOS()	 OS_RESUME_RTOS()	 /* Disable RTOS, used in a stand-alone ISR Re-enable RTOS, used in a stand-alone ISR

* The following RTOS system calls do receive parameters: * ------------------------------------------------------*/

void OS_INIT_RTOS (uchar blank);//  Initialises RTOS variables, parameter is not actually used void OS_RTOS_GO (uchar prior);	 //  Starts the RTOS running with priorities if required

void OS_SIGNAL_TASK (uchar task); // Signals a task void OS_WAITI (uchar intnum);	 //  Waits for an event (interrupt) to occur void OS_WAITT (uint ticks);	 //  Waits for a timeout period given by a defined

				// number of ticks void OS_WAITS (uint ticks);	 //  Waits for a signal to arrive within a given number of ticks

void OS_PERIODIC (uint ticks); //  Sets task to behave periodically every given number of ticks

90
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

void OS_CREATE_TASK (uchar task, uint taskadd); // Creates a task void OS_RESUME_TASK (uchar task);	 // Resumes a task which was previously killed 

/* The following commands are simply defines as MACROS below OS_WAITT_A(M,s,ms)	 Absolute OS_WAITT() for minutes, seconds and milliseconds OS_WAITS_A(M,s,ms)	 Absolute OS_WAITS() for minutes, seconds and milliseconds 	 */ OS_PERIODIC_A(M,s,ms)  Absolute OS_PERIODIC() for minutes, seconds and milliseconds

/* ********************************************************************************************** * 					RTOS USER DEFINITIONS ********************************************************************************************** */ #define SYSCLOCK #define CPU		 	 22118400UL 		 5120	 	 // 22.1184 MHz crystal // set to 8051F020 (denoted by 5120)

/* Stack variable points to the start pointer in hardware stack and */ /* should be defined in Startup_PaulOS_F020.A51 */

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

91
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
extern idata unsigned char MAINSTACK[STACKSIZE]; /*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

/* ********************************************************************************************** * 	 					RTOS MACROS ********************************************************************************************** */

#define OS_CPU_IDLE()		 #define OS_CPU_DOWN()		

PCON |= IDLE	 //  Sets the microprocessor in idle mode PCON |= STOP	 //  Sets the microprocessor in power-down mode

#if (TICK_TIMER == 0) #define OS_PAUSE_RTOS()		 #define OS_RESUME_RTOS()	 ET0 = 0 ET0 = 1

#elif (TICK_TIMER == 1) #define OS_PAUSE_RTOS()		 #define OS_RESUME_RTOS()	 ET1 = 0 ET1 = 1

#elif (TICK_TIMER == 2) #define OS_PAUSE_RTOS()		 #define OS_RESUME_RTOS()	 ET2 = 0 ET2 = 1

#elif (TICK_TIMER == 3) #define OS_PAUSE_RTOS()		 #define OS_RESUME_RTOS()	 EIE2 ^= ET3 EIE2 |= ET3

#endif

/* ********************************************************************************************** */

/* ********************************************************************************************** * 					RTOS TIMING DEFINITIONS **********************************************************************************************

92
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*/

Appendix A: PaulOS_F020.C Source Listing

/* Timers used for this RTOS use the system clock divided by 12	 */ /* that is they count up once every 0.542535 micro seconds		 /* For 1 msec, count = SYSCLK/12/1000 = 1843.2			 #define MSEC10 18432UL		 				 #define CLOCK	 */ */

//  In theory 1843.2 counts represent 1 msec assuming an // 22.1184 MHz crystal. //  i.e. approx. 35

((TICKTIME * MSEC10)/10)	

–

However respecting the

						// condition #define BASIC_TICK 	 (65535

–

CLOCK + 1)	

//  above, max. acceptable TICKTIME = 25 msecs.

// Hence all suitable values are: 1, 2, 4, 5, 8, 10, 20, 25 // For reliable time-dependent results a value of 10 or // above is recommended depending upon the application

#define NOT_TIMING		

0	

// An indefinite period of waiting time in the RTOS is given by a value of 0 #define NO_INTERRUPT 0xFF /* ********************************************************************************************** */

/* ********************************************************************************************** *					COMPILE-TIME ERROR TRAPPING ********************************************************************************************** */

#if (CPU != 5120) #error Invalid CPU Setting #endif

#if (NOOFTASKS > 254) # error Number of tasks is out of range. The ReadyQ can store up to 254 tasks #endif

#if 0 // set to one if you need the following checks to be done

#if (CPU == 5120) /* C8051F020 SiLabs processor */ #if ((MAINSTACK + STACKSIZE) > 0x100) # error Internal RAM Space exceeded. Please recheck the MAINSTACK and STACKSIZE definitions

93
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#endif #elif (CPU == 8051) #if ((MAINSTACK + STACKSIZE) > 0x80)

Appendix A: PaulOS_F020.C Source Listing

# error Internal RAM Space exceeded. Please recheck the MAINSTACK and STACKSIZE definitions #endif #endif #endif

#if ((TICKTIME * SYSCLOCK / 12000) > 65535) #error Tick time value exceeds valid range of the timer counter setting #endif

# if ((TICKTIME * SYSCLOCK / 12000) < 65535) && ((1000 % TICKTIME) != 0) # error Undesirable TICKTIME setting. Suggested: 1, 2, 4, 8, 10, 20, 25, 40, 50 ms #endif

#if (CLOCK > 65535) # error Timer counter setting exceeded valid range. Please recheck the TICKTIME and MSEC definitions #endif

/* ********************************************************************************************** */

/* ********************************************************************************************** * 					TASK-RELATED DEFINITIONS ********************************************************************************************** */ // Interrupt names #define IE0_INT	 #define TF0_INT	 #define IE1_INT	 #define TF1_INT	 #define UART0_INT	 #define TF2_INT	 #define SPIF_INT	 #define SI_INT	 #define AD0WIN_INT	 0 1 2 3 4 5 6 7 8

94
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#define PCA_INT	 #define CP0FIF_INT		 #define CP0RIF_INT		 #define CP1FIF_INT		 #define CP1RIF_INT		 #define TF3_INT			 #define AD0INT_INT		 #define TF4_INT			 #define AD1INT_INT		 #define IE6_INT			 #define IE7_INT			 9 10 11 12 13 14 15 16 17 18 19

Appendix A: PaulOS_F020.C Source Listing

#define UART1_INT		 20 #define XTLVLD_INT		 21

#define SIGS_Flag	 #define SIGW_Flag	 #define SIGV_Flag	

0x80 0x40 0x20

#define IDLE_TASK NOOFTASKS //  Main endless loop in application given a task number equal to NOOFTASKS

95
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

/* ********************************************************************************************** * 				 ENHANCED EVENT-WAITING ADD-ON MACROS

********************************************************************************************** * *  These macros perform the same functions of the WAITT, WAITS and PERIODIC * calls but rather than ticks *  they accept absolute time values as parameters in terms of days, hours, minutes, seconds * and milliseconds *  This difference is denoted by the _A suffix * version of WAITT() * * Range of values accepted: *

–

eg. WAITT_A() is the absolute-time

*

Using a minimum TICKTIME of 1 msec: 1 msec 

–

1 min, 5 secs, 535 msecs

*  Using a recommended TICKTIME of 10 msec: 10 msecs *  Using a maximum TICKTIME of 50 msec: 50 msecs

–

10 mins, 55 secs, 350 msecs

–

54 mins, 36 secs, 750 msecs

*  If the conversion from absolute time to ticks results in 0 (all parameters being 0 or * overflow) this *  result is only accepted by WAITS() by virtue of how the WAITT(), WAITS() and PERIODIC() * calls were

*  written. In the case of the WAITT() and PERIODIC() calls the tick count would automatically * be changed to 1 meaning an interval of e.g. 50 msecs in case the TICKTIME is defined to be * 50 msecs * *  Liberal use of parentheses is made in the following macros in case the arguments might * be expressions. * ********************************************************************************************** */ # define OS_WAITT_A(M,S,ms) OS_WAITT((uint)((60000*(##M) + 1000*(##S) + (##ms))/TICKTIME)) # define OS_WAITS_A(M,S,ms) OS_WAITS((uint)((60000*(##M) + 1000*(##S) + (##ms))/TICKTIME)) # define OS_PERIODIC_A(M,S,ms) OS_PERIODIC((uint)((60000*(##M)+1000*(##S)+(##ms))/TICKTIME))

96
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

/* * Other functions used internally by the RTOS: * --------------------------------------------*/

void QShift (void);			 void RTOS_Timer_Int (void);		 void Xtra_Int (uchar task_intflag);	

// Task swapping function // RTOS Scheduler ISR // Function used by ISRs other than the RTOS Scheduler

#if (!STAND_ALONE_ISR_00) void Xtra_Int_0 (void);		 #endif // External Interrupt 0 ISR

#if ( (TICK_TIMER != 0 ) && (!STAND_ALONE_ISR_01) ) void Xtra_Int_1 (void);		 #endif // Timer 0 ISR

#if (!STAND_ALONE_ISR_02) void Xtra_Int_2 (void);		 #endif // External Interrupt 1 ISR

#if ( (TICK_TIMER != 1 ) && (!STAND_ALONE_ISR_03) ) void Xtra_Int_3 (void);		 #endif // Timer 1 ISR

#if (!STAND_ALONE_ISR_04) void Xtra_Int_4 (void);		 #endif // Serial Port ISR

#if ( (TICK_TIMER != 2 ) && (!STAND_ALONE_ISR_05) ) void Xtra_Int_5 (void);		 #endif // Timer 2 ISR

#if (!STAND_ALONE_ISR_06) void Xtra_Int_6 (void); #endif

97
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_07) void Xtra_Int_7 (void); #endif

Appendix A: PaulOS_F020.C Source Listing

#if (!STAND_ALONE_ISR_08) void Xtra_Int_8 (void); #endif

#if (!STAND_ALONE_ISR_09) void Xtra_Int_9 (void); #endif

#if (!STAND_ALONE_ISR_10) void Xtra_Int_10 (void); #endif

#if (!STAND_ALONE_ISR_11) void Xtra_Int_11 (void); #endif

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

98
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_12) void Xtra_Int_12 (void); #endif

Appendix A: PaulOS_F020.C Source Listing

#if (!STAND_ALONE_ISR_13) void Xtra_Int_13 (void); #endif

#if ((TICK_TIMER != 3 ) && (!STAND_ALONE_ISR_14) ) void Xtra_Int_14 (void); 		 #endif // Timer 3 isr

#if (!STAND_ALONE_ISR_15) void Xtra_Int_15 (void); #endif

#if (!STAND_ALONE_ISR_16) void Xtra_Int_16 (void); #endif

#if (!STAND_ALONE_ISR_17) void Xtra_Int_17 (void); #endif

#if (!STAND_ALONE_ISR_18) void Xtra_Int_18 (void); #endif

#if (!STAND_ALONE_ISR_19) void Xtra_Int_19 (void); #endif

#if (!STAND_ALONE_ISR_20) void Xtra_Int_20 (void); #endif

#if (!STAND_ALONE_ISR_21) void Xtra_Int_21 (void); #endif

99
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */ #endif

A.3	
$NOMOD51

Startup_PaulOS_F020.A51

;--------------------------------------------------------------------------------------------; This file is part of the C51 Compiler package ; Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc. ; modified by Paul Debono in order to ; handle the C8051F020 micro-controller, running the PaulOS RTOS ;--------------------------------------------------------------------------------------------; Startup_PaulOS_F020.A51: This code is executed after processor reset. ; ; To translate this file use A51 with the following invocation: ; ; ; ;  To link the modified Startup_PaulOS_F020.OBJ file to your application use the ; following BL51 invocation: ; ; ; ;--------------------------------------------------------------------------------------------; ; User-defined Power-On Initialization of Memory ; ; With the following EQU statements the initialization of memory ; at processor reset can be defined: ; ; 	 IDATALEN	 ; XDATASTART	 XDATALEN	 ; PDATASTART	 PDATALEN	 EQU EQU 0H		 0H		 ; the absolute start-address of PDATA memory ; the length of PDATA memory in bytes. EQU EQU 0H		 4096		 ;  the absolute start-address of XDATA memory ; the length of XDATA memory in bytes. ;  the absolute start-address of IDATA memory is always 0 EQU 100H		 ;  the length of IDATA memory in bytes. BL51 <your object file list>, Startup_PaulOS_F020.OBJ <controls> A51 Startup_PaulOS_F020.A51

100
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
;

Appendix A: PaulOS_F020.C Source Listing

; Notes:  The IDATA space overlaps physically the DATA and BIT areas of the ;	 ;	 8051 CPU. At minimum the memory space occupied from the C51 run-time routines must be set to zero.

;--------------------------------------------------------------------------------------------; ; Reentrant Stack Initilization ; ; The following EQU statements define the stack pointer for reentrant ; functions and initialized it: ; ; Stack Space for reentrant functions in the SMALL model. IBPSTACK	 IBPSTACKTOP	 ; ; Stack Space for reentrant functions in the LARGE model. XBPSTACK	 XBPSTACKTOP	 ; ; Stack Space for reentrant functions in the COMPACT model. EQU	 EQU	 0	 ; set to 1 if large reentrant is used. EQU	 EQU	 0	 ; set to 1 if small reentrant is used.

0FFH+1	 ; set top of stack to highest location+1.

0FFFFH+1; set top of stack to highest location+1.

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

101
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
PBPSTACK	 PBPSTACKTOP	 ; EQU	 EQU	 0	

Appendix A: PaulOS_F020.C Source Listing
; set to 1 if compact reentrant is used.

0FFFFH+1; set top of stack to highest location+1.

;--------------------------------------------------------------------------------------------; ; Page Definition for Using the Compact Model with 64 KByte xdata RAM ; ; The following EQU statements define the xdata page used for pdata ; variables. The EQU PPAGE must conform with the PPAGE control used ; in the linker invocation. ; PPAGEENABLE	 ; PPAGE		 ; PPAGE_SFR	 ;		 ; ;--------------------------------------------------------------------------------------------; Standard SFR Symbols ACC 	 B 	 SP 	 DPL 	 DPH 	 DATA DATA DATA DATA DATA 0E0H 0F0H 81H 82H 83H DATA	0A0H		 ;  SFR that supplies uppermost address byte EQU	 0 	 	 ; define PPAGE number. EQU	 0 		 ; set to 1 if pdata object are used.

(most 8051 variants use P2 as uppermost address byte)

		

NAME ?C_STARTUP

?C_C51STARTUP	 SEGMENT ?STACK 		 SEGMENT

CODE IDATA

#include “PaulOS_F020_Parameters.h”

		 MAINSTACK:	

RSEG DS

?STACK STACKSIZE

		 		

EXTRN CODE (?C_START) PUBLIC ?C_STARTUP PUBLIC MAINSTACK

		

102
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
		 ?C_STARTUP:	 CSEG LJMP AT 0 STARTUP1

Appendix A: PaulOS_F020.C Source Listing

		
STARTUP1:

RSEG	?C_C51STARTUP

IF IDATALEN <> 0 		 		 IDATALOOP: 	 		 ENDIF MOV	 CLR	 MOV	 DJNZ	 R0,#IDATALEN A @R0,A R0,IDATALOOP

–

1

IF XDATALEN <> 0 		 		 MOV	 MOV	 DPTR,#XDATASTART R7,#LOW (XDATALEN)

IF (LOW (XDATALEN)) <> 0 		 ELSE 		 ENDIF MOV	 R6,#HIGH (XDATALEN) MOVR6,#(HIGH (XDATALEN)) +1

		
XDATALOOP:	 		 		 		 ENDIF

CLR	A MOVX	 INC	 DJNZ	 DJNZ	 @DPTR,A DPTR R7,XDATALOOP R6,XDATALOOP

IF PPAGEENABLE <> 0 			 ENDIF MOV	 PPAGE_SFR,#PPAGE

IF PDATALEN <> 0 		 		 		 PDATALOOP: 	 		 		 ENDIF MOV	 MOV	 CLR	 MOVX	 INC	 DJNZ	 R0,#LOW (PDATASTART) R7,#LOW (PDATALEN) A @R0,A R0 R7,PDATALOOP

103
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
IF IBPSTACK <> 0 EXTRN DATA (?C_IBP)

Appendix A: PaulOS_F020.C Source Listing

		 ENDIF

MOV	

?C_IBP,#LOW IBPSTACKTOP

IF XBPSTACK <> 0 EXTRN DATA (?C_XBP)

		 		 ENDIF

MOV	 MOV	

?C_XBP,#HIGH XBPSTACKTOP ?C_XBP+1,#LOW XBPSTACKTOP

IF PBPSTACK <> 0 EXTRN DATA (?C_PBP) 		 ENDIF MOV	 ?C_PBP,#LOW PBPSTACKTOP

		

MOV	

SP,#?STACK-1

; This code is required if you use L51_BANK.A51 with Banking Mode 4

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

104
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
; EXTRN CODE (?B_SWITCH0) ; 		 		 CALL	 LJMP	 ?B_SWITCH0		 ?C_START

Appendix A: PaulOS_F020.C Source Listing

;  init bank mechanism to code bank 0

		

END

A.4	
/*

PaulOS_F020.c

********************************************************************************************** *	 PaulOS_F020.c 			 * * Co-Operative RTOS written in C by Ing. Paul P. Debono: * ------------------------------------------------------------------* * For use with the Silicon Labs C8051F020 family of micro-controllers * * Notes: * *  Timer to use for the RTOS ticks is user selectable: Timer 0, 1, 2, or 3 * * Assign the correct values to ‘TICK_TIMER’, ‘CPU’, ‘MAINSTACK’ * and ‘NOOFTASKS’ in PaulOS_F020.H * *  If it is noticed that timing parameters are not being met well RTOS KERNEL SOURCE CODE

–

the system’s TICKTIME

* can be modified by changing the value ‘TICKTIME’ in PaulOS_F020.H * conditions mentioned in PaulOS_F020.H *

–

please adhere to the

*

File 		

: PaulOS_F020.C : 10 : FEBRUARY 2015 	 : Paul P. Debono

* Revision 	 * Date 		 * By	 * * 	 *

University Of Malta

********************************************************************************************** */

105
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** * 					INCLUDES ********************************************************************************************** */

#include “C8051F020.h”		 #include “PaulOS_F020.h”	

/*  special function registers definitions for the C8051F020 */ /* RTOS system calls definitions */

/* ********************************************************************************************** */

/* ********************************************************************************************** * 				STRUCTURE DEFINITIONS ********************************************************************************************** */ struct task_param { 	 	 	 	 	 	 	 }; struct task_param xdata task[NOOFTASKS + 1]; uchar stackptr; uchar flags; uchar intnum; uint uint uint char timeout; interval_count; interval_reload; stack[STACKSIZE];

/* ********************************************************************************************** *					 GLOBAL VARIABLES

********************************************************************************************** */

bit	 bit	 bit	

bdata IntFlag;		 bdata TinQFlag;	 bdata Priority;	

//  Flag indicating a task waiting for an interrupt was found // Flag indicating that a task timed out //  Flag indicating whether priority is enabled or disabled

106
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
uchar data * data ReadyQTop;		 uchar data Running;			 uchar data ReadyQ[NOOFTASKS + 2];	

Appendix A: PaulOS_F020.C Source Listing
// Address of last ready task // Number of current task //  Queue stack for tasks ready to run

/* ********************************************************************************************** */

/* ********************************************************************************************** * 						FUNCTION DEFINITIONS ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_INIT_RTOS * * Function type: Initialisation System call

107
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
*

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This system call initialises the RTOS variables, task SPs and enables any * 		 * * Arguments 	 : 0	 *			 * * * Returns	 * ********************************************************************************************** */ : None parameter required but not used here, just to keep compatibility with the other basic PaulOS command required interrupts

void OS_INIT_RTOS(uchar TickTimer) { 	 	 uchar xdata i,j; TickTimer = TickTimer; /*  parameter not used here, just to keep compatibility with basic PaulOS */ #if (TICK_TIMER == 0) 	 	 	 	 #message “Using Timer 0 as the tick timer” // compile time message IE &= 0x7F; IE |= 0x02;			 IP = 0x02;			 /* Set up 8051 IE register, using timer 0 */ /* Assign scheduler interrupt high priority */

#elif (TICK_TIMER == 1) 	 	 	 	 #message “Using Timer 1 as the tick timer” IE &= 0x7F; IE |= 0x08;			 IP = 0x08;			 /* Set up 8051 IE register, using timer 1 */ /* Assign scheduler interrupt high priority */

#elif (TICK_TIMER == 2) 	 	 	 	 #message “Using Timer 2 as the tick timer” IE &= 0x7F; IE |= 0x20;			 IP = 0x20; 			 /* Set up 8051 IE register, using timer 2 */ /* Assign scheduler interrupt high priority */

#elif (TICK_TIMER == 3) 	 	 	 #message “Using Timer 3 as the tick timer” EIE2 |= 0x01;	 EIP2 = 0x01; 	 		 		 /* Set up 8051 IE register, using timer 3 */ /* Assign scheduler interrupt high priority */

#endif

108
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 Running = IDLE_TASK;	

Appendix A: PaulOS_F020.C Source Listing
/* Set idle task as the running task */

for (i = 0; i < NOOFTASKS; i++)

	{ 	 task[i].timeout = NOT_TIMING;		 	 task[i].intnum = NO_INTERRUPT; 		 	 task[i].interval_count = NOT_TIMING;	 	 task[i].interval_reload = NOT_TIMING; 	 ReadyQ[i] = IDLE_TASK;	 	 /* Initialise task timeouts,		 */

/* not waiting for any interrupt.	 */ /* periodic interval count 		 /* and reload variables. 	 */ */ */

/* Fill the READY queue with 	

	 }						/* with the idle task		 */ 	 	 	 ReadyQ[NOOFTASKS] = IDLE_TASK; ReadyQ[NOOFTASKS + 1] = IDLE_TASK; ReadyQTop = ReadyQ;	 		 /*  Pointer to last task made to point to */

						/* base of the queue. */

	

for (i = 0; i < NOOFTASKS + 1; i++)

	{ 	 	 task[i].stackptr = MAINSTACK + 2;		 task[i].flags = 0;	 			 /*  Initialise task SP values */ /*  Initialise task status bytes */

	 for(j=0; j<STACKSIZE; j++) task[i].stack[j] = 0; /* clear all ext. stack area */ 	} }

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_CREATE_TASK * * Function type: Initialisation System call * * Description :  This system call is used in the main program for each task to be created for use in the application.

*			 * * Arguments	 * * 		

: task	 Represents the task number (1st task is numbered as 0).

taskadd	 Represents the task’s start address, which in the C

* 				 environment, would simply be the name of the procedure

109
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* * Returns	 * : None

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

void OS_CREATE_TASK(uchar tasknum, uint taskadd) { 	 	 	 	 ReadyQTop++;		 *ReadyQTop = tasknum;	 /* Task is added to next available */ /* position in the READY queue.	 */

task[tasknum].stack[0] = taskadd % 256; task[tasknum].stack[1] = taskadd / 256;

}

/* ********************************************************************************************** */

/*

110
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** * * Function name: OS_RTOS_GO * * Function type: Initialisation System call * * Description 	 :  This system calls is used to start the RTOS going such that it supervises the application processes. * * Arguments 	 : prior	 Determines whether tasks ready to be executed are sorted * 	 prior to processing

*	 or not. If prior = 0 a FIFO queue function is implied, * 	 if prior = 1 the

*	 queue is sorted by task number in ascending order, as a * 	 higher priority is

*	 associated with smaller task number (task 0 would have * 	 the highest

*	 priority), such that the first task in the queue, which * 	 would eventually

*	 run, would be the one with the smallest task number * 	 * * Returns		 * ********************************************************************************************** */ : None having highest priority.

void OS_RTOS_GO(uchar prior) { 	 	 	else 	 Priority = 0; if (prior == 1)	 	 /* Checks if tasks priorities 	 */ */

Priority = 1;	

/* are to be enabled 			

#if (TICK_TIMER == 0) 	 	 /* Configure Timer 0 in 16-bit timer mode for the 8051 	 /* TH0 and TL0 are loaded in the TF0 RTOS Tick ISR */ /* Clear T0 mode control, leaving T1 untouched */ /* Set T0 mode control */ */

	 TMOD &= 0xF0;		 	 TMOD |= 0x01;		

111
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 	 CKCON &= 0xF0;		 TR0 = 1;			 TF0 = 1;		 	

Appendix A: PaulOS_F020.C Source Listing
/* Use sysclk/12 (T0M = 0) */ /* Start timer 0 */ /* Cause first interrupt immediately */

#elif (TICK_TIMER == 1) 	 	 /* Configure Timer 1 in 16-bit timer mode for the 8051 	 /* TH1 and TL1 are loaded in the TF1 RTOS Tick ISR */ /* Clear T1 mode control, leaving T0 untouched */ /* Set T1 mode control */ 	 	 	 /* Use sysclk/12 (T1M = 0) */ /* Start timer 1 */ /* Cause first interrupt immediately */ */

	 TMOD &= 0x0F;		 	 	 	 	 TMOD |= 0x10;		 CKCON &= 0xE8;	 TR1 = 1;		 TF1 = 1;		

#elif (TICK_TIMER == 2) 	 RCAP2 = BASIC_TICK;	 	 CKCON |= 0xD8;		 /* Configures Timer 2 in 16-bit auto-reload mode */ /* Use sysclk/12 (T2M=0) */ /* TR2 = TF2 = 1, causes first interrupt immediately */

	 T2CON = 0x84;		

#elif (TICK_TIMER == 3) 	 TMR3CN = 0x00;		 //  Stop timer 3, clear TF3 use SYSCLK/12 as timer base /* Configures Timer 3 in 16-bit auto-reload mode 	 */

	 TMR3RL = BASIC_TICK;	 	 TMR3 = 0xFFFF;		 	 EIE2 |= ET3;		

/* Causes immediate overflow, (reload immediately) 	 */ /* Enable Timer 3 interrupts */ /* Start Timer 3 using sysclk/12 (TR3=1, TF3=T3M=T3XCLK=0) */

	 TMR3CN |= TR3;		

#endif

	 	

TinQFlag = 1; /* Signals scheduler that tasks have been	 /* added to the queue.	 					

*/ */

	 EA = 1;		

/* Interrupts are enabled, starting the RTOS */

}

/* ********************************************************************************************** */

/* **********************************************************************************************

112
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* * Function name: OS_RUNNING_TASK_ID * * Function type: Inter-task Communication System call *

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This system call is used to check to get the number of the *					 current task. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ uchar OS_RUNNING_TASK_ID(void) { 	 } return (Running); :  Number of currently running task from which it must be called

/*

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

113
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** * * Function name: OS_SCHECK * * Function type: Inter-task Communication System call * * Description 	 :  This system call is used to check if the current task has its signal set. * 			 * * Arguments	 * * Returns	 * ********************************************************************************************** */ : 1 if its signal bit is set, 0 if not set : None It tests whether there was any signal sent to it by some other task. 

bit OS_SCHECK(void) { 	 EA = 0;

	 if (task[Running].flags & SIGS_Flag) /* If a signal is present it’s cleared */ 	{ 	 	 	 	} 	 else 			 /*  If a signal is not present, 0 is returned */ task[Running].flags &= ~SIGS_Flag;	 /*  and a 1 is returned. */ EA = 1; return 1;

	{ 	 	 } } EA = 1; return 0;

/* ********************************************************************************************** /*

********************************************************************************************** * * Function name: OS_SIGNAL_TASK *

114
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* Function type: Inter-task Communication System call *

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This system call is used to send a signal to another task. * * Arguments 	 : task		 Represents the task to which a signal is required to be sent. * * Returns	 * ********************************************************************************************** */ : None

void OS_SIGNAL_TASK(uchar tasknum) { 	 EA = 0;

	

if (task[tasknum].flags & SIGW_Flag)

	{ 	 task[tasknum].flags &= ~SIGS_Flag; 	 	 task[tasknum].flags &= ~SIGW_Flag; 	 	 task[tasknum].timeout = NOT_TIMING;	 	 ReadyQTop++;			 	 	 	 	} 	 else							/*  If it was not waiting, its */ 	 	 } task[tasknum].flags |= SIGS_Flag; 	 /*  signal sent bit is set	 EA = 1; */ *ReadyQTop = tasknum; TinQFlag = 1; EA = 1; /* If a task has been waiting	*/ /* for a signal, the task no 	 /* longer has to wait and is	*/ /* added to the READY queue.	*/ */

		

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_WAITS * * Function type: Event-Waiting System call

115
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This system call causes a task to wait for a signal to arrive within a given number of RTOS ticks. If the signal is already present, the task continues to execute. * * Arguments 	 : ticks		 Represents the number of ticks for which the task will wait for a signal to *				 arrive. Valid range for this argument is 0 to * 				 4294967295. A value of 0 means waiting forever for a * 				 * * Returns		 * ********************************************************************************************** */ : None signal to arrive.

.

116
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
void OS_WAITS (uint ticks) { 	 EA = 0;

Appendix A: PaulOS_F020.C Source Listing

	

if (task[Running].flags & SIGS_Flag) /*  If signal already sent it clears the */

	{ 	 	 	} 	 else 						 /*  If signal is not present */ task[Running].flags &= ~SIGS_Flag;		 EA = 1;					 /*  signal and the task */ /*  continues to run. */

	{ 	 task[Running].flags |= SIGW_Flag; /*  the task is sent in the 			 	 task[Running].timeout = ticks; 	 /*  waiting state, by causing 		 	 } } QShift();				 /* a task switch. */ */ */

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_WAITT * * Function type: Event-Waiting System call * * Description 	:  This system call causes a task to go in the waiting state for a timeout period given *		 * * Arguments 	 : ticks		 Represents the number of ticks for which the task will * 				 wait. Valid range for by a defined number of RTOS ticks.

*				 this parameter is 1 to 4294967295. A zero waiting time * 				 parameter is set to 1

*				 by the RTOS itself, since a zero effectively kills the *				 * * Returns	 : None task, making it wait forever.

117
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

void OS_WAITT (uint ticks) { 	 EA = 0;

	 	 	

if (ticks == 0) ticks = 1;		 		 /*  Task’s timeout variable is updated */ */ */

task[Running].timeout = ticks;	 /*  and the task then enters the 		

	 QShift();			 		/* waiting state.			 }

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_WAITP * * Function type: Event-Waiting System call * * Description 	 :  This system call is used by a task to wait for the end of its periodic * 		 * 		 * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ : None  interval. If the interval has already passed, the task continues to execute.

118
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
void OS_WAITP(void) { 	 EA = 0;

Appendix A: PaulOS_F020.C Source Listing

	

if ((task[Running].flags & SIGV_Flag)==SIGV_Flag )/*  If the periodic */

	{ 	 	 task[Running].flags &= ~SIGV_Flag; 	 EA = 1;				 	 /*  interval time has elapsed, the	 /*  task continues to	*/ */

	 }							 /* execute.		*/ 	else 	{ 	 	 	 } } /* Else the task */ task[Running].flags |= SIGV_Flag;	 	 /* enters the waiting */

QShift();					/* state.		*/

/* ********************************************************************************************** */

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

119
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** * * Function name: OS_PERIODIC * * Function type: Event-Waiting System call * * Description 	 :  This system call causes a task to repeat its function every given number of * 		 * * Arguments 	 : ticks		 Represents the length of the periodic interval in terms * 				 *				 * 				 * * Returns 		 * ********************************************************************************************** */ : None of RTOS ticks, after which the task repeats itself. Valid range for this parameter is 1 to 4294967295. RTOS ticks.

void OS_PERIODIC (uint ticks) { 	 EA = 0;

	

if (ticks == 0) /* at least 1 tick time is required */

	 ticks = 1; 					

	 task[Running].interval_reload = ticks; 	 /* Task’s periodic interval count */ 	 task[Running].interval_count = ticks; 	 } EA = 1;					 	 /* and reload variables are	 /* initialised. */ */

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_WAITI *

120
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* Function type: Event-Waiting System call *

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This system call causes a task to wait for a given event (interrupt). * 		 *		 * 		 * 		 *		 * 		 *	 * 		 *		 * * Arguments 	 : intnum	 Represents the interrupt number associated with the given * 				interrupt for * 				 * * Returns 	 * ********************************************************************************************** */ void OS_WAITI(uchar intnum) { 	 	 EA = 0; switch (intnum) : None which the calling task intends to wait 	 It identifies for which interrupt the task has to wait. Once identified 

–

the task’s

appropriate flag is set and the task is set in the waiting state by  causing a task swap

–

the task

would wait indefinitely for the interrupt as its timeout  variable would be set to 0  (NOT_TIMING) either during initialisation of the RTOS or after expiry of its timeout period due to other prior invocations of wait-inducing system calls. 

	{ #if (!STAND_ALONE_ISR_00) 	 case 0:						 /* Interrupt number 0 */ */ */

	 task[Running].intnum = IE0_INT;	

/* Task made to wait for  /* external interrupt 0 

	 QShift();					 	break; #endif #if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) 	 	 	 case 1: 					 task[Running].intnum = TF0_INT;	 QShift();		 			

/* Interrupt number 1  /* Task made to wait for  /* timer 0 interrupt 

*/ */ */

	break; #endif

121
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_02) 	 case 2: 						

Appendix A: PaulOS_F020.C Source Listing

/* Interrupt number 2 */ /* Task made to wait for	 */

	 task[Running].intnum = IE1_INT;		

	 QShift();					/* external interrupt 1	 */ 	break; #endif

#if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) 	 case 3: 						 /* Interrupt number 3 	 /* Task made to wait for 	 /* timer 1 interrupt 	 */ */ */

	 task[Running].intnum = TF1_INT; 		 	 QShift();					 	break; #endif

#if (!STAND_ALONE_ISR_04) 	 case 4: 						 	 task[Running].intnum = UART0_INT; 	 /* Interrupt number 4 	 /*  Task made to wait for 	 */ */ */

	 QShift();					/* serial port interrupt 	 	break; #endif

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel – as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

122
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if ( (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) ) 	 case 5: 						 	 task[Running].intnum = TF2_INT; 		 		

Appendix A: PaulOS_F020.C Source Listing

/* Interrupt number 5 	 /*  Task made to wait for 	 /* timer 1 interrupt 	 */

*/ */

	 QShift();			 	break; #endif #if (!STAND_ALONE_ISR_06)

	 case 6: 						 	 task[Running].intnum = SPIF_INT;		

/* Interrupt number 6	*/ /* Task made to wait for 	 */ */

	 QShift();					/* serial peripheral interface 	 	break; #endif #if (!STAND_ALONE_ISR_07) 	 case 7: 						 	 task[Running].intnum = SI_INT; 		 /* Interrupt number 7 	 /*  Task made to wait for 	 */ */

	 QShift();					/* SMBus interface */ 	break; #endif #if (!STAND_ALONE_ISR_08) 	 case 8: 						 	 task[Running].intnum = AD0WIN_INT; 	 	 QShift();					 	break; #endif	 #if (!STAND_ALONE_ISR_09) 	 case 9: 						 /* Interrupt number 9 	 /* Task made to wait for 	 */ */ */ /* Interrupt number 8 	 /* Task made to wait for 	 /* ADC0 Window comparator 	 */ */ */

	 task[Running].intnum = PCA_INT;		 	 QShift();					 	break; #endif #if (!STAND_ALONE_ISR_10) 	 case 10:						 	 task[Running].intnum = CP0FIF_INT; 	 	 QShift();					 	break; #endif

/* Programmable Counter Array 	

/* Interrupt number 10 	 /* Task made to wait for 	

*/ */

/* comparator 0 Falling Edge 	 */

123
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_11) 	 case 11: 						

Appendix A: PaulOS_F020.C Source Listing

/* Interrupt number 11 */ /* Task made to wait for 	 */

	 task[Running].intnum = CP0RIF_INT; 	 	 QShift();					 	break; #endif #if (!STAND_ALONE_ISR_12) 	 case 12:						 	 task[Running].intnum = CP1FIF_INT; 	 	 QShift();					 	break; #endif #if (!STAND_ALONE_ISR_13) 	 case 13:						 	 task[Running].intnum = CP1RIF_INT; 	 	 QShift();					 	break; #endif #if ( (TICK_TIMER != 3) && (!STAND_ALONE_ISR_14) ) 	 case 14: 						 	 task[Running].intnum = TF3_INT; 		

/* comparator 0 Rising Edge 	*/

/* Interrupt number 12 	 /* Task made to wait for 	

*/ */

/* comparator 1 Falling Edge 	 */

/* Interrupt number 13 	 /* Task made to wait for 	

*/ */

/* comparator 1 Rising Edge 	*/

/* Interrupt number 14 	 /*  Task made to wait for */ /* timer 3 interrupt 	 */

*/

	 QShift();					 	break; #endif #if (!STAND_ALONE_ISR_15) 	 case 15: 						 	 task[Running].intnum = AD0INT_INT; 	 	 QShift();					 	break; #endif #if (!STAND_ALONE_ISR_16) 	 case 16: 						 	 task[Running].intnum = TF4_INT; 		 	 QShift();					 	break; #endif

/* Interrupt number 15 	 /* Task made to wait for */ /* ADC0 end of conversion 	

*/

*/

/* Interrupt number 16 	 /* Task made to wait for 	 /* timer 4 interrupt 	 */

*/ */

124
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_17) 	 case 17: 						 	 task[Running].intnum = AD1INT_INT; 	 	 QShift();					 	break; #endif

Appendix A: PaulOS_F020.C Source Listing

/* Interrupt number 17 	 /* Task made to wait for 	 /* ADC1 end of conversion 	

*/ */ */

#if (!STAND_ALONE_ISR_18) 	 case 18: 						 	 task[Running].intnum = IE6_INT; 		 	 QShift();			 	break; #endif 		 /* Interrupt number 18 	 /* Task made to wait for 	 /* external interrupt 6 	 */ */ */

#if (!STAND_ALONE_ISR_19) 	 case 19: 						 	 task[Running].intnum = IE7_INT; 		 	 QShift();					 	break; #endif /* Interrupt number 19 	 /* Task made to wait for 	 /* external interrupt 7 	 */ */ */

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

125
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_20) 	 case 20: 						 	 task[Running].intnum = UART1_INT; 	

Appendix A: PaulOS_F020.C Source Listing

/* Interrupt number 20 	 /* Task made to wait for 	 */

*/ */

	 QShift();					/* UART1 interrupt 	 	break; #endif

#if (!STAND_ALONE_ISR_21) 	 case 21: 						 	 task[Running].intnum = XTLVLD_INT; 	 /* Interrupt number 21 	 /* Task made to wait for 	 */ */

	 QShift();					/* External Crystal Osc. Ready interrupt */ 	break; #endif

	default: 	 EA = 1;

	break; } }

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_DEFER * * Function type: Task Suspension System call * * Description 	 :  This system call is used to stop the current task in order for the next * 			 *				 * * Arguments 	 : None * * Returns 	 * : None 	 task in the queue to execute. In the meantime the current task is placed at the end of the queue. 

126
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

void OS_DEFER(void) { 	 	 EA = 0; task[Running].timeout = 2;	 					 	 } QShift();			 	 /* Task added to the waiting  /*  queue, for 2 tick times, prior to  /* causing a task switch  */ */ */

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_KILL_IT * * Function type: Task Suspension System call * * Description 	 :  This system call kills the current task, by putting it permanently waiting, * 		 * 		 * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ : None such that it never executes again. It also clears any set waiting signals  which the task might have.

void OS_KILL_IT(void) { 	 EA = 0; /* Task is killed by clearing its flags 	 */

	 task[Running].flags = 0;	 	 	

task[Running].intnum = NO_INTERRUPT; /* setting it to wait forever 	 */

	 task[Running].timeout = NOT_TIMING;	

127
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 task[Running].interval_count = 0;	 	 QShift();					 }

Appendix A: PaulOS_F020.C Source Listing
/* Task’s periodic interval count is set to zero*/ /* and then cause a task switch. 	 */

/* ********************************************************************************************** */

/* ********************************************************************************************** * * Function name: OS_RESUME_TASK * * Function type: Inter-task Communication System call * * Description 	 :  This system call is used to resume another KILLed task. * * Arguments 	 : task		 Represents the task to which is to be restarted. * * Returns 	 : None

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

128
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

PaulOS F020: An RTOS for the C8051F020
*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

void OS_RESUME_TASK (uchar tasknum) { 	 EA = 0;

	

if (task[tasknum].interval_reload != 0) 						 /*  if task was a KILLed periodic task */

	 task[tasknum].interval_count = 1; /* resume periodic task otherwise */ 	else 	 task[tasknum].timeout = 1;		 	 task[Running].timeout = 2; 	 QShift();			 				 } /* ********************************************************************************************** */ /* resume normal waiting task after 1 tick */

/* Place the current task waiting for the */ /* next 2 ticks in the waiting state, thus  /*  giving up its time for other tasks.  */ */

/* ********************************************************************************************** * * Function name: QShift * * Function type: Context Switcher (Internal function) * * Description 	 :  This function is used to perform a context switch i.e. task swapping * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ : None

void QShift (void) using 1 {

129
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 	 	 uchar data i, temp; uchar idata * idata internal; uchar data * idata qtask; uchar data * idata qptr;

Appendix A: PaulOS_F020.C Source Listing

	

TinQFlag = 0;

	 task[Running].stackptr = temp = SP;	 	 internal = MAINSTACK;

/* Current task’s SP is saved */

						/*  Current task’s USED stack area is saved */ 	 	 	 	} 	 while (internal<=temp); /* READY queue is shifted down */ i = 0; do { task[Running].stack[i++] = *(internal++);

	 qtask = ReadyQ;				 	 	 qptr = ReadyQ + 1; while (qtask <= ReadyQTop)		

/* by one position		

*/

	{ 	 	} 	 ReadyQTop--;/* Pointer to last task in queue is decremented */ *qtask++ = *qptr++;

	 if (ReadyQTop < ReadyQ)	/* Ensure that this pointer is never 	 ReadyQTop = ReadyQ;	 	 if (Priority == 1) 		

*/ */

/* below the start of the READY queue /* If task priorities are enabled */

	{ 					 	 qptr = ReadyQTop; 		 	 while (qptr > ReadyQ) 	 	{ 					 /* the one having the smallest */ /* the queue is sorted such that */ /* the highest priority task */ */

/* becomes the running task, i.e. 

					/* task number.	 */ 					 		 		 		 qptr--; if (*qptr > *(qptr + 1)) { temp = *qptr; *qptr = *(qptr + 1); *(qptr + 1) = temp; /* Just one scan through the list */

			 			 			

130
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
		 	 } 					 	 Running = ReadyQ[0];		 } }

Appendix A: PaulOS_F020.C Source Listing

/* The first task in the READY queue */ /* becomes the new running task	 */

					/* The new running task’s stack */ 					/* area is copied to internal RAM */ 	 	 	 	 	 	 	} 	 while (internal<=temp); temp = task[Running].stackptr; internal = MAINSTACK; /*  The new running task’s USED stack area is copied to internal RAM */ i=0; do { *(internal++) = task[Running].stack[i++];

	 SP = task[Running].stackptr;	 					 	 } EA = 1;

/* The new running task’s SP is restored */ /*  such that the new task will execute. */

AXA Global Graduate Program
Find out more and apply

131
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */

/* ********************************************************************************************** * * Function name: Xtra_Int_0 * * Function type: Interrupt Service Routine * * Description 	 :  This is the external 0 interrupt ISR whose associated interrupt no. is 0. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ : None

#if (!STAND_ALONE_ISR_00) void Xtra_Int_0 (void) interrupt 0 using 1 { 	 	 } #endif EA = 0; Xtra_Int(IE0_INT); /* Passes EXT0W for identification purposes */

/* ********************************************************************************************** * * Function name: RTOS_Timer_Int * * Function type: Scheduler Interrupt Service Routine * * Description 	 :  This is the RTOS scheduler ISR. It generates system ticks and calculates * 		 * * Arguments 	 : None * any remaining waiting and periodic interval time for each task. 

132
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* Returns 	 * : None

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************** */ #if (TICK_TIMER == 0)	 		 /*  If Timer 0 is used for the scheduler  */

void RTOS_Timer_Int (void) interrupt 1 using 1 { 	 	 	 	 	 uchar data k;			 uchar data * idata q; 		 bit data On_Q; TH0 = BASIC_TICK / 256; 	 TL0 = BASIC_TICK % 256; /* If Timer 1 is used for the scheduler */ /* Timer registers reloaded */ /* Timer 0 is used */ /* for scheduling.			 */

#elif (TICK_TIMER == 1)	

void RTOS_Timer_Int (void) interrupt 3 using 1 { 	 	 	 	 	 uchar data k;		 /* Timer 1 is used */ */

uchar data * idata q; /* for scheduling.			 bit data On_Q; TH1 = BASIC_TICK / 256; 	 TL1 = BASIC_TICK % 256; /* Timer registers reloaded */

#elif (TICK_TIMER == 2)	

/* If Timer 2 is used for the scheduler */

void RTOS_Timer_Int (void) interrupt 5 using 1 { 	 	 	 	 uchar data k; 		 /* For the 8032, Timer 2 is used */ */

uchar data * idata q; 	 /* for scheduling.			 bit data On_Q; TF2 = 0;			

/* Timer 2 interrupt flag is cleared */ /* If Timer 3 is used for the scheduler */

#elif (TICK_TIMER == 3)	

void RTOS_Timer_Int (void) interrupt 14 using 1 { 	 	 	 	 uchar data k; 		 uchar data * idata q; 	 bit data On_Q; TMR3CN &= ~TF3;		 /* Timer 3 interrupt flag is cleared */ /* For the 8032, Timer 2 is used */ /* for scheduling.			 */

133
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#endif

Appendix A: PaulOS_F020.C Source Listing

	

for (k = 0; k < NOOFTASKS; k++)

	{ 	 if (task[k].interval_count != NOT_TIMING) /* Updates the tasks’ */ 	{ 							/*  periodic intervals. */ 		 		 		 task[k].interval_count--; if (task[k].interval_count == NOT_TIMING) { task[k].interval_count = task[k].interval_reload; if (task[k].flags & SIGV_Flag)

			 			

			{ 								/*  If periodic interval	 */ 				 task[k].flags &= ~SIGV_Flag; /* has elapsed and the	 */ 				 q = ReadyQ; 			 				 On_Q = 0; 			 				 while (q <= ReadyQTop)	 /* task has been waiting	*/ /* for this to occur, the 	 /* task is placed in the 	 */ */ */

								/*  READY queue, if it is	 				{

134
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
					 if (k == *q) 		

Appendix A: PaulOS_F020.C Source Listing
/* verified that the task	 */

								/*  does not already reside	 */ 					{ 						 On_Q = 1; 	 				 		 break; 		 /* in the queue, as now 	 /* the task no longer 	 */ */

								/*  requires to wait.		*/ 					} 					q++; 				} 				 if (On_Q == 0)

				{ 				 				 				 				} 			} 								/*  If however the task 	 */ 								/*  was not waiting for 	 */ ReadyQTop++; *ReadyQTop = k; TinQFlag = 1;

								/*  this event, the task 	 */ 								 /*  is not place in the 	 */

								/*  the ready queue. 		*/ 			else 				 		 	} 	 if (task[k].timeout != NOT_TIMING) } task[k].flags |= SIGV_Flag;

	{ 								/* Updates the tasks’		*/ 		 		 		 task[k].timeout--;				 if (task[k].timeout == NOT_TIMING) { */ */ */ */ /* timeout variables. 	 */

			ReadyQTop++; 				/* If a waiting task’s 	 			 			 *ReadyQTop = k; 			 TinQFlag = 1;	 			 /* timeout elapses 		 /* the task is placed 	

			 task[k].flags &= ~SIGW_Flag; 	 /* in the ready queue. 		 		 	} 	 	 	 /* If the idle task is running, when tasks are */ /* known to reside in the queue, a task switch */ /* is purposely induced so these tasks can run. */ }

135
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	} 	 	 } if ((TinQFlag == 1) && (Running == IDLE_TASK)) QShift();

Appendix A: PaulOS_F020.C Source Listing

/* ********************************************************************************************* */

/* ********************************************************************************************* Here are the Interrupt Service routines handlers for ALL the C8051F020 interrupts ********************************************************************************************* */

/* ********************************************************************************************* * * Function name: Xtra_Int_1 * * Function type: Interrupt Service Routine * * Description 	 :  This is the Timer 0 ISR whose associated interrupt number is 1. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) /* Timer 0 interrupt used for RTOS on 8051 */

void Xtra_Int_1 (void) interrupt 1 using 1 { 	 	 } EA = 0; Xtra_Int(TF0_INT); /* Passes TF0_INT for identification purposes */

136
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#endif /*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* */

/* ********************************************************************************************* * * Function name: Xtra_Int_2 * * Function type: Interrupt Service Routine * * Description 	 :  This is the external 1 interrupt ISR whose associated int. number is 2. * * Arguments 	 : None * * Returns 	 * */ #if (!STAND_ALONE_ISR_02) : None

I’M WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

137
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
void Xtra_Int_2 (void) interrupt 2 using 1 { 	 	 } #endif /* EA = 0;

Appendix A: PaulOS_F020.C Source Listing

Xtra_Int(IE1_INT); /* Passes IE1_INT for identification purposes */

********************************************************************************************* */

/* ********************************************************************************************* * * Function name: Xtra_Int_3 * * Function type: Interrupt Service Routine * * Description 	 : T his is the Timer 1 ISR whose associated interrupt number is 3. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) : None

void Xtra_Int_3 (void) interrupt 3 using 1 { 	 	 } EA = 0; Xtra_Int(TF1_INT); /* Passes TF1_INT for identification purposes */

#endif /* ********************************************************************************************* */

/*

138
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* * * Function name: Xtra_Int_4 * * Function type: Interrupt Service Routine * * Description 	 :  This is the serial port ISR whose associated interrupt number is 4. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if (!STAND_ALONE_ISR_04) void Xtra_Int_4 (void) interrupt 4 using 1 { 	 	 } #endif /* ********************************************************************************************* */ EA = 0; Xtra_Int(UART0_INT); /* Passes UART0_INT for identification purposes */ : None

/* ********************************************************************************************* * * Function name: Xtra_Int_5 * * Function type: Interrupt Service Routine * * Description 	 : This is the Timer 2 ISR whose associated interrupt number is 5. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* : None

139
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*/ #if ( (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) )

Appendix A: PaulOS_F020.C Source Listing

void Xtra_Int_5 (void) interrupt 5 using 1 { 	 	 EA = 0; TF2 = 0; 			 /* may be cleared in the task itself */ /* Passes TF2_INT for identification purposes */

	 Xtra_Int(TF2_INT); 	 } #endif

/* ********************************************************************************************* * * Function name: Xtra_Int_6 * * Function type: Interrupt Service Routine * * Description 	 :  This is the SPI interrupt ISR whose associated interrupt number is 6. *

If it really matters, make it happen – with a career at Siemens.

siemens.com/careers

140
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
* Arguments 	 : None * * Returns 	 * : None

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* */ #if (!STAND_ALONE_ISR_06) void Xtra_Int_6 (void) interrupt 6 using 1 { 	 	 } #endif EA = 0; Xtra_Int(SPIF_INT); /* Passes SPIF_INT for identification purposes */

/* ********************************************************************************************* * * Function name: Xtra_Int_7 * * Function type: Interrupt Service Routine * * Description 	 :  This is the SI interrupt ISR whose associated interrupt number is 7. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if (!STAND_ALONE_ISR_07) void Xtra_Int_7 (void) interrupt 7 using 1 { 	 	 } #endif EA = 0; Xtra_Int(SI_INT); /* Passes SI_INT for identification purposes */

/* *********************************************************************************************

141
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* Function name: Xtra_Int_8 * * Function type: Interrupt Service Routine *

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This is the AD0 interrupt ISR whose associated interrupt number is 8. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if (!STAND_ALONE_ISR_08) void Xtra_Int_8 (void) interrupt 8 using 1 { 	 	 } #endif EA = 0; Xtra_Int(AD0WIN_INT); /* Passes AD0WIN_INT for identification purposes */

/* ********************************************************************************************** * * Function name: Xtra_Int_9 * * Function type: Interrupt Service Routine * * Description 	 :  This is the PCA interrupt ISR whose associated interrupt number is 9. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************** */ 	 : None

#if (!STAND_ALONE_ISR_09) void Xtra_Int_9 (void) interrupt 9 using 1 {

142
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 } #endif /* EA = 0;

Appendix A: PaulOS_F020.C Source Listing

Xtra_Int(PCA_INT); /* Passes PCA_INT for identification purposes */

********************************************************************************************* * * Function name: Xtra_Int_10 * * Function type: Interrupt Service Routine * * Description 	 :  This is the CP0 interrupt ISR whose associated interrupt number is 10. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

143
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_10) void Xtra_Int_10 (void) interrupt 10 using 1 { 	 EA = 0;

Appendix A: PaulOS_F020.C Source Listing

	 Xtra_Int(CP0FIF_INT); /* Passes CP0FIF_INT for identification purposes  } #endif

*/

/* ********************************************************************************************* * * Function name: Xtra_Int_11 * * Function type: Interrupt Service Routine * * Description 	 :  This is the CP0 interrupt ISR whose associated interrupt number is 11. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if (!STAND_ALONE_ISR_11) void Xtra_Int_11 (void) interrupt 11 using 1 { 	 EA = 0; */

	 Xtra_Int(CP0RIF_INT); /* Passes CP0RIF_INT for identification purposes  } #endif

/* ********************************************************************************************* * * Function name: Xtra_Int_12 * * Function type: Interrupt Service Routine *

144
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

* Description 	 : This is the CP1 interrupt ISR whose associated interrupt number is 12. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if (!STAND_ALONE_ISR_12) void Xtra_Int_12 (void) interrupt 12 using 1 { 	 EA = 0; */ : None

	 Xtra_Int(CP1FIF_INT); /* Passes CP1FIF_INT for identification purposes  } #endif /*

********************************************************************************************* * * Function name: Xtra_Int_13 * * Function type: Interrupt Service Routine * * Description 	 :  This is the CP1 interrupt ISR whose associated interrupt number is 13. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if (!STAND_ALONE_ISR_13) void Xtra_Int_13 (void) interrupt 13 using 1 { 	 EA = 0; */ : None

	 Xtra_Int(CP1RIF_INT); /* Passes CP1RIF_INT for identification purposes  } #endif

/*

145
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* * * Function name: Xtra_Int_14 * * Function type: Interrupt Service Routine * * Description 	 :  This is the Timer 3 interrupt ISR whose associated interrupt number is 14. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It’s not what we do. It’s how we do it.

Impact matters.
navigant.com

©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

146
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if ( (TICK_TIMER != 3) && (!STAND_ALONE_ISR_14) ) void Xtra_Int_14 (void) interrupt 14 using 1 { 	 	 EA = 0;

Appendix A: PaulOS_F020.C Source Listing

TMR3CN &= 0x7F; /* may be cleared in the task itself */ */

	 Xtra_Int(TF3_INT); /* Passes TF3_INT for identification purposes  } #endif

/* ********************************************************************************************* * * Function name: Xtra_Int_15 * * Function type: Interrupt Service Routine * * Description 	 : This is the AD0 interrupt ISR whose associated interrupt number is 15. * * Arguments 	 : None * * Returns 	 * ******************************************************************************************* **	 */ : None

#if (!STAND_ALONE_ISR_15) void Xtra_Int_15 (void) interrupt 15 using 1 { 	 EA = 0; */

	 Xtra_Int(AD0INT_INT); /* Passes AD0INT_INT for identification purposes  } #endif

/* ********************************************************************************************* * * Function name: Xtra_Int_16 * * Function type: Interrupt Service Routine

147
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*

Appendix A: PaulOS_F020.C Source Listing

* Description 	 :  This is the Timer 4 interrupt ISR whose associated interrupt number is 16. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if (!STAND_ALONE_ISR_16) void Xtra_Int_16 (void) interrupt 16 using 1 { 	 EA = 0; */

	 Xtra_Int(TF4_INT); /* Passes TF4_INT for identification purposes  } #endif

/* ********************************************************************************************* * * Function name: Xtra_Int_17 * * Function type: Interrupt Service Routine * * Description 	 : This is the AD1 interrupt ISR whose associated interrupt number is 17. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

#if (!STAND_ALONE_ISR_17) void Xtra_Int_17 (void) interrupt 17 using 1 { 	 EA = 0;

	 Xtra_Int(AD1INT_INT); 	 /* Passes AD1INT_INT for identification purposes */ } #endif

148
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/*

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* * * Function name: Xtra_Int_18 * * Function type: Interrupt Service Routine * * Description 	 :  This is the IE6 interrupt ISR whose associated interrupt number is 18. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ : None

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There’s no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives — and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It’s why we employ 135 different nationalities. It’s why we’ve taken proactive steps to increase female representation at the highest levels. And it’s just one of the reasons why you’ll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

149
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
#if (!STAND_ALONE_ISR_18) void Xtra_Int_18 (void) interrupt 18 using 1 { 	 	 } #endif /* EA = 0; Xtra_Int(IE6_INT);	

Appendix A: PaulOS_F020.C Source Listing

/* Passes IE6_INT for identification purposes */

********************************************************************************************* * * Function name: Xtra_Int_19 * * Function type: Interrupt Service Routine * * Description 	 :  This is the IE7 interrupt ISR whose associated interrupt number is 19. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if (!STAND_ALONE_ISR_19) void Xtra_Int_19 (void) interrupt 19 using 1 { 	 EA = 0; */ : None

	 Xtra_Int(IE7_INT); /* Passes IE7_INT for identification purposes  } #endif /*

********************************************************************************************* * * Function name: Xtra_Int_20 * * Function type: Interrupt Service Routine * * Description 	 :  This is the UART1 interrupt ISR whose associated interrupt number is 20. *

150
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
* Arguments 	 : None * * Returns 	 * : None

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* */ #if (!STAND_ALONE_ISR_20) void Xtra_Int_20 (void) interrupt 20 using 1 { 	 EA = 0; */

	 Xtra_Int(UART1_INT); /* Passes UART1_INT for identification purposes  } #endif /*

********************************************************************************************* * * Function name: Xtra_Int_21 * * Function type: Interrupt Service Routine * * Description 	 :  This is the XTL interrupt ISR whose associated interrupt number is 21. * * Arguments 	 : None * * Returns 	 * ********************************************************************************************* */ #if (!STAND_ALONE_ISR_21) void Xtra_Int_21 (void) interrupt 21 using 1 { 	 EA = 0; */ : None

	 Xtra_Int(XTLVLD_INT); /* Passes XTLVLD_INT for identification purposes  } #endif /*

*********************************************************************************************

151
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*/

Appendix A: PaulOS_F020.C Source Listing

/* ********************************************************************************************* * * Function name: Xtra_Int * * Function type: Interrupt Handling (Internal function) * * Description 	 :  This function performs the operations required by the previous ISRs. * * Arguments 	 : task_intflag		 Represents the flag mask for a given interrupt * 					against which the *					 byte storing the flags of each task will be * 					 compared in order to

*					 determine whether any task has been waiting for * 					 * * Returns 	 * : None the interrupt in question.

Real drive. Unreal destination.

As an intern, you’re eager to put what you’ve learned to the test. At Ernst & Young, you’ll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You’ll also get to test what you learn. Even better, you’ll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

© 2012 Ernst & Young LLP. All Rights Reserved.

152
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

********************************************************************************************* */

void Xtra_Int (uchar current_intnum) using 1 { 	 	 	 uchar data k; IntFlag = 0; for (k = 0; k < NOOFTASKS; k ++)

	{ 	 if (task[k].intnum == current_intnum)

	{ 		 		 		 		 		 	 	 }		 }				 task[k].intnum = NO_INTERRUPT; IntFlag = 1; task[k].timeout = NOT_TIMING; 	 ReadyQTop++;		  *ReadyQTop = k;	  		 		 /*  If it found that a task */ /* has been waiting for the */ /* given interrupt, it no	 /*  longer requires to wait */ /*  and is therefore placed */ */

				 			

							/* on the READY queue. */

	

if ((IntFlag == 1) && (Running == IDLE_TASK))

	{ 	 	 TinQFlag = 1;	 QShift(); 		 /*  If tasks are known to now reside in the */ /*  READY queue while the idle task is */ */

	 }				 /*  running, a task switch is purposely	 	 /* induced, such that these tasks can run. */

	

else if ((IntFlag == 1) && (Running != IDLE_TASK))

	{ 				 	 TinQFlag = 1; 	 				 	 	} 	 } else EA = 1;		 /* Otherwise exit normally */ EA = 1; /* Otherwise, the ISR exits after */ /* interrupts are re-enabled, */ /* since the RTOS cannot pre-empt task */

/* ********************************************************************************************* */

153
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix A: PaulOS_F020.C Source Listing

A.5	C8051F020.H
#ifndef _C8051F020_H_ #define _C8051F020_H_

/*----------------------------------------------------------------------------------------------------------------;	 ;	 ; ; ;	 ;	 ;	 ; ;	 ; ; 	 Extra sfr16 declarations and additional bit definitions have been added to the non-bit-addressable ; 		 SFRs – P. Debono ;-----------------------------------------------------------------------------------------------------------------*/ /* BYTE Registers */ sfr P0			 sfr SP 			 sfr DPL 		 	 sfr DPH 		 sfr P4 			 sfr P5 			 sfr P6 			 sfr PCON 		 sfr TCON 		 sfr TMOD 		 sfr TL0 			 sfr TL1 			 sfr TH0 			 sfr TH1 			 sfr CKCON 		 sfr PSCTL 		 sfr P1 			 sfr TMR3CN 		 sfr TMR3RLL 		 = 0x80;		 = 0x81	 ;	 = 0x82;		 = 0x83;		 = 0x84; 		 = 0x85;	 	 = 0x86; 	/*	 = 0x87;		 = 0x88;		 = 0x89;		 = 0x8A;		 = 0x8B;		 = 0x8C;		 = 0x8D;		 = 0x8E;		 = 0x8F;		 = 0x90;		 = 0x91;		 = 0x92;		 /* PORT 0			 */ */ */ */ */ */ */ */ */ */ */ */ */ */ */ REVISION 1.1 FILE NAME 	 : C8051F020.H TARGET MCUs	 : C8051F020, ‘F021, ‘F022, ‘F023 DESCRIPTION	 : Register/bit definitions for the C8051F02x product family. Copyright (C) 2001 CYGNAL INTEGRATED PRODUCTS, INC. All rights reserved.

/* STACK POINTER 			 /* DATA POINTER – LOW BYTE		 /* DATA POINTER – HIGH BYTE		 /* PORT 4			 /* PORT 5 			 /* POWER CONTROL		 /* TIMER MODE 		 /* TIMER 0 – LOW BYTE 		 /* TIMER 1 – LOW BYTE 		 /* TIMER 0 – HIGH BYTE 		 /* TIMER 1 – HIGH BYTE 		 /* CLOCK CONTROL 			 /* PROGRAM STORE R/W CONTROL 	 /* PORT 1			 /* TIMER 3 CONTROL 		 */ */

PORT 6				 */ /* TIMER CONTROL 			

/* TIMER 3 RELOAD REGISTER – LOW BYTE */ 154

Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 sfr TMR3RLH 		 sfr TMR3L 		 sfr TMR3H 		 sfr P7			 sfr SCON0 		 sfr SBUF0 		 sfr SPI0CFG 		 sfr SPI0DAT 		 sfr ADC1 		 sfr SPI0CKR 		 sfr CPT0CN 		 sfr CPT1CN 		 sfr P2 			 sfr EMI0TC 		 sfr EMI0CF 		 sfr P0MDOUT 		 sfr P1MDOUT 		 sfr P2MDOUT 		 sfr P3MDOUT 		 sfr IE 			 = 0x93;		 = 0x94;		 = 0x95	 ;	 = 0x96; 		 = 0x98;		 = 0x99	 ;	 = 0x9A;		 = 0x9B;		 = 0x9C; 	 = 0x9E;		 = 0x9F;		 = 0xA0;		 = 0xA1; 	 = 0xA4;		 = 0xA5;		 = 0xA6;		 = 0xA7;		 = 0xA8;		

Appendix A: PaulOS_F020.C Source Listing /* TIMER 3 RELOAD REGISTER – HIGH BYTE */ /* TIMER 3 – LOW BYTE 		 /* TIMER 3 – HIGH BYTE 		 /* PORT 7 			 */ */ */ /* SERIAL PORT 0 CONTROL 		 /* SERIAL PORT 0 BUFFER 		 */ */

/* SERIAL PERIPHERAL INTERFACE 0 CONFIGURATION */ /* SERIAL PERIPHERAL INTERFACE 0 DATA */ /* ADC 1 DATA 			 /* COMPARATOR 0 CONTROL	 /* PORT 2 		 */ */ */ */

= 0x9D;	 /* SERIAL PERIPHERAL INTERFACE 0 CLOCK RATE CONTROL */ /* COMPARATOR 1 CONTROL 	 */ /* EMIF TIMING CONTROL 		

= 0xA3; 	 /* EXTERNAL MEMORY INTERFACE (EMIF) CONFIGURATION */ /* PORT 0 OUTPUT MODE CONFIGURATION */ /* PORT 1 OUTPUT MODE CONFIGURATION */ /* PORT 2 OUTPUT MODE CONFIGURATION */ /* PORT 3 OUTPUT MODE CONFIGURATION */ /* INTERRUPT ENABLE 		 */

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

155
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020 sfr SADDR0 		 sfr ADC1CN 		 sfr ADC1CF 		 sfr AMX1SL 		 sfr P3IF 			 sfr SADEN1 		 sfr EMI0CN 		 sfr P3 			 sfr OSCXCN 		 sfr OSCICN 		 sfr P74OUT 		 sfr FLSCL 		 sfr FLACL 		 sfr IP 			 sfr SADEN0 		 sfr AMX0CF 		 sfr AMX0SL 		 sfr ADC0CF 		 sfr P1MDIN 		 sfr ADC0L 		 sfr ADC0H 		 sfr SMB0CN 		 sfr SMB0STA 		 sfr SMB0DAT 		 sfr SMB0ADR 		 sfr ADC0GTL 		 sfr ADC0GTH 		 sfr ADC0LTL 		 sfr ADC0LTH 		 sfr T2CON 		 sfr T4CON 		 sfr RCAP2L 		 sfr RCAP2H 		 sfr TL2 			 sfr TH2 			 sfr SMB0CR 		 sfr PSW 		 	 sfr REF0CN 		 sfr DAC0L 		 sfr DAC0H 		 = 0xA9; 	 = 0xAA; 	 = 0xAB; 	 = 0xAC; 	 = 0xAD; 	 = 0xAE; 	 = 0xAF; 	 = 0xB0;		 = 0xB1	 ;	 = 0xB2;		 = 0xB5; 	 = 0xB6;		 = 0xB7;		 = 0xB8;		 = 0xB9; 	 = 0xBA;		 = 0xBB;		 = 0xBC;		 = 0xBD; 	 = 0xBE;		 = 0xBF;		 = 0xC0;		 = 0xC1;		 = 0xC2;		 = 0xC3;		 = 0xC4;		 = 0xC5;		 = 0xC6;		 = 0xC7;		 = 0xC8;		 = 0xC9; 	 = 0xCA;	 = 0xCB;		 = 0xCC;	 = 0xCD;	 = 0xCF;		 = 0xD0;		 = 0xD1;		 = 0xD2;		 = 0xD3;		

Appendix A: PaulOS_F020.C Source Listing /* SERIAL PORT 0 SLAVE ADDRESS 		 /* ADC 1 CONTROL 			 */ */ */ */ /* ADC 1 ANALOG MUX CONFIGURATION 	 /* ADC 1 ANALOG MUX CHANNEL SELECT */ /* PORT 3 EXTERNAL INTERRUPT FLAGS 	 /* SERIAL PORT 1 SLAVE ADDRESS MASK 	 /* PORT 3 			 */ */

/* EXTERNAL MEMORY INTERFACE CONTROL 	 */ /* EXTERNAL OSCILLATOR CONTROL 	 */ /* INTERNAL OSCILLATOR CONTROL 	 */ /* PORTS 4 – 7 OUTPUT MODE 	 */ /* FLASH MEMORY TIMING PRESCALER 	 /* FLASH ACESS LIMIT 	 */ /* INTERRUPT PRIORITY 	 */ */ */ */ */ */ */ */ /* SERIAL PORT 0 SLAVE ADDRESS MASK	 /* ADC 0 MUX CONFIGURATION 	 /* ADC 0 MUX CHANNEL SELECTION /* ADC 0 CONFIGURATION 		 /* PORT 1 INPUT MODE 		 /* ADC 0 DATA – LOW BYTE 		 /* ADC 0 DATA – HIGH BYTE		 /* SMBUS 0 CONTROL 	 /* SMBUS 0 STATUS 	 /* SMBUS 0 DATA 	 */ */ */ */ */ */ */

/* SMBUS 0 SLAVE ADDRESS 		

/* ADC 0 GREATER-THAN REGISTER – LOW BYTE 	 /* ADC 0 GREATER-THAN REGISTER – HIGH BYTE 	 /* ADC 0 LESS-THAN REGISTER – LOW BYTE */ /* ADC 0 LESS-THAN REGISTER – HIGH BYTE */ /* TIMER 2 CONTROL 		 /* TIMER 4 CONTROL 		 */ */

/* TIMER 2 CAPTURE REGISTER – LOW BYTE 	 */ /* TIMER 2 CAPTURE REGISTER – HIGH BYTE 	 */ /* TIMER 2 – LOW BYTE 		 /* TIMER 2 – HIGH BYTE 		 /* SMBUS 0 CLOCK RATE 		 /* PROGRAM STATUS WORD 		 */ */ */ */ /* VOLTAGE REFERENCE 0 CONTROL 		 /* DAC 0 REGISTER – LOW BYTE 		 /* DAC 0 REGISTER – HIGH BYTE 		 */ */ */

156
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 sfr DAC0CN 		 sfr DAC1L 		 sfr DAC1H 		 sfr DAC1CN 		 sfr PCA0CN 		 sfr PCA0MD 		 sfr PCA0CPM0 	 	 sfr PCA0CPM1 	 	 sfr PCA0CPM2 	 	 sfr PCA0CPM3 	 	 sfr PCA0CPM4 	 	 sfr ACC 		 	 sfr XBR0 		 sfr XBR1 		 sfr XBR2 		 sfr RCAP4L 		 sfr RCAP4H 		 sfr EIE1 			 sfr EIE2 		 	 sfr ADC0CN 		 sfr PCA0L 		 sfr PCA0CPL0		 sfr PCA0CPL1		 sfr PCA0CPL2 		 sfr PCA0CPL3 		 sfr PCA0CPL4 		 sfr RSTSRC 		 sfr B 			 sfr SCON1 		 sfr SBUF1 		 sfr SADDR1 		 sfr TL4	 		 sfr TH4 		 sfr EIP1 		 sfr EIP2 		 	 	 	 = 0xD4;		 = 0xD5;		 = 0xD6;		 = 0xD7;		 = 0xD8;		 = 0xD9;		 = 0xDA;		 = 0xDB;		 = 0xDC;		 = 0xDD;		 = 0xDE;		 = 0xE0;		 = 0xE1;		 = 0xE2;		 = 0xE3;		 = 0xE4; 	 = 0xE5; 		 = 0xE6;		 = 0xE7;		 = 0xE8;		 = 0xE9;		 = 0xEA; 	 = 0xEB; 	 = 0xEC; 	 = 0xED; 	 = 0xEE; 	 = 0xEF; 	 = 0xF0; 		 = 0xF1; 		 = 0xF2; 		 = 0xF3; 		 = 0xF4; 		 = 0xF5; 		 = 0xF6; 	 	 = 0xF7; 		 = 0xF8; 		 = 0xF9; 		 = 0xFA; 	 = 0xFB; 	 = 0xFC; 	

Appendix A: PaulOS_F020.C Source Listing /* DAC 0 CONTROL 			 /* DAC 1 REGISTER – LOW BYTE 		 /* DAC 1 REGISTER – HIGH BYTE 		 /* DAC 1 CONTROL 			 /* PCA 0 COUNTER CONTROL 		 /* PCA 0 COUNTER MODE 		 */ */ */ */ */ */

/* CONTROL REGISTER FOR PCA 0 MODULE 0	 */ /* CONTROL REGISTER FOR PCA 0 MODULE 1 	 */ /* CONTROL REGISTER FOR PCA 0 MODULE 2 	 */ /* CONTROL REGISTER FOR PCA 0 MODULE 3 	 */ /* CONTROL REGISTER FOR PCA 0 MODULE 4 	 */ /* ACCUMULATOR 				 */ /* DIGITAL CROSSBAR CONFIGURATION REGISTER 0 */ /* DIGITAL CROSSBAR CONFIGURATION REGISTER 1 */ /* DIGITAL CROSSBAR CONFIGURATION REGISTER 2 */ /* TIMER 4 CAPTURE REGISTER – LOW BYTE 	 */ /* TIMER 4 CAPTURE REGISTER – HIGH BYTE 	 */ /* EXTERNAL INTERRUPT ENABLE 1 	 /* EXTERNAL INTERRUPT ENABLE 2 	 /* ADC 0 CONTROL 			 /* PCA 0 TIMER – LOW BYTE 		 */ */ */ */

/* CAPTURE/COMPARE REG. PCA 0 MODULE 0 – LOW BYTE */ /* CAPTURE/COMPARE REG. PCA 0 MODULE 1 – LOW BYTE */ /* CAPTURE/COMPARE REG. PCA 0 MODULE 2 – LOW BYTE */ /* CAPTURE/COMPARE REG. PCA 0 MODULE 3 – LOW BYTE */ /* CAPTURE/COMPARE REG.PCA 0 MODULE 4 – LOW BYTE */ /* RESET SOURCE 			 /* B REGISTER		 /* SERAIL PORT 1 DATA */ /* SERAIL PORT 1 */ /* TIMER 4 DATA – LOW BYTE */ /* TIMER 4 DATA – HIGH BYTE */ /* EXTERNAL INTERRUPT PRIORITY REGISTER 1 */ /* EXTERNAL INTERRUPT PRIORITY REGISTER 2 */ /* SERIAL PERIPHERAL INTERFACE 0 CONTROL */ /* PCA 0 TIMER – HIGH BYTE */ /* CAPTURE/COMPARE REG. PCA 0 MODULE 0 – HIGH BYTE */ /* CAPTURE/COMPARE REG. PCA 0 MODULE 1 – HIGH BYTE */ /* CAPTURE/COMPARE REG.PCA 0 MODULE 2 – HIGH BYTE */ */ */ */

/* SERIAL PORT 1 CONTROL 			

sfr SPI0CN 		 sfr PCA0H 		 sfr PCA0CPH0 		 sfr PCA0CPH1 		 sfr PCA0CPH2 		

157
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 sfr PCA0CPH3 	 	 sfr PCA0CPH4 		 sfr WDTCN 		 /* = 0xFD; 		 = 0xFE; 		 = 0xFF; 		

Appendix A: PaulOS_F020.C Source Listing /* CAPTURE/COMPARE REG.PCA 0 MODULE 3 – HIGH BYTE */ /* CAPTURE/COMPARE REG.PCA 0 MODULE 4 – HIGH BYTE */ /* WATCHDOG TIMER CONTROL */

16-bit sfr Definitions – enabling 16-bit registers which have consecutive addresses for their low and high byte, to be loaded with one command, aligning the low and high byte correctly (little endian). */ sfr16 DP	 	 sfr16 TMR3RL	 sfr16 TMR3	 sfr16 ADC0	 sfr16 ADC0GT	 sfr16 ADC0LT	 sfr16 RCAP2 	 sfr16 T2		 sfr16 RCAP4	 sfr16 T4	 	 sfr16 DAC0	 sfr16 DAC1	 = 0x82;		 = 0x92;		 = 0x94;		 = 0xBE;		 = 0xC4;		 = 0xC6;		 = 0xCA;	 = 0xCC;	 = 0xE4;		 = 0xF4;		 = 0xD2;		 = 0xD5;		 // data pointer // Timer 3 reload value // Timer 3 counter // ADC0 data // ADC0 greater than window // ADC0 less than window // Timer 2 capture/reload // Timer 2 // Timer 4 capture/reload // Timer 4 // DAC0 data // DAC1 data
�e Graduate Programme for Engineers and Geoscientists

I joined MITAS because I wanted real responsibili� I joined MITAS because I wanted real responsibili�

Maersk.com/Mitas www.discovermitas.com

�e G for Engine

Ma

Real work International Internationa al opportunities �ree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities �ree wo work or placements s solve pr
Click on the ad to read more

158
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* BIT Registers */ /* TCON 0x88 */ sbit TF1 		 sbit TR1 	 sbit TF0 		 sbit TR0 	 sbit IE1 	 	 sbit IT1 	 	 sbit IE0 	 	 sbit IT0 	 	 = TCON ^ 7;	 = TCON ^ 6;	 = TCON ^ 5;	 = TCON ^ 4;	 = TCON ^ 3;	 = TCON ^ 2;	 = TCON ^ 1;	 = TCON ^ 0;	

Appendix A: PaulOS_F020.C Source Listing

/* TIMER 1 OVERFLOW FLAG 	 */ /* TIMER 1 ON/OFF CONTROL 	 */ /* TIMER 0 OVERFLOW FLAG 	 */ /* TIMER 0 ON/OFF CONTROL	 */ /* EXT. INTERRUPT 1 EDGE FLAG */ /* EXT. INTERRUPT 1 TYPE 	 /* EXT. INTERRUPT 0 TYPE 	 */ */ /* EXT. INTERRUPT 0 EDGE FLAG */

/* SCON0 0x98 */ sbit SM00 	 sbit SM10 	 sbit SM20 	 sbit REN0 	 sbit TB80 	 sbit RB80 	 sbit TI0 		 sbit RI0 		 /* IE 0xA8 */ sbit EA 		 sbit ET2 	 sbit ES0 	 	 sbit ET1 	 sbit EX1 	 sbit ET0 	 sbit EX0 	 /* IP 0xB8 */ sbit PT2 	 sbit PS 		 sbit PT1 	 sbit PX1 	 sbit PT0 	 sbit PX0 	 = IP ^ 5; 	 = IP ^ 4; 	 = IP ^ 3;	 = IP ^ 2; 	 = IP ^ 1; 	 = IP ^ 0; 	 /* TIMER 2 PRIORITY					 /* TIMER 1 PRIORITY					 /* EXTERNAL INTERRUPT 1 PRIORITY		 /* EXTERNAL INTERRUPT 0 PRIORITY		 */ */ */ /* TIMER 0 PRIORITY					 */ */ /* SERIAL PORT PRIORITY				*/ = IE ^ 7;	 = IE ^ 5;	 = IE ^ 4;	 = IE ^ 3;	 = IE ^ 2;	 = IE ^ 1;	 = IE ^ 0;	 /* GLOBAL INTERRUPT ENABLE 	 /* TIMER 2 INTERRUPT ENABLE 	 /* UART0 INTERRUPT ENABLE 		 /* TIMER 1 INTERRUPT ENABLE 	 /* TIMER 0 INTERRUPT ENABLE 	 */ */ */ */ */ = SCON0 ^ 7;	 = SCON0 ^ 6;	 = SCON0 ^ 5;	 = SCON0 ^ 4;	 = SCON0 ^ 3;	 = SCON0 ^ 2;	 = SCON0 ^ 1;	 = SCON0 ^ 0;	 /* SERIAL MODE CONTROL BIT 0 	 /* SERIAL MODE CONTROL BIT 1 	 /* RECEIVE ENABLE 		 /* TRANSMIT BIT 8 		 /* RECEIVE BIT 8 		 */ */ */ */ */ */ */

/* MULTIPROCESSOR COMMUNICATION ENABLE 	

/* TRANSMIT INTERRUPT FLAG 		 /* RECEIVE INTERRUPT FLAG 	 */

/* EXTERNAL INTERRUPT 1 ENABLE 	 */ /* EXTERNAL INTERRUPT 0 ENABLE 	 */

159
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* SMB0CN 0xC0 */ sbit BUSY 	 sbit ENSMB 	 sbit STA 	 sbit STO 	 sbit SI 		 sbit AA 	 	 sbit SMBFTE 	 sbit SMBTOE 	 = SMB0CN ^ 7;	 	 = SMB0CN ^ 6;	 	 = SMB0CN ^ 5; 	 	 = SMB0CN ^ 4; 	 	 = SMB0CN ^ 3; 	 	 = SMB0CN ^ 2; 	 	 = SMB0CN ^ 1; 	 	 = SMB0CN ^ 0; 	 	

Appendix A: PaulOS_F020.C Source Listing

/* SMBUS 0 BUSY 		 /* SMBUS 0 ENABLE 		 /* SMBUS 0 START FLAG 	 /* SMBUS 0 STOP FLAG 	 */

*/ */ */

/* SMBUS 0 INTERRUPT PENDING FLAG */ /* SMBUS 0 ASSERT/ACKNOWLEDGE FLAG */ /* SMBUS 0 FREE TIMER ENABLE */ /* SMBUS 0 TIMEOUT ENABLE */

/* T2CON 0xC8 */ sbit TF2 		 sbit EXF2 	 sbit RCLK0	 sbit TCLK0 	 sbit EXEN2 	 sbit TR2 	 sbit CT2 	 sbit CPRL2	 /* PSW */ sbit CY 		 sbit AC 		 sbit F0 		 sbit RS1	 	 sbit RS0	 	 sbit OV	 	 sbit F1 		 sbit P 		 = PSW ^ 7; 	 = PSW ^ 6; 	 = PSW ^ 5;	 = PSW ^ 4; 	 = PSW ^ 3; 	 = PSW ^ 2;	 = PSW ^ 1;	 = PSW ^ 0;	 /* CARRY FLAG 	 /* USER FLAG 0 	 */ */ */ /* AUXILIARY CARRY FLAG 	 /* REGISTER BANK SELECT 1 */ /* REGISTER BANK SELECT 0 */ /* OVERFLOW FLAG 	 /* USER FLAG 1 	 */ */ */ = T2CON ^ 7; 	 /* TIMER 2 OVERFLOW FLAG 	 */ = T2CON ^ 6;	 = T2CON ^ 4;	 = T2CON ^ 2;	 = T2CON ^ 1;	 = T2CON ^ 0;	 /* EXTERNAL FLAG 		 */ = T2CON ^ 5;	 /* UART0 RX CLOCK SOURCE 	 */ /* UART0 TX CLOCK SOURCE 	 */ /* TIMER 2 ON/OFF CONTROL /* TIMER OR COUNTER SELECT /* CAPTURE OR RELOAD SELECT 	 */ */ */ = T2CON ^ 3; 	 /* TIMER 2 EXTERNAL ENABLE FLAG */

/* ACCUMULATOR PARITY FLAG 	

/* PCA0CN D8H */ sbit CF 		 sbit CR 		 sbit CCF4 	 sbit CCF3 	 sbit CCF2 	 sbit CCF1 	 sbit CCF0 	 = PCA0CN ^ 7; 	/* PCA 0 COUNTER OVERFLOW FLAG */ = PCA0CN ^ 6; 	/* PCA 0 COUNTER RUN CONTROL BIT */ = PCA0CN ^ 4; 	/* PCA 0 MODULE 4 INTERRUPT FLAG */ = PCA0CN ^ 3; 	/* PCA 0 MODULE 3 INTERRUPT FLAG */ = PCA0CN ^ 2; 	/* PCA 0 MODULE 2 INTERRUPT FLAG */ = PCA0CN ^ 1; 	/* PCA 0 MODULE 1 INTERRUPT FLAG */ = PCA0CN ^ 0; 	 /* PCA 0 MODULE 0 INTERRUPT FLAG */

160
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* ADC0CN E8H */ sbit AD0EN 	 sbit AD0TM 	 sbit AD0INT 	 sbit AD0CM1 	 sbit AD0CM0 	 sbit AD0LJST 	 = ADC0CN ^ 7;		 = ADC0CN ^ 6; 	 = ADC0CN ^ 5; 	 = ADC0CN ^ 3; 	 = ADC0CN ^ 2; 	 = ADC0CN ^ 0; 		

Appendix A: PaulOS_F020.C Source Listing

/* ADC 0 ENABLE 		

*/ */ */

/* ADC 0 TRACK MODE 		 /* ADC 0 BUSY FLAG 		 */

/* ADC 0 CONVERISION COMPLETE INTERRUPT FLAG  /* ADC 0 START OF CONVERSION MODE BIT 1 */ /* ADC 0 START OF CONVERSION MODE BIT 0 */ /* ADC 0 WINDOW COMPARE INTERRUPT FLAG */ /* ADC 0 RIGHT JUSTIFY DATA BIT 		 */

sbit AD0BUSY 	 = ADC0CN ^ 4; 	

sbit AD0WINT	 = ADC0CN ^ 1; 	

/* SPI0CN F8H */ sbit SPIF 	 sbit WCOL 	 sbit MODF 	 sbit TXBSY 	 sbit SLVSEL 	 sbit MSTEN 	 sbit SPIEN 	 = SPI0CN ^ 7; 	 /* SPI 0 INTERRUPT FLAG			 = SPI0CN ^ 6; 	 /* SPI 0 WRITE COLLISION FLAG	 = SPI0CN ^ 5; 	 = SPI0CN ^ 3; 	 = SPI0CN ^ 1; 	 /* SPI 0 MODE FAULT FLAG		 /* SPI 0 TX BUSY FLAG			 */ */ */ */ */ */ */ */

sbit RXOVRN 	 = SPI0CN ^ 4; 	 /* SPI 0 RX OVERRUN FLAG		 = SPI0CN ^ 2; 	 /* SPI 0 SLAVE SELECT		

/* SPI 0 MASTER ENABLE			

= SPI0CN ^ 0; 	 /* SPI 0 SPI ENABLE				

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

161
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020 /*

Appendix A: PaulOS_F020.C Source Listing

EXTRA: BIT definitions for bits held in SFRs that are not bit-addressable and hence not directly accessible */ /* TMOD Bits */ #define T0M0		 #define T0M1		 #define C_T0		 #define GATE0		 #define T1M0		 #define T1M1		 #define C_T1		 #define GATE1		 /* CKCON Bits */ #define T0M	 #define T1M	 #define T2M	 #define T4M	 /* PSCTL Bits */ #define PSWE		 #define PSEE		 #define SFLE		 /* TMR3CN Bits */ #define T3XCLK		 #define T3M	 #define TR3	 #define TF3	 /* P7 Bits */ #define P7_0		 #define P7_1		 #define P7_2		 #define P7_3		 #define P7_4		 #define P7_5		 #define P7_6		 0x01 0x02 0x04 0x08 0x10 0x20 0x40 	 	 	 0x01	 0x02	 0x04	 0x80	 /* Timer 3 external clock select */ /* Timer 3 clock select */ /* Timer 3 Run control */ /* Timer 3 overflow flag */ 0x01	 0x02	 0x04	 /* Program Store Write Enable */ /* Program Store Erase Enable */ /* Scratch pad Flash memory access enable */ 	 	 	 	 0x08	 0x10	 0x20	 0x40	 /* Timer 0 clock select */ /* Timer 1 clock select */ /* Timer 2 clock select */ /* Timer 4 clock select */ 0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80

162
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 #define P7_7		 /* SPI0CFG Bits */ #define SPIFRS0	 	 #define SPIFRS1	 	 #define SPIFRS2	 	 #define BC0	 #define BC1	 #define BC2	 	 	 	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* SPI0 Frame Size, bit 0 */ /* SPI0 Frame Size, bit 1 */ /* SPI0 Frame Size, bit 2 */ /* SPI0 Bit Count, bit 0 */ /* SPI0 Bit Count, bit 1 */ /* SPI0 Bit Count, bit 2 */ /* SPI0 Clock polarity */ /* SPI0 Clock phase */ 0x80

Appendix A: PaulOS_F020.C Source Listing

#define CKPOL		 #define CKPHA		

/* SPI0DAT Bits, data only no bits*/ /* ADCI Bits, data word register, no bits */ /* SPI0CKR Bits */ #define SCR0		 #define SCR1		 #define SCR2		 #define SCR3		 #define SCR4		 #define SCR5		 #define SCR6		 #define SCR7		 /* CPT0CN Bits */ #define CP0HYN0	 #define CP0HYN1	 #define CP0HYP0	 #define CP0HYP1	 #define CP0FIF		 #define CP0RIF		 #define CP0OUT		 #define CP0EN		 /* CPT1CN Bits */ #define CP1HYN0	 #define CP1HYN1	 #define CP1HYP0	 0x01	 0x02	 0x04	 /* Comparator 1 negative hysteresis control, bit 0 */ /* Comparator 1 negative hysteresis control, bit 1 */ /* Comparator 1 positive hysteresis control, bit 0 */ 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* Comparator 0 negative hysteresis control, bit 0 */ /* Comparator 0 negative hysteresis control, bit 1 */ /* Comparator 0 positive hysteresis control, bit 0 */ /* Comparator 0 positive hysteresis control, bit 1 */ /* Comparator 0 Falling Edge Interrupt Flag */ /* Comparator 0 rising Edge Interrupt Flag */ /* Comparator 0 Output state flag */ /* Comparator 0 Enable bit */ 0x01	 0x02 0x04 0x08 0x10 0x20 0x40 0x80 /* SPI0 Clock Rate */

163
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 #define CP1HYP1	 #define CP1FIF		 #define CP1RIF		 #define CP1OUT		 #define CP1EN		 /* EMI0TC Bits */ #define EAH0		 #define EAH1		 #define EWR0		 #define EWR1		 #define EWR2		 #define EWR3		 #define EAS0		 #define EAS1		 /* EMI0CF Bits */ #define EALE0		 #define EALE1		 #define EMD0		 0x01	 0x02	 0x04	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x08	 0x10	 0x20	 0x40	 0x80	

Appendix A: PaulOS_F020.C Source Listing /* Comparator 1 positive hysteresis control, bit 1 */ /* Comparator 1 Falling Edge Interrupt Flag */ /* Comparator 1 rising Edge Interrupt Flag */ /* Comparator 1 Output state flag */ /* Comparator 1 Enable bit */

/* EMIF Address Hold, bit 0 */ /* EMIF Address Hold, bit 1 */ /* EMIF /WR and /RD Pulse Width Control, bit 0 */ /* EMIF /WR and /RD Pulse Width Control, bit 1 */ /* EMIF /WR and /RD Pulse Width Control, bit 2 */ /* EMIF /WR and /RD Pulse Width Control, bit 3 */ /* EMIF Address setup time, bit 0 */ /* EMIF Address setup time, bit 1 */

/* ALE pulse width select, bit 0 */ /* ALE pulse width select, bit 1 */ /* EMIF operating mode select, bit 0 */

164
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020 #define EMD1		 #define EMD2		 #define PRTSEL		 /* FLSCL Bits */ #define FLWE		 #define FRAE		 #define FOSE		 /* ADC1CN Bits */ #define ADC1CM0	 #define ADC1CM1	 #define ADC1CM2	 #define AD1BUSY	 #define AD1INT		 #define AD1TM		 #define AD1EN		 /* ADC1CF Bits */ #define AMP1GN0	 #define AMP1GN1	 #define AD1SC0		 #define AD1SC1		 #define AD1SC2		 #define AD1SC3		 #define AD1SC4		 /* SMB0STA Bits */ /* SMB0ADR Bits */ #define GC		 #define SLV0		 #define SLV1		 #define SLV2		 #define SLV3		 #define SLV4		 #define SLV5		 #define SLV6		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x08	 0x10	 0x20	 0x40	 0x80	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x40	 0x80	 /* Flash Read/Write Enable */ 0x08	 0x10	 0x20	

Appendix A: PaulOS_F020.C Source Listing /* EMIF operating mode select, bit 1 */ /* EMIF Multiplex mode select */ /* EMIF Port Select */

/* Flash Read Always Enable */ /* Flash One shot timer enable */

/* ADC1 Start of conversion mode select, bit 0 */ /* ADC1 Start of conversion mode select, bit 1 */ /* ADC1 Start of conversion mode select, bit 2 */ /* ADC1 Busy bit */ /* ADC1 Conversion complete interrupt flag */ /* ADC1 Track mode bit */ /* ADC1 Enable */

/* ADC1 Internal amplifier Gain, bit 0 */ /* ADC1 Internal amplifier Gain, bit 1 */ /* ADC1 SAR Conversion clock period bit 0 */ /* ADC1 SAR Conversion clock period bit 1 */ /* ADC1 SAR Conversion clock period bit 2 */ /* ADC1 SAR Conversion clock period bit 3 */ /* ADC1 SAR Conversion clock period bit 4 */

/* General call address enable */ /* Slave address, bit 0 */ /* Slave address, bit 1 */ /* Slave address, bit 2 */ /* Slave address, bit 3 */ /* Slave address, bit 4 */ /* Slave address, bit 5 */ /* Slave address, bit 6 */

165
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* T4CON Bits */ #define CP_RL4		 #define C_T4		 #define TR4	 	 #define EXEN4		 #define TCLK1		 #define RCLK1		 #define EXF4		 #define TF4	 /* SMB0CR */ /* REF0CN Bits */ #define REFBE		 #define BIASE		 #define TEMPE		 #define AD1VRS		 #define AD0VRS		 /* DAC0CN Bits */ #define DAC0DF0	 #define DAC0DF1	 #define DAC0DF2	 #define DAC0MD0	 #define DAC0MD1	 #define DAC0EN		 /* DAC1CN Bits */ #define DAC1DF0	 #define DAC1DF1	 #define DAC1DF2	 #define DAC0MD0	 #define DAC0MD1	 #define DAC0EN		 /* PCA0MD Bits */ #define ECF	 	 0x01	 0x02	 0x04	 0x08	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	

Appendix A: PaulOS_F020.C Source Listing

/* Timer 4 Capture/Reload select */ /* Timer 4 Counter/Timer Select */ /* Timer 4 Run Control */ /* Timer 4 External Enable */ /* Transmit clock flag for UART 1 */ /* Receive clock flag for UART 1 */ /* Timer 4 External Flag */ /* Timer 4 Overflow Flag */

/* Internal reference buffer enable bit */ /* ADC/DAC Bias generator enable bit */ /* Temperature sensor enable bit */ /* ADC1 Voltage reference select */ /* ADC0 Voltage reference select */

/* DAC0 Data format bits, bit 0 */ /* DAC0 Data format bits, bit 1 */ /* DAC0 Data format bits, bit 2 */ /* DAC0 Mode bits, bit 0 */ /* DAC0 Mode bits, bit 1 */ /* DAC0 enable bit */

/* DAC1 Data format bits, bit 0 */ /* DAC1 Data format bits, bit 1 */ /* DAC1 Data format bits, bit 2 */ /* DAC0 Mode bits, bit 0 */ /* DAC0 Mode bits, bit 1 */ /* DAC0 enable bit */

/* PCA Counter/Timer Overflow Interrupt enable */ /* PCA0 Counter/Timer Pulse Select, bit 0 */ /* PCA0 Counter/Timer Pulse Select, bit 1 */ /* PCA0 Counter/Timer Pulse Select, bit 2 */ /* PCA0 Counter/Timer Idle control */

#define CPS0		 #define CPS1		 #define CPS2		 #define CIDL		

166
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* PCA0CPM0 Bits */ #define EECF0		 #define PWM0		 #define TOG0		 #define MAT0		 #define CAPN0		 #define CAPP0		 #define ECOM0	 0x40	 #define PWM160	0x80	 /* PCA0CPM1 Bits */ #define EECF1		 #define PWM1		 #define TOG1		 #define MAT1		 #define CAPN1		 #define CAPP1		 #define ECOM1		 #define PWM161		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	

Appendix A: PaulOS_F020.C Source Listing

/* ECCF0 Capture/Compare Flag Interrupt enable */ /* PWM0 Pulse Width Modulation Mode enable */ /* TOG0 Toggle Function enable */ /* MAT0 Match Function enable */ /* CAPN0 Capture negative function enable */ /* CAPP0 Capture positive function enable */

/* ECOM0 Comparator function enable */ /* PWM160 16-bit PWM enable */

/* ECCF1 Capture/Compare Flag Interrupt enable */ /* PWM1 Pulse Width Modulation Mode enable */ /* TOG1 Toggle Function enable */ /* MAT1 Match Function enable */ /* CAPN1 Capture negative function enable */ /* CAPP1 Capture positive function enable */ /* ECOM1 Comparator function enable */ /* PWM161 16-bit PWM Enable */

Brain power

By 2020, wind could provide one-tenth of our planet’s electricity needs. Already today, SKF’s innovative knowhow is crucial to running a large proportion of the world’s wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

167
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020 /* PCA0CPM2 Bits */ #define EECF2		 #define PWM2		 #define TOG2		 #define MAT2		 #define CAPN2		 #define CAPP2		 #define ECOM2		 #define PWM162		 /* PCA0CPM3 Bits */ #define EECF3		 #define PWM3		 #define TOG3		 #define MAT3		 #define CAPN3		 #define CAPP3		 #define ECOM3		 #define PWM163		 /* PCA0CPM4 Bits */ #define EECF4		 #define PWM4		 #define TOG4		 #define MAT4		 #define CAPN4		 #define CAPP4		 #define ECOM4		 #define PWM164		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	

Appendix A: PaulOS_F020.C Source Listing

/* ECCF2 Capture/Compare Flag Interrupt enable */ /* PWM2 Pulse Width Modulation Mode enable */ /* TOG2 Toggle Function enable */ /* MAT2 Match Function enable */ /* CAPN2 Capture negative function enable */ /* CAPP2 Capture positive function enable */ /* ECOM2 Comparator function enable */ /* PWM162 16-bit PWM enable */

/* ECCF3 Capture/Compare Flag Interrupt enable */ /* PWM3 Pulse Width Modulation mode enable */ /* TOG3 Toggle Function enable */ /* MAT3 Match Function enable */ /* CAPN3 Capture negative function enable */ /* CAPP3 Capture positive function enable */ /* ECOM3 Comparator function enable */ /* PWM163 16-bit PWM enable */

/* ECCF4 Capture/Compare Flag Interrupt enable */ /* PWM4 Pulse Width Modulation Mode enable */ /* TOG4 Toggle Function enable */ /* MAT4 Match Function enable */ /* CAPN4 Capture negative function enable */ /* CAPP4 Capture positive function enable */ /* ECOM4 Comparator function enable */ /* PWM164 16-bit PWM enable */

/* XBR0 bits, PORT IO Crossbar Reg 0 */ #define SMB0EN		 #define SPI0EN		 #define UART0EN	 #define PCA0ME0	 #define PCA0ME1	 #define PCA0ME2	 #define ECI0E		 #define CP0E		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* SMBus 0 Bus I/O Enable bit */ /* SPIBus 0 Bus I/O Enable bit */ /* UART0 I/O Enable bit */ /* PCA0 Module I/O Enable bits, bit 0 */ /* PCA0 Module I/O Enable bits, bit 1 */ /* PCA0 Module I/O Enable bits, bit 2 */ /* PCA0 External Counter Input Enable bit */ /* Comparator 0 Output Enable bit */

168
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* XBR1 bits, PORT IO Crossbar Reg 1 */ #define CPIE		 #define T0E	 #define T1E	 #define T2E	 	 	 	 #define INT0E		 #define INT1E		 #define T2EXE		 #define SYSCKE		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* CP1 output enable bit */ /* T0 input enable bit */ /* /INT0 input enable bit */ /* T1 input enable bit */ /* /INT1 input enable bit */ /* T2 input enable bit */ /* T2EX input enable bit */

Appendix A: PaulOS_F020.C Source Listing

/* /SYSCLK output enable bit */

/* XBR2 bits, PORT IO Crossbar Reg 2 */ #define CNVSTE		 #define EMIFLE		 #define UART1E		 #define T4E	 	 #define T4EXE		 #define XBARE		 #define WEAKPUD	 0x01	 0x02	 0x04	 0x08	 0x10	 0x40	 0x80	 /* External Convert Start enable bit */ /* External Memory Interface low port enable bit */ /* UART1 I/O enable bit */ /* T4 input enable bit */ /* T4EX input enable bit */ /* Crossbar enable bit */ /* Weak pull-up disable bit */

/* IEI1 bits, Extended Interrupt Enable 1 */ #define ESPI0		 #define ESMB0		 #define EWADC0	 #define EPCA0		 #define ECP0F		 #define ECP0R		 #define ECP1F		 #define ECP1R		 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* Enable SPI0 interrupt */ /* Enable SMBus0 interrupt */ /* Enable Window Comparison ADC0 interrupt */ /* Enable PCA0 interrupt */ /* Enable comparator 0 (CP0) Falling edge interrupt */ /* Enable comparator 0 (CP0) rising edge interrupt */ /* Enable comparator 1 (CP1) Falling edge interrupt */ /* Enable comparator 1 (CP1) Rising edge interrupt */

/* EIE2 bits, Extended Interrupt Enable 2 */ #define ET3	 #define ET4	 #define EX6	 #define EX7	 #define ES1	 	 	 	 	 	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 /* Enable timer 3 interrupt */ /* Enable ADC0 End of conversion interrupt */ /* Enable timer 3 interrupt */ /* Enable ADC1 End of conversion interrupt */ /* Enable External interrupt 6 */ /* Enable External interrupt 7 */ /* Enable UART1 interrupt */ /* Enable External Clock source valid interrupt */ #define EADC0		 #define EADC1		

#define EXVLD		

169
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 /* RSTSRC Bits */ #define PINRSF		 #define PORSF		 #define MCDRSF		 #define WDTRSF		 #define SWRSEF		 #define C0RSEF		 #define CNVRSEF	 /* SCON1 Bits */ #define RI1	 #define TI1	 	 	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 /* Hardware Pin Reset Flag */

Appendix A: PaulOS_F020.C Source Listing

/* Power-on Reset force and flag */ /* Missing clock detector flag */ /* Watchdog Timer reset flag */ /* Software Reset Force and flag */ /* Comparator 0 (CP0) Reset enable and flag */ /* Convert Start Reset source enable and flag */

/* UART1 Receive interrupt flag */ /* UART1 Transmit interrupt flag */ /* UART1 9th bit receive */ /* UART1 Ninth transmit bit */ /* UART1 Receiver enable */ /* UART1 Multiprocessor communication enable */ /* UART1 mode bit */ /* UART1 mode bit */

#define RB81		 #define TB81		 #define REN1		 #define SM21		 #define TXCOL1		 #define SM11		 #define RXOV1		 #define SM01		 #define FE1	 	

0x20 /* UART1 Transmit Collision bit */ 0x40 /* UART1 Receive Overflow bit */ 0x80 /* UART1 Frame Error bit */

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT… RUN FASTER. RUN LONGER.. RUN EASIER…
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

170
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020 /* EIP1 Bits */ #define PSPI0		 #define PSMB0		 #define PWADC0	 #define PPCA0		 #define PCP0F		 #define PCP0R		 #define PCP1F		 #define PCP1R		 /* EIP2 Bits */ #define PT3	 #define PT4	 #define PX6	 #define PX7	 #define EP1	 	 	 	 	 	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	 0x01	 0x02	 0x04	 0x08	 0x10	 0x20	 0x40	 0x80	

Appendix A: PaulOS_F020.C Source Listing

/* SPI0 interrupt priority control */ /* SMBus0 interrupt priority control */ /* ADC0 Window comparator interrupt priority control */ /* PCA0 interrupt priority control */ /* Comparator 0 (CP0) Falling interrupt priority control */ /* Comparator 0 (CP0) Rising interrupt priority control */ /* Comparator 1 (CP1) Falling interrupt priority control */ /* Comparator 1 (CP1) Rising interrupt priority control */

/* Timer 3 interrupt priority control */ /* ADC0 End of Conversion interrupt priority control */ /* Timer 4 interrupt priority control */ /* ADC1 End of Conversion interrupt priority control */ /* External interrupt 6 Priority Control */ /* External interrupt 7 Priority Control */ /* UART1 interrupt Priority Control */ /* External Clock Source valid interrupt priority control */

#define PADC0		 #define PADC1		

#define PXVLD		 /* PCON bits */ #define IDLE		 #define STOP		 #define SSTAT1		 #define SMOD1		 #define SSTAT0		 #define SMOD0		 #endif // _C8051F020_H_

0x01	 0x02	 0x08	 0x10	 0x40	 0x80	

/* Idle mode select */ /* Stop mode select */ /* UART1 Enhanced status mode select */ /* UART1 Baud Rate doubler enable */ /* UART0 Enhanced status mode select */ /* UART0 Baud Rate doubler enable */

/* ========================================================= */

171
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

Appendix B Further Examples
We list here some interesting examples for the 8032 microprocessor. Some of them do not use any RTOS at all, but rely solely on interrupts. Other valuable examples can be found in the application note AN122 for the C8051F02x family (Silicon Labs, 2003a).

B.1	

Timer 0 in Mode 3 (split timer) and Timer 1 as a baud rate generator

The first example is a program showing how we can use Timer 0 in the split mode. This is not often found detailed in most books, probably because nowadays, most of the advanced versions of the 8051 have 4 or more timers available. However, if still using the original 8051, this mode 3 would effectively increase the number of timers available. In this example, the two timers from Timer 0 (here labelled as Timer 00 and Timer 000) both run as an 8-bit timer, generating interrupts. The main program checks whether the required number of interrupts have been generated, and prints a statement accordingly. Timer 1 is used as a baud rate generator and since Timer 0 is running in mode 3, the only way to switch on and off this timer 1 is by changing its mode. If timer 1 is set to mode 3, it is stopped. Thus as an example, we are starting the timer only before printing and switching it off once we are done with the printing command.
/* TimersMode3.c */

/* 	 Timer 0 runs in mode 3 mode, thus splitting it into two timers, which we shall call Timer00 and Timer000

			

	 Assuming that we are using a 22.1184MHz clock, then if the timers 	 	 as their counting pulse: Timer 00 generates interrupts every 78.125us, since it is set to count 144 times before it overflows

are using sysclk/12

		

		 hence 12800 interrupts would be equivalent to 1 second (using TL0, TF0)

	

Timer 000 generates interrupts every 117.1875us, since it is set to count 216 times before it overflows

		

		 hence 25600 interrupts would be equivalent to 3 seconds (using TH0, TF1) 	 Timer 1 is used as the baud-rate generator, switching it on and off 			 by switching it out of and into its own mode 3. No interrupts available.

172
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
*/

Appendix B Further Examples

#include “C8051F020.h” #include “MySystem.h” #include <stdio.h>

void SetUp_Timer0_M3 (void); void SetUp_Timer1_M3_and_UART0 (void); char putchar (char c);

/* Global variables */ bit T00_FLAG, T000_FLAG; // flags to indicate timer timeouts

/* ------------------------------------------------ */

/* * putchar: outputs character, used by the printf command */ char putchar (char c) { while (!TI0);	 /* wait for transmitter to be ready */

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
173
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
TI0 = 0; return (SBUF0 = c); }

Appendix B Further Examples

/* ------------------------------------------ */

/* set up Timer 0 mode 3, GATE = C/T = 0 */ /* splitting it into two timers, Timer00 and Timer000 */ /* Assuming 22.1184 MHz clock */

/* 156.25 microsecond overflow for TF0 (normal Timer 00) */ /* 78.125 microsecond overflow for TF1 (extra Timer 000) */ void SetUp_Timer0_M3 (void) { CKCON &= ~T0M;	 TMOD &= 0xF0;	 	 TMOD |= 0x03;	 	 TL0 = 112; 	  TH0 = 40; 	  TR0 = 1;		 TR1 = 1; 	 ET0 = 1;		 ET1 = 1;		 } 	 	 	 // set T0M = 0, thus using SYSCLK/12 // clear Timer 0 control bits only // mode 3 (two split timers), GATE = C/T = 0 // 256 // 256

– –

144 = 112 ==> 78.125us for normal Timer 00 216 = 40 ==> 117.1875us for extra Timer 000

// Timer 00 ON // Timer 000 ON // Enable TF0 interrupt, from Timer 00 overflows // Enable TF1 interrupt, from Timer 000 overflows

/* ------------------------------------------ */

/* Set up timer 1 in mode 2, 8-bit, auto re-load, GATE = C/T = 0 */ /* for 115200 baud rate generator */ /* Assuming 22.1184 MHz clock */

/*  Since Timer 0 is in mode 3, then Timer 1 will be switched on and off 	 by setting it to mode 2 (on) or mode 3 (off) in the application program */

/* Setup also the UART0 */

void SetUp_Timer1_M3_and_UART0 (void) { CKCON &= ~T1M;		 TMOD &= 0x0F;			  // set T1M = 0, thus using SYSCLK/12 // clear timer 1 control bits only (momentarily set T1 to mode 0)

174
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
TMOD |= 0x30; 		 TH1 = TL1 = 0xFF; 		  PCON |= 0X80;			  SCON0 = 0X52; 		  				 }

Appendix B Further Examples
// set initially to mode 3, i.e. timer off // set for 115200 or 57600 baud rate (reload value in TH1) // SMOD0 = 1 so as to double the baud rate to 115200 bps // 8-bit UART, variable baud rate, receiver disabled, // transmitter ready TI0 = 1	

/* ------------------------------------------ */

/* ------------------------------------------------ */

// Timer00 Interrupt Service Routine void TF0_ISR (void) interrupt 1 using 1 { static data unsigned int TF0_OVF;	 TF0_OVF++; TL0 = 112; 			 if (TF0_OVF == 12800)	  		 { TF0_OVF = 0; T00_FLAG = 1; // reload value // number of interrupts required for a 1 second delay // counts TF0 overflows, from Timer00

			 			 		} }

/* ------------------------------------------------ */

// Timer000 Interrupt Service Routine void TF1_ISR (void) interrupt 3 using 2 { static data unsigned int TF1_OVF;	 TF1_OVF++; TH0 = 40;				 if (TF1_OVF == 25600)	  	 { TF1_OVF = 0; T000_FLAG = 1; // reload value //  counts TF1 overflows, from Timer000

// number of interrupts required for a 3 second delay

			 			 	 } }

175
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
/* ------------------------------------------------ */

Appendix B Further Examples

/* ------------------------------------------------ */

/* Main program */ void main(void) {

DISABLE_Watchdog(); SYSCLK_Init (); PORT_Init ();

SetUp_Timer0_M3 ();	

		

// Timer 0 mode 3

–

split timer

SetUp_Timer1_M3_and_UART0();		 					 					

// Timer 1 (off) mode 3, //  8-bit auto reload value as a baud rate generator //  initially set in mode 3, not running.

EA = 1;

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

176
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
while(1) {

Appendix B Further Examples

//  Timer 1 is switched on and off just to show that we can still control it. //  It is switched on only for use as the baud rate generator before the ‘printf’ command

	 	

if (T00_FLAG == 1) { T00_FLAG = 0; TMOD = 0x23;	 //  set Timer 1 to mode 2, start it as the baud rate generator //  ready for the ‘printf’ command which follows //  leaving Timer 0 set to mode 3 //  This method is used instead of:

		 		

				 				 				

				// 				 				 				 				 //  TMOD &= 0x0F; 	 // clear timer 1 control bits only

//  (momentarily set T1 to mode 0) //  TMOD |= 0x20; 	 // TH1 = 0xFF; 	 // set to mode 2, i.e. Timer 1 on // set reload value

				// 				 				 				 				 				 //  which would have placed Timer 1 momentarily in mode 0 //  and thus possibly modifying the reload value held in TH1 //  (and hence the baud rate) before setting it to mode 2 //  Hence the need to set the reload value in TH1 every time. //  Thus TMOD = 0x23 is much quicker and neater this time!

	 	

printf (“Timer 00: 12800 timeouts every 1 second\n”); TMOD = 0x33; 	  // set Timer 1 to mode 3 to stop the baud rate generator // leaving Timer 0 set to mode 3

				 }

if (T000_FLAG == 1) 	 	 	 { T000_FLAG = 0; TMOD = 0x23;	 				 				 	 	 //  set Timer 1 to mode 2, start it as the baud rate generator // ready for the ‘printf’ command which follows // leaving Timer 0 set to mode 3

printf (“Timer 000: 25600 timeouts every 3 seconds\n”); TMOD = 0x33; 	 //  set Timer 1 to mode 3 to stop the baud rate generator // leaving timer 0 set to mode 3

				 } } }

177
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
// ===============================================================

Appendix B Further Examples

// ===============================================================

/* MySystem.h */

#ifndef __MYSYSTEM_H__ #define __MYSYSTEM_H__

#define SYSCLK		 #define BAUDRATE	

22118400	 115200UL	

// SYSCLK frequency in Hz // Baud rate of UART in bps

void DISABLE_Watchdog (void); void PORT_Init (void); void SYSCLK_Init (void); void PORT_Init (void);

#endif // __MYSYSTEM_H__

// ===============================================================

// MySystem.c

#include “C8051F020.h”

//-----------------------------------------------------------------// SYSCLK_Init //-----------------------------------------------------------------// //  This routine initializes the system clock to use an 22.1184MHz crystal // as its clock source. //

void SYSCLK_Init (void) { 	 	 unsigned int i; 			 OSCXCN = 0x67; 			 					 // delay counter // start external oscillator with // 22.1184MHz crystal

178
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 for (i=0; i < 300; i++);	// wait for oscillator to start

Appendix B Further Examples

#ifndef SIMULATOR 	 while (!(OSCXCN & 0x80));	 // Wait for crystal osc. to settle 				 #endif 	 OSCICN = 0x88; 		 // select external oscillator as SYSCLK // source and enable missing clock /*  disable above line if using simulator */

					

					// detector }

//-----------------------------------------------------------------// DISABLE_Watchdog //-----------------------------------------------------------------// // Disables the watchdog timer // void DISABLE_Watchdog (void) { 	 EA = 0;

	WDTCN = 0xDE;

179
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
	WDTCN = 0xAD; 	 } EA = 1;

Appendix B Further Examples

//-----------------------------------------------------------------// PORT_Init //-----------------------------------------------------------------// // Configure the Crossbar and GPIO ports, (see page 163 of manual) // void PORT_Init (void) { 	 XBR0 = 0x04; 			 // Enable UART0, UART0EN=1 // TX0=P0.0 and RX0=P0.1

						 	 	 	 } XBR2 = 0x40; 			

// Enable crossbar and weak pull-ups //  enable TX0 (P0.0) as a push-pull output //  enable P1.6 (LED) as push-pull output

P0MDOUT |= 0x01; 			 P1MDOUT |= 0x40; 			

// ===============================================================

B.2	

UART0 and UART1

This package initialises UART0 or UART1 at the required baud rate and uses the specified timer to generate this baud rate. The function to setup the baud rate is normally called from the main program, and a routine to do this, such as ‘UART_Selector( )’ is included as a remarked routine in the DualUarts.c program listed below. Its usage in an application program can be seen in appendix B.3 Clock example. The UART, timer and baud rate are all defined in this ‘UART_selector( )’ routine. ‘sio_bit’ should be a global bit variable in the application program. Note that the same ‘putchar’ and ‘_getkey’ routines are used for both UARTs. Hence if the application requires the use of both UARTs, the ‘sio_bit’ should be set before using any ‘printf ’ statement. It should then be reset whenever you need to print to the other UART. Moreover, another re-named copy of the ‘UART_Selector( )’ routine would have to be made so that each one of them would have separate UART, timer and baud rate definitions, so that both UARTs can be initialised concurrently. The XBR0, XBR2 and P1MDOUT would also have to be modified to reflect the use of both UARTs as shown below:
XBR0 = 0x04; 		 XBR2 = 0x44; 		 P1MDOUT = 0x05; 	 // UART0 enabled // Weak pull-up, Crossbar and UART1 enabled // P0.0 (TX0) and P0.2 (TX1) configured as Push-Pull

180
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

The UARTs initialisation program and header are listed here for reference.
/*-----------------------------------------------------------------	DualUarts.c -----------------------------------------------------------------------------*/ #include “C8051F020.H” #include <stdio.h> /* prototype declarations for I/O functions */ #include “DualUarts.h”

extern bit sio_port;

/* ‘sio_port’ is declared and set in the main program */ /*  according to which UART one intends to use (0 = UART0, 1 = UART1) */ /* It is used here in the ‘putchar’ and ‘_getkey’ routines */ /*  If both UARTS are being used, then you would need to set the sio_port */ /* bit to the correct UART before issuing the ‘printf’ command */ /* and obviously, both UARTS must be initialised */

/*

// Copy and paste this routine in the main application program // in order to program the UARTs. // Moreover, you would need to declare // // bit sio_port; // // as a global variable in the main application program // //-----------------------------------------------------------------// UART_Selector function //-----------------------------------------------------------------// //  Remember to configure XBR0, XBR2 and P1MDOUT according to which UART you use //

void UART_Selector (void) { // UART0 can use Timer 1 or Timer 2 as the baud rate generator // UART1 can use Timer 1 or Timer 4 as the baud rate generator // set the following #define statements as required:

181
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
#define UART_IN_USE 0 #define TIMER_FOR_UART 1 #define BAUD_RATE 115200UL

Appendix B Further Examples

	 	

#if (UART_IN_USE == 0) sio_port = 0; // SIO port to use (0 = UART0, 1 = UART1), used in DualUarts.c

	

SetUpUART(UART_IN_USE, BAUD_RATE, TIMER_FOR_UART);

	 		 		 		

#if (TIMER_FOR_UART == 1) #message “Set up UART0, at BAUD_RATE bps using Timer 1” #elif (TIMER_FOR_UART == 2) #message “Set up UART0, at BAUD_RATE bps using Timer 2”

		#else 		 #error “Wrong Timer for UART0”

		#endif 	 #endif

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

182
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
	 		 		 		 #if (UART_IN_USE == 1) sio_port = 1;

Appendix B Further Examples

//  SIO port to use (0 = UART0, 1 = UART1), used in DualUarts.c SetUpUART(UART_IN_USE, BAUD_RATE, TIMER_FOR_UART);

		 		 		 		

#if (TIMER_FOR_UART == 1) #message “Set up UART1, at BAUD_RATE bps using Timer 1” #elif (TIMER_FOR_UART == 4) #message “Set up UART1, at BAUD_RATE bps using Timer 4”

		#else 		 #error “Wrong Timer for UART1”

		#endif 	 #endif

} */

/*----------------------------------------------------------------*/

/*-----------------------------------------------------------------The following putchar function replaces the one in the library. ------------------------------------------------------------------*/ char putchar (char c) { char d;

if (sio_port == 0) {			 while (!TI0); TI0 = 0; SBUF0 = c; } else			 /* UART1 */ { while (!(SCON1 & TI1)); /* While TI1 = 0 */ SCON1 &= ~TI1; /* TI1 = 0 */ SBUF1 = c; } /* UART0 */

for(d=0; d<10; d++){;} /* just a delay if needed, depending on receiving device requirement */

183
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
return (c); }

Appendix B Further Examples

/*-----------------------------------------------------------------The following _getkey function replaces the one in the library. ------------------------------------------------------------------*/ char _getkey (void) { char c;

if (sio_port == 0) { while (!RI0); c = SBUF0; RI0 = 0; } else { while (!(SCON1 & RI1)); /* While RI1 = 0 */ c = SBUF1; SCON1 &= ~RI1; /* RI1 = 0 */ }

return (c); }

/*------------------------------------------------

Set up any UART in mode 1, 8-bit, variable baud rate UART 0 can use Timers 1 or 2 as the baud rate generator UART 1 can use Timers 1 or 4 as the baud rate generator

------------------------------------------------*/

void SetUpUART(unsigned char UART, unsigned long BaudRate, unsigned char Timer) { #message “Remember to set XBR0, XBR2 and P1MDOUT correctly” if (UART == 1) /* Set up UART 1 */ { 	 	 switch (Timer) {

184
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

//-----------------------------------------------------------------// Setup RS232 UART1 in the Silicon Labs chip using Timer 1 or Timer 4 // For UART0 to use timer 1, set it in mode 1, 8-BIT AUTO-RELOAD. //  to generate baud rate. SMOD1 = 0 (divisor 32) and T0M = 1 (use SYSCLK) // so baud rate formula is // Baud rate = 22.1184 MHz /(32 * (256 // TH1 = 256 //	

–

TH1))

–

[22118400/(32 * BR)]

= 256

–

(691200/BR) = 184 = 0xB8 = 250 = 0xFA

// For 9600 baud TH0		 // For 115.2K baud TH0	 // // Similarly for Timer 4

// Serial interrupt is NOT enabled //------------------------------------------------------------------

	 		 		 		 		

case 1: CKCON |= T1M;	 PCON &= ~SMOD1;	  SCON1 = 0x50;	  TMOD &= 0x0F;	 // T1M = 1, use SYSCLK for timer 1 // SMOD1 = 0, baud rate divide by 2 disabled for UART 1 // 8-bit UART variable baud rate, mode 1, REN1 enabled // Clear Timer 1 control bits

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

185
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
		 		 		 		 		 TMOD |= T1M1;	 // Set to mode 2

Appendix B Further Examples

TH1 = -(SYSCLK/32UL/BaudRate); 	 TR1 = 1;		 SCON1 |= TI1; 	 break; // start timer 1 // Indicate TX1 ready for UART 1

	 		 		 		 		 		 		 		 		

case 4: CKCON |= T4M; 	 SCON1 = 0x50; 	  // T4M = 1, use SYSCLK for timer 4 // SCON1: Mode 1, 8-bit UART, enable receiver

T4CON = TCLK1 + RCLK1; // T4CON: Use T4 for Baud Rate Tx and Rx on UART1  RCAP4 = -(SYSCLK/32UL/BaudRate); // set Timer reload value for baud rate  T4 = RCAP4; 		 T4CON |= TR4; 	 SCON1 |= TI1; 	 break; // initialise Timer value // TR4: T4 Run // TI1: Set TI1 to send first char of UART1

	} 	} else /* Set up UART 0 */

{ 	 switch (Timer)

	{ //-----------------------------------------------------------------// Setup RS232 UART0 in the Silicon Labs chip using Timer 1 or Timer 2 // For UART0 to use timer 1, then set it in mode 1, 8-BIT AUTO-RELOAD. //  to generate baud rate. SMOD1 = 0 (divisor 32) and T0M = 1 (use SYSCLK) // so baud rate formula is // Baud rate = 22.1184 MHz /(32 * (256 // TH1 = 256 //	

–

TH1))

–

[22118400/(32 * BR)]

= 256

–

(691200/BR)

// For 9600 baud TH1 = 184 = 0xB8 // For 115.2K baud TH1 = 250 = 0xFA // // Similarly if using Timer 2 // Serial interrupt is NOT enabled //------------------------------------------------------------------

	
		 		

case 1: CKCON |= T1M; // T1M = 1, use SYSCLK for timer 1

PCON &= ~SMOD0; // SMOD0 = 0, baud rate divide by 2 disabled for UART 0 

186
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
		 		 		 		 		 		

Appendix B Further Examples

SCON0 = 0x50; // 8-bit UART variable baud rate, REN0 enabled  TMOD &= 0x0F; // Clear Timer 1 control bits TMOD |= T1M1; // Set to mode 2 TH1 TR1 = -(SYSCLK/32UL/BaudRate); = 1; 	 // start timer 1 // Indicate TX0 ready, for UART 0

TI0 = 1; 	

		 break;

	 		 		 		 		 		 		

case 2: SCON0 = 0x50; // SCON: Mode 1, 8-bit UART, enable receiver T2CON = 0x34; 	 // T2CON: Use T2 for Baud Rate on UART0

RCAP2 = -(SYSCLK/32UL/BaudRate); // set Timer reload value for baud rate  T2 = RCAP2; 			 TR2 = 1; 			 TI0 = 1; 			 // initialise Timer value // TR2: T2 Run // TI0: Set TI0 to send first char of UART0

		 break; 	}

	} }

Header file to be include in the main program when using DualUARTS.c file
/*-----------------------------------------------------------------	DualUarts.h ------------------------------------------------------------------*/ #ifndef _DUAL_UARTS_H_ #define _DUAL_UARTS_H_

#define SYSCLK (22118400UL)

char putchar (char c); char _getkey (void);

void SetUpUART(unsigned char UART, unsigned long BaudRate, unsigned char Timer);

#endif // _DUAL_UARTS_H_

/*-----------------------------------------------------------------/

187
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

Or else we may write separate routines for UART0 and UART1 such as:
/*-----------------------------------------------------------------The following putcharU0 function uses UART0 ------------------------------------------------------------------*/ char putcharU0 (char c) { char d;

while (!TI0); TI0 = 0; SBUF0 = c; for (d=0; d<2; d++){;} /* just a delay if needed, since no hand shaking */  return (c); }

/*-----------------------------------------------------------------The following putcharU1 function uses UART1 -----------------------------------------------------------------------------*/

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

188
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
char putcharU1 (char c) { char d;

Appendix B Further Examples

while (!(SCON1 & TI1)); /* While TI1 = 0 */ SCON1 &= ~TI1; /* TI1 = 0 */ SBUF1 = c; for (d=0; d<2; d++){;} /* just a delay if needed, since no hand shaking */  return (c); }

// *********************************************** // TEXT STRING, TERMINATED WITH A NULL, IS TRANSMITTED THROUGH UART0 void TX_STRING_U0(char *text) { while(*text != ‘\0’) 	putcharU0(*text++); }

// *********************************************** // TEXT STRING, TERMINATED WITH A NULL, IS TRANSMITTED THROUGH UART1 void TX_STRING_U1(char *text) { while(*text != ‘\0’) 	putcharU1(*text++); } /*-----------------------------------------------------------------/

With these routines, both UARTs can be setup using the ‘SetUpUART( )’ routine for each UARTx. Then we can easily print a string of text to whichever UART we want by using the corresponding ‘TX_STRING_Ux( )’ routine, without the need to use the standard ‘printf ’ (which uses ‘putchar( )’). We can of course opt to use the ‘printf ’ commands with one UART and ‘TX_SRING_Ux( )’ with the other UART; we are completely flexible to do so.

189
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

B.3	Clock
This example is a clock with a blinking LED. It uses 5 tasks, one task keeping track of the seconds, running periodically every second. It sends a signal to the minute task (which is set waiting for a signal) every sixty seconds. The minute task itself then signals the hour task every sixty minutes. Another task, the ‘clock_reset’ task waits for an External 0 (/INT0) interrupt. When this falling edge triggered interrupt happens, the task resets the clock to 23:58:50. The last task simply blinks the LED connected to pin 3.6 every 500ms. Note the ‘PORT_Init’ task where the UART0 Tx and Rx signals and the /INT0 external input signals are routed to Port 0. The bits to setup can be verified by looking at Figure 1-10, Figure 1-11 and Table 1-4. The ‘UART_Selector( )’ routine is used to initialise the required UART as previously explained in appendix B.2 UART0 and UART1.
//-----------------------------------------------------------------// Clock.c //-----------------------------------------------------------------// Copyright (C) 2015 // // AUTH: PD // DATE: 21 FEB 15 // //  This program flashes the green LED on the C8051F020 target board, 500ms on, 500ms off //  Example program to demonstrate the use of various PaulOS_F020 commands // Target: C8051F02x // //

//-----------------------------------------------------------------// Includes //-----------------------------------------------------------------#include “C8051F020.h” 	 #include “DualUarts.h” 	 #include “PaulOS_F020.h” 	 #include <stdio.h> #include <stdlib.h> /* special function registers 8051F020 */ /* UARTS functions header file */ /* PaulOS_F020 version system calls definitions */

//-----------------------------------------------------------------// Enumerates //------------------------------------------------------------------

190
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

enum eTasks {CLOCK_SEC, CLOCK_MIN, CLOCK_HOUR, CLOCK_RESET, BLINK};

//-----------------------------------------------------------------// Global CONSTANTS //------------------------------------------------------------------

bit sio_port; /* SIO port to use (0 = UART0, 1 = UART1) */

sbit LED = P1^6; 		 sbit INT0 = P0^2; 		 	 			

// green LED: ‘1’ = ON; ‘0’ = OFF //  EXT0 (/INT0) input pin, routed to this port pin // in the port initialisation routine

struct time { /* structure of the time record */ unsigned char hour; 			 unsigned char min; 			 unsigned char sec; 			 }; /* hour 				 /* minute 				 /* second 				 */ */ */

struct time ctime = { 12, 58, 30 }; /* storage for clock time values */

191
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Appendix B Further Examples

//-----------------------------------------------------------------// Function PROTOTYPES //-----------------------------------------------------------------void SYSCLK_Init (void); void PORT_Init (void); void DISABLE_Watchdog (void); void UART_Selector (void);

//-----------------------------------------------------------------// SYSCLK_Init //-----------------------------------------------------------------// // This routine initializes the system clock to use an 22.1184MHz crystal // as its clock source. // void SYSCLK_Init (void) {

	
	

unsigned int i; 			

// delay counter

OSCXCN = 0x67; 			 						

// start external oscillator with // 22.1184MHz crystal

	

for (i=0; i < 256; i++) ; 	

// wait for oscillator to start //  SIMULATOR defined in the C51 Target Tab // Wait for crystal osc.to settle

#ifndef SIMULATOR 			 	 while (!(OSCXCN & 0x80)) ;	

#endif 	 OSCICN = 0x88; 			 					 //  select external oscillator as SYSCLK // source and enable missing clock

					// detector }

//-----------------------------------------------------------------// DISABLE_Watchdog //-----------------------------------------------------------------// // Disables the watchdog timer // void DISABLE_Watchdog (void) {

192
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 EA = 0;

Appendix B Further Examples

	WDTCN = 0xDE; 	WDTCN = 0xAD; 	 } EA = 1;

//-----------------------------------------------------------------// PORT_Init //-----------------------------------------------------------------// // Configure the Crossbar and GPIO ports // void PORT_Init (void) { 	 XBR0 = 0x04;			 // Enable UART 0, UART0EN = 1 // TX0 => P0.0 and RX0 => P0.1 // Route INT0 to port pins, INT0E = 1 // INT0 => P0.2 // Enable crossbar and weak pull-ups // enable TX0 as a push-pull output // enable P1.6 (LED) as push-pull output

					 	 XBR1 = 0x04; 			

					 	 	 	 } XBR2 = 0x40; 			 P0MDOUT |= 0x01; 			

P1MDOUT |= 0x40; 				

//-----------------------------------------------------------------// UART_Selector //-----------------------------------------------------------------// //  Remember to configure XBR0, XBR2 and P1MDOUT according to which UART you use //

void UART_Selector (void) { // UART0 can use Timer 1 or Timer 2 as the baud rate generator // UART1 can use Timer 1 or Timer 4 as the baud rate generator #define UART_IN_USE 0 #define TIMER_FOR_UART 1 #define BAUD_RATE 115200UL

193
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 	 	 #if (UART_IN_USE == 0) sio_port = 0;

Appendix B Further Examples

/* SIO port to use (0 = UART0, 1 = UART1), used in DualUarts.c */  SetUpUART(UART_IN_USE, BAUD_RATE, TIMER_FOR_UART);

	 		 	 		 	 		 	 	

#if (TIMER_FOR_UART == 1) #message “Set up UART0, at BAUD_RATE bps using Timer 1”  #elif (TIMER_FOR_UART == 2) #message “Set up UART0, at BAUD_RATE bps using Timer 2” #else #error “Wrong Timer for UART0” #endif #endif

	 	 	 	

#if (UART_IN_USE == 1) sio_port = 1; /* SIO port to use (0 = UART0, 1 = UART1), used in DualUarts.c */  SetUpUART(UART_IN_USE, BAUD_RATE, TIMER_FOR_UART);

194
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
	 		 	 		 	 		 	 	 } #if (TIMER_FOR_UART == 1)

Appendix B Further Examples

#message “Set up UART1, at BAUD_RATE bps using Timer 1” #elif (TIMER_FOR_UART == 4) #message “Set up UART1, at BAUD_RATE bps using Timer 4” #else #error “Wrong Timer for UART1” #endif #endif

/******************************************************************/ /*	 Task 0 ‘clock_sec’ */

/******************************************************************/ void clock_sec (void) { OS_PERIODIC_A(0,1,0); 	 while (1) 			 { 	 	 	 	 	 } if (++ctime.sec == 60) { 	 /* calculate the second */ ctime.sec = 0; OS_SIGNAL_TASK(CLOCK_MIN); /* Repeat every 1 second */ /* clock is an endless loop */

	 else printf (“Clock Time: %02bu:%02bu:%02bu\r”, /* display time */ 			 	 } } ctime.hour, ctime.min, ctime.sec);

OS_WAITP(); /* wait for 1 second */

/******************************************************************/ /* Task 2 ‘clock_min’ */ /******************************************************************/ void clock_min (void) { while (1) /* clock is an endless loop */ { 	 OS_WAITS(0); /* wait for 1 second */

195
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 	 	 	 	 } if (++ctime.min == 60) { 	 /* calculate the second */ ctime.min = 0; OS_SIGNAL_TASK(CLOCK_HOUR);

Appendix B Further Examples

	 else printf (“Clock Time: %02bu:%02bu:%02bu\r”, /* display time */ 			 } } ctime.hour, ctime.min, ctime.sec);

/******************************************************************/ /*	 Task 2 ‘clock_hour’ */

/******************************************************************/ void clock_hour (void) { while (1) 		 { 	 OS_WAITS(0); /* wait for 1 second */ /* clock is an endless loop */

	 	 	 	

if (++ctime.hour == 24) { /* calculate the second */ ctime.hour = 0; }

	

printf (“Clock Time: %02bu:%02bu:%02bu\r”, /* display time */ ctime.hour, ctime.min, ctime.sec);

			 } }

/******************************************************************/ /* 	 Task 3 ‘rest clock’ */

/******************************************************************/

196
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
void clock_reset (void) { while(1) 	{ 	 OS_WAITI(0); 			 ctime.hour = 23; ctime.min = 59; ctime.sec = 50; // wait for /INT0

Appendix B Further Examples

			 			 			 	} }

/******************************************************************/ /* 	 Task 4 ‘Blink’ */

/******************************************************************/

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

197
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020
void BlinkTask (void) { 	 while(1) 	{ 	 	 	} } LED = !LED; OS_WAITP(); // wait for the periodic interval OS_PERIODIC_A(0,0,500); 			

Appendix B Further Examples

/* Repeat every 500 ms */

/******************************************************************/

/* ******************************************************************** */ //-----------------------------------------------------------------// MAIN Routine //-----------------------------------------------------------------void main (void) {

	 	 	

DISABLE_Watchdog (); SYSCLK_Init ();	 UART_Selector (); /* Set up UART */

	

PORT_Init ();

	 OS_INIT_RTOS(TICK_TIMER); /* initialise RTOS (Timer 0 interrupt), */ 						 /* variables and stack */

	

/* CREATE the 5 tasks */

	OS_CREATE_TASK(CLOCK_SEC,clock_sec); 	OS_CREATE_TASK(CLOCK_MIN,clock_min); 	OS_CREATE_TASK(CLOCK_HOUR,clock_hour); 	OS_CREATE_TASK(CLOCK_RESET,clock_reset); 	OS_CREATE_TASK(BLINK,BlinkTask);

	 	

IT0 = 1; // fallling edge triggered EX0 = 1; // enable external 0 (/INT0) interrupt

198
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020
	 OS_RTOS_GO(0); /* Start the RTOS */

Appendix B Further Examples

	

while (1) { #ifndef SIMULATOR OS_CPU_IDLE();	  */ /* Go to idle mode if doing nothing, to conserve energy

	
	

		

	#else 			 ;

			#endif 	 }

}

.

199
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS F020: An RTOS for the C8051F020

Bibliography

Bibliography
Blaut, J. (2004). 8051 RTOS. B.Sc. Electrical Engineering Thesis, University of Malta. Chew, M.T., & Gupta, G.S. (2005). Embedded Programming with Field-Programmable Mixed-Signal Microcontrollers. Silicon Laboratories. Debono, P.P. (2013a). PaulOS: Part I – An 8051 Real-Time Operating System (1st ed.). bookboon.com. Debono, P.P. (2013b). PaulOS: Part II – An 8051 Real-Time Operating System (1st ed.). bookboon.com. Huang, H. (2009). Embedded System Design with the C8051. Stanford, CT, USA: Cengage Learning. Pont, M.J. (2002). Patterns for Time-Triggered Embedded Systems: Building reliable applications with the 8051 family of microcontrollers. Boston, Ma, USA: Addison-Wesley Longman Publishing Co., Inc. Schultz, T.W. (1999). C and the 8051 (volume II): building efficient applications. Upper Saddle River, NJ, USA: Prentice Hall PTR. Schultz, T.W. (2004). C and the 8051. Pagefree Publishing. Silicon Labs. (2003a). AN122 – Annotated “C” Examples for the “F02x” Family. Austin, TX, USA: Silicon Laboratories Inc. Silicon Labs. (2003b). C8051F020 Data Sheet. Austin, TX, USA: Silicon Laboratories Inc.

200
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Index

Index
A addresses 18, 20, 26, 27, 28, 78, 79, 158, 204 area 16, 18, 20, 21, 22, 23, 25, 44, 45, 50, 51, 78, 109, 130, 131 B bit-addressable 23, 28, 80, 154, 162 C code 7, 8, 13, 14, 16, 17, 24, 30, 45, 50, 55, 56, 62, 69, 76, 78, 79, 81, 84, 85, 100, 104, 105 co-operative 7, 8, 43, 44, 45, 54, 83, 84, 204 Crossbar 33, 34, 35, 36, 37, 38, 39, 40, 79, 168, 169, 180, 193, 204 C Tips 84 D description 28, 49 E EIE1 41, 157 EIE2 41, 92, 108, 112, 157, 169 EIP1 41, 157, 171 EIP2 41, 108, 157, 171 External 15, 17, 40, 97, 126, 166, 168, 169, 171, 190 I IE 41, 81, 108, 155, 159 Internal Data 15, 17, 19 interrupts 7, 20, 30, 40, 41, 43, 47, 50, 52, 70, 81, 84, 85, 108, 112, 136, 153, 172, 175, 204 IP 41, 81, 108, 156, 159 ISR stand-alone – PaulOS_F020 62 M mode 3 68, 172, 174, 175, 176, 177 Mode 3 67, 172 O on-chip 15, 17 organisation 7, 13, 14 OS_CPU_DOWN( ) 61 OS_CPU_IDLE( ) 61 OS_CREATE_TASK (uchar tasknum, uint taskadd) 48, 49 OS_CREATE_TASK(uchar tasknum, uint taskadd) 110 OSCXCN 28, 29, 156, 178, 179, 192 OS_DEFER( ) 53, 54, 60 OS_INIT_RTOS (uchar blank) 48, 49, 90 OS_KILL_IT( ) 59 OS_PAUSE_RTOS( ) 61, 62, 77 OS_PERIODIC_A(min, sec , msec) 54 OS_PERIODIC(Ticks) 54 OS_RESUME_RTOS( ) 61, 62, 77 OS_RESUME_TASK (uchar tasknum) 48, 49, 129 OS_RTOS_GO(priority) 47 OS_RUNNING_TASK_ID( ) 53 OS_SCHECK 48, 49, 90, 114 OS_SIGNAL_TASK (uchar tasknum) 48, 49 OS_WAITI (uchar intnum) 48, 49, 90 OS_WAITP( ) 32, 54, 56 OS_WAITS_A(M,S,ms) 61, 96 OS_WAITS(ticks) 46, 57, 61 OS_WAITT_A(M,S,ms) 61, 96 OS_WAITT(ticks) 59, 61 P PaulOS_F020 7, 8, 44, 47, 62, 64, 77, 84, 85, 86, 89, 91, 100, 102, 105, 106, 190 OS_WAITP( ) 54 stand-alone ISR 62 PaulOS_F020.h 86, 89, 106, 190 PaulOS_F020_Parameters.h 62, 86, 102 PaulOS_F020 RTOS 7, 44, 47, 62, 64

201
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020 pitfalls 8, 78, 84 PORT 33, 154, 155, 156, 157, 159, 168, 169, 176, 178, 180, 190, 192, 193, 198 programming 7, 8, 13, 14, 15, 24, 29, 54, 55, 68, 78, 83 Programming 78, 200 R RAM size 78 READY 47, 109, 110, 115, 130, 131, 134, 153 register banks 18, 20, 62, 84 running 8, 16, 28, 29, 31, 44, 45, 46, 47, 48, 49, 51, 57, 61, 62, 67, 68, 69, 71, 74, 76, 83, 87, 90, 100, 109, 113, 130, 131, 135, 153, 172, 176, 190, 204 S serial 8, 23, 24, 27, 34, 41, 68, 69, 70, 71, 72, 74, 75, 77, 79, 80, 81, 122, 123, 139 SFR 17, 18, 23, 24, 25, 26, 27, 28, 50, 61, 62, 78, 79, 81, 102, 103, 204 SFRs 17, 19, 23, 24, 25, 26, 27, 28, 41, 62, 78, 79, 80, 81, 154, 162, 204 source listing 56, 79, 86 split timers 174 stand-alone 61, 62, 85, 90 stand-alone ISR 61, 62, 85, 90 Startup_PaulOS_F020.A51 86, 91, 100 system clock 28, 29, 30, 66, 79, 93, 178, 192 System Clock 28, 79 System Commands 47 T tips 8, 78 U

Index

UART0 23, 24, 27, 33, 34, 38, 39, 64, 66, 67, 68, 71, 74, 75, 77, 80, 81, 94, 122, 139, 159, 160, 168, 171, 173, 174, 176, 180, 181, 182, 183, 185, 186, 187, 188, 189, 190, 191, 193, 194 UART1 23, 38, 66, 67, 80, 81, 95, 126, 150, 151, 169, 170, 171, 180, 181, 182, 183, 185, 186, 188, 189, 190, 191, 193, 194, 195 usage 54, 55, 85, 180 W waiting 28, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 59, 60, 66, 70, 75, 90, 93, 106, 109, 115, 116, 117, 118, 119, 121, 127, 129, 132, 134, 135, 152, 153, 190 Watchdog Timer 29, 79, 170 Watchdog Timer Setup 79 WDTCN 29, 30, 31, 32, 158, 179, 180, 193 X XBR0 33, 34, 35, 36, 79, 157, 168, 180, 181, 184, 193 XBR1 33, 34, 35, 36, 79, 157, 169, 193 XBR2 33, 34, 35, 37, 38, 40, 79, 157, 169, 180, 181, 184, 193

202
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Endnotes

Endnotes
1	 This resource assignment flexibility is achieved through the use of a Priority Crossbar Decoder. Note that the state of a Port I/O pin can always be read from its associated Data register regardless of whether that pin has been assigned to a digital peripheral or behaves as GPIO. 2	When the interrupts are recognised by the micro-controller at the same time (i.e. simultaneous), a decision has to be made on which interrupt is to be serviced first. If all these interrupts have the same high/low priority setting, the controller will follow the fixed priority order column shown in Table 1-5 to determine which one should run first. If the interrupts are not simultaneous, then the priority order column does not come into play at all. An interrupt occurring while another interrupt of the same high/low priority setting is running, will not be allowed to interrupt this running ISR. 3	 The main structure for this RTOS came from the book “C and the 8051 – Building Efficient Applications – Volume II” by Thomas W. Schultz and published by Prentice Hall (0-13-521121-2). In this book, Prof. Schultz discusses the development of two real-time kernels. The first one is the RTKS which I corrected and developed into PaulOS co-operative RTOS. The second one is the RTKB which I also corrected, modified and developed into MagnOS pre-emptive RTOS. Both operating systems, RTKS and RTKB as written in the book are not fully functional, contain some errors and lack some essential components. I did correspond with Prof. Schultz and sent him my modifications and final versions of the programs which he later acknowledged in the 3rd edition of the book “C and the 8051”, again published by Prentice-Hall (058961-237-X). So I am particularly grateful to Prof. Schultz for being the catalyst of my increased interest in RTOSs. 4	16-bit SFR declarations: Some 8051 derivatives have 16-bit SFRs that are created using consecutive addresses in SFR memory to specify 16-bit values. For example, the C8051F020 uses addresses 0xCC and 0xCD for the low and high bytes of timer/counter 2 respectively. The Cx51 Compiler provides the sfr16 data type to access two 8-bit SFRs as a single 16-bit SFR (see also section 1.7). 	Access to 16-bit SFRs using sfr16 is possible only when the low byte address location immediately precedes the high byte (little endian) and when the low byte is written last. The low byte is used as the address in the sfr16 declaration. For example: 	 	 	 	 sfr16 ADC0 = 0xBE;	 sfr16 RCAP2 = 0xCA;	 sfr16 RCAP4 = 0xE4;	 		 /* ADC0L 0BEh, ADC0H 0BFh */ /* RCAP2L 0CAh, RCAP2H 0CBh */ /* RCAP4L 0E4h, RCAP4H 0E5h */ sfr16 T2 = 0xCC;	/* TL2 0CCh, TH2 0CDh */

In this example, ADC0, T2, RCAP2 and RCAP4 are declared as 16-bit SFRs and can b used as for example: T2 = 0x1234; // equivalent to TH2 = 0x12 and TL2 = 0x34

203
Download free eBooks at bookboon.com

PaulOS F020: An RTOS for the C8051F020

Endnotes

Whilst hoping that you found this book useful, please feel free to contact me if you have any queries or suggestions. If there is a great demand for porting the RTOS to another family of micro-controllers, I would be willing to attempt to do so. Paul Debono e-mail: pawlu.debono@yahoo.co.uk

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

204
Download free eBooks at bookboon.com

Click on the ad to read more

