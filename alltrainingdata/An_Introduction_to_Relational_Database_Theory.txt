An	Introduction	to	Relational Database	Theory
Hugh	Darwen

Download	free	books	at

Hugh Darwen

An Introduction to Relational Database Theory

2
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory 4th edition ¬© 2014 Hugh Darwen & bookboon.com ISBN 978-87-403-0777-1

This book is dedicated to the researchers at IBM United Kingdom‚Äôs Scientific Centre, Peterlee, UK, in the 1970s, who designed and implemented the relational database language, ISBL, that has been my guide ever since.

3
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Contents

Contents
	Preface	 1	Introduction	 1.1	Introduction	 1.2	 1.3	 1.4	 1.5	 1.6	 1.7	 1.8	 1.9	 1.10	 1.11	 1.12	 1.13	 What Is a Database?	 ‚ÄúOrganized Collection of Symbols‚Äù	 ‚ÄúTo Be Interpreted as a True Account‚Äù	 ‚ÄúCollection of Variables‚Äù	 What Is a Relational Database?	 ‚ÄúRelation‚Äù Not Equal to ‚ÄúTable‚Äù	 Anatomy of a Relation	 What Is a DBMS?	 What Is a Database Language?	 What Does a DBMS Do?	 Creating and Destroying Variables	 Taking Note of Integrity Rules	 9 14 14 14 15 15 17 18 19 21 22 23 23 24 26

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

4
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Contents

1.14	 1.15	 1.16	

Taking Note of Authorisations	 Updating Variables	 Providing Results of Queries	

27 28 31 32 33 33 33 36 37 41 42 42 44 47 49 51 54 55

	EXERCISE	 2	 Values, Types, Variables, Operators	 2.1	Introduction	 2.2	 2.3	 2.4	 2.5	 2.6	 2.7	 2.8	 2.9	 2.10	 2.11	 2.12	 Anatomy of A Command	 Important Distinctions	 A Closer Look at a Read-Only Operator (+)	 What Is a Type?	 What Is a Type Used For?	 The Type of a Relation	 Relation Literals	 Types and Representations	 What Is a Variable?	 Updating a Variable	

Read-only Operators in Tutorial D	37

2.13	Conclusion	 	EXERCISES	

5
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Contents

3	 3.2	 3.3	 3.4	 3.5	

Predicates and Propositions	 What Is a Predicate?	 Substitution and Instantiation	 How a Relation Represents an Extension	 Deriving Predicates from Predicates	

64 64 64 69 70 76 86 88 88 91 92 92 96 99 105 108 110 113 116 117

3.1	Introduction	

	EXERCISES	 4	 Relational Algebra‚ÄîThe Foundation	 4.1	Introduction	 4.2	 4.3	 4.4	 4.6	 4.7	 4.8	 4.9	 4.10	 4.11	 Relations and Predicates	 Relational Operators and Logical Operators	 JOIN and AND	 Projection and Existential Quantification	 Restriction and AND	 Extension and AND	 UNION and OR	 Semidifference and NOT	 Concluding Remarks	

4.5	RENAME	

	EXERCISES	
Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

6
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Contents

5	 5.1	 5.2	 5.3	 5.4	 5.5	 5.7	 5.8	 5.9	 5.10	

Building on The Foundation	 Introduction	 Semijoin and Composition	 Aggregate Operators	 Relations within a Relation	 Using Aggregate Operators with Nested Relations	 GROUP and UNGROUP	 WRAP and UNWRAP	 Relation Comparison	 Other Operators on Relations and Tuples	

121 121 122 127 131 133 134 136 140 143 148 149 150 150 151 152 160 165 174

5.6	SUMMARIZE	

	EXERCISES	 6	 6.2	 6.3	 6.4	 6.5	 Constraints and Updating	 A Closer Look at Constraints and Consistency	 Expressing Constraint Conditions	 Useful Shorthands for Expressing Constraints	 Updating Relvars	

6.1	Introduction	

	EXERCISES	

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

7
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Contents

7	 Database Design I: Projection-Join Normalization	 7.1	Introduction	 7.2	 7.3	 7.4	 7.5	 7.7	 7.8	 7.9	 Avoiding Redundancy	 Join Dependencies	 Fifth Normal Form	 Functional Dependencies	 The Role of FDs and Keys in Optimization	 Boyce-Codd Normal Form (BCNF)	 JDs Not Arising from FDs	

175 175 175 177 185 192 198 199 201 211 216 219 219 226 227 230 233

7.6	Keys	

	EXERCISES	 8	 8.1	 8.2	 8.3	 8.4	 	 Database Design II: Other Issues	 Group-Ungroup and Wrap-Unwrap Normalization	 Restriction-Union Normalization	 Surrogate Keys	 Representing ‚ÄúEntity Subtypes‚Äù	 Appendix A:  References and Bibliography	

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

8
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Preface

Preface
This book introduces you to the theory of relational databases, focusing on the application of that theory to the design of computer languages that properly embrace it. The book is intended for those studying relational databases as part of a degree course in Information Technology (IT). Relational database theory, originally proposed by Edgar F. Codd in 1969, is a topic in Computer Science. Codd‚Äôs seminal paper (1970) was entitled A Relational Model of Data for Large Shared Data Banks (reference [5] in Appendix A). An introductory course on relational databases offered by a university‚Äôs Computer Science (or similarly named) department is typically broadly divided into a theory component and what we might call an ‚Äúindustrial‚Äù component. The ‚Äúindustrial‚Äù component typically teaches the language, SQL (Structured Query Language), that is widely used in the industry for database purposes, and it might also teach other topics of current significance in the industry. Although this book is only about the theory, I hope it will be interesting and helpful to you even if your course‚Äôs main thrust is industrial. In the companion book SQL: A Comparative Survey I show how the concepts covered in this book are treated in SQL, along with historical notes explaining how and when the treatments in question arose in the official version of that language. (Aside: SQL doesn‚Äôt officially stand for anything, though it is usually assumed to stand for Structured Query Language. And the standard pronunciation is ‚Äúess-cue-ell‚Äù, not ‚Äúsequel‚Äù, so a DBMS that supports it is an SQL DBMS, not a SQL DBMS.) The book is directly based on a course of nine lectures that was delivered annually from 2004 to 2011 to undergraduates at the University of Warwick, England, as part of a 14-lecture module entitled Fundamentals of Relational Databases. The remaining five lectures of that module were on SQL. We encouraged the students to compare and contrast SQL with what they had learned in the theory part. We explained that study of the theory, and an example of a computer language based on that theory, should: ‚Ä¢	 enable them to understand the technology that is based on it, and how to use that technology (even if it is only loosely based on the theory, as is the case with SQL systems); ‚Ä¢	 provide a basis for evaluating and criticizing the current state of the art; ‚Ä¢	 illustrate of some of the generally accepted principles of good computer language design; ‚Ä¢	 equip those who might be motivated in their future careers to bring about change for the better in the database industry.

9
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Preface

Examples and exercises in this book all use a language, Tutorial D, invented by the author and C.J.¬†Date for the express purpose of teaching the subject matter at hand. Implementations of Tutorial D, which is described in reference [12], are available as free software on the Web. The one we use at the University of Warwick is called Rel, made by Dave Voorhis of the University of Derby. Rel is freely available at http://dbappbuilder.sourceforge.net/Rel.html. This book is accompanied by Exercises in Relational Database Theory, in which the exercises given at the end of each chapter (except the last) are copied and a few further exercises have been added. Sample solutions to all the exercises are provided and the reader is strongly recommended to study these solutions (preferably after attempting the exercises!). The book consists of eight chapters and two appendixes, as follows. Chapter 1, Introduction, is based on my first lecture and gives a broad overview of what a database is, what a relational database is, what a database management system (DBMS) is, what a DBMS is expected to do, and how a relational DBMS does those things. In Chapter 2, Values, Types, Variables, Operators, based on my second lecture, we look at the four fundamental concepts on which most computer languages are based. We acquire some useful terminology to help us talk about these concepts in a precise way, and we begin to see how the concepts apply to relational database languages in particular. Relational database theory is based very closely on logic. Fortunately, perhaps, in-depth knowledge and understanding of logic are not needed. Chapter 3, Predicates and Propositions, based on my third lecture, teaches just enough of that subject for our present purposes, without using too much formal notation. Chapter 4, Relational Algebra‚ÄîThe Foundation, based on material from lectures 4 and 5, describes the set of operators that is commonly accepted as forming a suitable basis for writing a special kind of expression that is used for various purposes in connection with a relational database‚Äînotably, queries and constraints. Chapter 5, Building on The Foundation, describes additional operators that are defined in Tutorial D (lectures 5‚Äì6) to illustrate some of the additional kinds of things that are needed in a relational database language for practical purposes. Chapter 6, Constraints and Updating, based on lecture 7, describes the operators that are typically used for updating relational databases, and the methods by which database integrity rules are expressed to a relational DBMS, declaratively, as constraints.

10
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Preface

The final two chapters address various issues in relational database design. Chapter 7, Database Design I: Projection-Join Normalization, based on lectures 8 and 9, deals with one particularly important issue that has been the subject of much research over the years. Chapter 8, Database Design II: Other Issues, discusses some other common issues that are not so well researched. These are not dealt with in my lectures but they sometimes arise in the annual course work assigned to our students. Note to Teachers Over the years since 1970 there have been many books covering relational database theory. I have aimed for several distinguishing features in this one, namely: 1.	 Focusing, in the first six chapters, on the application of the theory in a computer language. (Choosing a language, for that purpose, that I co-designed myself might seem a little selfserving on my part. I would plead guilty to any such charge, but really there was no choice.) 2.	 Emphasizing the difference between relations per se and relation variables (‚Äúrelvars‚Äù). Failure to do this in the past has resulted in all sorts of confusion. 3.	 Emphasizing the connection between the operators of the relational algebra and those of the first order predicate calculus. 4.	 Spurning Codd‚Äôs distinction (and SQL‚Äôs) between primary keys and alternate keys. As Codd himself originally pointed out, the choice of primary key is arbitrary. 5.	 In Chapter 7, on projection-join normalization, omitting details of normal forms that were defined in the early days but no longer seem useful, leaving just 6NF, 5NF, and BCNF. 2NF and 3NF are subsumed by the simpler BCNF, 4NF by the simpler 5NF. 1NF, not being a projection-join normal form, is dealt with (sort of) in Chapter 8. Domain-key normal form (DKNF) serves little purpose in practice and is not mentioned at all. 6.	 Also in Chapter 7, to study the normal forms in reverse order to that in which they are normally presented. I put 6NF first because it is the simplest and also the most extreme. More important to me was to deal with 5NF and join dependencies before BCNF and functional dependencies (though I do leave to the end discussion of those pathological cases where BCNF is satisfied but not 5NF). 7.	 In Chapters 7 and 8, taking care to include the integrity constraints that are needed in connection with each of the design choices under discussion; and, in Chapter 7, using those constraints to draw a clear distinction between decomposition as a genuine design choice and decomposition to correct design errors.

11
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Preface

Topics that might reasonably be expected but are not covered include: ‚Ä¢	 relational calculus (after all, it is only a matter of notation) ‚Ä¢	 the so-called problem of ‚Äúmissing information‚Äù and approaches to that problem that involve major departures from the theory ‚Ä¢	 views (apart from a brief mention) and view updating (too controversial) ‚Ä¢	 DBMS implementation issues, performance and optimization, concurrency ‚Ä¢	 database topics that are not particular to relational databases‚Äîfor example, security and authorization Acknowledgments Chris Date reviewed preliminary drafts of all the chapters and made many useful suggestions that I acted upon. Erwin Smout carefully reviewed the first publication and reported many minor errors which have now been corrected. Further errors were subsequently reported by Gene Wirchenko, Wilhelm Steinbuss, Laith Alissa, Joe Abbate, and Bernard Lambeau. These have been corrected too. I am most grateful to all these people. Ron Fagin saved me from making some egregious errors in connection with the definition of 5NF in Chapter 7. All remaining errors in this chapter and elsewhere in the book are, of course, my own. When I started to prepare the material for my lectures at Warwick no implementation of Tutorial D existed and I was fully expecting that students would be doing my exercises on paper. Then an amazingly timely e-mail came out of the blue from Dave Voorhis, telling me about Rel. Even more fortuitously, Dave himself was (and is) working at another UK university no more than 60 miles away from mine, so we were able to meet face-to-face for the demo that confirmed Rel‚Äôs usability for the purposes I had in mind. My relationship with the Computer Science department at Warwick started many years ago when I was working for IBM. I am most grateful to Meurig Beynon, who first invited me to be a guest lecturer and has given me much support and encouragement ever since. Alexandra Cristea was my valued colleague on the database modules from 2006 to 2013 and I am grateful for her help and support too.

12
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Preface

Fourth Edition Revisions 1.	 The Tutorial D examples and definitions have been revised where necessary to conform with Version 2 of that language. The revisions affect the operators EXTEND, SUMMARIZE, RENAME, UPDATE, GROUP, UNGROUP, WRAP, and UNWRAP, and also the WITH construct. The companion book Exercises on Relational Database Theory has been similarly revised and a few small changes were also needed in the other companion book, SQL: A Comparative Survey. 2.	 Appendix A of the first edition, dealing with differences between Version 1 and Version 2 of Tutorial D, clearly became surplus to requirements and has been dropped. In any case, both grammars are available at www.thethirdmanifesto.com. 3.	 Appendix B of previous editions becomes Appendix A, to which reference [8] has been added. 4.	 Chapter 7 has been revised to deal with a significant recent advance in the theory of normal forms given in reference [8]. 5.	 The end notes of previous editions have been eliminated. In most cases their text has been incorporated into the main body.

13
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

1	Introduction
1.1	Introduction
This chapter gives a very broad overview of ‚Ä¢	 what a database is ‚Ä¢	 what a relational database is, in particular ‚Ä¢	 what a database management system (DBMS) is ‚Ä¢	 what a DBMS does ‚Ä¢	 how a relational DBMS does what a DBMS does We start to familiarise ourselves with terminology and notation used in the remainder of the book, and we get a brief introduction to each topic that is covered in more detail in later sections.

1.2	

What Is a Database?

You will find many definitions of this term if you look around the literature and the Web. At one time (in 2008), Wikipedia [1] offered this: ‚ÄúA structured collection of records or data.‚Äù I prefer to elaborate a little:
A database is an organized, machine-readable collection of symbols, to be interpreted as a true account of some enterprise. A database is machine-updatable too, and so must also be a collection of variables. A database is typically available to a community of users, with possibly varying requirements.

The organized, machine-readable collection of symbols is what you ‚Äúsee‚Äù if you ‚Äúlook at‚Äù a database at a particular point in time. It is to be interpreted as a true account of the enterprise at that point in time. Of course it might happen to be incorrect, incomplete or inaccurate, so perhaps it is better to say that the account is believed to be true. The alternative view of a database as a collection of variables reflects the fact that the account of the enterprise has to change from time to time, depending on the frequency of change in the details we choose to include in that account. The suitability of a particular kind of database (such as relational, or object-oriented) might depend to some extent on the requirements of its user(s). When E.F. Codd developed his theory of relational databases (first published in 1969), he sought an approach that would satisfy the widest possible ranges of users and uses. Thus, when designing a relational database we do so without trying to anticipate specific uses to which it might be put, without building in biases that would favour particular applications. That is perhaps the distinguishing feature of the relational approach, and you should bear it in mind as we explore some of its ramifications.

14
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

1.3	

‚ÄúOrganized Collection of Symbols‚Äù

For example, the table in Figure 1.1 shows an organized collection of symbols.
StudentId S1 S1 S2 S3 Name Anne Anne Boris Cindy CourseId C1 C2 C1 C3

Figure 1.1: An Organized Collection of Symbols

Can you guess what this tabular arrangement of symbols might be trying to tell us? What might it mean, for symbols to appear in the same row? In the same column? In what way might the meaning of the symbols in the very first row (shown in blue) differ from the meaning of those below them? Do you intuitively guess that the symbols below the first row in the first column are all student identifiers, those in the second column names of students, and those in the third course identifiers? Do you guess that student S1‚Äôs name is Anne? And that Anne is enrolled on courses C1 and C2? And that Cindy is enrolled on neither of those two courses? If so, what features of the organization of the symbols led you to those guesses? Remember those features. In an informal way they form the foundation of relational theory. Each of them has a formal counterpart in relational theory, and those formal counterparts are the only constituents of the organized structure that is a relational database.

1.4	

‚ÄúTo Be Interpreted as a True Account‚Äù

For example (from Figure 1.1):
StudentId S1 Name Anne CourseId C1

Perhaps those green symbols, organized as they are with respect to the blue ones, are to be understood to mean: ‚ÄúStudent S1, named Anne, is enrolled on course C1.‚Äù

15
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

An important thing to note here is that only certain symbols from the sentence in quotes appear in the table‚ÄîS1, Anne, and C1. None of the other words appear in the table. The symbols in the top row of the table (presumably column headings, though we haven‚Äôt actually been told that) might help us to guess ‚Äústudent‚Äù, ‚Äúnamed‚Äù, and ‚Äúcourse‚Äù, but nothing in the table hints at ‚Äúenrolled‚Äù. And even if those assumed column headings had been A, B and C, or X, Y and Z, the given interpretation might still be the intended one. Now, we can take the sentence ‚ÄúStudent S1, named Anne, is enrolled on course C1‚Äù and replace each of S1, Anne, and C1 by the corresponding symbols taken from some other row in the table, such as S2, Boris, and C1. In so doing, we are applying exactly the same mode of interpretation to each row. If that is indeed how the table is meant to be interpreted, then we can conclude that the following sentences are all true: Student S1, named Anne, is enrolled on course C1. Student S1, named Anne, is enrolled on course C2. Student S2, named Boris, is enrolled on course C1. Student S3, named Cindy, is enrolled on course C3.

16
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

In Chapter 3, ‚ÄúPredicates and Propositions‚Äù, we shall see exactly how such interpretations can be systematically formalized. In Chapter 4, ‚ÄúRelational Algebra‚ÄîThe Foundation‚Äù, and Chapter 5, ‚ÄúBuilding on The Foundation‚Äù, we shall see how they help us to formulate correct queries to derive useful information from a relational database.

1.5	

‚ÄúCollection of Variables‚Äù

Now look at Figure 1.2, a slight revision of Figure 1.1. ENROLMENT
StudentId S1 S1 S2 S3 S4 Name Anne Anne Boris Cindy Devinder CourseId C1 C2 C1 C3 C1

Figure 1.2: A variable, showing its current value

We have added the name, ENROLMENT, above the table, and we have added an extra row. ENROLMENT is a variable. Perhaps the table we saw earlier was once its value. If so, it (the variable) has been updated since then‚Äîthe row for S4 has been added. Our interpretation of Figure 1.1 now has to be revised to include the sentence represented by that additional row: Student S1, named Anne, is enrolled on course C1. Student S1, named Anne, is enrolled on course C2. Student S2, named Boris, is enrolled on course C1. Student S3, named Cindy, is enrolled on course C3. Student S4, named Devinder, is enrolled on course C1. Notice that in English we can join all these sentences together to form a single sentence, using conjunctions like ‚Äúand‚Äù, ‚Äúor‚Äù, ‚Äúbecause‚Äù and so on. If we join them using ‚Äúand‚Äù in particular, we get a single sentence that is logically equivalent to the given set of sentences in the sense that it is true if each one of them is true (and false if any one of them is false). A database, then, can be thought of as a representation of an account of the enterprise expressed as a single sentence! (But it‚Äôs more usual to think in terms of a collection of individual sentences.)

17
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

We might also be able to conclude that the following sentences (for example) are false: Student S2, named Boris, is enrolled on course C2. Student S2, named Beth, is enrolled on course C1. Whenever the variable is updated, the set of true sentences represented by its value changes in some way. Updates usually reflect perceived changes in the enterprise, affecting our beliefs about it and therefore our account of it.

1.6	

What Is a Relational Database?

A relational database is one whose symbols are organized into a collection of relations. Figure 1.3 confirms that the examples we have already seen are in fact relations, depicted in tabular form. Indeed, according to Figure 1.2, the relation depicted in Figure 1.3 is the current value of the variable ENROLMENT.
StudentId S1 S1 S2 S3 S4 Name Anne Anne Boris Cindy Devinder CourseId C1 C2 C1 C3 C1

Figure 1.3: A relation, shown in tabular form

Happily, the visual (tabular) representation we have been using thus far is suited particularly well to relational databases: so much so that many people use the word table as an alternative to relation. The language SQL in particular uses that term, so in the context of relational theory it is convenient and judicious to stick with relation for the theoretical construct, allowing SQL‚Äôs deviations from relational theory to be noted as differences between tables and relations. Relation is a formal term in mathematics‚Äîin particular, in the logical foundation of mathematics. It appeals to the notion of relationships between things. Most mathematical texts focus on relations involving things taken in pairs but our example shows a relation involving things taken three at a time and, as we shall see, relations in general can relate any number of things (and, as we shall see, the number in question can even be less than two, making the term relation seem somewhat inappropriate).

18
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

Relational database theory is built around the concept of a relation. Our study of the theory will include: ‚Ä¢	 The ‚Äúanatomy‚Äù of a relation. ‚Ä¢	 Relational algebra: a set of mathematical operators that operate on relations and yield relations as results. ‚Ä¢	 Relation variables: their creation and destruction, and operators for updating them. ‚Ä¢	 Relational comparison operators, allowing consistency rules to be expressed as constraints (commonly called integrity constraints) on the variables constituting the database. And we will see how these, and other constructs, can form the basis of a database language (specifically, a relational database language).

1.7	

‚ÄúRelation‚Äù Not Equal to ‚ÄúTable‚Äù

‚ÄúTable‚Äù, here, refers to pictures of the kind shown in Figures 1.1, 1.2, and 1.3. The terms relation and table are not synonymous. For one thing, although every relation can be depicted as a table, not every table is a representation of (i.e., denotes) some relation. For another, several different tables can all represent the same relation. Consider Figure 1.4, for example.

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

19
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

Name Devinder Cindy Anne Boris Anne

StudentId S4 S3 S1 S2 S1

CourseId C1 C3 C1 C1 C2

(Actually, there are two very special relations which cannot sensibly be depicted in tabular form. You will encounter these two in Chapter 4.)

Figure 1.4: Same relation as Figure 1.3

The table in Figure 1.4 is different from the one in Figure 1.3, but it represents the same relation. I have changed the order of the columns and the order of the rows, each green row in Figure 1.4 has the same symbols for each column heading as some row in Figure 1.3 and each row in Figure 1.3 has a corresponding row, derived in that way, in Figure 1.4. What I am trying to illustrate is the principle that the relation represented by a table does not depend on the order in which we place the rows or the columns in that table. It follows that several different tables can all denote the same relation, because we can simply change the left-to-right order in which the columns are shown and/or the top-to-bottom order in which the rows are shown and yet still be depicting the same relation. What does it mean to say that the order of columns and the order of rows doesn‚Äôt matter? We will find out the answer to this question when we later study the typical operators that are defined for operating on relations (e.g., to compute results of queries against the database) and relation variables (e.g., to update the database). None of these operators will depend on the notion of some row or some column being the first or last, or immediately before or after some other column or row. We can also observe that not every table depicts a relation. Such tables can easily be obtained just by deleting the blue rows (the column headings) from each of Figures 1.1 to 1.4. Figure 1.5 shows another table that does not depict any relation.
A 1 4 6 9 1 7 9 2 B 2 A 3 5 8 ? 3

Figure 1.5: Not a relation

The various reasons why this table cannot be depicting a relation should become apparent to you by the time you reach the end of this chapter.

20
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

1.8	

Anatomy of a Relation

Figure 1.6 shows the terminology we use to refer to parts of the structure of a relation.

DWWULEXWH QDPH

WKHKHDGLQJ

1DPH

6WXGHQW,G 6 6 6 6 6

&RXUVH,G & & & & &

WKHERG\WKLV RQHKDVWXSOHV LVWKH FDUGLQDOLW\RI WKHUHODWLRQ

'HYLQGHU &LQG\ $QQH %RULV $QQH

QWXSOHRU WXSOHKHUH Q WKH GHJUHHRIWKH UHODWLRQ

DWWULEXWHYDOXHV

Figure 1.6: Anatomy of a relation

Because of the distinction I have noted between the terms relation and table, we prefer not to use the terminology of tables for the anatomical parts of a relation. We use instead the terms proposed by E.F.¬†Codd, the researcher who first proposed relational theory as a basis for database technology, in 1969. Try to get used to these terms. You might not find them very intuitive. Their counterparts in the tabular representation might help: ‚Ä¢ ‚Ä¢ ‚Ä¢ relation (n-)tuple attribute : : : table row column

Also (as shown in Figure 1.6): The degree is the number of attributes. The cardinality is the number of tuples.

21
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

The heading is the set of attributes (note set, because the attributes are not ordered in any way and no attribute appears more than once). The body is the set of tuples (again, note set‚Äîthe tuples are not ordered and no tuple appears more than once). An attribute has an attribute name, and no two have the same name. Each attribute has an attribute value in each tuple.

1.9	

What Is a DBMS?

A database management system (DBMS) is exactly what its name suggests‚Äîa piece of software for managing databases and providing access to them. But be warned!‚Äîin the industry the term database is commonly used to refer to a DBMS, especially in promotional literature. You are strongly discouraged from adopting such sloppy practice (if such a system is a database, what are the things it manages?) A DBMS responds to commands given by application programs, custom-written or general-purpose, executing on behalf of users. Commands are written in the database language of the DBMS (e.g., SQL). Responses include completion codes, messages and results of queries.

.

22
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

In order to support multiple concurrent users a DBMS normally operates as a server. Its immediate users are thus those application programs, running as clients of this server, typically (though not necessarily) on behalf of end users. Thus, some kind of communication protocol is needed for the transmission of commands and responses between client and server. Before submitting commands to the server a client application program must first establish a connection to it, thus initiating a session, which typically lasts until the client explicitly asks for it to be terminated. That is all you need to know about client-server architecture as far as this book is concerned. This book is concerned with relational DBMSs and relational databases in particular, and soon we will be looking at the components we expect to find in a relational DBMS. Before that we need to briefly review what is expected of a DBMS in general.

1.10	

What Is a Database Language?

To repeat, the commands given to a DBMS by an application are written in the database language of the DBMS. The term data sublanguage is sometimes used instead of database language. The sub- prefix refers to the fact that application programs are sometimes written in some more general-purpose programming language (the ‚Äúhost‚Äù language), in which the database language commands are embedded in some prescribed style. Sometimes the embedding style is such that the embedded statements are unrecognized by the host language compiler or interpreter, and some special preprocessor is used to replace the embedded statements by, for example, CALL statements in the host language. A query is an expression that, when evaluated, yields some result derived from the database. Queries are what make databases useful. Note that a query is not of itself a command (though some texts, curiously, use the term query for commands as well as genuine queries, including commands that update the database!). The DBMS might support some kind of command to evaluate a given query and make the result available for access, also using DBMS commands, by the application program. The application program might execute such commands in order to display a query result (usually in tabular form) in a window.

1.11	

What Does a DBMS Do?

In response to requests from application programs, we expect a DBMS to be able, for example, to ‚Ä¢	 create and destroy variables in the database ‚Ä¢	 take note of integrity rules (constraints) ‚Ä¢	 take note of authorisations (who is allowed to do what, to what) ‚Ä¢	 update variables (honouring constraints and authorisations) ‚Ä¢	 provide results of queries To amplify some of the terms just used:

23
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

The requests take the form of commands written in the database language supported by the DBMS. The variables are the constituents of the database, like the ENROLMENT variable we looked at earlier. Such variables are both persistent and global. A persistent variable is one that ceases to exist only when its destruction is explicitly requested by some user. A global variable is one that exists independently of the application programs that use it, distinguishing it from a local variable, declared within the application program and automatically destroyed when the program unit (‚Äúblock‚Äù) in which it is declared finishes its execution. Constraints (sometimes called integrity constraints) are rules governing permissible values, and permissible combinations of values, of the variables. For example, it might be possible to tell the DBMS that no student‚Äôs assessment score can be less than zero. A database that violates a constraint is, by definition, incorrect‚Äîit represents an account that is in some respect false. A database that satisfies all its constraints is said to be consistent, even though it cannot in general be guaranteed to be correct. In the sense that constraints are for integrity, authorisations are for security. Some of the data in a database might represent sensitive information whose accessibility is restricted to certain privileged users only. Similarly, it might be desired to allow some users to access certain parts of the database without also being able to update those parts. Note the three parts of an authorisation: who, what, and to what. ‚ÄúWho‚Äù is a user of the database; ‚Äúwhat‚Äù is one of the operations that are available for operating on the variables in the database; ‚Äúto what‚Äù is one of those variables. In the remaining sections of this chapter you will see examples of how a relational DBMS does these things. Unless otherwise stated, the examples use commands written in Tutorial¬†D.

1.12	

Creating and Destroying Variables

Example 1.1 shows a command to create the variable shown in Figure 1.2: Example 1.1: Creating a database variable. VAR ENROLMENT BASE RELATION Name		

{ StudentId	 SID , CourseId	 CID }

CHAR ,

KEY { StudentId, CourseId } ;

24
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

Explanation 1.1: VAR is a key word, indicating that a variable is to be created. ENROLMENT is the variable‚Äôs name. BASE is a key word indicating that the variable is to be part of the database, thus both persistent

and global. If BASE were omitted, then the command would result in creation of a local variable. The text from RELATION to the closing brace specifies the declared type of the variable, meaning

that every value ever assigned to ENROLMENT must be a value of that type.

and a heading specification. Thus, every value ever assigned to ENROLMENT must be a relation of that type. A heading specification consists of a list of attribute names, each followed by a

The declared type of ENROLMENT is a relation type, indicated by the key word RELATION

type name, the entire list being enclosed in braces. Thus, each attribute of the heading also has a declared type. The type names SID and CID (for student ids and course ids) refer to userdefined types. User-defined types have to be defined by some user of the DBMS before they can be referred to. The type name CHAR (character strings), by contrast, is a built-in type: it is provided by the DBMS itself, is available to all users, and cannot be destroyed.

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

25
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

Chapter 2, ‚ÄúValues, Types, Variables, Operators‚Äù, deals with types in more detail, and shows you how to define types such as SID and CID. KEY indicates that the variable is subject to a certain kind of constraint, in this case declaring

that no two tuples in the relation assigned to ENROLMENT can ever have the same combination of attribute values for StudentId and CourseId (i.e., we cannot enrol the same student on and key constraints in particular in Chapter 6. Destruction of ENROLMENT is the simple matter shown in Example 1.2, Example 1.2: Destroying a variable. DROP VAR ENROLMENT ; After execution of this command the variable no longer exists and any attempt to reference it is in error. the same course more than once, so to speak). We will learn more about constraints in general

1.13	

Taking Note of Integrity Rules

For example, suppose the university has a rule to the effect that there can never be more than 20,000 enrolments altogether. Example 1.3 shows how to declare the corresponding constraint in Tutorial D. Example 1.3: Declaring an integrity constraint. CONSTRAINT MAX_ENROLMENTS

COUNT ( ENROLMENT ) ÔÇü 20000 ;

Explanation 1.3: ‚Ä¢	 CONSTRAINT is the key word indicating that a constraint is being declared. ‚Ä¢	 COUNT ( ENROLMENT ) is a Tutorial D expression yielding the cardinality (see the ‚Ä¢	 COUNT (ENROLMENT) ÔÇü 20000 is a truth-valued expression, yielding true if the earlier section, ‚ÄúAnatomy of a Relation‚Äù) of the current value of ENROLMENT. ‚Ä¢	 MAX_ENROLMENTS is the name of the constraint.

cardinality is less than or equal to 20000, otherwise yielding false. (Note regarding Rel: Because the symbol ÔÇü is normally unavailable on keyboards, Rel accepts <= in its place.)

The declaration tells the DBMS that the database is inconsistent if the value of MAX_ENROLMENTS is would bring about that situation. Example 1.4 shows how to retract a constraint that ceases to be applicable.

ever false, and that the DBMS is therefore to reject any attempt to update the database that, if accepted,

26
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

Example 1.4: Retracting an integrity constraint. DROP CONSTRAINT MAX_ENROLMENTS ;

1.14	

Taking Note of Authorisations

Tutorial D does not include any commands for creating and destroying permissions, because security and authorization, though important, are not specifically relational database issues. If Tutorial D did include such commands, we might reasonably expect them to look like those shown in Example 1.5, which are meant to be self-explanatory. Example 1.5: Creating permissions PERMISSION U9_ENROLMENT FOR User9 TO READ ENROLMENT ;

PERMISSION U8_ENROLMENT FOR User8 TO UPDATE ENROLMENT ; Note the syntactic consistency with commands we have already seen: a key word indicating the kind of thing being created or destroyed, followed by the name of the thing, followed in turn by the specification of the thing. (C.J. Date, co-designer of Tutorial D, makes a slightly different suggestion for granting permissions in his Introduction to Database Systems, 8th edition, on page 506.) How do you rate computer languages you are already acquainted with, for syntactic consistency? For example, the database language SQL has been noted to suffer from several syntactic inconsistencies (as well as‚Äîmuch more seriously‚Äîseveral harmful deviations from relational database theory). By now you can predict the command, consistent with Example 1.5 and shown in Example 1.6, to be used to retract a permission previously granted. Example 1.6: Retracting a permission DROP PERMISSION U9_ENROLMENT ; In case you are familiar with SQL‚Äôs GRANT and REVOKE statements that are used for such purposes, you might like to give some thought to the advantages and disadvantages of using specific names for permission you are withdrawing. permissions. SQL doesn‚Äôt use them‚Äîin an SQL REVOKE statement you have to repeat the details of the

27
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

1.15	

Updating Variables

The usual way of updating a variable in computer languages is by assignment. For example, if X is an integer variable, the assignment X := X + 1 updates X such that its value immediately after execution of := denotes the source for the assignment and the variable name on the left denotes the target. When the target is a relation variable‚Äîas it always is when it is part of a relational database‚Äîthe source must be a relation. You will learn how to write expressions that denote relations in Chapters 2, 4 and 5, but in any case assignment, though it should be available (it isn‚Äôt in SQL), is not the usual way of applying updates to a relational database. This is because there is very often only a small amount of difference, in a manner of speaking, between the ‚Äúold‚Äù value and the ‚Äúnew‚Äù value and it is usually much more convenient to be able to express the update in terms of that small difference. The differential update operators expected in a relational DBMS are usually called INSERT, DELETE, (Example 1.8). of the assignment is one more than its value was immediately beforehand. The expression on the right

and UPDATE, and those are the names used in Tutorial D (also in SQL). Take a look at DELETE first

Example 1.8: Updating by deletion DELETE ENROLMENT WHERE StudentId = SID ( 'S4' ) ;

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

28
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

Explanation 1.8: ‚Ä¢	 Informally, Example 1.8 deletes all the tuples for student S4 and can be interpreted as meaning ‚Äústudent S4 is no longer enrolled on any courses‚Äù. More formally, it assigns to the variable ENROLMENT the relation whose body consists of those tuples in the current value of ENROLMENT that fail to satisfy the condition given in the WHERE clause‚Äîthus, every tuple in which the value of the StudentId attribute is not the student identifier S4.

‚Ä¢	 StudentId = SID ( 'S4' ) is a conditional expression. Because it follows the key ‚Ä¢	 The expression SID ( 'S4' ) will be explained in Chapter 2, when we study types. Next, in Example 1.9, we look at UPDATE. Example 1.9: Updating by replacement UPDATE ENROLMENT WHERE StudentId = SID ( 'S1' ) : { Name := 'Ann' } ; word WHERE here, it is in fact a WHERE condition, also known as a restriction condition.

of assignments‚Äîin Example 1.9 just one assignment‚Äîbut these are assignments to attributes, not assignments to variables. Explanation 1.9: ‚Ä¢	 Informally, Example 1.9 updates each ENROLMENT tuple for student S1, changing its Name value to 'Ann'. More formally, it assigns to the variable ENROLMENT the relation that is identical to the current value in all respects except that the value for the attribute Name, in in each case. (I would have written ‚Äúexcept possibly‚Äù had I not known that the existing

Note that UPDATE uses a WHERE clause, just like DELETE. The WHERE clause is followed by a list

the tuples whose StudentId value is the student identifier S1, becomes the string 'Ann' Name value in those tuples is 'Anne' in each case. In some circumstances no change takes ‚Ä¢	 Name := 'Ann' is an attribute assignment. An attribute assignment sets the value of the target attribute to the specified value, in each tuple that satisfies the WHERE condition. place as a result of executing an UPDATE, and the same applies to DELETE and INSERT.)

Finally, Example 1.10 illustrates the use of INSERT. Example 1.10: Updating by insertion INSERT ENROLMENT RELATION { TUPLE { StudentId SID ( 'S4' ) , Name 'Devinder' , CourseId CID ( 'C1' ) } } ;
29
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

Explanation 1.10: ‚Ä¢	 Informally, Example 1.10 adds a tuple to ENROLMENT indicating that student S4, still called Devinder, is now enrolled on course C1. More formally, it assigns to the variable ENROLMENT the relation consisting of every tuple in the current value of ENROLMENT expression following the word ENROLMENT. and every tuple (there is only one in this particular example) in the relation denoted by the

‚Ä¢	 The expression beginning with the key word TUPLE and ending at the penultimate closing brace denotes the tuple consisting of the three indicated attribute values: SID¬†(¬†'S4'¬†) for the attribute StudentId, 'Devinder' for the attribute Name,

‚Ä¢	 The expression beginning with the key word RELATION and ending at the final closing brace denotes the relation whose body consists of that single tuple. Such expressions are fully explained in Chapter 2, ‚ÄúValues, Types, Variables, Operators‚Äù. Example 1.8 has no effect on the database in the case where the current value of ENROLMENT has no

and CID¬†(¬†'C1'¬†) for the attribute CourseId.

tuples for student S4.

Example 1.9 has no effect on the database in the case where the current value of ENROLMENT has no tuples for student S1.

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

30
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Introduction

Example 1.10 has no effect on the database in the case where the current value of ENROLMENT already

contains the tuple representing the enrolment of student S4, named Devinder, on course C1. It also has no effect on the database if the cardinality of the current value of ENROLMENT is 20,000 and the constraint MAX_ENROLMENTS (Example 1.3) is in effect. In this case, and possibly in the first case too, an error message results.

1.16	

Providing Results of Queries

Expressing queries in Tutorial D is the (big) subject of Chapters 4 and 5. Here I present just a simple example to give you the flavour of things to come in those chapters. Example 1.11 is a query expressing the question, who is enrolled on course C1? Example 1.11: A query in Tutorial D ENROLMENT WHERE CourseId = CID('C1') { StudentId, Name } Note carefully that Example 1.11 is not a command. It is just an expression, denoting a value‚Äîin this case, a relation. In a relational database language the result of a query is always another relation! Figure 1.7 shows the result of Example 1.11 in the usual tabular form.
StudentId S1 S2 S4 Name Anne Boris Devinder

Figure 1.7: Result of query in Example 1.11

Explanation 1.11: ‚Ä¢	 WHERE is the key word identifying the Tutorial D operator of that name. This operator operates on a given relation and yields a relation. Certain operators, including this one, that operate on relations and yield relations together constitute the relational algebra, covered in detail in Chapter 4. ‚Ä¢	 CourseId = CID('C1') qualifies WHERE, specifying that just the tuples for course C1 are required. ‚Ä¢	 { StudentId, Name } specifies that from the result of the previous operation (WHERE) just the StudentId and Name attributes are required.

The overall result is a relation formed from the current value of ENROLMENT by discarding certain tuples and a certain attribute.

31
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Introduction

EXERCISE
Consider the table shown in Figure 1.5, repeated here for convenience:
A B

A 3 5

1 4 6 9 1

2

7 9 2

8 ? 3

Give three reasons why it cannot possibly represent a relation. By the way, this table is supported by SQL, and the three reasons represent some of SQL‚Äôs serious and far-reaching deviations from relational theory.

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

32
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2	Values, Types, Variables, Operators
2.1	Introduction
In this chapter we look at the four fundamental concepts on which most computer languages are based. We acquire some useful terminology to help us talk about these concepts in a precise way, and we begin to see how the concepts apply to relational database languages in particular. It is quite possible that you are already very familiar with these concepts‚Äîindeed, if you have done any computer programming they cannot be totally new to you‚Äîbut I urge you to study the chapter carefully anyway, as not everybody uses exactly the same terminology (and not everybody is as careful about their use of terminology as we need to be in the present context). And in any case I also define some special terms, introduced by C.J. Date and myself in the 1990s, which have perhaps not yet achieved wide usage‚Äîfor example, selector and possrep. I wrote ‚Äúmost computer languages‚Äù because some languages dispense with variables. Database languages typically do not dispense with variables because it seems to be the very nature of what we call a database that it varies over time in keeping with changes in the enterprise. Money changes hands, employees come and go, get salary rises, change jobs, and so on. A language that supports variables is said to be an imperative language (and one that does not is a functional language). The term ‚Äúimperative‚Äù appeals to the notion of commands that such a language needs for purposes such as updating variables. A command is an instruction, written in some computer language, to tell the system to do something. The terms statement (very commonly) and imperative (rarely) are used instead of command. In this book I use statement quite frequently, bowing to common usage, but I really prefer command because it is more appropriate; also, in normal discourse statement refers to a sentence of the very important kind described in Chapter 3 and does not instruct anybody to do anything.

2.2	

Anatomy of A Command

Figure 2.1 shows a simple command‚Äîthe assignment, Y := X + 1‚Äîdissected into its component parts. The annotations show the terms we use for those components.

33
Download free eBooks at bookboon.com

module entitled Fundamentals of Relational Databases. The remaining five lectures of that module were on SQL. We encouraged the students to compare and contrast SQL with what they had learned in the theory part. We explained that study of the theory, and an example of a computer language based on that theory, should:

An Introduction to Relational Database Theory

page 33, Figure 2.1: The edit resulting from my previous errata has lost the text in the third ellipse down on the right. The missing text is ‚ÄúAn operator name (denoting a read-only operator)‚Äù. Here is my copy of the complete figure: An invocation (of +), denoting a value A literal (denoting a value) An operator name (denoting a read-only operator)

Values, Types, Variables, Operators

Example: Y := A variable name (denoting a variable)

X + 1 ;

A variable reference (denoting its current value) An operator name (denoting an update operator)

X and 1 denote arguments to the invocation of + Y and X+1 denote arguments to the invocation of :=

Figure 2.1: Some terminology
Figure 2.1: Some terminology

It is important to distinguish carefully between the concepts and the language constructs that
End of Errata represent (denote) those concepts. It is the distinction between what is written and what it means‚Äîsyntax

and semantics. Each annotated component in Figure 1 is an example of a certain language construct. The annotation shows the term used for the language construct and also the term for the concept it denotes. Honouring this distinction at all times can lead to laborious prose. Furthermore, we don‚Äôt always have distinct terms for the language construct and the corresponding concept. For example, there is no single-word term for an expression denoting an argument. We can write ‚Äúargument expression‚Äù when we need to be absolutely clear and there is any danger of ambiguity, but normally we would just say, for example, that X+1 is an argument to that invocation of the operator ‚Äú:=‚Äù shown in Figure 2.1. (The real argument is the result of evaluating X+1.)
Errata in Version of 02 November 2012 ‚Äî Page 1 of 1

The update operator ‚Äú:=‚Äù is known as assignment. The command Y := X+1 is an invocation of assignment, often referred to as just an assignment. The effect of that assignment is to evaluate the references to Y therefore yield r (until some command is given to assign something else to Y). expression X+1, yielding some numerical result r and then to assign r to the variable Y. Subsequent

Note the two operands of the assignment: Y is the target, X+1 the source. The terms target and source here are names for the parameters of the operator. In the example, the argument expression Y is substituted for the parameter target and the argument expression X+1 is substituted for the parameter source. We say that target is subject to update, meaning that any argument expression substituted for it must denote a variable. The other parameter, source, is not subject to update, so any argument expression substituted must denote a value, not a variable. Y denotes a variable and X+1 denotes a value. When Y becomes the argument substituted for target, and the current value of X+1 becomes the argument the assignment is evaluated (or, as we sometimes say of commands, executed), the variable denoted by substituted for source.

34
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Whereas the Y in Y := X + 1 denotes a variable, as I have explained, the X in Y := X + 1 does operator +, which has two parameters, perhaps named a and b. Neither a nor b is subject to update. A

not, as I am about to explain. So now let‚Äôs analyse the expression X+1. It is an invocation of the read-only read-only operator is one that has no parameter that is subject to update. Evaluation of an invocation of a read-only operator yields a value and updates nothing. The arguments to the invocation, in this example denoted by the expressions X and 1, are the values denoted by those two expressions. 1 is a currently assigned to X. literal, denoting the numerical value that it always denotes; X is a variable reference, denoting the value

A literal is an expression that denotes a value and does not contain any variable references. But we do not use that term for all such expressions: for example, the expression 1+2, denoting the number 3, is not a literal. I defer a precise definition of literal to later in the present chapter.

AXA Global Graduate Program
Find out more and apply

35
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.3	

Important Distinctions

The following very important distinctions emerge from the previous section and should be firmly taken on board: ‚Ä¢	 Syntax versus semantics ‚Ä¢	 Value versus variable ‚Ä¢	 Variable versus variable reference ‚Ä¢	 Update operator versus read-only operator ‚Ä¢	 Operator versus invocation ‚Ä¢	 Parameter versus argument ‚Ä¢	 Parameter subject to update versus parameter not subject to update Each of these distinctions is illustrated in Figure 2.1, as follows: ‚Ä¢	 Value versus variable: Y denotes a variable, X denotes the value currently assigned to the variable X. 1 denotes a value. Although X and Y are both symbols referencing variables, what they denote depends in the context in which those references appear. Y appears as

an update target and thus denotes the variable of that name, whereas X appears where an

expression denoting a value is expected and that position denotes the current value of the referenced variable. Note that variables, by definition, are subject to change (in value) from time to time. A value, by contrast, exists independently of time and space and is not subject to change. ‚Ä¢	 Update operator versus read-only operator: ‚Äú:=‚Äù (assignment) is an update operator; ‚Äú+‚Äù (addition) is a read-only operator. An update operator has at least one parameter that is value; an update operator doesn‚Äôt. ‚Ä¢	 Operator versus invocation: ‚Äú+‚Äù is an operator; the expression X+1 denotes an invocation ‚Ä¢	 Parameter versus argument: The expressions X and 1 denote arguments to the invocation of +; the operator + is defined to have two parameters. When an operator is invoked, an argument must be substituted for each of its defined parameters. The term argument strictly refers to the value or variable denoted by the argument expression but is often used to refer to the expression itself. ‚Ä¢	 Parameter subject to update versus parameter not subject to update: The first parameter of ‚Äú:=‚Äù (the one representing the target) is subject to update, so a variable must be substituted for it when ‚Äú:=‚Äù is invoked (and an expression denoting a variable must appear in the corresponding position in the expression denoting the invocation); the second parameter of ‚Äú:=‚Äù and both parameters of + are not subject to update, so values must be substituted for them in invocations (and expressions denoting values must appear in the corresponding positions in the expressions denoting the invocations).
36
Download free eBooks at bookboon.com

subject to update; a read-only operator doesn‚Äôt. A read-only operator, when invoked, yields a

of ‚Äú+‚Äù.

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.4	

A Closer Look at a Read-Only Operator (+)

A read-only operator is what mathematicians call a function, and a function turns out to be just a special case of a relation! Because it is a relation, a function can be depicted in tabular form. Figure¬†2.2 is a picture of part of the function represented by the read-only operator +.
D      E      F     

DQGVRRQDGLQILQLWXP
Figure 2.2: The operator + as a relation (part)

The relation shown in Figure 2.2 represents the predicate a + b = c. The relation attributes a and b can be considered as the parameters of the operator +. Each tuple maps a pair of values substituted for a and b to the result of their addition, which is substituted for c. The relation is a function because each b value, so, given an a and a b, so to speak, we know the (only) resulting c. Notice how the relational perception of an operator neutralises the distinction between arguments and result. This relation could also represent the predicate c‚Äîb = a, or c‚Äîa = b. You can imagine the invocation 1+2 as singling out the tuple with a=1 and b=2 (there is only one such tuple) and yielding the c value (3) in that tuple. unique <a,b> pair maps to exactly one c value‚Äîno two tuples with the same a value also have the same

This particular relation is concerned only with numbers‚Äîits domain of discourse, some would say. Mathematicians, perceiving + as a function mapping pairs of numbers (<a,b>) to numbers (c), call the (<a,b>) number-pairs the domain of the function and the numbers (c) its range. Computer scientists, perceiving + as an operator, say that its parameters a and b are of type number, as is the result, c (the type of the result is also referred to as the type of the operator).

2.5	

Read-only Operators in Tutorial D

In computer languages we distinguish between operators that are defined as part of the language and operators that may be defined by uses of the language. Those defined as part of the language are called built-in, or system-defined, operators whereas those defined by users are called user-defined operators.

37
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

A complete grammar for Tutorial D does not yet exist and the incomplete one that does exist does not give a complete list of built-in operators. It mentions a few particular ones that have been devised for certain special purposes and adds ‚Äú‚Ä¶plus the usual possibilities‚Äù, leaving it to the implementation to decide what the usual possibilities are. In this book the matter of whether an operator used in my examples is built-in or user-defined is immaterial, except of course for those operators which an implementation is explicitly required to provide as built-in. User-defined operator definition in Tutorial D is illustrated in Example 2.1, which defines an operator named HIGHER_OF to give the value of whichever is the higher of two given integers. For example, the invocation HIGHER_OF(3,4) yields the integer 4. Example 2.1: A User-Defined Operator OPERATOR HIGHER_OF ( A INTEGER, B INTEGER ) RETURNS INTEGER ; IF A > B THEN RETURN A ; END IF ; ELSE RETURN B ;

END OPERATOR ;

38
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Explanation 2.1: ‚Ä¢	 OPERATOR HIGHER_OF announces that an operator is being defined and its name is HIGHER_OF. There might be other operators, also named HIGHER_OF, in which case they are distinguished from one another by the types of their parameters. The name combined HIGHER_OF(A¬†INTEGER,B¬†INTEGER), which would distinguish it from with the parameter definitions is called the signature of the operator. Here the signature is HIGHER_OF(A¬†RATIONAL,B¬†RATIONAL) if that operator were also defined.

‚Ä¢	 A INTEGER, B INTEGER specifies two parameters, named A and B and both of

declared type INTEGER. (Although I have included parameter names in the signature, they do not normally have any significance in distinguishing one operator from another. That is because parameter names are not normally used in invocations, the connections between argument expressions and their corresponding parameters being established by position rather than by use of names.)

‚Ä¢	 RETURNS INTEGER specifies that the value resulting from every invocation of

‚Ä¢	 IF ‚Ä¶ END IF ; is a single command (specifically, an IF statement) constituting

HIGHER_OF shall be of type INTEGER (which is thus the declared type of HIGHER_OF).

the program code that implements HIGHER_OF. The programming language part of

Tutorial D, intended for writing implementation code for operators and applications, is really beyond the scope of this book, but if you are reasonably familiar with programming languages in general you should have no trouble understanding Tutorial D, which is deliberately both simple and conventional. ‚Ä¢	 IF A > B THEN RETURN A ‚Ä¶ such as RETURN A here, which is executed only substituted for A and B in an invocation of HIGHER_OF). The RETURN statement expression, A, to be the result of the invocation. not satisfied. The IF statement contains further commands within itself‚Ä¶

when the given IF condition, A > B, evaluates to TRUE (i.e., is satisfied by the arguments terminates the execution of an invocation and causes the result of evaluating the given

‚Ä¢	 ELSE RETURN B specifies the statement to be executed when the given IF condition is ‚Ä¢	 END IF marks the end of the IF statement. operator definition.

‚Ä¢	 END OPERATOR marks the end of the program code and in fact the end of the

39
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Notes concerning Rel: ‚Ä¢	 Rel provides as built-in all the Tutorial D operators used in this book except where explicitly stated to the contrary. ‚Ä¢	 Rel supports Tutorial D user-defined operators. ‚Ä¢	 Rel additionally supports user-defined operators with program code written in Java‚Ñ¢ (the language in which Rel itself is implemented), indicated by the key word FOREIGN. Examples of such operators are provided in the download package for Rel. Here are two of them (as provided at the time of writing in Version 3.15, in the file OperatorsChar.d, which you can load and execute in Dbrowser): OPERATOR INTEGER) RETURNS CHAR Java FOREIGN // Substring, 0 based SUBSTRING(s CHAR, beginindex INTEGER,

endindex

return new ValueCharacter(s.stringValue().substring(

(int)beginindex.longValue(), (int)endindex.longValue()));

END OPERATOR; FOREIGN

OPERATOR SUBSTRING(s CHAR, index INTEGER) RETURNS CHAR Java // Substring, 0 based

return new ValueCharacter(s.stringValue().substring( END OPERATOR;

(int)index.longValue()));

Notice that these two operators are both named SUBSTRING, the first having three parameters, the second two. Thus, Rel can tell which one is being invoked by a particular expression of the form SUBSTRING( ‚Ä¶ ) according to the number of arguments to the invocation (and in fact invoked, yields the string that starts at the given beginindex position within the given string

according to the declared types of the expressions denoting those arguments). The first, when s, and ends at the given endindex position, where 0 is the position of the first character in s. at the end of s. Hence, SUBSTRING('database',2,4) =

The second yields the string that starts at the given index position in s and ends 'tab' and

SUBSTRING('database',4) = 'base'. the scope of this book.

I do not offer an explanation of the Java‚Ñ¢ code used in these examples, that being beyond

40
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.6	

What Is a Type?

A type is a named set of values. Much of the relational database literature, especially the earlier literature, uses the term domain for this concept, because that was the term E.F. Codd used. Nowadays we prefer type because that is the term most commonly used for the concept in computer science. Codd‚Äôs term domain derived from the fact that he used it exclusively to refer to the declared type of an attribute of a relation. For example, there might be a type named WEEKDAY whose values constitute the set { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }. For another example, type INTEGER is commonly available in computer languages, its values being all the integers

certain value of type WEEKDAY and -7 denotes a certain value of type INTEGER. It is essential that every value that can be operated on in a computer language can be denoted by some literal in that language.

in some range, such as -(232) to 232-1. Terms such as Monday and -1 are literals. Monday denotes a

In any computer language that supports types (as most of them do), some types are built-in (provided as part of the language). In some languages the only supported types are the built-in ones, but the trend in modern languages has been towards inclusion of support for user-defined types too.

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

41
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

The built-in types of Tutorial D are: ‚Ä¢	 CHARACTER or, synonymously, CHAR, for character strings. ‚Ä¢	 INTEGER or, synonymously, INT, for integers. such as 3.25, 1.0, 0.0, -7.935. ‚Ä¢	 RATIONAL for rational numbers, denoted by numeric literals that include a decimal point, ‚Ä¢	 TUPLE types and RELATION types as described later in this Chapter.

2.7	

What Is a Type Used For?

In general, a type is used for constraining the values that are permitted to be used for some purpose. In particular, for constraining: ‚Ä¢	 the values that can be assigned to a variable ‚Ä¢	 the values that can be substituted for a parameter ‚Ä¢	 the values that an operator can yield when invoked ‚Ä¢	 the values that can appear for a given attribute of a relation In each of the above cases, the type used for the purpose in question is the declared type of the variable, parameter, operator, or attribute, respectively. As a consequence, every expression denoting a value has a declared type too, whether that expression be a literal, a reference to a variable, parameter, or attribute or an invocation of an operator. Most importantly, these uses for types enable a processor such as a compiler or a DBMS to detect errors at ‚Äúcompile-time‚Äù‚Äîby mere inspection of a given script‚Äîthat would otherwise arise, and cause much more inconvenience, at run-time (when the script is executed). Thus, support for types is deemed essential for the development of robust application programs.

2.8	

The Type of a Relation

Now, if every value is of some type, and a relation, as we have previously observed, is a value, then we need to understand to what type a given relation belongs, and we need a name for that type. Here again (Figure 2.3) is our running example of a relation:
StudentId S1 S1 S2 S3 S4 Name Anne Anne Boris Cindy Devinder CourseId C1 C2 C1 C3 C1

Figure 2.3: Enrolments again

42
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

At this stage it is perhaps tempting to conclude that relations are all of the same type, which we might as well call RELATION, just as all integers are of type INTEGER. However, it turns out to be much more appropriate, as we shall see, to consider relations of the same heading to be of the same type and relations of different headings to be of different types. But all the types whose values are relations have that very fact‚Äîthat their values are relations‚Äîin common, and we call them relation types. If relation types are distinguished by their headings, it is clear that a relation type name must include a specification of its heading. In Tutorial D, therefore, the type name for the relation shown in Figure 2.3 can be written as RELATION { StudentId SID, Name NAME, CourseId CID } or, equivalently (for recall that there is no ordering to the elements of a set), RELATION { Name NAME, StudentId SID, CourseId CID } (and so on). Note the braces, { }. Tutorial D always uses braces to enclose an enumeration of the of attributes, each consisting of an attribute name followed by a type name. SID is the declared type of the attribute StudentId , NAME that of Name, and CID that of CourseId.

elements of set. In fact, { StudentId SID, Name NAME, CourseId CID } denotes a set

RELATION { StudentId SID, Name NAME, CourseId CID } might in fact be the declared type of a relation variable ENROLMENT, and that variable might be part of some database.

Clearly, there is in theory an infinite number of relation types, because there is no limit to the degree of a relation. (Recall that the degree of a relation is the number of its attributes.) Here are some more relation types: RELATION { StudentId SID, CourseId CID } RELATION { n INTEGER, w WEEKDAY } RELATION { }

RELATION { a INTEGER, b INTEGER, c INTEGER }

That last one looks a bit special! It does indeed merit special attention. We will have more to say about it later. Relation types have other things in common about them, even though they are different types. We can see already, for example, that every relation type is defined by a set of attributes (the empty set in one particular case). Of particular interest are the read-only operators defined for operating on relations of all types. These operators are described in Chapter 4.
43
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.9	

Relation Literals

In Section 2.6, What Is a Type?, we noted the essential need to be able to denote every value that can be operated on in a computer language by some literal in that language. We have also noted that a relation, such as the one shown in Figure 2.3, is a value. What might a literal look like that denotes that value? Well, we might try something like what is shown in Example 2.2, in which the key word RELATION in braces. Example 2.2: A Relation Literal (not good enough!) RELATION {

is followed by a list of expressions denoting tuples‚Äîeach one a putative tuple literal, in fact‚Äîenclosed

TUPLE { StudentId S1, CourseId C2, Name Anne	 },

TUPLE { StudentId S1, CourseId C1, Name Anne	 },

TUPLE { StudentId S2, CourseId C1, Name Boris }, TUPLE { StudentId S3, CourseId C3, Name Cindy }, } TUPLE { StudentId S4, CourseId C1, Name Devinder}

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

44
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

But of course it is not reasonable to expect a computer language to recognise symbols such as S1,C1, and Boris. We need a proper way of writing literals for those student identifiers, course identifiers, and names.

Recall the declared types of the attributes: SID, NAME, CID. These are necessarily user-defined types, for it would not be reasonable to expect them to be built-in.

Suppose that values of type SID are represented by character strings (values of type CHAR). CHAR might

well be a built-in type, and is indeed built-in in Tutorial D and Rel. Suppose further that character strings are denoted by text in quotes, like this: 'S1', as indeed they are in most computer languages. Then a whose name happens to be the same as that of the type for student identifiers, SID. This operator has a single parameter whose declared type, CHAR, is that of the representation (character strings) chosen for student identifiers. In this invocation the CHAR literal 'S1' denotes the argument corresponding to that parameter. The result of the invocation is not a character string but a value of type SID. literal for the student identifier S1 might be: SID ( 'S1' ). This literal is an invocation of the operator

is very likely that not every character string can validly represent a student identifier. Perhaps student

We call the operator SID a selector, because it can be used to ‚Äúselect‚Äù any value of type SID. Now, it

identifiers must each be the letter S, followed by a maximum of four numeric digits. In that case we can expect the operator SID, when it is invoked, to check that the given string conforms to this rule‚Äîand CHAR for student identifiers. raise an error if it doesn‚Äôt. That is one good reason why type SID might be chosen in preference to type

By the way, you can think of the literal 'S1' as ‚Äúselecting‚Äù a CHAR value. Every CHAR value can be denoted denote a CHAR value; so this syntax for literals does satisfy the requirements for being a selector.

by a sequence of characters enclosed in quotes, and every sequence of characters enclosed in quotes does

In Example 2.2 we tried to write a relation literal by specifying a set of tuple literals, and we tried to write a tuple literal by specifying a set of attribute values. Now that you know how to specify those attribute values properly, you can easily see that the correct way of writing the first of those tuple literals, arising from the foregoing discussion, is like this: TUPLE { StudentId SID('S1'), CourseId CID('C1'), Name NAME('Anne') }

The literals for course identifiers and names assume that those, too, are represented by character strings. Perhaps a course identifier must be the letter ‚ÄúC‚Äù followed by numeric digits, and perhaps a name must be an upper-case letter followed by lower-case letters, possibly with imbedded hyphens or spaces.

45
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

From that tuple literal it is easy to see how to write the complete relation literal (Example 2.3) in Tutorial D. Example 2.3: A Relation Literal (correct version) RELATION {

TUPLE { StudentId SID('S1'), CourseId CID('C1'), TUPLE { StudentId SID('S1'), CourseId CID('C2'), TUPLE { StudentId SID('S2'), CourseId CID('C1'), TUPLE { StudentId SID('S3'), CourseId CID('C3'), TUPLE { StudentId SID('S4'), CourseId CID('C1'), } Name NAME('Devinder')} Name NAME('Cindy')}, Name NAME('Boris')}, Name NAME('Anne')}, Name NAME('Anne')},

Note that the relation literal given in Example 2.3 is an invocation of a certain relation selector‚Äîthe specific selector for relations of that specific type. Similarly, a tuple literal is an invocation of a certain tuple selector. An invocation of a selector is not necessarily a literal. The relation selector takes a list of tuple expressions, each of which might be a literal but is not required to be one. Similarly, the tuple selector takes a list of attribute name/attribute value pairs, each of which might use a literal for the value but is not required to use one‚Äîany expression of the same type as the declared type of the attribute can be used.
A note concerning abbreviations in Tutorial D: The abbreviations REL and TUP can be used in place of the key words RELATION and TUPLE. Other abbreviations such as INT for INTEGER, CHAR for CHARACTER, and BOOL for BOOLEAN are also available

Now I can return to a small matter I deferred from Section 2.2, the definition of literal. As already stated, a literal is an expression that contains no variable references. We can now add that it is, specifically, an invocation of a selector. The invocation can be explicit, as in the relation and tuple literals we have looked at, and as in the SID, CID, and NAME literals contained in those tuple literals. It can also be implicit, as in the case of, for example, 'Cindy', denoting a value of the system-defined type CHAR and 1, denoting

a value of the system-defined type INTEGER. Because these types are system-defined, the language can

include special syntax for invoking their selectors, for which it doesn‚Äôt necessarily need to provide names.
CHAR literals in Rel: Rel allows CHAR literals to be enclosed either in quotes, as already shown, or in double-quotes, like this: "S1". Thus, "S1" and 'S1' both denote the same CHAR value. This makes it easier to write CHAR literals for values that include quotes. Tutorial D officially uses only single quotes for CHAR literals.

46
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.10	

Types and Representations

According to the authors of reference [4]: ‚ÄúA major purpose of type systems is to avoid embarrassing questions about representations, and to forbid situations in which these questions might come up.‚Äù Consider again the invocation SID('S1'), a literal of type SID. Recall that SID is an operator that,

when invoked with a suitable character string, returns a value of type SID; also that every value of type SID can be denoted by some invocation of the operator SID. I have explained that we call such an operator a selector (for values of the type in question). The parameters of a selector correspond to components of what we call a possible representation (possrep for short). I will explain why we use the word ‚Äúpossible‚Äù here in just a moment. First, I want to show how a type is defined in Tutorial D, using a single command. In the case of type SID, whose values are ‚Äúpossibly represented‚Äù by simple character strings, the possrep consists of a single component of type CHAR. I have also suggested that a character string representing a student identifier might have to be format in question would be enforced by the selector. The Tutorial D type definition shown in Example 2.4 specifies the appropriate possrep and expresses the suggested format as a constraint.

of a particular format, such as the letter ‚ÄúS‚Äù followed by a digit sequence of limited length; and that the

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

47
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Example 2.4: A Type Definition TYPE SID POSSREP SID { C CHAR

CONSTRAINT LENGTH(C) <= 5 AND AND STARTS_WITH(C, 'S') IS_DIGITS(SUBSTRING(C,1)))

INIT SID('S1'); Explanation 2.4: ‚Ä¢	 POSSREP SID announces that what follows, in braces, specifies a possible representation for values of the type. It means that the operators defined for type SID behave as if values of type SID were represented that way, regardless of how they are physically represented ‚Äúunder the covers‚Äù. That is why we use the word ‚Äúpossible‚Äù‚Äîthe values might possibly be represented internally that way (but they don‚Äôt have to be and we don‚Äôt even know if they are). In this case the name of that possrep is the same as the type name, SID (as it would be type, but such complications are beyond the scope of this book. I do not deal with types in any depth. It is sufficient for present purposes just to understand how they exist, what they ‚Ä¢	 C CHAR defines the first and only component of the possrep, naming it C and specifying CHAR as its declared type. This definition causes an operator, THE_C, to come into s under the possible representation SID. existence. THE_C takes a value, s, of type SID and returns the value of the C component of ‚Ä¢	 CONSTRAINT announces that the expression following it (up to but excluding the closing brace) is a condition that must be satisfied by all possrep values that do indeed represent values of type SID. Note that the expression itself uses the logical connective AND, with are for, and how to use them.) if we omitted the name). (Tutorial D allows more than one possrep to be given for the same ‚Ä¢	 TYPE SID announces that a type named SID is being defined to the system.

}

its usual meaning, to connect three expressions, two of which are comparisons and each of which is a truth-valued expression‚Äîone that, when evaluated, yields either TRUE or FALSE. The operators LENGTH, STARTS_WITH, SUBSTRING, and IS_DIGITS, invoked in their existence as user-defined operators. Happily, their definitions are contained in the file ‚Ä¢	 LENGTH(C) <= 5 expresses a rule to the effect that the total length of a value for the C possrep component must never exceed 5. OperatorsChar.d included in the download package for Rel. the constraint expression, are not defined as built-in operators in Tutorial D. I am assuming

48
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

‚Ä¢	 STARTS_WITH(C, ‚ÄòS‚Äô) returns TRUE if and only if the string given as the first operand the capital letter ‚ÄòS‚Äô.

starts with the string given as the second operand‚Äîin this case the string consisting of just

‚Ä¢	 SUBSTRING(C,1) denotes the string consisting of the whole of the value of the C possrep component apart from the first character. This is given as the argument to an invocation of a numeric digit, otherwise FALSE. IS_DIGITS, which takes a string and yields TRUE if every character in the given string is ‚Ä¢	 INIT SID(‚ÄôS1‚Äô) specifies an example value for the type, just to confirm that values exist for the type being defined.

2.11	

What Is a Variable?

Example 2.5 shows a variable declaration in Tutorial D. Example 2.5: A Variable Declaration VAR SN SID INIT SID ( 'S1' ) ; Note that a variable is declared by means of a VAR statement. Explanation 2.5: ‚Ä¢	 VAR SN announces that what follows defines a variable named SN. only values of type SID can be assigned to SN. ‚Ä¢	 SID, immediately following SN, specifies the declared type of this variable, indicating that ‚Ä¢	 INIT specifies that what follows is an expression whose value is to be immediately assigned to SN. You already know what SID ( 'S1' ) denotes (see Section 2.9). The value specified in an INIT clause is commonly called the initial value of the variable in question. It remains that value until it is replaced by subsequent invocation of an update operator such as assignment. A variable is a container or holder for a value. To answer the question posed in the section heading, we can now see that a variable: ‚Ä¢	 has a name; ‚Ä¢	 has a declared type, namely the type of the values it can legally hold; ‚Ä¢	 always ‚Äúhas‚Äù a value (of its declared type).

49
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

The name and declared type remain the same throughout the existence of the variable, but its value can change from time to time, which is of course why it is called a variable. Although the value can change from time to time, the value must always be a value of the declared type of the variable‚Äîin Example 2.5 a value of type SID. The variable SN is an example of a scalar variable in Tutorial D. Such variables are for use only as local operator. Of more interest in the context of relational databases are relation variables, known for short and from here onwards as relvars. Unlike scalar variables, relvars can appear as persistent objects in the database‚Äîin fact, these are the only variables permitted as persistent objects in the database. Example 2.6 shows a relvar declaration in Tutorial D. Example 2.6: A Relvar Declaration VAR ENROLMENT BASE RELATION { StudentId SID, Name NAME, CourseId CID }

variables in computer programs, such as an application program or the code implementing a user-defined

KEY { StudentId, CourseId } ;

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

50
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Explanation 2.6: ‚Ä¢	 BASE, immediately following ENROLMENT, specifies that the variable is to be a persistent ‚Ä¢	 RELATION { ‚Ä¶ } specifies the declared type of the variable. object in the database. ‚Ä¢	 VAR ENROLMENT announces that what follows defines a variable named ENROLMENT.

‚Ä¢	 KEY { StudentId, CourseId } specifies a certain very important kind of

constraint that Tutorial D requires to be specified for all base relvars. Keys are covered in detail in Chapter 5. This one specifies that at no time can two distinct tuples appear in the current value of ENROLMENT, having the same values for StudentId and also the same and the same course. values for CourseId. In enterprise terms, no two enrolments can involve the same student

No INIT specification is given in Example 2.6. In the absence of an INIT specification in a Tutorial D relvar declaration the relvar is initialised to the empty relation of its declared type.

2.12	

Updating a Variable

A value is assigned to a variable by invoking some update operator. The simplest and most general of such operators is the assignment operator itself‚Äî‚Äú:=‚Äù in Tutorial D (and some other languages). Example 2.7 shows a simple invocation of assignment to ‚Äúupdate‚Äù the variable SN. Example 2.7: A Simple Assignment SN := SID ( 'S2' ) ; If that assignment is given some time after the declaration shown in Example 2.5, then the effect will indeed be to change the value of the variable SN. It is changed from being the student identifier S1 to the student identifier S2. Here SID ( 'S2' ) is the source for the assignment and SN is the target. The source does not have to be a literal, of course, as Example 2.8 demonstrates. Example 2.8: Assignment Source Not a Literal SN := SID ( LEFT ( THE_C (SN), 1 ) || '5' ) ;

51
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Explanation 2.8: ‚Ä¢	 THE_C (SN) denotes the value of the C component of the current value of SN under the possrep (SID) declared for type SID. LEFT ( THE_C (SN), 1 ) therefore denotes the leftmost character of that string, which will of course be the letter S.

‚Ä¢	 || is the concatenation operator for strings. LEFT ( THE_C (SN), 1 ) || '5' concatenates the letter S with the digit 5 to produce the string 'S5'. In Example 2.7 this string is then operated on by the SID selector to yield the corresponding value of type SID, the left it denotes the variable itself, the target. On the right, where it appears as part of the source, it denotes the current value of SN. Example 2.9 is an invocation of a hypothetical update operator other than assignment‚Äîprobably a userdefined operator. As with assignment, the invocation takes the form of a command. Example 2.9: Invocation of a user-defined update operator CALL SET_DIGITS ( SN , 23 ) ; Explanation 2.9: ‚Ä¢	 CALL announces that an update operator invocation follows. The effect of that invocation is ‚Ä¢	 SET_DIGITS ( SN , 23 ) , let us assume, has the same effect as also the effect of the CALL statement.

which is assigned to SN. Note that the term, SN, is used on both sides of the assignment. On

SN := SID ( SUBSTRING ( THE_C (SN), 0, 1 ) || '23';

(which is almost identical to Example 2.8). Note that SN in the invocation of SET_DIGITS is an argument substituted for a parameter that is defined for update, so here stands for the variable itself and not for its current value. Tutorial D additionally allows certain special kinds of expression to appear as update targets. Such expressions are called pseudovariables‚Äîthey are not real variables but they can be treated as if they were. A pseudovariable takes the form of an invocation of a read-only operator in which one of the operands is a reference to a variable (or pseudovariable) that is to be updated. Example 2.10: Assignment to a pseudovariable THE_C ( SN ) := 'S2' ;

52
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Explanation 2.10: ‚Ä¢	 THE_C ( SN ) denotes the C possrep component of the current value of the variable SN. However, because the invocation of THE_C appears in a target position here, that value is to be replaced by the value denoted by the expression on the right-hand side of the assignment. type SID.

‚Ä¢	 'S2' is a literal of type CHAR, the declared type of the C possrep component defined for ‚Ä¢	 The entire statement is equivalent to the regular assignment SN := SID ( 'S2' ) ;

‚Äînot a very compelling example of pseudovariable updating, perhaps, but such shorthands are very useful when updating variables of more complicated types, having very many possrep components. Counterparts typically exist in object-oriented programming languages, in connection with object classes.

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

53
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

2.13	Conclusion
I conclude this chapter by reminding you of the important distinctions I drew to your attention at its beginning. I repeat them here, with illustrative examples to remind you: ‚Ä¢	 syntax and semantics (expressions and their meaning) An expression (syntax) denotes either a value or a variable. ‚Ä¢	 values and variables A value such as the integer 3, the character string 'London', or the relation RELATION¬†{¬†TUPLE¬†{¬†A¬†3,¬†B¬†'London'¬†}¬†} is something that exists independently of time or space and is not subject to change. A variable is subject to change (in value only), by the variable of that name or its current value, depending on the context in which it appears. ‚Ä¢	 values and representations of values The character string value denoted by 'S1' is a possible representation of the student identifier ‚Ä¢	 types and representations S1, a value of type SID denoted by SID('S1'). invocation of update operators. A variable reference, such as the expression X, denotes either

‚Ä¢	 read-only operators and update operators

POSSREP { C CHAR } defines a possible representation for all values of type SID. ‚Äú+‚Äù is a read-only operator because, when it is invoked, it returns a value. ‚Äú:=‚Äù is an update operator because, when it is invoked, it has the effect of replacing the current value of a variable (i.e., updating the variable by changing its value)‚Äîand does not return a value.

‚Ä¢	 operators and invocations SID is an operator. Its signature is SID(C CHAR). SID('S1') denotes an invocation of x+y denotes an invocation of ‚Äú+‚Äù. SID. Similarly, ‚Äú+‚Äù is an operator, with signature +(A RATIONAL, B RATIONAL), and ‚Ä¢	 parameters and arguments

the argument substituted for C CHAR in the invocation SID('S1'). Similarly, x and y denote the arguments substituted for A RATIONAL and B RATIONAL, respectively, in the invocation x+y.

C CHAR is a parameter (and in fact the only parameter) of the operator SID. 'S1' denotes

You can now test your understanding of these distinctions by carrying out the first set of accompanying exercises (which also include some revision material for Chapter 1). In the second set you can start to explore Tutorial D in action, using Rel.

54
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

EXERCISES
Complete sentences 1‚Äì10 below, choosing your fillings from the following: =, :=, ::=, argument, arguments, body, bodies, BOOLEAN, cardinality, CHAR, CID, degree, denoted, parameters, read-only, set, sets, SID, true, type, types, update, variable, variables. In 1‚Äì5, consider the expression X = 1 OR Y = 2. 1.	 In the given expression, = and OR are _____ whereas X and Y are _____ references. 2.	 X and 1 denote _____ to an invocation of _____. 4.	 1 and 2 are both _____ of _____ INTEGER. 3.	 The value _____ by the given expression is of _____ BOOLEAN.

expressions, false, heading, headings, INTEGER, list, lists, literal, literals, operator, operators, parameter,

5.	 The operators used in the given expression are _____ operators. In 6‚Äì10, consider the expression RELATION { X SID, Y CID } { }. 6.	 It denotes a relation whose _____ is zero and whose _____ is two. 7.	 It is a relation _____. 8.	 The declared type of Y is _____. possibly empty _____ of tuples. 10.	 It is _____ that the assignment RV __ RELATION { X SID, Y CID } { } is legal if the _____ of RV is { Y CID, X SID }, _____ that it is legal if the _______ of RV is {¬†A¬†SID,¬†B¬†CID¬†}, _____ that it is legal if the _____ of RV is {¬†X¬†CID,¬†Y¬†SID¬†}, and _____ that it is legal if the _____ of RV is {¬†X¬†CHAR,¬†Y¬†CHAR¬†}. Getting Started with Rel After you have downloaded and installed Rel from http://dbappbuilder.sourceforge.net/Rel.html, work through the following exercises. From number 7 onwards they involve constructs introduced in Chapter 4. You might prefer to wait until you have studied that chapter but on the other hand a little hands-on experience might help you to understand that chapter when you come to it. 1.	 Start up Rel ‚Äôs DBrowser. DBrowser is the general-purpose client application provided by Rel for evaluating Tutorial D expressions and executing Tutorial D statements entered by the user. 2.	 Familiarise yourself with the way of working and the things you can do in Rel. You should be looking at a window something like this (which was obtained in Windows Vista): 9.	 In general, the heading of a relation is a possibly empty _____ of attributes and its body is a

55
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

‚Ä¢	 Note the layout of the window: a lower pane into which you can type statements to be executed, an upper pane in which results are displayed, and the movable horizontal bar between the panes. ‚Ä¢	 Note the ‚ñ≤ and ‚ñº at the left-hand end of the horizontal bar, allowing you to let one or the other pane occupy the whole window for a while. ‚Ä¢	 See what is available on the Tools menu and perhaps choose your preferred font. ‚Ä¢	 Note the < and > to the left of the menu on the input (lower) pane. These are greyed out initially but after you have executed a couple of statements you will be able to use them to recall previously executed statements to the input pane. ‚Ä¢	 Note the toolbars on both panes. As you do the exercises, decide which options suit you best. Note that you can save the contents of either pane into a local file, and that you can load the contents of a local file into the input area. ‚Ä¢	 Note the check boxes on the right of the toolbars. They are fairly self-explanatory, apart from ‚ÄúEnhanced‚Äù, which we will examine later. ‚Ä¢	 The box at the top of the upper pane, labelled ‚ÄúLocation:‚Äù, identifies the directory containing the database you are working with. You can switch to another directory by clicking on the little button to the right of the box, labelled with three dots (‚Ä¶).

56
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

3.	 Type the following into the lower pane: output 2+2 ; Execute what you have typed, either by clicking on Evaluate (F5) shown at the bottom of the window or by pressing F5. Now delete the semicolon and try executing what remains. (If necessary, use the < button on the lower pane to recall the statement.) You will see how Rel handles errors. Now strike out the word output and do not put back the semicolon. What happens when you execute that? (i.e., just 2+2).

You have now learned: ‚Ä¢	 that in Rel (as in Tutorial D) every executable command (or statement) is terminated by a semicolon; ‚Ä¢	 that Rel allows you to obtain the result of evaluating an expression by using an output statement; ‚Ä¢	 that Rel treats an attempt to ‚Äúexecute‚Äù an expression x as shorthand for the statement output x ; ‚Äî the absence of the semicolon signals to Rel that you are using this convenient shorthand.

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

57
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

4.	 This exercise is merely to alert you to a certain awkwardness in Rel that has no real importance but might cause you to waste a lot of time if you are not warned about it. It‚Äôs the same as Step 3 except that instead of 2+2 you type 2+2.0. Look closely at what happens. It doesn‚Äôt work!

Rel, like some other languages, treats INTEGER and RATIONAL as distinct types. If you want to

do arithmetic on rational numbers, both operands must be rational numbers. Literals denoting rational numbers are distinguished from those denoting integers by the presence of a decimal point, and Rel follows the convention in the English-speaking community of using a full stop for this purpose (as opposed to the comma that is used throughout most of Europe, for example). Now try this: 1/2 (i.e., the integer 1 divided by the integer 2). And then this: 1.0/2.0. You have now learned that (a) the operands of dyadic arithmetic operators in Rel must be of the same type, and (b) the type of the result of an invocation of such an operator is always of the same type as the operands. Tutorial D is silent on such issues, because they are orthogonal to what Tutorial D is really intended for (teaching relational theory). But every implementation of Tutorial D has to address them somehow. Fortunately, arithmetic is orthogonal to relational theory and there is no need for us to be bothered by Rel‚Äôs behaviour here. You have possibly already learned that the same problems do not arise in SQL, where 1/2, 1/2.0 and 1.0/2.0 are all equivalent, in spite of the fact types in SQL. that INTEGER and REAL (SQL‚Äôs counterpart of Tutorial D‚Äôs RATIONAL) are also distinct

5.	 Now try the following compound statement: begin ; VAR x integer init(0) ; x := x + 1 ; output x ; end ;

Why do we have to write output x ; in full here, instead of just x? Now write the fourth line in uppercase: OUTPUT X ; What happens? Try OUTPUT x ; instead. What have you learned about Rel‚Äôs rules concerning case sensitivity?

58
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

6.	 Now you can start investigating Rel‚Äôs support for relations (though not relational databases yet). First, see how Rel displays a relation (i.e., the result of evaluating a relation expression) in its upper pane. Rel supports two styles of presentation, depending on whether the ‚ÄúEnhanced‚Äù option is checked. With ‚ÄúEnhanced‚Äù unchecked (it is usually checked to start with), get Rel to evaluate the following relation expression (a literal which we shall call enrolment): RELATION {

TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' }, TUPLE { StudentId 'S1', CourseId 'C2', Name 'Anne' }, TUPLE { StudentId 'S2', CourseId 'C1', Name 'Boris' }, TUPLE { StudentId 'S3', CourseId 'C3', Name 'Cindy' }, } TUPLE { StudentId 'S4', CourseId 'C1', Name 'Devinder' }

See Section 2.9. Look closely at the output. Is it identical to the input? Next, without altering the contents of the lower pane, turn ‚ÄúEnhanced‚Äù back on. Note the effect on the display in the output pane. Now delete all the tuple expressions, leaving just RELATION { }. What happens when Rel tries to evaluate that?

Now use < to recall the original RELATION expression to the input pane and re-evaluate it with ‚ÄúEnhanced‚Äù off. Use copy-and-paste to copy the result to the input pane, then delete all the TUPLE expressions, to leave this: RELATION {StudentId CHARACTER, CourseId CHARACTER, Name CHARACTER} { }

Study the result of that in the output pane, first with ‚ÄúEnhanced‚Äù off, then with it on. What conclusions do you draw from all this, about Rel and Tutorial D? From now on you can run with ‚ÄúEnhanced‚Äù either on or off, according to your own preference. Next, enter the following literal, perhaps by using the < button to recall enrolment and editing it:

59
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

RELATION {

TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' }, TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' } }

Before you press Evaluate (F5), think about what you expect to happen. Does the result meet your expectation? How do you explain it? Use < again to recall the enrolment literal. Insert the word WITH at the beginning, add AS enrolment : enrolment at the end, to give: WITH ( enrolment := RELATION { TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' }, TUPLE { StudentId 'S1', CourseId 'C2', Name 'Anne' }, TUPLE { StudentId 'S2', CourseId 'C1', Name 'Boris' }, TUPLE { StudentId 'S3', CourseId 'C3', Name 'Cindy' }, } ) : enrolment and evaluate that. TUPLE { StudentId 'S4', CourseId 'C1', Name 'Devinder' }

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

60
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

How do you understand what you have just done? (WITH isn't described in the book. In case eight + four. Note carefully that the introduced names, four and eight, are local only.)

you aren't clear, try this in Rel: WITH ( four := 2+2, eight := four+four ) :

By inspection of enrolment only, write down all the cases you can find of two students such that there is at least one course they are both enrolled on.

7.	 For this exercise you will need to continue using < to recall your previous command (now including the definition of the introduced name enrolment) and overtype as necessary. Use enrolment to investigate the relational operator known as projection (see Chapter 4, Section 4.6 ). The projection of a given relation over a specified subset of its attributes yields another relation. In Tutorial D a projection is specified by writing a list of attribute names, enclosed in braces {} and separated by commas, after the operand relation. The key words ALL BUT can optionally precede the list of attribute names, inside the braces.

How many distinct projections can be obtained from enrolment? Obtain as many of these as you wish, trying both the ‚Äúinclusion‚Äù method and the ‚Äúexclusion‚Äù method using ALL BUT. 8.	 Still using enrolment, investigate the relational operator known as rename (see Chapter 4, Section 4.5). The renaming of a given relation returns that relation with one or more of AS new, ... } after the operand relation. its attributes renamed. In Tutorial D a renaming is specified by writing RENAME { old

At the moment you should have this in your input pane: WITH ( enrolment := RELATION { TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' }, TUPLE { StudentId 'S1', CourseId 'C2', Name 'Anne' }, TUPLE { StudentId 'S2', CourseId 'C1', Name 'Boris' }, TUPLE { StudentId 'S3', CourseId 'C3', Name 'Cindy' }, } ) : enrolment TUPLE { StudentId 'S4', CourseId 'C1', Name 'Devinder' }

61
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

Replace the single word (enrolment) that follows the colon by a renaming of enrolment and is otherwise the same as enrolment itself. Replace the : that ends the WITH specification by E1 := and add : E1 at the end. The result should look like this: WITH ( enrolment := RELATION { TUPLE { StudentId 'S1', CourseId 'C1', Name 'Anne' }, TUPLE { StudentId 'S1', CourseId 'C2', Name 'Anne' }, TUPLE { StudentId 'S2', CourseId 'C1', Name 'Boris' }, TUPLE { StudentId 'S3', CourseId 'C3', Name 'Cindy' }, } , E1 := <your renaming of enrolment, as specified> ) : E1 TUPLE { StudentId 'S4', CourseId 'C1', Name 'Devinder' } such that the result has attribute name SID1 instead of StudentId, N1 instead of Name,

Evaluate that to check that you wrote the renaming correctly. 9.	 Now replace the : by , E1 := and this time add a similar renaming of enrolment, using SID2 and N2 instead of SID1 and N1 for the new attribute names, and add : E1 JOIN E2 at the end. You are investigating the operator called JOIN (see Chapter 4, Section 4.4). How do you interpret the result? How many tuples does it contain? Replace the key word JOIN are there now? How do you account for the difference?

by COMPOSE (see Chapter 5, Section 5.2). How do you interpret this result? How many tuples

10.	 Add WHERE NOT ( SID1 = SID2 ) to end of the expression you evaluated in Step 9 (see Chapter 4, Section 4.7 ). Examine the result closely. Now place parentheses around E1 COMPOSE E2 and evaluate again. Confirm that you get the same result.

Repeat the experiment, replacing WHERE NOT ( SID1 = SID2 ) by { SID1 }. Do you get the same results this time? If not, why not?

What does all this tell you about operator precedence rules in Tutorial D? Why was it probably a good idea to add that WHERE invocation? Did it completely solve the problem? If not, can you think of a better solution?

What connection, if any, do you see between this exercise and Exercise 6?

62
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Values, Types, Variables, Operators

11.	 Load the file OperatorsChar.d, provided in the Scripts subdirectory of the Rel program directory, and execute it. Now you have the operators used in Example 2.4, among others. Give appropriate type definitions for types NAME and CID. Notice that the operator

TO_UPPER_CASE is available for converting a given string to its upper-case counterpart. all names begin with a capital letter. 12.	 Close Rel by clicking on File/Exit.

You might like to try using this operator to define a constraint for type NAME to ensure that

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩe G for Engine

Ma

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities ÔøΩree wo work or placements s solve pr
Click on the ad to read more

63
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

3	 Predicates and Propositions
3.1	Introduction
In Chapter 1 I defined a database to be ‚Äú‚Ä¶an organised, machine-readable collection of symbols, to be interpreted as a true account of some enterprise.‚Äù I also gave this example (extracted from Figure 1.1):
StudentId S1 Name Anne CourseId C1

I suggested that those green symbols, organised as they are with respect to the blue ones, might be understood to mean: ‚ÄúStudent S1, named Anne, is enrolled on course C1.‚Äù In this chapter I explain exactly how such an interpretation can be justified. In fact, I describe the general method under which data organized in the form of relations is to be interpreted‚Äîto yield information, as some people say. This method of interpretation is firmly based in the science of logic. Relational database theory is based very directly on logic. Predicates and propositions are the fundamental concepts that logic deals with. Fortunately, we need to understand only the few basic principles on which logic is founded. You may well already have a good grasp of the principles in question, but even if you do, please do not skip this chapter. For one thing, the textbooks on logic do not all use exactly the same terminology and I have chosen the terms and definitions that seem most suitable for the purpose at hand. For another, I do of course concentrate on the points that are particularly relevant to relational theory; you need to know which points those are and to understand exactly why they are so relevant.

3.2	

What Is a Predicate?

Predicates, one might say, are what logic is all about. And yet the textbooks do not speak with one voice when it comes to pinning down exactly what the term refers to! I choose the definition that appears to me to fit best, so to speak, with relational database theory. We start by looking again at that possible interpretation of the symbols S1, Anne, and C1, placed the way they are in Figure 1.1: ‚ÄúStudent S1, named Anne, is enrolled on course C1.‚Äù This is a sentence. Sentences are what human beings typically use to communicate with each other, using language. We express our interpretations of the data using sentences in human language and we use relations to organize the data to be interpreted. Logic bridges the gap between relations and sentences.

64
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

Our example sentence can be recast into two simpler sentences, ‚ÄúStudent S1 is named Anne‚Äù and ‚ÄúStudent S1 is enrolled on course C1‚Äù. Let‚Äôs focus on the second: Example 3.1: A simple sentence ‚ÄúStudent S1 is enrolled on course C1.‚Äù The symbols S1 and C1 appear both in this sentence and in the data whose meaning it expresses. Because they each designate, or refer to, a particular thing‚ÄîS1 a particular student, C1 a particular course‚Äîthey are called designators. The word Anne is another designator, referring to a particular forename. ‚ÄúAn Introduction to Relational Database Theory‚Äù is also a designator, referring to a particular book, and so is, for example, -7, referring to a particular number. Now, suppose we replace S1 and C1 in Example 3.1 by another pair of symbols, taken from the same columns of Figure 1.1 but a different row. Then we might obtain Example 3.2: ‚ÄúStudent S3 is enrolled on course C3.‚Äù A pattern is clearly emerging. For every row in Figure 1.1, considering just the columns headed StudentId and CourseId, we can obtain a sentence in the form of Examples 3.1 and 3.2. The words ‚ÄúStudent‚Ä¶is enrolled on course‚Ä¶‚Äù appear in that order in each case and in each case the gaps indicated by‚Ä¶‚Äîsometimes called placeholders‚Äîare replaced by appropriate designators. If we now replace each placeholder by the name given in the heading of the column from which the appropriate designator is to be drawn, we obtain this: Example 3.3: ‚ÄúStudent StudentId is enrolled on course CourseId.‚Äù Example 3.3 succinctly expresses the way in which the named columns in each row of Figure 1.1 are probably to be interpreted. And we now know that those names, StudentId and CourseId, in the column headings are the names of two of the attributes of the relation that Figure 1.1 depicts in tabular form. Now, the sentences in Examples 3.1 and 3.2 are in fact statements. They state something of which it can be said, ‚ÄúThat is true‚Äù, or ‚ÄúThat is not true‚Äù, or ‚ÄúI believe that‚Äù, or ‚ÄúI don‚Äôt believe that‚Äù.

65
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

Not all sentences are statements. A good informal test, in English, to determine whether a sentence is a statement is to place ‚ÄúIs it true that‚Äù in front of it. If the result is a grammatical English question, then the original sentence is indeed a statement; otherwise it is not. Here are some sentences that are not statements: ‚Ä¢	 ‚ÄúLet‚Äôs all get drunk.‚Äù ‚Ä¢	 ‚ÄúWill you marry me?‚Äù ‚Ä¢	 ‚ÄúPlease pass me the salt.‚Äù ‚Ä¢	 ‚ÄúIf music be the food of love, play on.‚Äù They each fail the test. In fact one of them is a question itself and the other three are imperatives, but we have no need of such sentences in our interpretation of relations because we seek only information, in the form of statements‚Äîstatements that we are prepared to believe are statements of fact; in other words, statements we believe to be true. We do not expect a database to be interpreted as asking questions or giving orders. We expect it to be stating facts (or at least what are believed to be facts). As an aside, I must own up to the fact that some sentences that would be accepted as statements in English don‚Äôt really pass the test as they stand. Here are two cases in point, from Shakespeare: ‚Ä¢	 ‚ÄúO for a muse of fire that would ascend the highest heaven of invention.‚Äù ‚Ä¢	 ‚ÄúTo be or not to be‚Äîthat is the question.‚Äù

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

66
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

The first appears to lack a verb, but we know that ‚ÄúO for a‚Ä¶‚Äù is a poetical way of expressing a wish for something on the part of the speaker, so we can paraphrase it fairly accurately by replacing ‚ÄúO‚Äù by ‚ÄúI wish‚Äù, and the sentence thus revised passes the test. In the second case we have only to delete the word ‚Äúthat‚Äù, whose presence serves only for emphasis (and scansion, of course!), and alter the punctuation slightly: ‚ÄúIt is true that ‚Äòto be or not to be?‚Äô is the question.‚Äù Now, a statement is a sentence that is declarative in form: it declares something that is supposed to be true. Example 3.3, ‚ÄúStudent StudentId is enrolled on course CourseId‚Äù, is not a statement‚Äîit does not pass the test. It does, however, have the grammatical form of a statement. We can say that, like a statement, it is declarative in form. And we know that we have only to replace those italicised symbols (about which more anon) by appropriate designators, such as S1 and C1, to make it into a statement. Now I can say exactly what are meant by the terms predicate and proposition, starting with predicate. A sentence that is in declarative form has a certain meaning, hopefully agreed upon by all who might read or hear it. That meaning is what logicians call a predicate. We can therefore say that such a sentence denotes a certain predicate. It is important to bear the distinction between the sentences and the predicates they denote firmly in mind. For consider the following sentences: ‚Ä¢	 1 is less than 2 ‚Ä¢	 1 est moins que 2 ‚Ä¢	 1 < 2 They are written in three different languages but they all have exactly the same meaning‚Äîthey denote the same predicate. Here are some more declarative sentences: ‚Ä¢	 I love you. Here the designators are the pronouns, ‚ÄúI‚Äù and ‚Äúyou‚Äù. In isolation they designate nothing but in an appropriate context they do, if we know who the speaker is and to whom the sentence is spoken. ‚Ä¢	 The present king of France is bald This is a popular example used by logicians when they want to discuss problems concerning designators. Here we have something‚Äî‚ÄúThe present king of France‚Äù‚Äîthat looks like a designator but in fact, at the time of writing, designates nothing because France has no king. At various times in the past, however, France has had a king. As far as relational databases are concerned, problems to do with designation are addressed by types (see Chapter 2) and database constraints (Chapter 5). ‚Ä¢	 2 + 2 = 5 ‚Ä¢	 x < y ‚Ä¢	 a + b = c These three are sentences written in mathematical notation. The first is a statement but the other two are not‚Äîthey contain italicised symbols that designate nothing.
67
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

‚Ä¢	 Student s is enrolled on course c. This is identical to Example 3.3, except that s replaces StudentId and c replaces CourseId. It will suit our present purposes to regard this and Example 3.3 as denoting distinct predicates, though not all textbooks on logic take this stance (and not all are even clear on the matter). ‚Ä¢	 P(x,y) This kind of notation is commonly used by logicians as denoting a predicate without stating which particular predicate is being denoted. Notice that the symbol P, standing for what would be written in roman for a particular predicate, is italicised. For example, if we replace P by the ‚Äúless than‚Äù symbol, <, we obtain <(x,y), which might be just another way of denoting the same predicate as x < y. Up to now I have been very careful to maintain that clear distinction between the sentences and the predicates denoted by those sentences. However, it is often very convenient to refer to the sentences themselves as predicates, just to avoid excessive repetition of ‚Äúdenoted by‚Äù, and I will do so frequently from now on in this book‚Äîstarting right now. Consider again, then, the predicate ‚ÄúStudent StudentId is enrolled on course CourseId‚Äù (Example 3.3). Instead of designators for student and course it has symbols StudentId and CourseId, neither of which designates anything in particular. They are usually called variables, but note very carefully that they are not variables in the sense of that term as defined in Chapter 2. Logic does not deal with that kind of variable, so no confusion arises in texts dealing with logic alone, but in this book we have to deal with both kinds of variable. For that reason I prefer the alternative term, parameter, for variables appearing in predicates‚Äîbut we shall see later that although a parameter is a variable, not all variables appearing in predicates are parameters (so I will occasionally have to revert to the term variable). Special adjectives are used to indicate the number of parameters in a predicate. In general these take the form of a number suffixed by ‚Äú-adic‚Äù. Thus a 5-adic predicate has five parameters, a 0-adic predicate none at all, and an n-adic predicate has n parameters. For the lower numbers the appropriate prefix derived from Greek is often used instead: monadic, dyadic, triadic, tetradic, and so on, though we switch to Latin with niladic for 0-adic. Some of the predicates I have shown you contain one or more parameters; others do not. Those that contain no parameters are, as already noted, statements. The predicate denoted by a statement is a very important special case: what logicians call a proposition. Now, recall that test used to determine whether a sentence in English is in fact a statement‚Äîcan it be prefixed by ‚ÄúIs it true that‚Äù to yield a grammatical question in English? A proposition, then, being denoted by a sentence p that passes that test, is something that is either true or false, depending on the correct answer to the question, ‚ÄúIs it true that p?‚Äù

68
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

3.3	

Substitution and Instantiation

If a predicate has n parameters (n>0) and we replace one of those parameters by a designator, we obtain a predicate with n-1 parameters. For example, in the dyadic predicate a<b if we replace b by 10 we obtain the monadic predicate a < 10 We say that the designator 10 is substituted for the parameter b. If the designator is being substituted for a parameter that appears more than once in the sentence denoting the predicate, then of course that same designator must be substituted for each such appearance. For example, in the triadic predicate a < b and b < c if we substitute 10 for b we obtain the dyadic predicate a < 10 and 10 < c

69
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

If we substitute designators for all of the parameters, we obtain a niladic predicate‚Äîa proposition. For example, if we substitute 5 for a and 15 for c in the dyadic predicate above, we obtain 5 < 10 and 10 < 15 which happens to denote a true proposition. The act of substituting designators for all the parameters of a predicate is sometimes referred to as instantiation‚Äîa term that is especially useful in the interpretation of relations. We can say, then, that the proposition 5 < 10 is an instantiation of the predicate a < 10. It is also an instantiation of the predicates 5 < b, a < b and x < y. (Some textbooks use the term full instantiation, regarding substitution of some but not all of the parameters as ‚Äúpartial‚Äù instantiation. Personally, I find the notion of a ‚Äúpartial instance‚Äù (of a kind) rather weird!) According to our stance of regarding a proposition as a special case of a predicate, we must also accept the strange-looking notion that 5 < 10 is an instantiation‚Äîthe only possible instantiation‚Äîof itself! Such quirky observations are not often found in textbooks on logic, but they often turn out to be more important than might appear at first sight when it comes to designing computer languages, as we shall eventually see. Extension and Intension Now, given some predicate p, we can consider all the possible instantiations of p. Each is either a true proposition or a false one. The true instantiations of p, taken collectively, are referred to as the extension of p. This concept will prove to be very important to us in the database context. Also important is the intension of a predicate. Loosely speaking this is just its meaning, but note that predicates that differ only in the names of their parameters‚Äîfor example, a < b and x < y, have the same intension, and this gives meaning in turn to their instantiations. The same term, intension, is also used for the meaning of a designator. Thus, although 5 < 10 and 10 < 5 are both instantiations of a < b, their meanings are obviously different (as are their truth values). Intension is important with regard to our interpretation of a relation, but the relation itself tells us nothing about what its tuples might mean.

3.4	

How a Relation Represents an Extension

In Chapters 1 and 2 the word ‚Äúset‚Äù appears many times, without definition but intended to be precise. For example, the heading of a relation is described as a set of attributes, its body a set of tuples. I assume you are somewhat familiar with the concept of a set and in any case this book does not include a complete account of the mathematical theory of sets. The theory of sets arose out of predicate logic (in the 19th century); the theory of relations arose out of the theory of sets; and the theory of relational databases arose out of the theory of relations. The remainder of this section explains these connections.

70
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

A set is a collection of distinct objects, termed its elements. Each element appears exactly once‚Äîthere is no sense in which the same element can appear more than once in a given set. Anything can be an element of some set. Even a set can be an element of a set, though we can run into trouble, as the philosopher Bertrand Russell famously observed, if we consider the possibility of a set being one of its own elements. Mathematicians recognize two distinct methods of defining (or denoting) a set. These methods relate to the terms extension and intension that we have just met, and are indeed called extensional definition and intensional definition. We are interested in both methods. An extensional definition simply enumerates the elements. In mathematical notation the elements are denoted by a list of designators enclosed in braces. The order in which the designators are written is insignificant. The same element can be designated more than once in the list but the ‚Äúextra‚Äù designations signify nothing. Thus, the following extensional definitions all denote the same set: Example 3.4: extensional definitions of a set { 2, 3, 5 } { 5, 2, 3 } { 2, 5, 3, 2, 2, 5 } You have seen several extensional definitions already, in Chapter 2. For example, in Tutorial D names for relation types, such as RELATION { StudentId SID, CourseId CID } and RELATION { a INTEGER, b INTEGER, c INTEGER }, the word RELATION is followed by an extensional with a type name. The empty set is often denoted in mathematical texts by the symbol Œ¶ (one of several graphemes for the Greek letter phi) but Tutorial D uses its extensional definition, { }, as in the type name RELATION { } mentioned in Chapter 2. definition for a heading, in which each element is an attribute, designated by an attribute name paired

Tutorial D also allows the body of a relation to be denoted by an extensional definition, as in Example 2.3 in Chapter 2, repeated here for convenience: RELATION {

TUPLE { StudentId SID('S1'), CourseId CID('C1'), TUPLE { StudentId SID('S1'), CourseId CID('C2'), TUPLE { StudentId SID('S2'), CourseId CID('C1'), Name NAME('Boris')}, Name NAME('Anne')}, Name NAME('Anne')},

71
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

TUPLE { StudentId SID('S3'), CourseId CID('C3'), TUPLE { StudentId SID('S4'), CourseId CID('C1'), } Name NAME('Devinder')} Name NAME('Cindy')},

Each element of the body is denoted by a tuple literal consisting of the word TUPLE followed by an paired with a literal denoting some value of the declared type of that attribute.

extensional definition for the tuple itself. Each element of the tuple is denoted by an attribute name

An intensional definition for a set specifies a rule or property. The set being defined consists of every object that obeys the specified rule or has the specified property. For example, we have the set of all dogs, whose elements are all and only those objects that have the property of being a dog, and the set of all numbers from 1 to 10, whose elements are precisely those numbers n that obey the rule ‚Äún is between 1 and 10, inclusive‚Äù. Of course we could equally well say that the set of all dogs is the set whose elements are all and only those objects that obey the rule ‚Äúx is a dog‚Äù, and the set of all numbers from 1 to 10 is the set whose elements are precisely those numbers that have the property of being between 1 and 10, inclusive.

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

72
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

It should come as no surprise, now, to learn that the rule or property is actually some expression denoting a predicate. In fact, the mathematical notation for writing an intensional definition, sometimes called set-builder notation, consists of an expression specifying the parameters of a predicate and the predicate itself. Example 3.5 gives some intensional definitions using this notation. Example 3.5: intensional set definitions { x : x is a dog } { n : n is an integer and 1ÔÇünÔÇü10 } { p : p is prime and p<7 } { x : 0<x<9 and x = 1 + 2n for some integer n, where n‚â•0 { q : q is prime and q<7 }

In set-builder notation, the braces indicate that a set is being defined. The colon can be pronounced ‚Äúsuch that‚Äù. The elements of the set being defined, also known as its members, are all and only those objects that satisfy the given predicate, sometimes referred to as a membership predicate for that set. The last three definitions in Example 3.5 all define the same set, that being the set defined in Example 3.4. Each of the definitions in Example 3.5 uses a monadic predicate, with parameter name x, n, p, x again, and q, respectively. (The n appearing in the penultimate example is not a parameter, as will be explained shortly.) The sets denoted by these examples are not relations, nor are they bodies of relations. The elements of { 2, 3, 5 }, for example, are all numbers, and the body of a relation consists of tuples, not numbers. We are very close to pinning down a method of interpreting a relation but we haven‚Äôt quite got there yet. The light should dawn when we look at set-builder notation using predicates with more than one parameter, such as those in Example 3.6. Example 3.6: more intensional definitions { <a, b> : a < b } { <x, y, z> : x + y = z } { <StudentId, CourseId> : Student StudentId is enrolled on course CourseId } The example { <a, b> : a < b } can be read as ‚Äúthe set consisting of pairs of a and b such that a is less than b‚Äù. A pair is a tuple: a 2-tuple, to be precise. The body of a relation is a set of tuples. The tuples of the body of a relation all have the same heading. The expression <a,¬†b> can be thought of as specifying the names of the attributes of a heading. The objects <a,¬†b> that satisfy a¬†<¬†b are all tuples consisting of an a value and a b value.

73
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

We need to be clear, now, about that important term satisfies:
‚Ä¢	 ‚Ä¢	 An object x satisfies monadic predicate P if and only if substitution of x for the sole parameter of P, thus instantiating P, yields a true proposition. An n-tuple t satisfies n-adic predicate P if and only if substituting each element of t for the corresponding parameter of P, thus instantiating P, yields a true proposition

And now we need to be clear about that correspondence between tuple elements and parameters. In mathematics, notation such as <1,¬† 2>, using angle brackets, is often used to denote a tuple. Using this to instantiate the predicate a < b relies on an ordering of the parameters a and b, without which we would not know whether <1,¬†2> is to be interpreted as 1<2 or, instead, 2<1. In relational databases we sometimes deal with relations of quite high degree, when reliance on some specific ordering would give rise to difficulty that is avoided by the use of attribute names. Thus, in Tutorial D, the tuple literals TUPLE¬†{a¬†1,¬†b¬†2} and TUPLE¬†{b¬†2,¬†a¬†1} both denote the tuple <1,¬†2> in the present instantiation of any dyadic predicate, TUPLE¬†{a¬†1,¬†b¬†2} can represent an instantiation only of a predicate whose parameters are named a and b. context (and might instead denote <2,¬† 1> in some other context). Whereas <1,¬† 2> can represent an

Now, with monadic predicates the problem of matching designators to the right parameters obviously doesn‚Äôt arise, there being only one parameter to choose from. When considering whether the object named Rover satisfies the predicate ‚Äúx is a dog‚Äù, there is only the parameter x for which Rover can be substituted. Although the intensional definition could be written as { <x> : x is a dog } instead of as shown in Example 3.5, the mathematician might have little or no cause to include those angle brackets. However, as we shall see in the next chapter, uniformity is of the essence in a computer language, and a computer language treating relations of degree 1 differently from the others would be needlessly complicated and inconvenient to use. Thus, we revise the intensional definitions given in example 3.5 as shown in Example 3.7. Example 3.7: revision of Example 3.5 { <x> : x is a dog } { <n> : n is an integer and 1ÔÇünÔÇü10 } { <p> : p is prime and p<7 } { <x> : 0<x<9 and x = 1 + 2n for some integer n } { <q> : q is prime and q<7 } The set-builder expressions in Example 3.7 all define sets of tuples‚Äî1-tuples, to be precise. Now we can‚Äôt be so sure that the last three all denote the same set. The mathematician might say that they do, the set being {<2>, <3>, <5> } in each case, where the elements are ‚Äúordered‚Äù 1-tuples. But in relational database theory they do not: the tuples TUPLE { p 2 }, TUPLE { x 2 } and TUPLE¬†{¬†q¬†2¬†} are three different tuples.

74
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

We can usefully extend the definitions of satisfies (of tuples and predicates) to cover cases where the tuple has more elements than the predicate has parameters:
A tuple t satisfies n-adic predicate P if and only if instantiating P by substituting a corresponding element of t for each of its parameters yields a true proposition.

For example, we can now say that TUPLE { a 1, b 2, c 3 } satisfies the predicate a < b. It also satisfies c > b, b < 4, and, for that matter, the niladic predicate 4 < 5 (but not 5 < 4‚Äîwhy not?). Note that under this definition a tuple that satisfies P must have at least as many elements as P has parameters. Confining our attention to tuples as the objects that might or might not satisfy predicates entails absolutely no loss of generality. In fact, it might even be considered to gain something, for consider Example 3.8. Example 3.8: intensional definitions using niladic predicates {<>:2<1} { < > : Student S1 is enrolled on course C1 }

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

75
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

The first defines the empty set, { }, because there is no 0-tuple that satisfies the given predicate. (There is only one 0-tuple, < >. It is denoted by the literal TUPLE { } in Tutorial D.) Assuming that student S1 is indeed enrolled on course C1, the second denotes the singleton set {¬†<¬†>¬†}, this being the body of the relation RELATION { TUPLE { } }‚Äîmore about this strange-looking relation in Chapter 4. The mathematician has little use for it, to be sure, but computer languages that fail to recognize special limiting cases tend to give rise to occasional but needless disappointment. Now, at last, we can answer the question implied by the title of this section. Quite simply:
A relation represents the extension of some n-adic predicate P by having a body consisting of every n-tuple that satisfies P.

Finally, and most importantly, note that the extension of a predicate can vary from time to time. Indeed, relational databases are expected to consist of variables‚Äîrelvars, in fact‚Äîwhose assigned values do change from time to time; and yet the predicate whose extension is represented by the value assigned to such a relvar remains constant over time. Thus, we can and do speak of the predicate for a relvar (and note in passing that it might be quite useful for such predicates to be recorded in the system catalogue).

3.5	

Deriving Predicates from Predicates

We have already seen one method by which a predicate can be derived from a given predicate, namely, substitution. And we have begun to see the relevance of substitution in the context of relational databases. There are two other general methods, both also relevant in this context. One is by use of the logical connectives of the propositional calculus, such as those denoted in many computer languages, including Tutorial D, by AND, OR, and NOT. The other is by quantification. Why are ways of deriving predicates from predicates important to us? Well, the next chapter describes a set of operators for deriving relations from relations. This set of operators‚Äîthe relational algebra‚Äîis arguably the most important component of the machinery we use to work with a relational database. If relations r1 and r2 represent predicates p1 and p2 and we can derive relation r3 from r1 and r2, then r3 represents some predicate p3 that can be derived from p1 and p2. Moreover, the definitions of the relational operators we use to derive r3, as we shall see in Chapter 4, tell us how to derive p3. Therefore, if we know p1 and p2, which tell us how to interpret r1 and r2, we will know how to interpret r3. Conversely, if we can express p3 in terms of p1 and p2, then we can work out how to express r3 in terms of r1 and r2.

76
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

Logical Connectives In human languages such as English we can connect two sentences together such that the result is itself a sentence. The connecting word is called a conjunction. For example, in ‚ÄúIt‚Äôs raining and I‚Äôm wet through‚Äù, the conjunction ‚Äúand‚Äù connects the sentences ‚ÄúIt‚Äôs raining‚Äù and ‚ÄúI‚Äôm wet through‚Äù. Other examples: It‚Äôs raining but I have my umbrella with me. (‚Äúbut‚Äù) I have my umbrella with me because it‚Äôs raining. (‚Äúbecause‚Äù) I shall have my umbrella with me if it rains. (‚Äúif ‚Äù) I shan‚Äôt have my umbrella with me unless it rains. (‚Äúunless‚Äù) Since we use sentences to denote predicates it is easy to see that a sentence formed from two sentences in this way can denote a predicate formed from two predicates. And the meaning of the predicate thus formed can be derived from the meaning of the two constituent predicates and the meaning of the conjunction that connects the sentences. Many of the so-called logical connectives of the propositional calculus correspond approximately to conjunctions in human languages such as English. AND and OR are obvious examples. But some of them‚Äîfor example, NOT‚Äîjust modify a single predicate and thus don‚Äôt really do any connecting as such. called conjunction. The correspondence between logical connectives and conjunctions in human language in which it is used. Consider, for example, the English sentence, ‚ÄúYou pay me by Tuesday or I‚Äôll sue.‚Äù If that ‚Äúor‚Äù were the logical connective, then the sentence is true when either you do pay me by Tuesday or I sue you; so you could pay me on Monday and I might still sue you. But this particular use of ‚Äúor‚Äù would normally be taken to mean that either you pay me by Tuesday and I don‚Äôt sue you, or you do not pay me by Tuesday and I do sue you‚Äîthe so-called ‚Äúexclusive or‚Äù. Negation (NOT) In English, given a statement, s, we can derive the statement ‚ÄúIt is not true that s.‚Äù This denotes the negation of the proposition p denoted by s. Negation is usually denoted in formal treatments by the symbol ¬¨: the negation of p is written as ¬¨p. If p is true, then its negation is false; and if p is false, then its negation is true. It follows that ¬¨¬¨p has the same truth value as p. To add to the possible confusion, the abstract noun used to refer to one of them in particular‚ÄîAND‚Äîis is approximate because the meaning of a logical connective is always the same, regardless of the context

77
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

The definition of a logical connective is usually presented as a truth table, in which the letters T and F stand for TRUE and FALSE, respectively. The truth table for negation is shown in Figure 3.1.
p

¬¨p
F T

T F

Figure 3.1: The Truth Table for Negation

As we have seen, a proposition is a special case of a predicate, namely, a predicate with no parameters (a niladic predicate). Negation can be applied to other predicates too, the result always being a predicate with the same parameters as the predicate to which it is applied. Of course, a predicate with parameters has no truth value; therefore neither does its negation. However, the truth table for negation tells us that if tuple t satisfies predicate p, then t does not satisfy ¬¨p; and, conversely, if t fails to satisfy p, then t satisfies ¬¨p.

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
78
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

Consider the negation, ‚ÄúStudent StudentId is not enrolled on course CourseId.‚Äù Assuming the truth expressed by the ENROLMENT relation depicted in Figure 1.2 of Chapter 1, we can see that the tuple Here, by contrast, as some that do satisfy it: TUPLE { StudentId SID('S1'), CourseId CID('C1') } fails to satisfy this predicate.

TUPLE { StudentId SID('S1'), CourseId CID('C3') }

(No tuple in ENROLMENT shows student S1 as being enrolled on course C3) TUPLE { StudentId SID('S2'), CourseId CID('C97') } such course, though C97 is a valid course identifier)

(No tuple in ENROLMENT shows S1 as being enrolled on C97 and in fact there is currently no

TUPLE { StudentId SID('S98'), CourseId CID('C97') } no such student, though S98 is a valid student identifier)

(No tuple in ENROLMENT shows S98 as being enrolled on C97 and in fact there is currently

In Tutorial D, as previously noted, negation is denoted by the key word NOT. For example, the expression NOT (x = 5) evaluates to TRUE for all values of x except 5, when it evaluates to FALSE.

You will have realised by now that the cardinality of a relation representing the extension of ‚ÄúStudent StudentId is not enrolled on course CourseId ‚Äù is likely to be very high indeed‚Äîalmost certainly too high to be manageable using a computer. In Chapter 4 you will see that a relational DBMS‚Äôs support for relations representing negated predicates is subject to a certain restriction, addressing this problem. But you may also be thinking that relations for negated predicates such as the example at hand would be of little use in practice, in which case you will agree, when you see the restriction I am referring to, that it is of little or no import. Conjunction (AND) In English, two sentences may be connected by the conjunction, ‚Äúand‚Äù, yielding a single sentence. For example, ‚ÄúCome in and make yourself at home‚Äù, where the conjunction connects two imperatives, meaning that the person being spoken to is being enjoined to do both of those things. When the sentences being connected are statements, denoting propositions, the result is a single statement, denoting a single proposition. For example: ‚ÄúIt‚Äôs raining and I‚Äôm wet through‚Äù. If it really is raining, and I really am wet through, then that is a true statement; otherwise‚Äîeither it‚Äôs not raining, or I‚Äôm not wet through‚Äîit is a false statement. That example illustrates the logical connective AND, usually denoted in conjunction. Unfortunately, as previously noted, there are other conjunctions in English whose use does not denote logical conjunction (for example, ‚Äúor‚Äù). There are also other conjunctions that do denote logical conjunction (for example, ‚Äúbut‚Äù). formal treatments by the symbol ÔÄÆ. The connection of two propositions in this particular way is called

79
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

The conjunction of propositions p and q is true if and only if p is true and q is true, as shown in Figure 3.2, the truth table for conjunction.
p T T F F q T F T F p‚àßq T F F F

Figure 3.2: The Truth Table for AND

As we have seen, a proposition is a special case of a predicate, namely, a predicate with no parameters (a niladic predicate). Conjunction can be applied to other predicates too, the result being a predicate. Again, a predicate with parameters has no truth value; therefore neither does its conjunction with some other predicate. However, the truth table for conjunction tells us that if tuple t1 satisfies predicate p1 and tuple t2 satisfies predicate p2, then tuple t3, consisting of every element that is an element of either t1 or t2 (or both) satisfies p1ÔÄÆp2; conversely, if either t1 fails to satisfy p1 or t2 fails to satisfy p2 then t3 fails to satisfy p1ÔÄÆp2. Consider the conjunction ‚ÄúStudent StudentId is enrolled on course CourseId and student StudentId is called Name‚Äù. The predicates being connected are ‚ÄúStudent StudentId is enrolled on course CourseId ‚Äù and ‚ÄúStudent StudentId is called Name‚Äù. We connect two dyadic predicates to form a triadic one‚Äîit has only three parameters because the parameter StudentId is common to both of the dyadic predicates. ‚ÄúStudent StudentId is enrolled on course CourseId and student StudentId is called Name‚Äù is of course the intended predicate for the ENROLMENT relvar of Figure 1.2 in Chapter 1. Figure 1.2 tells us that TUPLE { StudentId SID('S1'), Name NAME('Anne'), CourseId CID('C1') } satisfies that predicate. That being the case, the truth table for conjunction allows us to conclude that it also satisfies both ‚ÄúStudent StudentId is enrolled on course CourseId‚Äù and ‚ÄúStudent StudentId is called Name‚Äù, for if it failed to satisfy either, then the instantiation of their conjunction under that tuple must be false according to that truth table. Disjunction (OR) As previously noted, there are plenty of other words (conjunctions) for connecting sentences, and they do not all denote conjunction. For example, ‚Äúor‚Äù is such a word and it denotes disjunction, usually denoted in formal treatments by the symbol ÔÄ≠. The disjunction of propositions p and q is true if either p is true, or q is true, or both are true; otherwise (neither p nor q is true) false. The truth table for disjunction is shown in Figure 3.3.

80
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

p T T F F

q T F T F

p ‚à®q T T T F

Figure 3.3: The Truth Table for Disjunction

The definition I have given for disjunction is surely intuitive and obvious. But note that, having previously defined negation and conjunction (in equally intuitive and obvious ways), I could now define disjunction in terms of those two, like this: p ÔÄ≠ q ‚â° ¬¨(¬¨p ÔÄÆ ¬¨q) We can use a truth table (Figure 3.4) to prove this equivalence:
p T T F F q T F T F

¬¨p
F F T T

¬¨q
F T F T

¬¨p‚àß¬¨q
F F F T

¬¨(¬¨p‚àß¬¨q)
T T T F

Figure 3.4: Disjunction in Terms of Negation and Conjunction

We used the truth tables for negation and conjunction to obtain the second, third, and fourth columns. As you can see, the final column is the same as in Figure 3.3. Like conjunction, disjunction can be applied to predicates in general as well as propositions. Consider the disjunction ‚ÄúStudent StudentId is enrolled on course CourseId or student StudentId is called Name‚Äù. The predicates being connected are once again ‚ÄúStudent StudentId is enrolled on course CourseId‚Äù and ‚ÄúStudent StudentId is called Name‚Äù. Because the first row of the truth table is the same as the first row of the truth table for conjunction, and because the conjunction of these two predicates is the agreed predicate for ENROLMENT, we can conclude that every tuple in ENROLMENT satisfies their disjunction too. However many other tuples, not in ENROLMENT, also satisfy it. For example, TUPLE {StudentId SID('S1'), Name NAME('Eve'), CourseId CID('C1')} satisfies it because it satisfies

‚ÄúStudent StudentId is enrolled on course CourseId‚Äù (student S1 isn‚Äôt called Eve but she is enrolled on course C1). For another example, TUPLE¬†{StudentId¬†SID('S1'), Name NAME('Anne'), S1 isn‚Äôt enrolled on course C97‚Äîin fact, as it happens there is no such course‚Äîbut she is called Anne. CourseId CID('C97')} satisfies it because it satisfies ‚ÄúStudent StudentId is called Name‚Äù (student

81
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

You will have realised by now that the cardinality of a relation representing the extension of ‚ÄúStudent StudentId is enrolled on course CourseId or student StudentId is called Name‚Äù is likely to be very high indeed‚Äîalmost certainly too high to be manageable using a computer. In Chapter 4 you will see that a relational DBMS‚Äôs support for relations representing disjunctive predicates is subject to a certain restriction, addressing this problem. As with negation, you may also be thinking that relations for disjunctive predicates such as the example at hand would be of little use in practice, in which case you will agree again, when you see the restriction I am referring to, that it is of little or no import. Conditionals Consider the sentences shown in Example 3.9. Example 3.9: conditional sentences (i)	 (ii)	 If you ask me nicely, then I will marry you. I will marry you only if you ask me nicely

(iii)	 I will marry you if and only if you ask me nicely.

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

82
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

Each denotes a predicate derived from two predicates using a connective of a general kind called conditional. Sentence (i) illustrates use of logical implication, usually denoted in formal treatments by the symbol ‚Üí. Sentence (i) denotes a true proposition in all situations except when the question is asked nicely but results in refusal. In general, p ‚Üí q (‚Äúif p then q‚Äù) is true except when p is true and q is false.
p T T F F q T F T F p‚Üíq T F T T

Figure 3.5: The Truth Table for Logical Implication

As an exercise, you might like to work out the truth table for the expression ¬¨p ÔÄ≠ q. You should find that the final column is identical to the final column of Figure 3.5, confirming the equivalence p ‚Üí q ‚â° ¬¨p ÔÄ≠ q Sentence (ii) of Example 3.9 is merely another way of saying, ‚ÄúIf I marry you, then you will have asked me nicely.‚Äù Sentence (iii) illustrates use of the biconditional, also known as equivalence, usually denoted in formal treatments by the symbol ‚Üî. It is true whenever the truth values of ‚ÄúI will marry you‚Äù and ‚ÄúYou ask me nicely‚Äù are identical‚Äîeither both TRUE or both FALSE; otherwise it is FALSE. It should be clear, then, that p ‚Üî q is equivalent to (p ‚Üí q) ÔÄÆ (q ‚Üí p), as confirmed by the truth table in Figure 3.6.
p T T F F q T F T F p‚Üíq T F T T q‚Üíp T T F T (p‚Üíq) ‚àß (q‚Üíp) T F F T

Figure 3.6: p ‚Üî q ‚â° (p ‚Üíq ) ‚àß (q‚Üíp)

As you can see, the final column indicates TRUE exactly when the first two columns indicate the same truth value.

Quantification Our final method of deriving a predicate from a predicate does not correspond to anything in propositional calculus and in fact is what distinguishes the predicate calculus from propositional calculus.

83
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

To quantify something is to state its quantity, to say how many of it there are. Consider the following sentences: x has been president of the USA. 44 people have been president of the USA. The first denotes a monadic predicate, the second a niladic one (and is either true or false, depending, as it happens, on when it is uttered‚Äîfor example, it became true in January 2009). The second sentence is in a sense derived from the first by stating how many x‚Äôs there are such that x has been president of the USA. Quantification doesn‚Äôt have to be numerically precise. Here are some further examples: At least 40 people have been president of the USA. Between 40 and 50 people have been president of the USA. Nobody has been president of the USA. That last one is precise, of course. It happens to be a false statement, from which it follows that its negation, It is not the case that nobody has been president of the USA. is a true one. But this uses a ‚Äúdouble negative‚Äù and is just an awkward way of stating At least one person has been president of the USA. Or There is a person x such that x has been president of the USA. This is derived from ‚Äúx has been president of the USA‚Äù by existential quantification. Like substitution, quantification reduces the number of parameters: one of the parameters of a given n-adic predicate is quantified and the result is an (n-1)-adic predicate. Note carefully that the symbol x, denoting a variable, appears twice in that last formulation, and yet it is not a parameter. The x in the predicate ‚Äúx has been president of the USA‚Äù is a parameter, of course. As such it is also referred to sometimes as a free variable, when it is then said to be bound, by quantification, in ‚ÄúThere is a person x such that x has been president of the USA‚Äù.

84
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Predicates and Propositions

Existential quantification is denoted in formal treatments by the symbol ‚àÉ (‚Äúthere exists‚Äù), as in ‚àÉ x : x has been president of the USA. As before, the colon can be pronounced ‚Äúsuch that‚Äù. Having seen how existential quantification can be expressed in a long-winded way using a double negative, now see what happens when we apply a double negative to an existentially quantified predicate, as in the sentence It is not the case that somebody doesn‚Äôt know who is the current president of the USA. This would be expressed formally as ¬¨(‚àÉx : ¬¨(x knows who is the current president of the USA))

85
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Predicates and Propositions

‚ÄúIt is not the case that there exists a person x such that it is not the case that x knows who is the current president of the USA.‚Äù You have perhaps worked out by now that all we are saying is, ‚ÄúEverybody knows who is the current president of the USA.‚Äù Here we are using universal quantification‚Äîstating that something is true of everything that is under consideration. Universal quantification is denoted in formal treatments by the symbol ‚àÄ (‚Äúfor all‚Äù), as in ‚àÄx : x knows who is the current president of the USA (The colon here clearly cannot be pronounced ‚Äúsuch that‚Äù but is kept for symmetry with existential quantification.) That concludes my digression into predicate logic to explain how relations are supposed to be interpreted. In the next chapter I show how the operators of the relational algebra are used to derive relations from relations, relating these to the methods I have described for deriving predicates from predicates. You might like to try the exercises that follow before moving on to that chapter.

EXERCISES
Consider again the relation shown as the current value of ENROLMENT in Figure 1.2, repeated here for convenience:
StudentId S1 S1 S2 S3 S4 Name Anne Anne Boris Cindy Devinder CourseId C1 C2 C1 C3 C1

86
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

For each of the following propositions, state whether it is true or false, basing your conclusions on this relation: 1.	 There exists a course CourseId such that some student named Anne is enrolled on CourseId. 2.	 Every student with StudentId S1 who is enrolled on some course is named Anne. 3.	 Every student who is enrolled on course C4 is named Anne. 4.	 Some student who is enrolled on course C4 is named Anne. 5.	 There are exactly 5 students who are enrolled on some course. 6.	 It is not the case that there is no course on which no student who is enrolled on some course but is not named Boris is not enrolled. 7.	 There are exactly 10 pairs of StudentIds (SID1, SID2) such that there is some course on which student SID1 is enrolled and student SID2 is enrolled. 8.	 There are exactly 3 pairs of StudentIds (SID1, SID2) such that there is some course on which student SID1 is enrolled and student SID2 is enrolled. 9.	 If a student named Eve is enrolled on course C1, then student S1 is named Adam. 10.	 If student S1 is named Anne, then S1 is enrolled on course C2.

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

87
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

4	Relational Algebra‚Äî The Foundation
4.1	Introduction
This chapter introduces you to relational operators. A relational operator is an operator that takes one or more relations as operands and produces a relation as a result. The relational operators described in this chapter constitute a basic set that is considered to be sufficient for relational completeness. Such a set of operators is called a relational algebra. My use of the word ‚Äúbasic‚Äù suggests that this set of operators would be necessary, as well as sufficient, for relational completeness. That will do as a working assumption for now, but we shall eventually see that there is actually a tiny element of superfluity. Sometimes that term, relational algebra, is used with the definite article: the relational algebra, even though several minor variations exist in the literature. Indeed, the term relational completeness is sometimes defined with reference to ‚Äúthe‚Äù relational algebra‚Äîa language is deemed relationally complete if it supports, directly or indirectly, all of the operators of ‚Äúthat‚Äù algebra. Suffice it here to say that the operators described in this chapter meet the criteria for constituting a complete relational algebra, and their manifestation in Tutorial D makes that language relationally complete. We start by looking at a particularly important relational operator, named JOIN (see Section 4.4 JOIN and AND for details). Consider the relations depicted in Figure 4.1, the current values of relvars named IS_CALLED and IS_ENROLLED_ON.
,6B&$//(' 6WXGHQW,G 6 6 6 6 6 1DPH $QQH %RULV &LQG\ 'HYLQGHU %RULV       ,6B(152//('B21 6WXGHQW,G 6 6 6 6 6 &RXUVH,G & & & & &

Figure 4.1: IS_CALLED and IS_ENROLLED_ON

88
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Notice that nearly all of the data shown Figure 4.1 appears also in Chapter 1, Figure 1.2, the current value of the variable ENROLMENT. In fact, the relation that is the current value of ENROLMENT can as shown in Example 4.1. easily be derived from the current values of IS_CALLED and IS_ENROLLED_ON by invoking JOIN,

Example 4.1: Joining IS_CALLED and IS_ENROLLED_ON IS_CALLED JOIN IS_ENROLLED_ON This is an example of a relational expression. Relational expressions in Tutorial D include: ‚Ä¢	 invocations of the relation selector, RELATION, defined in Chapter 2; ‚Ä¢	 invocations of relational operators; ‚Ä¢	 names of relation variables such as IS_CALLED and IS_ENROLLED_ON; and ‚Ä¢	 the names TABLE_DEE and TABLE_DUM, defined later in the present chapter. Note that operands of relational operators are denoted by relational expressions. Figure 4.2 shows the result of evaluating IS_CALLED JOIN IS_ENROLLED_ON. You can see that

it depicts exactly the same relation as the current value of ENROLMENT shown in Figure 1.2.
StudentId S1 S1 S2 S3 S4 Name Anne Anne Boris Cindy Devinder CourseId C1 C2 C1 C3 C1

Figure 4.2: The result of joining IS_CALLED with IS_ENROLLED_ON

ENROLMENT is the conjunction (AND) of the predicates for IS_CALLED and IS_ENROLLED_ON. In general, if p1 and p2 are predicates represented by relations r1 and r2, respectively, then the Tutorial D expression r1 JOIN r2 denotes the relation corresponding to the conjunction p1 AND p2 (written as

IS_ENROLLED_ON is ‚ÄúStudent StudentId is enrolled on course CourseId‚Äù. Notice that the predicate for

CourseId ‚Äù. The predicate for IS_CALLED is ‚ÄúStudent StudentId is called Name‚Äù and the predicate for

The predicate for ENROLMENT is ‚ÄúStudent StudentId is called Name and is enrolled on course

p1‚àßp2 in mathematical notation).

89
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

By studying this little example you might be able to work out for yourself how JOIN works, in general, before I explain it in detail. If you try that exercise, there are a couple of points of difference you should take careful note of in Figures 4.1 and 4.2: a)	 The only fact depicted in Figure 4.1 but not in Figure 4.2 is that student S5 is called Boris. Student S5 doesn‚Äôt appear in Figure 4.2 because that student isn‚Äôt enrolled on any courses at all. Therefore there is no course identifier‚Äîno value of type CID‚Äîthat satisfies the predicate ‚ÄúStudent S5 is called Boris and is enrolled on course CourseId‚Äù. 4.2 it is shown twice. JOIN is an operator that, when invoked, operates on two relations and returns a relation. A relational b)	 In Figure 4.1 the fact that student S1 is called Anne is shown just once, whereas in Figure

operator is one that, when invoked, operates on one or more given relations and returns a relation. A relational algebra is a set of such operators‚Äîin mathematical parlance it (the algebra) is closed over relations. The term closure refers to the property of a set of operators whereby the results are of the same type as the operands. For example, the familiar operators of arithmetic‚Äî‚Äú+‚Äù, ‚Äú-‚Äù, and so on‚Äîare closed over numbers. This chapter and the next describe the set of relational operators defined for Tutorial D, giving for each one the notation used in Tutorial D for invoking it. The ones described in this chapter are just those needed for relational completeness. In Chapter 5, ‚ÄúBuilding on The Foundation‚Äù, I describe some further operators defined in Tutorial D to illustrate some of the additional kinds of things that are needed to make a relational database language more useful for practical purposes. The aforementioned property of closure allows us to write relational expressions of arbitrary complexity, because an invocation of a relational operator, denoting, as it does, a relation, can be used to denote an argument to another invocation. Thus, invocations can be nested inside each other to any degree of complexity. (Recall that the operators of arithmetic allow us to write numerical expressions of arbitrary complexity in similar fashion.) In Chapter 3 we saw how a relation might represent the extension of some predicate. We also saw the various ways in which predicates can be derived from predicates, using logical connectives and quantifiers. For each such method we will discover a corresponding relational operator that can be used to derive the relation representing the extension of a predicate derived by that method, just as I have shown for JOIN in Example 4.1.

90
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

4.2	

Relations and Predicates

Recall from Chapter 3 how a relation represents the extension of a predicate:
A relation represents the extension of some n-adic predicate P by having a body consisting of every n-tuple that satisfies P.

The current value of IS_CALLED shown in Figure 4.1 tells us that the extension of ‚ÄúStudent StudentId

is called Name‚Äù is (currently) the set {Student S1 is called Anne, Student S2 is called Boris, Student S3 is called Cindy, Student S4 is called Devinder, Student S5 is called Boris}, each element of which is an instantiation of the predicate that happens to be true. From the given definition it follows that every other instantiation of that predicate is false and therefore does not appear in its extension. The assumption that the body of a relation consists of every tuple that satisfies the relation‚Äôs predicate is called the closed world assumption. This assumption underpins the operators of the relational algebra. Under the open world assumption, every tuple that‚Äôs in the relation does represent a true proposition but it is possible for tuples that satisfy the predicate not to appear in the relation. It would not be possible to devise relational operators based on that assumption, for unless every instantiation of the predicate were false it would be an arbitrary choice as to which tuples, if any, are to be included.

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

91
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

4.3	

Relational Operators and Logical Operators

The operators of the relational algebra are nearly all relational counterparts of the logical connectives AND, OR, and NOT, and existential quantification. Each relational operator, when invoked, yields a relation, which can be interpreted as the extension of some predicate. Because relations are used to Example 4.1 illustrates the use of JOIN as the relational counterpart of the logical operator AND to give us the relation representing the predicate represent predicates, it makes sense for relational operators to be counterparts of logical operators.

Student StudentId is called Name AND StudentId is enrolled on course CourseId. where the predicates for IS_CALLED and IS_ENROLLED_ON are connected by AND. We will meet other examples, enabling us to obtain relations representing predicates such as ‚Ä¢	 Student StudentId is enrolled on some course. Here the predicate for IS_ENROLLED_ON is subject to existential quantification on CourseId. ‚Ä¢	 Student StudentId is enrolled on course CourseId AND StudentId is NOT called Devinder. Here the predicate for IS_ENROLLED_ON is connected by AND to the negation of the monadic ‚Ä¢	 Student StudentId is NOT enrolled on any course OR StudentId is called Boris. predicate formed by substituting Devinder for Name in the predicate for IS_CALLED.

Here the negation of the predicate resulting from existential quantification of the predicate for in the predicate for IS_CALLED. IS_ENROLLED is connected by OR to the predicate formed by substituting Boris for Name

and more. Descriptions of relational operators now follow, starting with JOIN. In most cases the section heading shows the logical operator to which the given relational operator corresponds. You will see that in at least one case, AND, we have several distinct relational operators and I will explain why this is so.

4.4	

JOIN and AND

Figure 4.3 shows how Example 4.1 ‚Äúworks‚Äù. I have changed the order of the columns in the IS_CALLED table (you know that makes no difference) in order to place side by side the attributes that are both named StudentId. The upward arrows show which bits of the relational expression correspond to which bits of the predicate.

The arrows connecting rows in the tables show which combinations of operand tuples represent true instantiations of the predicate. Note how a tuple on the left matches a tuple on the right if and only if the two tuples have the same StudentId value. This concept of matching tuples is at play in several of the other operators too. Tuples t1 and t2 are said to match, or be matching, if and only if, for each common attribute c, they have the same value for c, where a common attribute is one that has the same name in both t1 and t2.
92
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

6WXGHQW,GLVFDOOHG1DPH ,6B&$//(' 1DPH $QQH %RULV &LQG\ 'HYLQGHU %RULV 6WXGHQW,G 6 6 6 6 6      

$1' -2,1

6WXGHQW,GLVHQUROOHGRQ&RXUVH,G ,6B(152//('B21 6WXGHQW,G 6 6 6 6 6 &RXUVH,G & & & & &

Figure 4.3: Joining IS_CALLED with IS_ENROLLED_ON

Common attributes have to be of the same type as well as having the same name. For consider, if that of type SID and StudentId in IS_ENROLLED_ON were of type CHAR‚Äîthen: were not the case in our JOIN example‚Äîsuppose, for example, that StudentId in IS_CALLED were

a)	 What would be the type, SID or CHAR, of the single StudentId attribute in the result of b)	 How could the DBMS determine whether a given pair of tuples match on StudentId? To be comparable at all, the operands of equals comparison must be of the same type. the JOIN?

Note very carefully that the result does have only one StudentId attribute, even though the corresponding parameter appears twice in the predicate. Multiple appearances of the same parameter in a predicate are always taken to stand for the same thing. Here, if we substitute S1 for one of the in the resulting relation. StudentId is a common attribute of r1 and r2. In general, there can be any StudentIds, then we must also substitute S1 for the other. That is why we have only one StudentId

number of common attributes; and there can even be no common attributes at all. Definition of JOIN Here is a formal definition of our first relational operator, JOIN:
Let s = r1 JOIN r2. Then: ‚Ä¢	 ‚Ä¢	

The heading Hs of s is the union of the headings of r1 and r2, which must be a heading (otherwise, r1 JOIN r2 is undefined). The body of s consists of those tuples having heading Hs that can be formed by taking the union of t1 and t2, where t1 is a tuple of r1 and t2 is a tuple of r2.

If both r1 and r2 have an attribute of the same name but not the same type, then the union of their headings is not a heading and r1 JOIN r2 is undefined.

93
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

We can take the union of two headings because headings are sets. In particular, a heading is a set of attribute name/type pairs. If two headings have different types for some attribute of the same name, then their union is a set (of course) but is not a heading‚Äîbecause a heading cannot have more than one type paired with the same name. We can take the union of two tuples because tuples are sets. In particular, a tuple is a set of attribute name/value pairs. If two tuples have different values for some common attribute, then their union is a set (of course) but is not a tuple‚Äîbecause a tuple cannot have more than one value paired with the same name. Note that if either operand is empty (its body is the empty set), then so is the result. Interesting properties of JOIN JOIN is both commutative and associative. Commutativity (of a dyadic operator) means that the order of operands is insignificant. That is to say, r1 JOIN r2 is equivalent to r2 JOIN r1. Associativity means

that (r1 JOIN r2) JOIN r3 is equivalent to r1 JOIN (r2 JOIN r3)‚Äîif we wish to join three or more relations together, then we can join them in any order, so to speak. Of course it is no mere coincidence that logical AND is also both commutative and associative.

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

94
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Properties such as these not only save us a certain amount of thinking when formulating expressions; they also help the optimizer to find alternative formulations that might perform better than a straightforward implementation of the one written. Tutorial D takes further advantage of these properties by supporting an alternative syntax for invoking JOIN, using prefix notation instead of the infix notation I have already When the operator is associative, we can have any number of arguments: JOIN { r1, r2, ‚Ä¶ } When there is just one argument, r1, the result is r1. I hope you are wondering what happens if there are no arguments at all‚Äîasking if JOIN { } is defined. Well, it is!‚Äîbut I have to defer the explanation until later, for a reason you will understand when I do so. shown you. In prefix notation the operator name is followed by a list of argument expressions in braces.

As well as being commutative and associative, JOIN is idempotent. Let r be any relation. Then r¬†JOIN¬†r¬†=¬†r. A dyadic operator is idempotent if, when its operands are the same value, it yields that value. Again, it is no mere coincidence that logical AND is idempotent: pÔÄÆp always has the same truth value as p. There is one further interesting property of JOIN, described later, in Section 4.6 of this chapter. Two special cases of JOIN There are two extreme cases concerning common attributes: the case when all attributes are common to both operands and the case where none of them are. If all attributes of r1 and r2 are common, then the body of r1 JOIN r2 is the set-theory intersection of the body of r1 and the body of r2. For that reason their join is sometimes called intersection. In fact, Tutorial D allows you to use the key word INTERSECT in place of JOIN in this special case only. If you and you might be grateful if the system rejects your invocation (at compile time) when they don‚Äôt. If no attributes of r1 and r2 are common, then every pair of tuples, t1 from r1 and t2 from r2, is such that their union is a tuple and so appears in the body of r1 JOIN r2. In mathematical terms we have the same combinations of tuples as would appear in the Cartesian product of the two bodies (the analogy combines them to form a single tuple). For that reason their join is sometimes called their product and is a little loose, because in the Cartesian product the paired elements remain as a pair, whereas JOIN Tutorial D allows you use the key word TIMES in place of JOIN in this special case only. If you do so, you are in effect telling the system that you expect the operands to have no attributes in common, and you might be grateful if the system rejects your invocation (at compile time) when they don‚Äôt.

do so, you are in effect telling the system that you expect the operands to have all attributes in common,

95
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Now, sometimes, when joining relations, we want attributes a1 of r1 and a2 of r2 to be used for determining matching tuples even though a1 and a2 do not have the same name. Conversely, we sometimes want common attributes not to take part in the matching process. In such cases we cannot simply take the result of r1 JOIN r2. We have to somehow ‚Äúchange‚Äù some attribute names before we do the join; and that brings me to the next operator, RENAME.

4.5	RENAME
Although I offer no logical counterpart for RENAME, consider that one predicate can be derived from another predicate simply by changing one or more of its parameter names. For example, from the predicate for IS_CALLED, ‚ÄúStudent StudentId is called Name‚Äù, we could derive the different predicate intensions too; but they aren‚Äôt represented by exactly the same relations, these being the two relations depicted in Figure 4.4.
StudentId S1 S2 S3 S4 S5 Name Anne Boris Cindy Devinder Boris Sid S1 S2 S3 S4 S5 Name Anne Boris Cindy Devinder Boris

‚ÄúStudent Sid is called Name‚Äù. Those two predicates have identical extensions and in fact have identical

Figure 4.4: Relations differing only in an attribute name

The one on the left is the current value of IS_CALLED. The one on the right is the same relation except that the attribute name Sid is used in place of StudentId. In some circumstances we might want to derive the relation on the right from the one on the left and use the result in some operation such relation on the right.

as a JOIN. That‚Äôs what the RENAME operator is for, and Example 4.2 shows how to use it to obtain the

Example 4.2: Renaming an attribute IS_CALLED RENAME { StudentId AS Sid } The expression enclosed in parentheses‚Äîwhich is not a relational expression‚Äîis called a renaming. In general there can be any number of renamings, separated by commas.

96
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Definition of RENAME
Let s = r RENAME { a1 AS b1, ‚Ä¶, an AS bn }. Then: ‚Ä¢	 ‚Ä¢	 The heading of s is the heading of r except that the attribute named ai, of type ti, is replaced by an attribute named bi, also of type ti (0ÔÇüiÔÇün). The body of s consists of the tuples of r except that in each tuple attribute ai with value œÖ is replaced by attribute b with value œÖ.

Obviously, the result must be such that no two attributes have the same name; otherwise, it wouldn‚Äôt be a relation. Note that when more than one attribute is being renamed, the renamings are considered to take place simultaneously, so to speak. Thus, the example R RENAME { A AS B, B AS A } swaps the names of those two attributes.

Syntax note When describing syntax we use the convenient term commalist for a list of items separated by commas. Thus we can say that an invocation of RENAME consists of a relation expression followed by the key word itself, followed in turn by a renaming commalist enclosed in parentheses. In Tutorial D, wherever the syntax requires a commalist, that commalist is permitted to be empty. Thus, for example, R RENAME { } is a legal expression. (Its value is equal to R.)

97
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Please do not confuse the RENAME operator with one that might be used for changing the name of an attribute of a relvar. That might be a very useful tool for database designers but in this chapter we are contents or definition. Unfortunately, E.F. Codd did not foresee the need for a RENAME operator and so it is missing from some accounts of relational algebra that you may come across. Using RENAME in combination with JOIN Suppose we wish to discover pairs of students who have the same name. The result must be a relation with three attributes: two for the student identifiers and one for the name those two students share. All the is ‚ÄúStudent StudentId is called Name‚Äù. What might be a predicate for our desired result? Obviously we cannot just connect ‚ÄúStudent StudentId is called Name‚Äù to itself using AND, because multiple appearances of the same parameter must all represent the same value. So we must use two different parameter names for the two student identifiers. Example 4.3 shows a suitable predicate, followed by a relational expression that uses RENAME (twice) and JOIN to denote the required relation. Example 4.3: Renaming and joining Student Sid1 is called Name and so is student Sid2 ( IS_CALLED RENAME { StudentId AS Sid1 } ) JOIN ( IS_CALLED RENAME { StudentId AS Sid2 } ) data we need for that ternary relation is in the binary relvar IS_CALLED. The predicate for IS_CALLED dealing only with read-only operators that yield relations. None of them has any effect on the database‚Äôs

Note that Name is the only common attribute for the JOIN. Now you can begin to see how relational obtained from this expression, shown in Figure 4.5, isn‚Äôt entirely satisfactory.
Sid1 S1 S2 S2 S5 S5 S3 S4 Name Anne Boris Boris Boris Boris Cindy Devinder Sid2 S1 S2 S5 S2 S5 S3 S4

operators can be used to construct expressions of unlimited complexity. Unfortunately, though, the result

Figure 4.5: Result of Example 4.3

98
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

You didn‚Äôt really want to be told that Anne has the same name as herself, nor that students S5 and S2 share the same name (Boris) as well as students S2 and S5 sharing that name! We need to look at some more operators before we can begin to address those little problems. The next one is called projection.

4.6	

Projection and Existential Quantification

Suppose we need to obtain the student identifiers of all the students who are enrolled on some course. Even though that result perhaps isn‚Äôt very interesting in itself, we might need it as part of some more interesting query. The relation we require would represent the predicate derived from the predicate for IS_ENROLLED_ON by existential quantification of CourseId: Student StudentId is enrolled on some course. or, more formally There exists a course CourseId such that student StudentId is enrolled on CourseId. Example 4.4 shows how to obtain the relation representing this predicate, using projection. Example 4.4: Projection Student StudentId is enrolled on some course. IS_ENROLLED_ON { StudentId } Points to note: ‚Ä¢	 Like RENAME, projection is monadic (it operates on just a single relation, in this case the ‚Ä¢	 Tutorial D uses no key word for projection. You just write a commalist of attribute names (a list of one in the example), enclosed in braces, after the expression denoting the single relation operand. ‚Ä¢	 The braces indicate that the order of attribute names in the given list is insignificant. Indeed, here it denotes a set (in the example, a set with just one element). ‚Ä¢	 The attributes named in braces are exactly those that remain if we remove the parameters that are existentially quantified in the predicate. Sometimes it is more convenient to name the attributes to be excluded rather than the remaining ones. With this in mind, Tutorial¬†D supports an alternative formulation, using ALL BUT. Thus Example 4.4 could have been expressed like this instead: IS_ENROLLED_ON { ALL BUT CourseId } current value of IS_ENROLLED_ON).

99
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

The result is shown in Figure 4.6.
StudentId S1 S2 S3 S4
Figure 4.6: Result of Example 4.4

Points to note: ‚Ä¢	 The degree is one, that being the number of attributes specified in the projection. ‚Ä¢	 Every StudentId value in the result is a StudentId value that appears in the operand ‚Ä¢	 No StudentId value appears more than once in the result, even though S1 appears twice in the operand. The body of a relation is a set and there is no sense in which the same element can appear more than once in a set. relation, IS_ENROLLED_ON (and no other StudentId value appears in the result).

100
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Definition of projection
Let s = r { a1, ‚Ä¶, an } = r {ALL BUT b1, ‚Ä¶, bm } where the sets { a1, ‚Ä¶, an } and { b1, ‚Ä¶, bm} are disjoint subsets of the heading of r, whose union contains every attribute of r. Then: ‚Ä¢	 ‚Ä¢	 The heading of s is the subset of the heading of r given by { a1, ‚Ä¶, an }. The body of s consists of each tuple that can be formed from a tuple of r by removing from it the attributes named b1, ‚Ä¶, bm.

Note that the cardinality of s can be less than that of r but cannot be more than that of r. Now look at Figure 4.7, showing the result of ( ( IS_CALLED RENAME { StudentId AS Sid1 } ) JOIN

( IS_CALLED RENAME { StudentId AS Sid2 } ) ) { ALL BUT Name }
Sid1 S1 S2 S2 S5 S5 S3 S4 Sid2 S1 S2 S5 S2 S5 S3 S4

Figure 4.7: A projection of the relation shown in Figure 4.5

As you can see, the figure shows pairs of student identifiers that identify pairs of students having the same name. Its predicate is ‚ÄúStudent Sid1 has the same name as student Sid2‚Äù. There is something I want to say about this predicate although it amounts to something of a digression at this point. Because it is true that every student has the same name as himself or herself, we say that the relation for this predicate is reflexive. Because it is also true that if student x has the same name as student y, then student y has the same name as student x, we say that the relation for this predicate is symmetric. In general, binary relations with attributes of the same type are said to be recursive. Clearly a relation that is reflexive must be recursive, for if x and y denote the same thing, they must be of the same type. A relation that is symmetric must also be recursive, for otherwise it would not be possible to interchange x and y (if x is a student id and y is a course id, for example).

101
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

How ENROLMENT was split Our current examples, IS_CALLED and IS_ENROLLED_ON, when joined yield the current value of values of IS_CALLED and IS_ENROLLED_ON from ENROLMENT‚Äîbut we can, by using projection, obtain the current value of IS_ENROLLED_ON, and we can obtain a subset of the current value of IS_CALLED (student S5 would be missing). ENROLMENT, as we have already seen. Now, we cannot exactly reverse that process‚Äîobtain the current

Suppose we have only ENROLMENT, but we suddenly realize that we need to record the names of students, such as student S5, who aren‚Äôt yet enrolled on any courses. We decide to address that problem by using the two relvars, IS_CALLED and IS_ENROLLED_ON, in place of ENROLMENT. Example 4.5 shows

one way of achieving that redesign in Tutorial D, using projection and a certain useful shortcut you can use in relvar declarations. (You may wish to return to Chapter 2, Section 2.11, to refresh your memory on relvar declarations in Tutorial D.) Example 4.5: Splitting ENROLMENT VAR IS_CALLED BASE

INIT (ENROLMENT { StudentId, Name }) KEY { StudentId } ;

VAR IS_ENROLLED_ON BASE

INIT (ENROLMENT { StudentId, CourseId }) KEY { StudentId, CourseId } ; DROP VAR ENROLMENT ; Explanation 4.5: ‚Ä¢	 VAR IS_CALLED BASE announces that what follows defines a database relvar named ‚Ä¢	 INIT (ENROLMENT { StudentId, Name }) specifies that the variable is to IS_CALLED.

be immediately assigned the result of projecting the current value of ENROLMENT over

ENROLMENT { StudentId, Name }, is the declared type of the variable. This is the ‚Ä¢	 KEY { StudentId } specifies a constraint to the effect that no two distinct tuples useful shortcut I mentioned‚Äîwhen INIT is used there is no need to spell out the type.

StudentId and Name. It also implies that the declared type of the specified expression,

having the same StudentId value can ever appear simultaneously in IS_CALLED. (In implicitly specified by INIT.)

Tutorial D the KEY specification must come after the type specification, including the type

102
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

‚Ä¢	 VAR IS_ENROLLED_ON up to the next semicolon is a similar relvar declaration for IS_ENROLLED_ON. The KEY specification, KEY { StudentId, CourseId }, specifies a constraint to the effect that no two distinct tuples having the same

StudentId value and the same CourseId value can ever appear simultaneously in

IS_ENROLLED_ON. It is superfluous, really, because those are the only two attributes and definition. However, Tutorial D requires at least one KEY specification to be included in a relvar declaration.

it is never possible for the same tuple to appear more than once in the body of a relation, by

‚Ä¢	 DROP VAR ENROLMENT destroys the variable we have no further use for. Of course, our revised database does not yet include any information about student S5, named Boris, but that information wasn‚Äôt present in ENROLMENT‚Äîand nor could it have been, until S5 became enrolled on something. Now, however, we can record S5‚Äôs name immediately, by adding the appropriate tuple to IS_CALLED.

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

103
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Two special cases of projection In Tutorial D syntax, wherever a commalist of items is required it is permissible for that list to be empty unless it is explicitly stated to the contrary. At the time of writing there are no exceptions; therefore the following two expressions must both be legal: r { ALL BUT } r{ }

where r denotes a relation. The first should come as no surprise‚Äîit obviously results in r itself‚Äîbut the second does surprise most students at first, for it appears to denote a relation with no attributes at all‚Äîa relation of degree zero. And indeed it does, and indeed there are such relations!‚Äîbut only two. The two relations have been given the pet names TABLE_DEE and TABLE_DUM and these names, which were proposed by the present author in a journal article published in 1988, are available in Tutorial D, which allows them to be abbreviated to just DEE and DUM. TABLE_DEE is a name for the relation RELATION { TUPLE { } }‚Äîthe relation of degree zero and

cardinality one. There is only one tuple of degree zero, so that has to be the only tuple of TABLE_DEE. have the same tuple appearing more than once in the body of a relation and that, as we have seen, cannot

Clearly there cannot be a relation of degree zero and cardinality greater than one, for then we would be. So TABLE_DUM must be the empty relation of degree zero: RELATION¬†{¬†}¬†{¬†} (the first { } specifies the empty heading, the second the empty body).

A predicate represented by a relation of degree zero is niladic (has no parameters). In other words, it must be a proposition, p. If TABLE_DEE represents p, then p is true; otherwise TABLE_DUM represents p and p is false. People often ask, ‚ÄúWhat purpose can relations of degree zero possibly serve? They seem to be of little or no value.‚Äù The answer is that they represent answers to queries of the form ‚ÄúIs it true that‚Ä¶?‚Äù or ‚ÄúAre there any‚Ä¶?‚Äù where the answer is just ‚Äúyes‚Äù or ‚Äúno‚Äù. For example, ‚ÄúIs it true that student S1 is enrolled on course C3?‚Äù, and ‚ÄúAre there any students enrolled on course C1?‚Äù Now that you have met TABLE_DEE I can show you one more interesting property of JOIN. If r is, as usual, a relation, what is the result of r JOIN TABLE_DEE? Even if an answer springs to mind your conclusion using Rel. immediately I suggest you work this out for yourself from the definition of JOIN‚Äîand perhaps verify

If a value i exists such that whenever i is one of the operands of a dyadic operator the result of invoking that operator is the other operand, then i is said to be an identity value under that operator. Think of the number 0 under addition, for example, and the number 1 under multiplication. TABLE_DEE is the identity value under JOIN.

104
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Now, consider an operator that is commutative and associative, as are numerical addition and relational JOIN. As we have seen, a language can support n-adic versions of such operators: we can take the sum of any number of numbers and we can take the join of any number of relations‚Äîeven just one or none at all. The sum of just one number is that number and the join of just one relation is that relation. The sum of no numbers is zero, because zero is the identity value under addition. The join of no relations is TABLE_DEE. So far I have shown you relational counterparts of AND and existential quantification. Eventually you to be suitable for certain common special cases of AND. The next operator addresses one of those cases and is called restriction. will see counterparts of OR and NOT too but we haven‚Äôt finished with AND yet, for JOIN turns out not

4.7	

Restriction and AND

its parameters:

Here is a predicate that we can derive from the predicate for IS_CALLED by substitution of one of

Student StudentId is called Boris. The relation representing that can be obtained quite easily using JOIN and projection, noting that the given predicate is equivalent to the more elaborate

There exists a name Name such that student StudentId is called Name and Name is Boris. Again the only parameter is StudentId, because Name is quantified. The relation is denoted by the expression shown in Example 4.6. Example 4.6: JOIN and projection ( IS_CALLED JOIN RELATION { TUPLE { Name NAME ( 'Boris' ) } } ) { StudentId }

Restriction, invoked using the key word WHERE, gives us an alternative and perhaps more intuitive formulation for the first line of Example 4.6, shown in Example 4.7. Example 4.7: Restriction ( IS_CALLED WHERE Name = NAME ( 'Boris' ) ) Here the word WHERE is preceded by a relational expression and followed by a condition,

Name¬†=¬†NAME¬†(¬†'Boris'¬†). Each tuple of the specified relation is tested to see if it satisfies the given condition. Those that do satisfy it, and only those tuples, appear in the result.

105
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Notice that the expression Name = NAME ( 'Boris' ) is not one that can be evaluated outside

of the context in which it appears. Its evaluation depends on the existence of a tuple to provide the value of the attribute Name. We shall refer to such expressions as open expressions. Unsurprisingly, we shall soon see that restriction isn‚Äôt the only context in which open expressions can appear. Of course the WHERE condition doesn‚Äôt have to be an open expression; but if it is closed, then its value is independent of the tuples of the operand relation and is therefore the same for each tuple. As a (the WHERE condition evaluates to TRUE) or empty (it evaluates to FALSE). Now, the reason why the example at hand can be formulated using JOIN instead of WHERE lies in the consequence, the result of a restriction whose condition is a closed expression is either the input relation refer to expressions that can be evaluated independently of their context as closed expressions. We shall

fact that the restriction condition is, very specifically, an ‚Äúequals‚Äù comparison of an attribute with a literal. The literal in question can be ‚Äúwrapped up‚Äù, so to speak, as a relation literal that can be used as an operand of JOIN. If the condition is less restrictive, the required relation literal might be far too large the letter ‚ÄúB‚Äù. Then we have to replace the relation literal in Example 4.6 by one that includes a tuple literal for every value of type NAME that begins with the letter ‚ÄúB‚Äù. That is out of the question. But, using the STARTS_WITH operator from Rel‚Äôs OperatorsChar.d (recall that we used this operator in the to be written down. Suppose, for example, that we wish to find all the students whose names begin with

definition of type SID in Chapter 2), the task becomes very easy using WHERE, as shown in Example 4.8. Example 4.8: A more useful restriction IS_CALLED WHERE STARTS_WITH(THE_C(Name), 'B') Definition of restriction
Let s = r WHERE c, where c is a possibly open truth-valued expression denoting a condition on attributes of r. Then: ‚Ä¢	 ‚Ä¢	 The heading of s is the heading of r. The body of s consists of those tuples of r for which the condition c evaluates to TRUE.

So the body of s is a subset of the body of r. Note that the result of r WHERE TRUE is r and that of c is a closed expression the result of r WHERE c is empty when c evaluates to FALSE and is otherwise equal to r. So closed expressions are rarely useful and in practice c is nearly always an open expression. r¬† WHERE¬†FALSE is the empty relation of the same type as r. In fact, whenever the specified condition

106
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Now let us return to Example 4.3, finding pairs of students who have the same name. It was annoying to find those tuples that pair students with themselves. Now we know how those can be eliminated: ( ( IS_CALLED RENAME { StudentId AS Sid1 } ) JOIN ( IS_CALLED RENAME { StudentId AS Sid2 } )

WHERE NOT (Sid1 = Sid2) ) { Sid1, Sid2 } which yields the relation shown in Figure 4.8.
Sid1 S2 S5 Sid2 S5 S2

Figure 4.8: An improvement on Figure 4.7

.

107
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

If we are still annoyed by seeing two different students paired together twice, we might be able to address that problem too, if a comparison operator such as ‚Äúless than‚Äù is available on values of type SID: ( ( IS_CALLED RENAME { StudentId AS Sid1 } ) JOIN ( IS_CALLED RENAME { StudentId AS Sid2 } )

WHERE Sid1 < Sid2 ) { Sid1, Sid2 }

Assuming that the value SID('S2') precedes SID('S5') in the ordering defined for values of type SID, this would yield the singleton relation shown in Figure 4.9.
Sid1 S2 Sid2 S5

Figure 4.9: A further improvement on Figure 4.7

Now please look again at Example 4.8. It involves computation of the first letter of every student‚Äôs name, for testing in the WHERE condition. Sometimes we wish to use such computations to obtain values that are to appear as attribute values in some relation. Suppose, for a rather unreal example, that we wish letters of their names. Then we will need our next operator, also related to AND, called extension (a slightly to obtain a relation showing not only the student identifier and name of each student, but also the first unfortunate name, perhaps‚Äînot to be confused with extensions of predicates as defined in Chapter 3!).

4.8	

Extension and AND

Consider, then, the predicate Student StudentId is called Name and Name begins with the letter Initial. We have AND connecting the predicate for IS_CALLED with ‚ÄúName begins with the letter Initial‚Äù. As

with Example 4.8, it is not feasible to write down a relational literal representing ‚ÄúName begins with the letter Initial‚Äù, so we cannot feasibly use JOIN. Here is a Tutorial D formulation using extension: EXTEND IS_CALLED : { Initial := FirstLetter ( Name ) } Here FirstLetter ( Name ) is an open expression‚Äîthe expression needs to be evaluated

against a tuple that provides an attribute value for Name. The expression is evaluated for each tuple t of of that open expression.

IS_CALLED, yielding the tuple formed by ‚Äúextending‚Äù t by the attribute Initial having the value

108
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

The result is the relation shown in Figure 4.10.
StudentId S1 S2 S3 S4 S5 Name Anne Boris Cindy Devinder Boris Initial A B C D B

Figure 4.10: An extension of IS_CALLED

The construct Initial := FirstLetter ( Name ) is called an ‚Äúextend addition‚Äù. In general, there can be any number of extend additions, including none at all (in which case the invocation returns its input relation). The extend additions are considered to be evaluated in order from left to right, so that a subsequent extend addition may use an open expression that refers to an attribute ‚Äúadded‚Äù by an earlier one. Definition of extension
Let s = EXTEND r : { a := exp } where relation r does not have an attribute named a and exp is a possibly open expression. Then: ‚Ä¢	 ‚Ä¢	 Let T be the declared type of exp and let Hr be the heading of r. The heading of s is Hr UNION { a T }. The body of s consists of tuples formed from those of r by adding the attribute a of type T with value exp.

EXTEND r : { a1 := exp-1, ‚Ä¶, an := exp-n }, where n ÔÇ¶ 0, is equivalent to EXTEND ( ‚Ä¶ ( EXTEND r : { a1 := exp-1 } ‚Ä¶ ) : { an := exp-n } )

Points to note: ‚Ä¢	 In the special case where the commalist of extend additions is empty, the input relation is ‚Ä¢	 If ai (0ÔÇüiÔÇün) is identical to the name of some attribute of r, then that attribute is effectively replaced (in which case ‚Äúextension‚Äù is something of a misnomer!). ‚Ä¢	 The cardinality of s is equal to the cardinality of r. The degree of s the degree of r plus one for each ai that is not identical to the name of some attribute of r. ‚Ä¢	 If a closed expression is used in an extend addition, then it will have the same value for each tuple of the input relation. returned. In other words, EXTEND r : { } = r.

109
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Now we have finished with AND and we can move to OR, where the corresponding relational operator is UNION.

4.9	

UNION and OR
JOIN IS_ENROLLED_ON gave us a relation

Recall that the relational expression IS_CALLED

representing the extension of the conjunctive predicate ‚ÄúStudent StudentId is called Name and is enrolled

on course CourseId‚Äù. Now consider the disjunctive predicate ‚ÄúStudent StudentId is called Name or is of AND. enrolled on course CourseId ‚Äù, the same as before except that the logical connective OR is used instead

Recall also that the truth table for AND (Figure 3.2) enabled us to determine which tuples, derived from

those of IS_CALLED and IS_ENROLLED_ON, satisfy that conjunctive predicate and thus constitute discover all the tuples that satisfy the disjunctive predicate.

the body of their join. Unfortunately, the truth table for OR (Figure 3.3) tells us that it‚Äôs not so easy to

Let‚Äôs think about the extension of ‚ÄúStudent StudentId is called Name or is enrolled on course CourseId ‚Äù. Here is a true instantiation that we can determine by examination of the current values of IS_CALLED and IS_ENROLLED on:

Student S1 is called Anne or is enrolled on course C1.

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

110
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

So TUPLE {StudentId SID('S1'), Name NAME('Anne'), CourseId CID('C1')} clearly appears in the body of the corresponding relation. But the following instantiations are also true: a)	 Student S1 is called Anne or is enrolled on course C3. b)	 Student S1 is called Jane or is enrolled on course C1. c)	 Student S1 is called Anne or is enrolled on course C4751. d)	 Student S1 is called Xdfrtghyuz or is enrolled on course C1. In case (a) the first disjunct, ‚ÄúStudent S1 is called Anne‚Äù, is true and the second is false. A similar remark applies to case (c), even though, as it happens, course C4751 doesn‚Äôt even exist‚Äîthe corresponding tuple appears in the relation because CID('C4751') does denote a value of type CID (and S1‚Äôs name is Anne). Cases (b) and (d) connect true statements about enrolments with false ones about names. In (d), though we can perhaps be 100% certain that nobody has ever been called Xdfrtghyuz, I am assuming that NAME('Xdfrtghyuz') is a value of type NAME (it would be difficult to define the type in such a way as to exclude such possibilities).

You can see, then, that the extension of the disjunctive predicate contains an inordinately large number of instantiations compared with the extension of the much more restrictive conjunctive predicate. In practical terms, the corresponding relation is too big, would take too much time to be computed, and in any case isn‚Äôt very useful. For those reasons, Codd deliberately excluded a general relational counterpart of OR from his relational algebra. However, noting that some disjunctive predicates do not suffer from this problem, he did include a dyadic operator, UNION, to give relations representing just those special cases.

described does not arise‚Äîif p and q have exactly the same set of parameters and the relations for p and q are computable. His UNION operator, therefore, requires its relation operands to be of the same type (i.e., to have the same heading). Consider, then, the predicate Student StudentId is called Devinder OR student StudentId is enrolled on course C1. The two disjuncts both have just the one parameter, StudentId. The first disjunct is derived from the is derived from the predicate for IS_ENROLLED_ON by similarly binding the CourseId parameter. reason I have given, the expression given in Example 4.9 is legal. predicate for IS_CALLED by substituting a value for the Name parameter (thus binding it); the second Although the expression IS_CALLED UNION IS_ENROLLED_ON is illegal in Tutorial D, for the

Codd noted that the relation for a predicate of the form p OR q is computable‚Äîthe problem just

111
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Example 4.9: A legal invocation of UNION ( IS_CALLED WHERE Name = NAME ('Devinder') ) { StudentId } UNION ( IS_ENROLLED_ON WHERE CourseId = CID ('C1') ) { StudentId } The binding of Name is achieved in two steps. First we use restriction (WHERE) to restrict it to exactly

one value by equals comparison; then we ‚Äúproject it away‚Äù. We dispose of CourseId in similar fashion. The resulting relation is shown in Figure 4.11. You can verify it for yourself by checking whether each of the students S1, S2 and S4 is either called Devinder or enrolled on course C1.
StudentId S1 S2 S4
Figure 4.11: Result of Example 4.9

Definition of UNION
Let s = r1 UNION r2 where r1 and r2 are relations of the same type. Then: ‚Ä¢	 ‚Ä¢	 The heading of s is the common heading of r1 and r2. The body of s consists of each tuple that is either a tuple of r1 or a tuple of r2.

Points to note: ‚Ä¢	 The cardinality of s is no less than the cardinality of the larger operand and no greater than the sum of the operand cardinalities. So, assuming the operands are computable, the result must be computable. ‚Ä¢	 Also like JOIN, UNION is associative. It is no mere coincidence that OR is also associative. Because UNION is associative, we can define an n-adic version: where UNION { r } = r. UNION { r1, r2, ‚Ä¶ } ‚Ä¢	 Like JOIN, UNION is commutative. It is no mere coincidence that OR is also commutative.

‚Ä¢	 Also like JOIN, UNION is idempotent: r UNION r = r.

112
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

‚Ä¢	 Unlike JOIN, UNION does not have a single identity value. The normal set-theory union

operator does have an identity value, namely, the empty set. But relations have headings and there is no single heading that can be the heading of a relation that, when unioned with any relation r, yields r. However, we can note that if re is the empty relation of the same type as r, then r UNION re = r. For that reason, Tutorial D, for what it‚Äôs worth, does allow you to For example: UNION { x CHAR, y INTEGER, z SID } { } If the key word UNION is replaced by RELATION, that would yield the same result of course. take the union of no relations at all, so long as you specify the heading of the desired result.

Now you may well ask, what is the point of being able to take the union of no relations? Well, experience shows that it is a mistake in a computer language to legislate against support for empty operands when the operation in question has a mathematically respectable definition. Sometimes scripts in a desired language are generated for us by special-purpose software; legislating against something that is definable but apparently pointless sometimes turns out to be inconvenient for the developers of the generating software. I know of several cases in SQL, for example, where that kind of concern has arisen. In particular, unions and joins with no operands. standard SQL has no counterparts of TABLE_DEE and TABLE_DUM, nor does it allow one to express

There remains one logical operator that I have not given you a relational counterpart of yet: negation. We shall see that, as with OR, we have to restrict ourselves to certain special cases involving negation, and these cases are addressed by a dyadic operator that goes by the strange name semidifference.

4.10	

Semidifference and NOT

run into the same problem as that one we encountered with disjunction, for its extension includes instantiations such as ‚ÄúStudent S1 is not called Jane‚Äù, ‚ÄúStudent S97431 is not called Anne‚Äù, ‚ÄúStudent S1 is not called Xdfrtghyuz‚Äù, and so on, ad infinitum (‚Äúalmost‚Äù!). The term unsafe is sometimes used in connection with predicates such as these, where the corresponding relation is likely to be of such inordinately high cardinality as to be not computable in practice. It is no coincidence that both negation and disjunction are unsafe in general: recall that pÔÄ≠q is equivalent to ¬¨(¬¨pÔÄÆ¬¨q). So, when exactly can we ‚Äúsafely‚Äù use negation? Here is one example: StudentId is called Devinder AND StudentId is NOT enrolled on C1.

Consider the negation of the predicate for IS_CALLED: ‚ÄúStudent StudentId is NOT called Name.‚Äù We

113
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

Here we use AND to connect two predicates that have the same parameter‚Äîthe same restriction as the one we needed for disjunction. In this case, though, the second is negated. In Tutorial D we can obtain the relation representing this predicate by using an operator named MINUS, as shown in Example 4.10. MINUS is a relational counterpart of set difference and is subject to exactly the same restriction as UNION concerning the types of its operands.

Example 4.10: A legal invocation of MINUS ( IS_CALLED WHERE Name = NAME ('Devinder') ) { StudentId } MINUS ( IS_ENROLLED_ON WHERE CourseId = CID ('C1') ) { StudentId } In general r1 MINUS r2 returns the relation whose heading is that of both operands and whose body consists of those tuples of r1 that do not appear in the body of r2. MINUS was the operator proposed actually need that restriction on the operand types, if we base the operator on the concept of matching tuples, as we did with JOIN, instead of basing it on identical tuples in particular. Consider the predicate Student StudentId is called Name and StudentId is not enrolled on any course. by Codd for dealing with negation, but it turned out that we can do better than that. In fact, we don‚Äôt

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

114
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

The first conjunct is the predicate for IS_CALLED. The second is clearly derivable from the predicate for IS_ENROLLED_ON but we should write it a little more formally to see how it is derived:

There does not exist a course CourseId such that student StudentId is enrolled on CourseId. We can discover whether a given StudentId value satisfies this monadic predicate by looking to see if there is a tuple with that StudentId value in the current value of IS_ENROLLED_ON. That means that for each tuple in the current value of IS_CALLED we can test to see if the student referred to is enrolled taking the difference between certain projections to satisfy the requirement of MINUS for operands of on anything by looking to see if that tuple has a matching tuple in IS_ENROLLED_ON. Instead of the same type, we can take the semidifference between IS_CALLED and IS_ENROLLED_ON (in that

Example 4.11.

order). Tutorial D uses the more intuitive name NOT MATCHING for this operator, as illustrated in

Example 4.11: Semidifference (students not on any courses) IS_CALLED NOT MATCHING IS_ENROLLED_ON Figure 4.12 shows the result of Example 4.11.
StudentId S5 Name Boris

Figure 4.12: Result of Example 4.11

Definition of NOT MATCHING
Let s = r1 NOT MATCHING r2 where r1 and r2 are relations such that r1 JOIN r2 is defined. Then: ‚Ä¢	 ‚Ä¢	 The heading of s is the heading of r1. The body of s consists of each tuple of r1 that has no matching tuple in r2.

Points to note: ‚Ä¢	 The body of the result is, as with restriction, a subset of that of the first operand. It follows that if r1 is empty, then so is s. ‚Ä¢	 If r1 and r2 have no common attributes, then s is equal to r1 in the case where r2 is empty and is otherwise empty (note that tuples having no common attributes are matching tuples under the definition of that term given in Chapter 4, Section 4.4 JOIN and AND). ‚Ä¢	 Where r1 MINUS r2 is defined, it is equivalent to r1 NOT MATCHING r2. So we can clearly dispense with MINUS without sacrificing completeness. As an exercise, you might like to also does not thereby sacrifice completeness.
115
Download free eBooks at bookboon.com

check whether an algebra that, like Codd‚Äôs, includes MINUS instead of NOT MATCHING

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

It‚Äôs a natural question to ask whether MATCHING is also supported. In fact it is, but because its inclusion in the language is not essential for relational completeness I defer discussion of it to the next chapter. have at least one matching tuple in r2. In a nutshell, r1 MATCHING r2 yields the relation whose body consists of just those tuples of r1 that

4.11	

Concluding Remarks

I have described the following relational operators: ‚Ä¢	 JOIN

‚Ä¢	 RENAME

‚Ä¢	 projection ‚Ä¢	 restriction (WHERE) ‚Ä¢	 EXTEND ‚Ä¢	 UNION

‚Ä¢	 semidifference (NOT MATCHING) I have claimed that these meet the criterion for completeness of a relational algebra for computational purposes. I justify this claim by showing that they include relational counterparts of logical AND, OR, NOT, and existential quantification, with agreed limitations on OR and NOT in the interests of ‚Äúsafety‚Äù. I have left slightly open the question of whether the chosen set is necessary for completeness, as well as being sufficient for it. Let me address that point now. Why do we have three different counterparts of AND? Well, it is true that if our purpose were mathematical only we could use JOIN for restrictions and extensions too, but that would entail the use of operand relations representing operators like ‚Äú<‚Äù and ‚Äú+‚Äù, and these tend to be as inordinately large as those that prohibit us from having unrestricted relational counterparts for disjunction and negation. For consider, the relation for ‚Äú<‚Äù of integers includes a tuple for every pair <a,b> of integers such that a<b is true, and the relation for plus includes a tuple for every triple <a,b,c> such that a+b=c is true. Restriction and extension allow us to use invocations of operators in open expressions. That said, there is actually one operator in my list that could be dispensed with without sacrificing completeness‚Äîone whose definition I could have given in terms of others in my list. I leave it as an exercise for the reader to discover which one that is and write a definition for it using the other operators. In any case, the inclusion of this superfluous operator‚Äîand we do have good reason to include it‚Äîreminds us all that we don‚Äôt always want an algebra to be pared to the theoretical minimum in terms of its number of operators. In propositional logic, for example, the psychological reasons for including both AND and overwhelming. OR, even though either can be defined in terms of the other along with NOT, are, most would agree, I have laid the foundation. In the next chapter I build on that foundation.

116
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

EXERCISES
1.	 Recall that r1 TIMES r2 requires r1 and r2 to have no common attributes, in which case it is of JOIN in such cases? equivalent to r1 JOIN r2. Why would it be a bad idea to require TIMES to be used in place

2.	 Given the following relvars: VAR Cust BASE RELATION {C# CHAR, Discount RATIONAL} KEY {C#}; VAR OrderItem BASE RELATION {O# CHAR, P# CHAR, Qty INTEGER } VAR Product BASE RELATION {P# CHAR, Unit_price RATIONAL} The price of an order item can be calculated by the formula: Write down a relation expression to yield a relation with attributes O#, P#, and PRICE, giving the price of each order item. 3.	 Given: VAR Exam_Marks BASE RELATION { StudentId SID, CourseId CID, Mark INTEGER} CAST_AS_RATIONAL(Qty)*Unit_price*(1.0-(Discount/100.0)) KEY {P#}; KEY {O#, P#}; VAR Orders BASE RELATION {O# CHAR, C# CHAR, Date DATE} KEY {O#};

KEY { StudentId, CourseId }; Write down a relational expression to give, for each pair of students sitting the same exam, the absolute value of the difference between their marks. Assume you can write ABS‚Ää‚Ää‚Ää(x) to obtain the absolute value of x. 4.	 State the value of a)	 r NOT MATCHING TABLE_DEE c)	 r NOT MATCHING r b)	 r NOT MATCHING TABLE_DUM d)	 (r NOT MATCHING r ) NOT MATCHING r e)	 r NOT MATCHING (r NOT MATCHING r) Is NOT MATCHING associative? Is it commutative?

5.	 (Repeated from the body of the chapter) Which operator, in the list given in Section 4.11, Concluding Remarks, can be dispensed with without sacrificing relational completeness? How can it be defined in terms of the other operators?

117
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

6.	 (Repeated from the body of the chapter) Investigate the completeness of an algebra that includes MINUS in place of NOT MATCHING by attempting to define NOT MATCHING in terms of MINUS and the other operators.

7.	 The chapter briefly mentions the operator MATCHING but defers its detailed description to Chapter 5. Before you read that chapter, define r1 MATCHING r2 in terms of the operators described in Chapter 4.

Working with a Database in Rel 1.	 Start up Rel. 2.	 Figure 4.13 shows the supplier-and-parts database from Chris Date‚Äôs Introduction to Database Systems (8th edition), as shown on the inside back cover of that book (except that the attribute names there are in upper case).
≈ï≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ò ≈í≈à≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈â≈à≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈â≈í ≈í6≈á6≈á6QDPH≈á6WDWXV≈á&LW\≈á63≈á6≈á3≈á4W\≈á≈í ≈í≈å≈ë≈ë≈ë≈ë≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ç≈å≈ë≈ë≈ë≈ë≈ê≈ë≈ë≈ë≈ë≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈ç≈í ≈í≈á6≈á6PLWK≈á≈á/RQGRQ≈á≈á6≈á3≈á≈á≈í ≈í≈á6≈á-RQHV≈á≈á3DULV≈á≈á6≈á3≈á≈á≈í ≈í≈á6≈á%ODNH≈á≈á3DULV≈á≈á6≈á3≈á≈á≈í ≈í≈á6≈á&ODUN≈á≈á/RQGRQ≈á≈á6≈á3≈á≈á≈í ≈í≈á6≈á$GDPV≈á≈á$WKHQV≈á≈á6≈á3≈á≈á≈í ≈í≈ä≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ã≈á6≈á3≈á≈á≈í ≈í≈á6≈á3≈á≈á≈í ≈í≈à≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈é≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈â≈á6≈á3≈á≈á≈í ≈í3≈á3≈á3QDPH≈á&RORU≈á:HLJKW≈á&LW\≈á≈á6≈á3≈á≈á≈í ≈í≈å≈ë≈ë≈ë≈ë≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ê≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ç≈á6≈á3≈á≈á≈í ≈í≈á3≈á1XW≈á5HG≈á≈á/RQGRQ≈á≈á6≈á3≈á≈á≈í ≈í≈á3≈á%ROW≈á*UHHQ≈á≈á3DULV≈á≈á6≈á3≈á≈á≈í ≈í≈á3≈á6FUHZ≈á%OXH≈á≈á2VOR≈á≈ä≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈ã≈í ≈í≈á3≈á6FUHZ≈á5HG≈á≈á/RQGRQ≈á≈í ≈í≈á3≈á&DP≈á%OXH≈á≈á3DULV≈á≈í ≈í≈á3≈á&RJ≈á5HG≈á≈á/RQGRQ≈á≈í ≈í≈ä≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈è≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈Ü≈ã≈í ≈õ≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈ë≈û
Figure 4.13: The suppliers-and-parts database

type for STATUS and QTY, RATIONAL for WEIGHT, and CHAR for all the other attributes. but do not otherwise change any of the given names.

Execute a Tutorial D VAR statement for each of S, P and SP. Use INTEGER as the declared Feel free to use lower case or mixed case to suit your own taste for attribute and relvar names,

Tutorial D requires at least one key constraint to be specified for each relvar. One key for each for S, are needed.

P and SP is shown by underlining the relevant attribute names in the table. No other key constraints

118
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

‚ÄúPopulate‚Äù (as they say) each relvar with the values shown in Date‚Äôs tables. There are several ways of achieving this. Choose whichever you prefer from the following: a)	 Include an INIT ( ... ) specification in the VAR statement, after the heading

and before the KEY specification. Inside the parens, write a RELATION { ... } used in the Rel exercises for Chapter 2.

expression, using a TUPLE expression for each required tuple, as in the enrolment literal b)	 Execute the VAR statement without an INIT ( ... ) specification. The implied

initial value is the empty relation of the appropriate type. You can see this by asking Rel

for the current value of the relvar. For example, to get the current value of S, just type S into the lower pane and click Run (F5). Now use an assignment statement of the form varname := relation-expression to populate the relvar. Check that Rel has indeed assigned the correct value to it. c)	 Use Rel INSERT statements to populate the relvar piecemeal, perhaps one tuple at INSERT statement to insert a single tuple: a time. Having typed in the first INSERT statement. Here is the general form of an INSERT varname RELATION { TUPLE { ... } } ;

Note that the source operand is still a relation, not just a tuple, hence the need to enclose the TUPLE expression inside RELATION { }. 3.	 Informally, we refer to S as suppliers, P as parts and SP as shipments. Predicates for these relvars are: S: Supplier S# is named Sname, has status Status and is located in city City.

P: Part P# is named Pname, is coloured Color, weighs Weight and is located in city City. SP: Supplier S# ships part P# in quantities of Qty. What, then, is the predicate for the expression S JOIN SP JOIN P? What do you expect to be the result of that expression? What is its degree? Does Rel give the result you expected? Explain what you see. 4.	 Attempt to insert a tuple into SP with supplier number S1, part number P1 and quantity 100. Explain the result of your attempt. 5.	 Get Rel to evaluate each of the following expressions. For each one, write down the corresponding predicate and also give an informal interpretation of the query in the style of those given in Exercise 6 below. a)	 SP WHERE P# = 'P2' c)	 SP { S#, Qty } b)	 S { ALL BUT Status } d)	 P NOT MATCHING ( SP WHERE S# = 'S2' ) e)	 S MATCHING ( SP WHERE P# = 'P2' )

119
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Relational Algebra‚Äî
The Foundation

f)	 S { City } UNION P { City } g)	 S { City } MINUS P { City } h)	 ( ( S RENAME { City AS SC } ) { SC } ) JOIN ( ( P RENAME { City AS PC } ) { PC } )

6.	 Write Tutorial D expressions for the following queries and get Rel to evaluate them: a)	 Get all shipments. b)	 Get supplier numbers for suppliers who supply part P1. c)	 Get suppliers with status in the range 15 to 25 inclusive. d)	 Get part numbers for parts supplied by a supplier in Paris. e)	 Get part numbers for parts not supplied by any supplier in Paris. f)	 Get city names for cities in which at least two suppliers are located. g)	 Get all pairs of part numbers such that some supplier supplies both of the indicated parts. h)	 Get supplier numbers for suppliers with a status lower than that of supplier S1. i)	 Get supplier-number/part-number pairs such that the indicated supplier does not supply the indicated part.

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

120
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

5	 Building on The Foundation
5.1	 Introduction
The relational operators described in Chapter 4 constitute a relationally complete set; but for practical purposes we need more. This chapter describes additional operators, defined for Tutorial D, which have been suggested as desirable by various people over the years. The additional relational operators are all defined in terms of those defined in Chapter 4. The relvars IS_CALLED and IS_ENROLLED_ON have been sufficient for illustrative purposes so far but now we need to extend our example database slightly, as shown in Figure 5.1.
COURSE CourseId C1 C2 C3 C4 EXAM_MARK StudentId S1 S1 S1 S2 S3 S4 CourseId C1 C2 C3 C1 C3 C1 Mark 85 49 85 49 66 93 Title Database HCI Op systems Programming

Figure 5.1: Current values of relvars COURSE and EXAM_MARK

(We assume that the relvar IS_ENROLLED_ON now includes a tuple for student S1 on course C3.) The predicate for COURSE is ‚ÄúCourse CourseId is entitled Title.‚Äù The predicate for EXAM_MARK is ‚ÄúStudent StudentId sat the exam for course CourseId and scored Mark marks for that exam.‚Äù The Tutorial D definitions for these relvars are VAR COURSE BASE RELATION { CourseId CID, Title CHAR } VAR EXAM_MARK BASE RELATION { StudentId SID, CourseId CID, KEY { StudentId, CourseId };
121
Download free eBooks at bookboon.com

KEY { CourseId };

Mark INTEGER }

An Introduction to Relational Database Theory

Building on The Foundation

We start with a couple of simple operators, based on ones already described in Chapter 4, that provide convenient shorthands (so called because what they express can be expressed more laboriously, and perhaps less clearly, without the use of the additional relational operators).

5.2	

Semijoin and Composition

Consider the predicate, ‚ÄúAt least one student sat the exam for Course CourseId, entitled Title‚Äù‚Äîmore precisely: ‚ÄúThere exist a student StudentId and a mark Mark such that StudentId sat the exam and scored Mark marks for course CourseId and CourseId is entitled Title.‚Äù The relation currently representing this predicate can be derived from the join of COURSE and

EXAM_MARK by ‚Äúprojecting away‚Äù the attributes corresponding to those quantified parameters, StudentId and Mark:

( COURSE JOIN EXAM_MARK ) { ALL BUT StudentId, Mark } or, equivalently, COURSE JOIN ( EXAM_MARK { ALL BUT StudentId, Mark } ) In either case the JOIN is indicated for us by the ‚Äúand‚Äù in the expanded version of the predicate and

the projection is indicated by the quantification. However, looking at the short form of the predicate we one matching tuple in EXAM_MARK. Now we may recall from Chapter 4 that we can find all the tuples of COURSE that do not have a matching tuple in EXAM_MARK by using semidifference: COURSE NOT MATCHING EXAM_MARK and I indicated briefly that Tutorial D also allows you to omit the word NOT, with the obvious effect: COURSE MATCHING EXAM_MARK MATCHING, without the NOT, is Tutorial D‚Äôs operator name for semijoin, so called because a semijoin the attributes of the first operand (by excluding the non-common attributes of the second). That result is shown in Figure 5.2. It contains every tuple of COURSE apart from the tuple for course C4, whose exam no student sat.
CourseId C1 C2 C3 Title Database HCI Op systems

may more intuitively think of its relation as consisting of just those tuples of COURSE that have at least

can be perceived, very loosely, as being ‚Äúhalf a join‚Äù. We join two relations but in the result retain only

Figure 5.2: COURSE MATCHING EXAM_MARK

122
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Now, perhaps, you can see why somebody once chose ‚Äúsemidifference‚Äù for the operator of that name, even though it can hardly be characterized as ‚Äúhalf a difference‚Äù: the name ‚Äúsemijoin‚Äù had already entered the jargon. (No, there isn‚Äôt a semiunion!) Definition of MATCHING
r1 MATCHING r2, where r1 and r2 are relations such that r1 JOIN r2 is defined, is equivalent to ( r1 JOIN r2 ) { r1-attrs } where r1-attrs is a commalist containing all and only the attribute names of r1.

Points to note (compare with those given for NOT MATCHING in Chapter 4): ‚Ä¢	 Recall that JOIN is not defined for all pairs of relations. If r1 and r2 have attributes of the MATCHING and several other dyadic operators. that if r1 is empty, then so is the result. ‚Ä¢	 If r1 and r2 have no common attributes, then the result is empty in the case where r2 is empty and is otherwise equal to r1 (recall that tuples having no common attributes are considered to be matching tuples). ‚Ä¢	 As the definition shows, semijoin is not needed as a primitive operator. As explained in Chapter 4, we could have chosen difference in place of semidifference as our primitive operator to support logical negation, but we preferred semidifference for its more general availability. Had we chosen difference instead, then our descriptions of NOT MATCHING and MATCHING could have appeared, neatly, side by side in the present chapter.

same name but different types, then r1 JOIN r2 is not defined. A similar proviso applies to

‚Ä¢	 The body of the result is, as with restriction, a subset of that of the first operand. It follows

There is another operator, advocated by some people as being useful enough to warrant its inclusion, that is based, like semijoin, on JOIN and projection. It is called composition. Consider the predicate ‚ÄúStudent StudentId scored Mark marks in the exam for a course entitled Title.‚Äù The corresponding relation must have attributes StudentId, Mark, and Title. The first two would clearly be derived from EXAM_MARK, the third from COURSE.

Notice the indefinite article in that predicate: ‚Äúa course‚Äù, not ‚Äúthe course‚Äù. Here we can replace the word ‚Äúa‚Äù by ‚Äúsome‚Äù without changing our meaning at all, indicating that existential quantification is lurking under the covers, so to speak, in our informal predicate. We can bring that quantification out into the open, as I did with the example I used for semijoin: ‚ÄúThere exists a course CourseId such that CourseId is entitled Title and student StudentId sat the exam for CourseId, scoring Mark marks.‚Äù

123
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

The relation representing this predicate can be derived from the join of COURSE and EXAM_MARK by ‚Äúprojecting away‚Äù CourseId (which happens to be the only common attribute):

( COURSE JOIN EXAM_MARK ) { ALL BUT CourseId } Composition gives us a shorthand that saves us from having to write that projection when its purpose is to exclude all and only the common attributes of the two operand relations. In Tutorial D, therefore, we can achieve the same effect more conveniently by COURSE COMPOSE EXAM_MARK The result is shown in Figure 5.3.
Title Database HCI Op systems Database Op systems Database StudentId S1 S1 S1 S2 S3 S4 Mark 85 49 85 49 66 93

Figure 5.3: COURSE COMPOSE EXAM_MARK

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

124
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

An Introduction to Relational Database Theory

Building on The Foundation

Definition of COMPOSE
r1 COMPOSE r2, where r1 and r2 are relations such that r1 JOIN r2 is defined, is equivalent to ( r1 JOIN r2 ) { ALL BUT common-attrs } where common-attrs is a commalist containing all and only the names of the attributes common to r1 and r2.

Points to note: ‚Ä¢	 r1 COMPOSE r2 is clearly equivalent to r1 JOIN r2 in the case where r1 and r2 have no common attributes. ‚Ä¢	 The case where r1 and r2 have identical headings is worth looking at. I invite the reader to study that case and find out what happens. ‚Ä¢	 Like JOIN, COMPOSE is commutative‚Äîthat‚Äôs clear, but is it also associative? Again, I leave that question as an exercise for the reader‚Äîcan you find an example where (r1 COMPOSE r2) COMPOSE r3 does not yield the same result as r1 COMPOSE (r2 COMPOSE r3)?

In case you are wondering if COMPOSE really is useful enough to be worth including in a computer motivation for its inclusion in Tutorial D was a desire to illustrate the extensibility of a well-designed language. Adding new operators increases a language‚Äôs complexity, to be sure, but that added complexity can be compensated for if the new operators are not only useful but can be easily defined and taught in terms of what the user already knows. The term composition as used here comes from mathematics, where it is used of functions. The explanation is not important for our purposes but I give it here for those that may be interested. A function is a special kind of binary relation, usually described as a mapping that connects each element of a set, known as the domain of the function, to exactly one element of another set (possibly the same set), known as the range of the function. Our relvar COURSE is in fact a function‚Äîor rather, its value at any point in time is a function‚Äîmapping each element of a certain set of course identifiers to exactly one element of a certain set of titles. Similarly, EXAM_MARK maps each element of a certain set of <student identifier, course identifier> pairs to exactly one element of a certain set of marks out of 100. EXAM_MARK also maps <student identifier, mark> pairs to course identifiers, but that mapping is not a function because it is possible for the same <student identifier, mark> pair to be connected to several distinct course identifiers, the pair <S1, 85> being a case in point.

language, and therefore to be worthy of inclusion in textbooks like this one, an important part of the

125
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

In mathematics, the composition of two functions f and g is defined in the case where the range of g is the domain of f. Thus, if g(x) denotes the element of g‚Äôs range to which its domain element x is connected, then f (g(x)) denotes the element of f ‚Äôs range to which the element g (x) (of f ‚Äôs domain) maps. The composition of f and g is thus a function whose domain is the domain of g and whose range is a subset of the range of f. The set that is the range of g and the domain of f in a sense ‚Äúdisappears‚Äù in the process of deriving the composition from the two participating functions. Well, just as a function is a special kind of relation, we can regard composition of functions as a special case of composition of relations. In COURSE COMPOSE EXAM_MARK we map <student identifier, mark> pairs to course titles via their mapping to course identifiers, losing those course identifiers in the process. (But note that the mapping here is many-to-many, not, as in functions, many-to-one.) Notice, by the way, that if two courses happened to have the same title, and a student who sat the exam for both of those courses scored the same mark in each case, then that fact would be represented by just one tuple in the result of COURSE COMPOSE EXAM_MARK. We cannot safely deduce from that result the total number of exams taken by students, unless course titles are unique as well as course mapping identifiers to functions. It seems that care needs to be taken over cases of relation composition that do not in fact represent function composition‚Äîone might easily misinterpret the result. identifiers‚Äîunless, that is, COURSE represents a function mapping titles to identifiers as well as one

AXA Global Graduate Program
Find out more and apply

126
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

Next, we look at a group of operators that, when invoked, operate on relations but do not return relations: aggregate operators. With these added to our ‚Äútool box‚Äù we can then proceed to define further useful shorthands.

5.3	

Aggregate Operators

An aggregate operator is one defined to operate on a relation and return a value obtained by aggregation over all the tuples of the operand. For example, simply to count the tuples in the body of EXAM_MARK (i.e., obtain its cardinality) we can invoke the aggregate operator COUNT, as shown in Example 5.1. Example 5.1: Counting the tuples in EXAM_MARK COUNT ( EXAM_MARK ) According to Figure 5.1, the result of COUNT ( EXAM_MARK ) is 6. The argument to an invocation of gives the number of students who have scored more than 50 in at least one exam. Example 5.2: Using relational operators with COUNT COUNT ( ( EXAM_MARK WHERE Mark > 50 ) {StudentId} ) Note the projection over StudentId. Without that, the expression would yield the (possibly higher) number of students‚Äô exam scripts scoring more than 50. Now take a look at Example 5.3. Example 5.3: Aggregate operator SUM SUM ( EXAM_MARK WHERE StudentId = SID ( 'S1' ), Mark ) Note the second operand, Mark, being the name of an attribute of the relation denoted by the first operand. Each tuple of the first operand provides a value for this attribute and the result of the invocation is the sum of those values. The result in this example is 219, the sum of the scores obtained by student S1. Note that both appearances of the score 85 in S1‚Äôs marks are counted. Example 5.4: MAX and MIN MAX ( EXAM_MARK WHERE StudentId = SID ( 'S1' ), Mark ) MIN ( EXAM_MARK WHERE StudentId = SID ( 'S1' ), Mark )

COUNT is a relation and so in Tutorial D can be denoted by any legal relational expression. Example 5.2

127
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Two more aggregate operators are illustrated in Example 5.4. MAX returns the highest value found for the specified attribute in the given relation and MIN returns the lowest. Points to note: ‚Ä¢	 Some aggregations can be thought of in terms of repeated invocation of some dyadic operator, which I shall call the basis operator. In the case of SUM, for example, the basis operator is addition. Because addition is commutative and associative, we could define an n-adic form of the operator, just as we did in Chapter 4 for operators such as JOIN and UNION. If we call this operator ADD, then we would have, for example, ADD(1,4,1,5)

= ((1+4)+1)+5. But those operands, 1, 4, 1, and 5, can be given in any order (thanks, to the ordering is what allows us to define aggregate operators for relations. The lack of

in this case, to the commutativity and associativity of +), and that lack of any significance an ordering to the tuples of a relation militates against defining aggregate operators whose results vary according to the order in which the operands are presented. Consider string concatenation, for example. We can concatenate any number of strings together to form a single string, but the result depends on the order in which the input strings are presented. ‚Ä¢	 The basis operators for MAX and MIN might reasonably be called HIGHER and LOWER, LOWER(x,y) returns x unless y<x, in which case it returns y. You can confirm for yourself respectively, where HIGHER(x,y) returns x unless y>x, in which case it returns y, and

‚Ä¢	 If the relation operand is empty, then the result of aggregation can be defined only if the basis operator has an identity value, defined thus: if a value i exists such that whenever i is one of the operands of a dyadic operator the result of invoking that operator is the other operand, then i is said to be an identity value under that operator. In the case of SUM, the basis operator is addition, whose identity value is zero. In the cases of MAX and MIN, the type of the result is the type of the attribute given as the second operand. The identity value of the basis operator depends on that type. If the type has a defined least value, min, such that min>v is FALSE for all values v of that type, then min is the identity under HIGHER. If empty relation is undefined for attributes of that type. Similarly, MIN(r,a) is defined only when a greatest value is defined for the type of attribute a. ‚Ä¢	 The examples shown use a simple attribute name as the second operand, and Version 1 of Tutorial D in fact requires that operand to be a simple attribute name. In general, however, the second operand in invocations of SUM, MAX, and MIN should be allowed to be any of Tutorial D does indeed allow this. expression of an appropriate type (obviously a numeric type in the case of SUM). Version 2 a least value is not defined, then there is no identity value under HIGHER, and MAX of the

that HIGHER and LOWER are commutative and associative.

128
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

‚Ä¢	 The simple attribute names used in my examples are cases of open expressions, as defined in Chapter 4, Section 4.7. As in other places where open expressions are permitted, closed equivalent to COUNT(r). expressions are also permitted‚Äîallowing us to sagely observe, for example, that SUM(r,1) is

Several other aggregate operators are defined in Tutorial D. Here are some that we can now deal with summarily: AVG ( r, x ) is equivalent to SUM ( r, x ) / COUNT ( r ) and is therefore undefined in the case where r is empty. As an exercise, the reader might like to consider whether there can be a basis operator for AVG.

129
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

AND ( r, c ) and OR ( r, c ), where c (a condition) is of type BOOLEAN, are named after their basis

operators‚Äîrecall that logical AND and OR are commutative and associative, with identity values TRUE for every tuple of r; and aggregate OR returns TRUE if and only if c evaluates to TRUE for some tuple of r. In some languages the names ALL and SOME (or ANY) are used in place

TRUE and FALSE, respectively. Thus, aggregate AND returns TRUE if and only if c evaluates to

Some people find it counterintuitive that aggregate AND on an empty relation returns TRUE as saying there does not exist a tuple in r for which c is FALSE.

of AND and OR. (Indeed, Rel allows ALL and ANY to be used as synonyms for AND and OR.)

but this is of course a logical necessity: to say that c is TRUE for every tuple in r is the same

Now, suppose we want to find out how many students sat each exam. Do we have to go to the lengths illustrated in Example 5.5? I have used Rel‚Äôs explicit OUTPUT statements in that example to emphasise large number of courses to consider, impossible if we didn‚Äôt even know all the course ids. Example 5.5: Number of students who sat each exam OUTPUT COUNT ( EXAM_MARK WHERE CourseId = CID ( 'C1' ) ); OUTPUT COUNT ( EXAM_MARK WHERE CourseId = CID ( 'C2' ) ); OUTPUT COUNT ( EXAM_MARK WHERE CourseId = CID ( 'C3' ) ); OUTPUT COUNT ( EXAM_MARK WHERE CourseId = CID ( 'C4' ) ); Shouldn‚Äôt we be able to use just a single query to obtain the desired result, which is shown in Figure 5.4? After all, I have claimed that the operators described in Chapter 4 make Tutorial D relationally complete, so we should, if we support counting at all, be able to obtain the relation representing the predicate, ‚Äún students sat the exam for course CourseId ‚Äù.
CourseId C1 C2 C3 C4 n 3 1 2 0

that it involves four distinct queries, one for each course. That would be very tiresome if we had a very

Figure 5.4: How many sat each exam

The answer is that we can indeed obtain that relation using a single query and the next section starts to show you the way.

130
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

5.4	

Relations within a Relation

Have a look at Figure 5.5. The figure itself is a two-column table, with a two-column table appearing in every cell of its second column {‚Äúsecond‚Äù because columns of tables do necessarily appear in some order, unlike attributes of relations}. The table depicts a relation‚Äîlet‚Äôs call it C_ER‚Äîwhose attribute INTEGER }. named ExamResult is of a certain relation type, namely, RELATION { StudentId SID, Mark
&RXUVH,G &RXUVH,G &RXUVH,G & & & ([DP5HVXOW ([DP5HVXOW ([DP5HVXOW 6WXGHQW,G 6WXGHQW,G 6WXGHQW,G 6 6 6 6 6 6 6 6 6
  

0DUN 0DUN 0DUN          0DUN 0DUN 0DUN   

& & &

6WXGHQW,G 6WXGHQW,G 6WXGHQW,G 6 6 6
 

& & &



  6WXGHQW,G 6WXGHQW,G 6WXGHQW,G  6 6 6
 



 0DUN 0DUN 0DUN     

& & &



6WXGHQW,G 6WXGHQW,G 6WXGHQW,G

0DUN 0DUN 0DUN

Figure 5.5: Relations within a relation

Perhaps you have already noticed that the information represented by the table in Figure 5.5 is exactly the same as that represented by the tables in Figure 5.1, but in a different form. That being the case, we should be able to use relational operators to derive the relation C_ER from the current values of COURSE and EXAM_MARK. In fact it can be done using operators I have already described, as shown in Example 5.6. Example 5.6: Obtaining C_ER from COURSE and EXAM_MARK EXTEND COURSE{CourseId} :

{ ExamResult := RELATION { TUPLE { CourseId CourseId } } COMPOSE EXAM_MARK }

131
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Explanation 5.6 ‚Ä¢	 The open expression on which the attribute ExamResult is defined denotes a relation, so ‚Ä¢	 TUPLE { CourseId CourseId } is an open expression, evaluated for each tuple in turn of the relation denoted by COURSE{CourseId}. It denotes the tuple of degree 1 the value of whose only attribute, CourseId, is the value of the attribute of that name appearances of CourseId, recall that each component of a TUPLE expression is an attribute name followed by an expression denoting the value for that attribute. body consists of just that tuple. the declared type of ExamResult is a relation type.

in the current tuple of COURSE{CourseId}. In case you are puzzled by the consecutive

‚Ä¢	 RELATION { TUPLE { CourseId CourseId } } denotes the relation whose ‚Ä¢	 RELATION { TUPLE { CourseId CourseId } } COMPOSE EXAM_MARK the tuples of EXAM_MARK that match TUPLE { CourseId CourseId }. Recall that r1 COMPOSE r2 denotes the join of r1 and r2 projected over all but the common attributes‚Äîhere there is a single common attribute, CourseId. denotes the relation whose body consists of projections over StudentId and Mark of

‚Ä¢	 The value for the attribute ExamResult in the tuple for a given CourseId value ci,

considering the method by which it is derived, is referred to as the image relation within the relation EXAM_MARK for the tuple TUPLE { CourseId ci }. In general, if t is a tuple and r is a relation, the image relation (or just image) of t in r is given by (RELATION { t }){ca} COMPOSE r where ca is the common attributes‚Äîattributes of t that are also attributes of r.

relations, being ‚Äúrelations within a relation‚Äù, so to speak. Because those attribute values are relations, we can use aggregate operators on them. With that hint you should now be able to see how to obtain the result shown in Figure 5.4‚Äîhow many students sat each exam.

The values for attribute ExamResult in C_ER have sometimes been referred to informally as nested

132
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

5.5	

Using Aggregate Operators with Nested Relations

Example 5.7 uses the aggregate operator COUNT on the relation values for attribute ExamResult to obtain the number of students who sat each exam.

Example 5.7: How many students sat each exam WITH ( EXTEND COURSE{CourseId} :

{ ExamResult := RELATION { TUPLE { CourseId CourseId } } AS C_ER ) : COMPOSE EXAM_MARK }

EXTEND C_ER : { n := COUNT ( ExamResult ) } To avoid an indigestible surfeit of parentheses we use WITH to define the name C_ER I have been using projection to eliminate the nested relations we no longer need. Similarly, we could obtain the total marks for each exam by including an extend addition such as TotalMarks := SUM(ExamResult, Mark), but if we need the average mark for each exam we will have to avoid zero-divides by excluding { ALL BUT ExamResult }

in the text. Then we use extension to obtain the student counts as values for attribute n, followed by

those which no students sat. We can do that by homing in on just those CourseId values that appear in

EXAM_MARK, as shown in Example 5.8, the significant difference from Example 5.7 being shown in bold. Example 5.8: Average mark per exam WITH

( C_ER2 :=

{ ExamResult := RELATION { TUPLE { CourseId CourseId } } EXTEND C_ER2 : COMPOSE EXAM_MARK } ) :

EXTEND EXAM_MARK{CourseId} :

{ ALL BUT ExamResult }

{ AvgMark := AVG(ExamResult, Mark) }

133
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Now, the expressions in Examples 5.7 and 5.8 are somewhat cumbersome and have much in common. They both use composition within extension to operate in a join-like fashion on two relations to produce a relation with a relation-valued attribute, ExamResult; and they both use extension on that relation to obtain results of aggregation on the nested relations, followed by projection to eliminate those nested useful shorthands for expressions such as the ones in Examples 5.7 and 5.8. relations. This commonality is captured in the definition of an operator named SUMMARIZE, providing

5.6	SUMMARIZE
Example 5.9 uses SUMMARIZE to give the same result as Example 5.7. Example 5.9: How many students sat each exam, using SUMMARIZE SUMMARIZE EXAM_MARK PER ( COURSE { CourseId } ) : { n := COUNT ( ) } Explanation 5.9 ‚Ä¢	 EXAM_MARK PER ( COURSE { CourseId } ) effectively gives C_ER but without specifying the attribute name for the attribute whose values are the nested relations. The missing attribute name doesn‚Äôt matter because this intermediate result is never seen by a user. relation operand is implied‚Äîfor each tuple of the PER relation (viz., Course projected

‚Ä¢	 COUNT ( ) represents an invocation of the aggregate operator COUNT, where the

‚Ä¢	 n := COUNT ( ) is a summarize addition, similar to an extend addition except

over CourseId), it is the relation obtained as a value for ExamResult in Example 5.7. that the expression on the right-hand side of := must be one that entails aggregation, thus obtaining a single attribute value from the implied relation operand. Tutorial D allows a

‚Ä¢	 commalist of summarize additions to be specified. ‚Ä¢	 As usual, that commalist is permitted to be empty. If { } had been specified instead COURSE { CourseId }. of {¬†n := COUNT ( ) }, then the expression would have been equivalent to just

‚Ä¢	 SUMMARIZE ‚Ä¶ : { n := COUNT ( ) } extends the result of EXAM_MARK PER ( COURSE { CourseId } ) as in Example 5.7. The fact that the nested that attribute. ‚Ä¢	 In this example EXAM_MARK is the SUMMARIZE operand; COURSE { CourseId } is the PER relation. relations do not appear as values for an attribute obviates the need for projection to exclude

The expression COUNT¬†(¬†) (a kind of open expression) is called a summary. If we had wanted the

total mark for each exam we would use the summary SUM¬†(¬†mark¬†)‚Äîagain, the relation operand of of SUMMARIZE, as shown.

the aggregate operator of the same name is omitted. Summaries are permitted only within invocations

134
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

In Tutorial D SUMMARIZE comes in two varieties. The variety used in Example 5.9 is called SUMMARIZE PER.

Definition of SUMMARIZE PER
SUMMARIZE r1 PER ( r2 ) : { a1 := sum1, ‚Ä¶, an := sumn }, where: ‚Ä¢	 ‚Ä¢	 ‚Ä¢	 r1 and r2 are relations such that r1 JOIN r2 is defined, a1, ‚Ä¶, an are attribute names not used in the heading of r1, and sum1, ‚Ä¶, sumn are summaries

is equivalent to EXTEND r2 :{

a1 := xsum1, ‚Ä¶, an := xsumn }

where each of xsum1, ‚Ä¶, xsumn is an aggregate operator invocation such that: ‚Ä¢	 its relation operand is given by (RELATION { TUPLE { b1b1, ‚Ä¶, bm bm } } COMPOSE r1 }, where b1, ‚Ä¶, bm are the attributes of r2 the aggregate operator and the remaining operands, if any, are as specified in the corresponding summaries sum1, ‚Ä¶, sumn.

‚Ä¢	

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

135
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

We can also use SUMMARIZE PER to obtain the result of Example 5.8, the average mark for each appearing in EXAM_MARK.

exam, as shown in Example 5.10. As in Example 5.8, we must restrict ourselves to the CourseId values

Example 5.10: Average mark for each exam, using SUMMARIZE ‚Ä¶ PER ‚Ä¶ SUMMARIZE EXAM_MARK PER ( EXAM_MARK { CourseId } ) : { AvgMark := AVG ( mark ) }

Here the relation being summarized is the same as the relation providing the PER values. That is very commonly the case in practice, sufficiently so to perhaps warrant a further shorthand, and Tutorial D does in fact provide one in the form of SUMMARIZE ... BY ..., as illustrated in Example 5.11. Example 5.11: Average mark for each exam, using SUMMARIZE ‚Ä¶ BY ‚Ä¶ SUMMARIZE EXAM_MARK BY { CourseId } :

{ AvgMark := AVG ( mark ) }

In case the shorthands offered by SUMMARIZE ‚Ä¶ BY ‚Ä¶ hardly seem worth the addition to the

sure, writing it out twice is not much of a problem these days, thanks to copy-and-paste, but reading it twice and noticing the special case might be rather burdensome, both for human and computer (for

language, consider that the SUMMARIZE operand can be a relation expression of any complexity. To be

Example 5.10 is likely to take significantly longer than Example 5.11 to compute unless the DBMS can notice that the PER operand in 5.10 is a projection of the SUMMARIZE operand). Definition of SUMMARIZE ‚Ä¶ BY ‚Ä¶
SUMMARIZE r1 BY { b1, ‚Ä¶, bm } : { a1 := sum1, ‚Ä¶, an := sumn } where r1 is a relation and b1, ‚Ä¶, bm are names of attributes of r1, is equivalent to SUMMARIZE r1 PER ( r1 { b1, ‚Ä¶, bm } ) : { a1 := sum1, ‚Ä¶, an := sumn }

There remain just two more relational operators defined in Tutorial D. They both deal with nested relations and they come as a pair, GROUP and UNGROUP.

5.7	

GROUP and UNGROUP

Example 5.8 includes the following expression, yielding an intermediate result named C_ER2: EXTEND EXAM_MARK{CourseId}:

{ ExamResult := RELATION { TUPLE { CourseId CourseId } } COMPOSE EXAM_MARK }

136
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Figure 5.6 shows the result. It differs from the C_ER of Figure 5.5 only in the absence of a tuple for course C4, whose exam nobody sat.

&RXUVH,G


([DP5HVXOW

&

6WXGHQW,G 6 6 6


0DUN   

&

6WXGHQW,G 6

0DUN 



&

6WXGHQW,G 6

0DUN 

Figure 5.6: Intermediate result C_ER2 from Example 5.8

Tutorial D has a shorthand for the expression producing the relation shown in Figure 5.6. This shorthand uses a relational operator named GROUP and is illustrated in Example 5.12. Example 5.12: Use of GROUP EXAM_MARK GROUP { StudentId, Mark } AS ExamResult Loosely speaking, Example 5.12 ‚Äúgroups‚Äù the StudentId/Mark combinations for each CourseId that CourseId value replacing the now redundant attributes StudentId and Mark. Somewhat less

value, the result being a relation that becomes the value of the attribute ExamResult in the tuple for loosely, Example 5.12 pairs each CourseId value appearing in EXAM_MARK with its image relation in

a given tuple, not a given attribute value, in a given relation. Strictly speaking, then, for each CourseId with its image relation in EXAM_MARK.)

EXAM_MARK. (That is still a little loose, however. Recall that in general we speak of the image relation of

value appearing in EXAM_MARK we take the tuple t consisting of just that attribute value and extend t

The specification { StudentId, Mark } AS ExamResult is called a grouping.

137
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Notice that Example 5.12, using GROUP, mentions EXAM_MARK only once, whereas Example 5.8

mentions it twice. Notice also that the first step in Example 5.8 is a projection of EXAM_MARK over {CourseId}. That projection is implied in Example 5.12, CourseId being the only attribute of EXAM_MARK that is not mentioned in the grouping for ExamResult.

Now, recall that in Tutorial D, wherever a commalist of attribute names is required, as in projection for example, that commalist can be preceded by the key words ALL BUT to indicate the attributes of the Example 5.12: EXAM_MARK GROUP { ALL BUT CourseId } AS ExamResult In case you are at all familiar with SQL I should now draw your attention to the fact that SQL has a counterpart of the ALL BUT method of specifying a grouping. This is its GROUP BY clause. In SQL, Example 5.12 would be expressed as FROM EXAM_MARK GROUP BY CourseId operand relation that are not to appear in the result. The following expression is therefore equivalent to

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

138
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

but this is only a fragment and cannot appear as a complete expression. The complete expression in which the fragment appears cannot refer to the presumed column containing the nested tables because, as you can see, that column has no name. However, SQL does allow you to operate on those nested tables by aggregation, using constructs similar to those used for that purpose in invocations of Tutorial D‚Äôs SUMMARIZE operator. Definition of GROUP
r GROUP { al } AS g, where: ‚Ä¢	 ‚Ä¢	 r is a relation such that the projection r { al } is defined, and g is an attribute name not appearing in the heading of r { ALL BUT al }

is equivalent to

( EXTEND r : { g := RELATION { t } COMPOSE r } ) { ALL BUT al }

where t = TUPLE { a1 a1, ‚Ä¶, an an }, where a1, ‚Ä¶, an are the attributes of r¬† {¬† al¬† }. The inverse operator of GROUP is UNGROUP. Example 5.13 shows how to get back (so to speak) to EXAM_MARK, given C_ER2 as the relation depicted in Figure 5.6. Example 5.13: Use of UNGROUP C_ER2 UNGROUP ExamResult As you can see from Figures 5.4 and 5.1, ungrouping C_ER on ExamResult effectively replaces that tuple of C_ER2 by joining its CourseId value with each tuple in turn of the ExamResult value.

attribute by its own attributes, StudentId and Mark, the tuples of the result being obtained from each

In Example 5.13, the cardinality of the result is equal to the sum of the cardinalities of the ExamResult

relations. A similar observation applies if we replace the operand C_ER2 by the relation C_ER shown

in Figure 5.5, because the extra tuple for course C4 contributes no tuples to the ungrouping result. Exercise for the reader: Is it always the case that the cardinality of an ungrouping is equal to the sum of the cardinalities of the relations the operand relation is being ungrouped on?

139
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Definition of UNGROUP The definition of UNGROUP uses an aggregate operator, UNION, that is not mentioned in Section 5.3 because its second operand is required to be a relation typed attribute. Recall from that chapter that UNION is commutative and associative, allowing us to defined the n-adic version, UNION¬†{¬†r1,¬†‚Ä¶,¬†rn¬†}. The existence of that n-adic version allows us to define a corresponding aggregate operator. In UNION rn for an equivalent invocation of the n-adic operator. Here, then, is the definition of UNGROUP:
r UNGROUP a, where: ‚Ä¢	 ‚Ä¢	 r is a relation, a is an attribute of r, and the declared type ta of a is a relation type no attribute of ta has an attribute name used in the heading of r, except perhaps a itself.

( r, x ) the second operand, whose declared type must be a relation type, provides the relations r1, ‚Ä¶

is equivalent to UNION ( EXTEND r : { x := RELATION { t } TIMES a }, x ) where x is an attribute name arbitrarily chosen and t = TUPLE { b1 b1, ‚Ä¶, bn bn }, where b1, ‚Ä¶, bn are the attributes of r{ALL¬†BUT¬†a}.

As with GROUP, Version 1 of Tutorial D allows the second operand to be a commalist, thus allowing single attribute and you are advised against using more than one attribute with Version 1. Points to note: ‚Ä¢	 The invocation of TIMES used in the extend addition effectively extends the (relation) value is the value of the attribute x by which that tuple of r is extended. ‚Ä¢	 Although UNGROUP is the inverse operator for GROUP, GROUP is not the inverse of ‚Ä¢	 The aggregate union of all the x values is the result of the invocation of UNGROUP.

more than one relation-valued attribute to be specified in a single invocation. Version 2 allows just a

of a in each tuple of r with the other attribute values of the same tuple. The resulting relation

UNGROUP. In other words, although r = ( r GROUP { al } AS g ) UNGROUP g in general, it is attributes of the relation-valued attribute g. Some tuples in s might have an empty relation as the value for g, whereas an invocation of GROUP can never give rise to such empty relations. Also, several distinct tuples might appear in s that differ only in their g values, in which case those tuples will be ‚Äúcondensed‚Äù into a single tuple in the grouping. not necessarily the case that s = ( s UNGROUP g ) GROUP { al } AS g, where al specifies the

140
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

5.8	

WRAP and UNWRAP

It is occasionally convenient to be able to collect together certain attribute values in each tuple of a relation to form a single attribute value that is itself a tuple, replacing the collected values. Example 5.14 shows how this effect can be achieved, laboriously, using EXTEND and projection on a relvar named CONTACT_INFO.

Example 5.14: Collecting attribute values together CONTACT_INFO WRAP { House, Street, City, Zip } AS Address Assuming that is assigned to a relvar CONTACT_INFO_WRAPPED: CONTACT_INFO_WRAPPED UNWRAP Address

The repetitions of the attribute names involved suggest a shorthand for this purpose and in Tutorial D it appears as the relational operator WRAP, which is accompanied in the language by its inverse, UNWRAP. In Example 5.15 WRAP is used to collect together the components of people‚Äôs postal addresses to form the tuple-valued attribute Address, and UNWRAP is used to reverse the process. Example 5.15: Use of WRAP and UNWRAP CONTACT_INFO WRAP { House, Street, City, Zip } AS Address CONTACT_INFO_WRAPPED UNWRAP ( Address )
www.sylvania.com

Assuming that is assigned to a relvar CONTACT_INFO_WRAPPED:

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

141
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

Definitions of WRAP and UNWRAP
r WRAP { al } AS w, where: ‚Ä¢	 ‚Ä¢	 r is a relation such that the projection r { al } is defined, and w is an attribute name not used in the heading of r

is equivalent to

where t = TUPLE { b1 b1, ‚Ä¶, bn bn }, where b1, ‚Ä¶, bn are the attributes of r { al }.
r UNWRAP a, where: ‚Ä¢	 ‚Ä¢	 r is a relation, a is an attribute of r, and the declared type ta of a is a tuple type no attribute of ta has an attribute name used in the heading of r, except perhaps a itself.

( EXTEND r : { w := t } ) { ALL BUT al }

is equivalent to

{ ALL BUT a }

( EXTEND r : { b1 := b1 FROM a, ‚Ä¶, b1 := bn FROM a } )

where b1, ‚Ä¶, bn are the attributes of ta.

An expression of the form a FROM t1 is called attribute extraction, defined in Section 5.10. It denotes the value of attribute a of tuple t1.

You have now met nearly all of the relational operators of Tutorial D Version 1 (there are a couple more that have been deliberately omitted as beyond the scope of an introduction to the subject). Here they are again, in categories monadic, dyadic, and n-adic according to their number of relation operands. Monadic:	 RENAME, projection, WHERE (restriction), EXTEND, SUMMARIZE ‚Ä¶ BY, GROUP, UNGROUP, WRAP, UNWRAP Dyadic:		JOIN, UNION, INTERSECT, NOT MATCHING (semidifference), MINUS (difference), MATCHING (semijoin), COMPOSE, SUMMARIZE ‚Ä¶ PER n-adic:		 JOIN { ‚Ä¶ }, UNION { ‚Ä¶ }, INTERSECT { ‚Ä¶ }

There remain to be described various non-relational operators that involve tuples or relations and are defined in Tutorial D, being deemed useful additional ingredients of a relational database language.

142
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

5.9	

Relation Comparison

The operators described in this section are especially useful for defining database constraints, as described in Chapter 6, but they can be useful in queries too. You are familiar with comparisons: dyadic, truth-valued or Boolean operators whose operands are of the same type. For example, comparisons of the form x = y, where x and y are expressions of the same type, are available for all types in Tutorial D, as you would surely expect. However, some computer languages do not support ‚Äú=‚Äù for all the types they recognize, and some do not support it correctly!‚Äîi.e., in the strict sense that is needed for relational databases. A Note on Equality In Tutorial D, the literals TRUE and FALSE denote the only two values of the type named BOOLEAN, the same value; otherwise (they denote different values) it yields FALSE. That is the strict sense I just commonly called truth values. The comparison x = y yields TRUE if the expressions x and y denote mentioned. As a consequence, if an expression w contains one or more appearances of x and we obtain expression w‚Äô from w by replacing every appearance of x by y, then w = w‚Äô has the same truth value as x = y. Some languages, such as COBOL and SQL, deviate somewhat from this strict definition of equality. In particular, those two languages both allow two character strings to ‚Äúcompare equal‚Äù if they differ only in their numbers of trailing blanks‚Äîfor example, the strings 'this' and 'this '. Such treatment is disastrous in a relational database language because the DBMS relies on the strict sense of ‚Äú=‚Äù for the definition and implementation of so many of the operators described in this book. Suppose, for example, that in the current value of IS_CALLED one of the two Borises had his name recorded with a trailing blank, and Tutorial D‚Äôs definition of ‚Äú=‚Äù were the same as SQL‚Äôs and COBOL‚Äôs. What then would be the result of the projection IS_CALLED{Name}? It can‚Äôt include both of TUPLE{Name NAME('Boris')} and TUPLE{Name NAME('Boris ')}, for those of them can appear, which one? In fact, does it have to be either of them? Couldn‚Äôt TUPLE{Name with Example 4.3 in Chapter 4, where Name is the common attribute for an invocation of JOIN.

two tuples would be deemed equal and thus cannot both appear in the same relation. And if only one NAME('Boris '}), with two trailing blanks, appear instead? Similar questions arise in connection

A language that allows the declared type of an attribute to be one for which ‚Äú=‚Äù is not supported (for example, SQL) is relationally incomplete. If, for example, relation r has such an attribute, a, then no projection of r that includes a can be defined. One such projection is the identity projection, r{ALL¬†BUT}, and if that is undefined it is difficult to see how even the expression r can be defined!

143
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

It follows in particular from the foregoing discussion that Tutorial D‚Äôs support of x¬†=¬†y allows x and y to denote relations (of the same type). Tutorial D also supports relation comparisons of the form r1¬† ÔÅ†¬† r2 (‚Äúr1 is a subset of r2‚Äù) and its inverse, r1¬† ÔÅ≤¬† r2 (‚Äúr1 is a superset of r2‚Äù). Definitions of relation comparison
Let r1 and r2 be relations having the same heading. Then: r1¬† ÔÅ†¬†r2 is true if every tuple of r1 is also a tuple of r2, otherwise false. r1¬† ÔÅ≤¬†r2 is equivalent to r2¬† ÔÅ†¬†r1 r1¬† =¬† r2 is equivalent to r1¬† ÔÅ†¬† r2 AND r2¬†‚äÜ¬†r1

Note carefully that the symbols ÔÅ† and ÔÅ≤ are often referred to ‚Äúsubset of or equal to‚Äù and ‚Äúsuperset of or equal to‚Äù, respectively. The words ‚Äúor equal to‚Äù are added for clarity only‚Äîthey are redundant because by definition every set is a subset of itself. Note that only one relation comparison operator needs to be taken as primitive, either ÔÅ† or ÔÅ≤, for the other two can than be defined in terms of it.
REL Alert Because the mathematical symbols ÔÅ† and ÔÅ≤ are unlikely to be easily available on your keyboard, Rel allows you to use the combinations <= and >=, respectively, in their places. These combinations are also used for ‚Äúless than or equal to‚Äù and ‚Äúgreater than or equal to‚Äù, so you have to read Rel expressions carefully to avoid confusion. There is no ambiguity, because there are no types in Tutorial D for which both ‚Äúless than‚Äù and ‚Äúsubset of‚Äù are defined.

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

144
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

The alert reader will have noticed that the definitions of relation comparisons tacitly depend on a definition of tuple equality. To determine whether tuple t appears in the bodies of both r1 and r2 the system must know how to evaluate t1 = t2 where t1 and t2 are tuples. Definition of tuple equality
Let t1 and t2 be tuples having the same heading. Then: t1¬†=¬†t2 is true if for every attribute a of t1, a FROM t1 = a FROM t2; otherwise it is false.

The expression a FROM t1 is an example of ‚Äúattribute extraction‚Äù, as already mentioned in connection

with the relational operator UNWRAP in Section 5.8. Just as relation equality depends on tuple equality, because the declared type of an attribute can be a tuple type or a relation type. Now, consider the relation comparison r { } = TABLE_DUM which is clearly defined for all relations r. Did you see immediately that it evaluates to TRUE if and

tuple equality in turn depends on equality being defined for all types. In fact the definition is recursive,

only if r is empty? For if r is empty, then so is every projection of r, and if r is not empty, then nor is Well, recognizing that taking a projection and comparing the result with an empty relation might strike provides the shorthand IS_EMPTY(r) as being equivalent to that comparison (and also to COUNT(r)=0, of course). Uses for Relation Comparisons

any projection of r. TABLE_DUM, recall, is Tutorial D‚Äôs pet name for the empty relation of degree zero. some people as a long-winded and not very obvious way of testing a relation for being empty, Tutorial D

As I have already suggested, relation comparisons are mostly used in the definition of database constraints. Their use for that purpose is described in the next chapter. Here I give just one example of the use of relational comparison in a query. Suppose we wish to discover which students have taken the exam for every course on which they are enrolled. In that case we need the relation representing the predicate For every course CourseId on which student StudentId, who is called Name, is enrolled, there exists a mark Mark such that StudentId scored Mark on the exam for CourseId.

145
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

That predicate has just two parameters, StudentId and Name. The other variables, CourseId and Mark are both quantified and therefore bound. Mark is existentially quantified, suggesting the use of projection on EXAM_MARK, but CourseId is universally quantified. I haven‚Äôt given you a relational operator corresponding to universal quantification and in fact Tutorial D doesn‚Äôt have one. (It did, once, but the operator in question, named DIVIDEBY, turned out to be somewhat troublesome and difficult to use and is now deprecated.) However, universal quantification can be expressed, albeit in an unpleasantly roundabout way, using existential quantification and negation. The students who have sat the exam for every course they are enrolled on are exactly those students for whom there does not exist a course, on which they are enrolled, whose exam they have not sat. The double negation used in that sentence shows up in Example 5.16 as two invocations of NOT MATCHING. Example 5.16: Students who have taken the exam for every course they are enrolled on IS_CALLED NOT MATCHING (IS_ENROLLED_ON NOT MATCHING EXAM_MARK) Explanation 5.16: ‚Ä¢	 IS_ENROLLED_ON NOT MATCHING EXAM_MARK gives the relation consisting of those tuples of IS_ENROLLED_ON that have no matching tuple in EXAM_MARK. In

other words, those tuples that satisfy the predicate ‚ÄúStudent StudentId is enrolled on course CourseId and there does not exist a mark Mark such that StudentId scored Mark in the exam

for CourseId.‚Äù The projection representing the existential quantification of Mark here is not explicitly given in Example 5.16 but is implicit in the use of NOT MATCHING: IS_ ENROLLED_ON NOT MATCHING EXAM_MARK is equivalent to IS_ENROLLED_ON ‚Ä¢	 IS_CALLED NOT MATCHING ( IS_ENROLLED_ON NOT MATCHING MINUS (EXAM_MARK{ALL BUT Mark}), where the projection does appear explicitly.

no matching tuple in the relation representing enrolments for which there is no matching exam result. Those tuples are precisely the ones that satisfy our predicate. Note that a tuple for student S5, who is enrolled on no courses at all, correctly appears in the result. That‚Äôs because there does not exist a course for which S5 is enrolled but has not taken the exam. But if you find double negation a bit much to get your head around, you might prefer the alternative given in Example 5.17. Example 5.17: Alternative solution to Example 5.16 using ÔÅ† IS_CALLED WHERE ÔÅ† IS_ENROLLED_ON COMPOSE RELATION {TUPLE {StudentId StudentId}} ( EXAM_MARK COMPOSE RELATION {TUPLE {StudentId StudentId}} ) {ALL BUT Mark}

EXAM_MARK ) gives the relation consisting of those tuples of IS_CALLED that have

146
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

Explanation 5.17: ‚Ä¢	 IS_CALLED WHERE announces clearly that the result of our query is a relation whose students that have the particular property defined in the WHERE condition. body is a subset of that of IS_CALLED; in other words, we are looking for just those

‚Ä¢	 The particular property defined in the WHERE condition is such that the entire query the exam. ‚Ä¢	 The relations being compared in the WHERE condition are the image relations of

translates roughly to students whose every enrolment is on a course for which they took

IS_CALLED tuples in IS_ENROLLED_ON and EXAM_MARK minus the Mark attribute. The commonality between the somewhat cumbersome expressions denoting those image and useful. The commonality is the invocation of COMPOSE with a singleton relation relations suggests that some shorthand embracing that commonality would be both feasible consisting of a tuple derived from the relation operand of WHERE. Under a suggestion from Chris Date in references [10] and [11] the fragment r COMPOSE RELATION {TUPLE mark, sometimes pronounced ‚Äúbang bang‚Äù), like this: {StudentId StudentId}} is reduced to just ‚Äºr (where ‚Äº is the double exclamation IS_CALLED WHERE ‚ÄºIS_ENROLLED_ON ÔÅ† ‚Äº(EXAM_MARK{ALL BUT Mark})

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

147
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Building on The Foundation

5.10	

Other Operators on Relations and Tuples

We close this chapter with brief descriptions of other operators defined in Tutorial D that operate on relations or tuples. Tuple Membership Test Let r be a relation and let t be a tuple of the same heading as r. Then t ‚àà r is defined to yield TRUE if the body of r contains tuple t, otherwise FALSE.
REL Alert Because the mathematical symbol ‚àà is unlikely to be easily available on your keyboard, Rel allows you to use the key word IN in its place.

Tuple Extraction Let r be a relation of cardinality one (a ‚Äúsingleton relation‚Äù). Then TUPLE FROM r is defined to yield the single tuple contained in the body of r. For example, TUPLE FROM COURSE WHERE CourseId = CID('C1') yielding TUPLE { CourseId CID('C1'), Title 'Database' }. Attribute Value Extraction (previously mentioned in Section 5.8) Let t be a tuple with an attribute named a. Then a FROM t is defined to yield the value of the attribute a in tuple t. For example, Title FROM TUPLE FROM COURSE WHERE CourseId = CID('C1') yielding the CHAR value 'Database'. Tuple Counterparts of Relational Operators Let t1 and t2 be tuples. Then the following are defined, with obvious semantics in each case and in each case yielding a tuple: ‚Ä¢	 tuple rename: t1 RENAME { a1 AS b1, ‚Ä¶, an AS bn } ‚Ä¢	 tuple projection: t1 { [ALL BUT] a1, ‚Ä¶ an }
148
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Building on The Foundation

‚Ä¢	 tuple extension: EXTEND t1 : { a1 := exp1, ‚Ä¶, a1 := expn } ‚Ä¢	 tuple compose: t1 COMPOSE t2 ‚Ä¢	 tuple union: t1 UNION t2 ‚Ä¢	 tuple wrap: t1 WRAP { a1, ‚Ä¶, an } AS a ‚Ä¢	 tuple unwrap: t1 UNWRAP a

EXERCISES
1.	 (Repeated from the body of the chapter) What can you say about the result of r1 COMPOSE r2 when r1 and r2 have identical headings? For example, what is the result of IS_CALLED COMPOSE IS_CALLED?

2.	 (Repeated from the body of the chapter) Is COMPOSE associative? In other words, is prove it; if not, show why.

(¬† r1¬† COMPOSE¬† r2¬†)¬† COMPOSE¬† r3 equivalent to r1¬† COMPOSE¬† (¬† r2¬† COMPOSE¬† r3¬†)? If so,

4.	 (Repeated from the body of the chapter) Does the aggregate operator AVG have a basis operator? If so, define it. 5.	 Suppose an aggregate operator PRODUCT is defined, with arithmetic multiplication as its 6.	 (Repeated from the body of the chapter) Is it always the case that the cardinality of an ungrouping is equal to the sum of the cardinalities of the relations being ungrouped on? 7.	 Write Tutorial D expressions for the following queries and get Rel to evaluate them: a)	 Get the total number of parts supplied by supplier S1. b)	 Get supplier numbers for suppliers whose city is first in the alphabetic list of such cities. c)	 Get part numbers for parts supplied by all suppliers in London. d)	 Get supplier numbers and names for suppliers who supply all the purple parts. e)	 Get all pairs of supplier numbers, Sx and Sy say, such that Sx and Sy supply exactly the same set of parts each. f)	 Write a truth-valued expression to determine whether all supplier names are unique in S. g)	 Write a truth-valued expression to determine whether all part numbers appearing in SP also appear in P. basis operator. What is the result of PRODUCT(r,x) if r is empty?

3.	 What can you say about the result of r1 MATCHING ( r2 MATCHING r1 )?

149
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

6	 Constraints and Updating
6.1	Introduction
You have already met constraints, in type definitions (Chapter 2), where they are used to define the set of values constituting a type. The major part of this chapter is about database constraints. Database constraints express the integrity rules that apply to the database. They express these rules to the DBMS. By enforcing them, the DBMS ensures that the database is at all times consistent with respect to those rules. In Chapter 1, Example 1.3, you saw a simple example of a database constraint declaration expressed in Tutorial D, repeated here as Example 6.1 (though now referencing IS_ENROLLED_ON rather than ENROLMENT).

Example 6.1: Declaring an integrity constraint CONSTRAINT MAX_ENROLMENTS

COUNT ( IS_ENROLLED_ON ) ÔÇ¶ 20000 ;

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

150
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

line gives the expression to be evaluated whenever the DBMS decides to check that constraint. This

The first line tells the DBMS that a constraint named MAX_ENROLMENTS is being declared. The second

particular constraint expresses a rule to the effect that there can never be more than 20000 enrolments altogether. It is perhaps an unrealistic rule and it was chosen in Chapter 1 for its simplicity. Now that you have learned the operators described in Chapters 4 and 5 you have all the equipment you need to express more complicated constraints and more typical ones. This chapter explains how to use those operators for that purpose. Now, if a database is currently consistent with its declared constraints, then there is clearly no need for the DBMS to test its consistency again until either some new constraint is declared to the DBMS, or, more likely, the database is updated. For that reason, it is also appropriate in this chapter to deal with methods of updating the database, for it is not a bad idea to think about which kinds of constraints might be violated by which kinds of updating operations, as we shall see.

6.2	

A Closer Look at Constraints and Consistency

A constraint is defined by a truth-valued expression, such as a comparison. A database constraint is defined by a truth-valued expression that references the database. To be precise, the expression defines a condition that must be satisfied by the database at all times. We have previously used such terminology in connection with tuples‚Äîin relational restriction for example, which yields a relation containing just those tuples of a given relation that satisfy the given condition. We can justify the use of the terminology in connection with database constraints by considering the database value (or ‚Äústate‚Äù, as it is sometimes called) at any particular point in time to be a tuple. The attributes of this tuple take their names and declared types from the variables constituting the database and their values are the values of those variables. Taking this view, the database itself is a tuple variable and every successful update operation conceptually assigns a tuple value to that variable, even if it actually assigns just one relation value to one relation variable, leaving the other relvars unchanged. When Are Constraints Checked? What do we really mean when we say that the DBMS must ensure that the database is consistent at all times? Internally, the DBMS might have to perform several disk writes to complete what is perceived by the user as a single update operation, but intermediate states arising during this process are visible to nobody (or should be so‚Äîcertain commercially available systems that call themselves DBMSs nevertheless do allow such intermediate states to be visible). Because those intermediate states are invisible, we can state that if the database is guaranteed to be consistent immediately following completion of each single statement that updates it, then it will be consistent whenever it is visible. We say therefore that, conceptually at least, constraints are checked at all statement boundaries, and only at statement boundaries‚Äîwe don‚Äôt care about the consistency of intermediate states arising during the DBMS‚Äôs processing of a statement because those states aren‚Äôt visible to us in any case.

151
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

To clarify ‚Äúall statement boundaries‚Äù, first, note that this includes statements that are contained inside other statements, such as IF ‚Ä¶ THEN ‚Ä¶ ELSE ‚Ä¶ constructs for example. Secondly, the conceptual checking need not take place at all for a statement that does no updating, but no harm is done to our model if we think of constraints as being checked at every statement boundary. In Tutorial D, as in many computer languages, a statement boundary is denoted by a semicolon, so we can usefully think of constraints as being effectively checked at every semicolon. If all the constraints are satisfied, then the updates brought about by the statement just completed are accepted and made visible; on the other hand, if some constraint is not satisfied, then the updates are rejected and the database reverts to the value it had immediately after the most recent successful statement execution. Declared Constraints and The Database Constraint We can usually expect a database to be subject to quite a few separately declared constraints. To say that the database must satisfy all of the conditions specified by these constraints is equivalent to saying that it must satisfy the single condition that is the conjunction of those individually specified conditions‚Äîthe condition formed by connecting them all together using logical AND. We can conveniently refer to the resulting condition as the database constraint. Now we can state the principle governing correct maintenance of database integrity by the DBMS quite succinctly: the database constraint is guaranteed to be satisfied at every statement boundary.

6.3	

Expressing Constraint Conditions

Use of Relational Operators The condition for a database constraint must reference the database and therefore must mention at least one variable in that database. In the case of relational databases, that means that at least one relvar must be mentioned. Moreover, as the condition is specified by a single expression (a truth-valued expression), it must use relational operators if it involves more than one relvar and, as we shall soon see, is likely to use them even when it involves just one relvar. However, a relation isn‚Äôt a truth value, so we need some of the non-relational operators described in Chapter 5, in addition to the relational operators, to express conditions for declared constraints. In particular, the expression itself must denote an invocation of some truth-valued operator. In Example 6.1 that operator is ‚Äú=‚Äù. No relational operators are used in that example, because the only relation we need to operate on is the one that is the value of the relvar IS_ENROLLED_ON when the constraint is checked. The aggregate operator COUNT operates on that relation to give its cardinality, an integer.

152
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Use of COUNT and IS_EMPTY It turns out that if the database language is relationally complete and also supports COUNT, along with expressing constraints (so long as the support for COUNT is orthogonal, such that an invocation of it can the usual numerical comparison operators, then it can also be regarded as complete for the purpose of appear wherever an integer literal would be permitted). Furthermore, every constraint can be expressed as a single comparison, one of whose operands is an invocation of COUNT. It seems, then, that the only operators we need in addition to those required for relational completeness are ones that we would surely have anyway for use in queries. However, requiring every constraint to be expressed as a comparison involving COUNT would not be very kind to users of our language. We need to explore the possibilities for more convenient ways of expressing common kinds of constraint.

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

153
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

One particular kind of comparison involving COUNT is an expression of the form COUNT(r)=0, where

r denotes a relation. This is effectively a test for emptiness on r. If r is empty, then there does not exist a tuple that satisfies the predicate for r. If, on the other hand, there does exist at least one such tuple, then it is a tuple that in a manner of speaking breaks the rule expressed by the constraint. So, if we can write a relational expression denoting the relation whose body consists of all the tuples representing counterexamples to the rule in question, then we can enforce that rule by requiring the cardinality of that relation to be zero. And that method of expressing a constraint turns out to be sufficient for any constraint that might be required, including even Example 6.1. But first look at Example 6.2 for an illustration of the idea. It enforces a rule to the effect that every student sitting an exam must be enrolled on the relevant course. Example 6.2: Testing for absence of counterexamples CONSTRAINT Must_be_enrolled_to_take_exam

COUNT ( EXAM_MARK NOT MATCHING IS_ENROLLED_ON ) = 0 ;

The expression EXAM_MARK NOT MATCHING IS_ENROLLED_ON denotes the relation whose body consists of those tuples of EXAM_MARK that have no matching tuple (on the common attributes StudentId and CourseId) in IS_ENROLLED_ON, and we don‚Äôt want there ever to be any such handed way of expressing what to a logician is nothing more than an existence test, negated. That is why Tutorial D provides the shorthand IS_EMPTY(r) for COUNT(r)=0, as shown in Example 6.3. Example 6.3: Use of IS_EMPTY CONSTRAINT Must_be_enrolled_to_take_exam_alternative1

tuples. But counting all the tuples in a relation and then seeing if the result is zero is a rather heavy-

IS_EMPTY ( EXAM_MARK NOT MATCHING IS_ENROLLED_ON ) ;

In case you are now wondering how the constraint in Example 6.1 can be expressed as a single invocation of IS_EMPTY, and thus questioning my claim that every constraint that can be expressed according to the theory can be expressed as a test for zero cardinality, Example 6.4 shows you one way of doing it, but note carefully that the expression still involves COUNT. Example 6.4: MAX_ENROLMENTS expressed as an invocation of IS_EMPTY CONSTRAINT MAX_ENROLMENTS_alternative1 WHERE N > 20000 ) ;

IS_EMPTY ( RELATION { TUPLE { N COUNT(IS_ENROLLED_ON) } }

the simple comparison used in Example 6.1‚Äîall I have done, in fact, is to bury that comparison as a restriction condition in a somewhat contrived relational expression.
154
Download free eBooks at bookboon.com

And here, of course, it is the invocation of IS_EMPTY that is significantly more ‚Äúheavy-handed‚Äù than

An Introduction to Relational Database Theory

Constraints and Updating

Explanation 6.4 ‚Ä¢	 RELATION { TUPLE { N COUNT(IS_ENROLLED_ON) } } denotes the relation of heading { N INTEGER } in whose single tuple the value of the attribute N is the number of tuples in the current value of IS_ENROLLED_ON.

‚Ä¢	 WHERE N > 20000 operates on that singleton relation to yield the empty relation of } fails to satisfy the condition N > 20000. Thus, the result is empty only when the number of enrolments is in fact no greater than the maximum allowed.

heading { N INTEGER } if and only if TUPLE { N COUNT(IS_ENROLLED_ON)

As this example shows, any value of any type can be ‚Äúconverted‚Äù to a tuple of degree one by invocation of the tuple selector, and the resulting tuple can be ‚Äúconverted‚Äù to a relation of cardinality one by invocation of the relation selector. The technique quite often turns out to be useful. Now, knowing that a language is relationally complete gives us a clear understanding of one very important aspect of its expressive power, but for the full picture we need to know what built-in types it supports of those types. If we can assume the availability of IS_EMPTY, which operates on a relation to yield a in addition to relation types and BOOLEAN, and what operators are available for operating on values

truth value, then we have a theoretically satisfying notion of completeness for expressing constraints. If the language is relationally complete, then every constraint can be expressed in the form IS_EMPTY(r) and the expressive power of the language for defining constraints depends on what additional types are available to be declared types of relation attributes. However, it turns out that in Tutorial D anything that can be expressed in the form IS_EMPTY(r) can be expressed in several other ways too, as I am about to describe, and it is a moot point which of these several methods the theoretician might consider to be the most satisfying. Use of Relation Comparisons Relational comparisons are described in Chapter 5, Section 5.9. It turns out that every constraint that r1 and r2 are relations, which is true if and only if the body of r1 is a subset of that of r2. Example 6.5 shows how ‚ÄúÔÅ†‚Äù provides an alternative way of expressing the constraint declared in Example 6.2, requiring every student who taking an exam to be enrolled on the relevant course. Example 6.5: Use of ÔÅ† CONSTRAINT Must_be_enrolled_to_take_exam_alternative1 EXAM_MARK { StudentId, CourseId } ÔÅ† IS_ENROLLED_ON { StudentId, CourseId } ; can be expressed using IS_EMPTY can be expressed as a single comparison of the form r1¬†ÔÅ†¬†r2, where

155
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

This might be considered to be clearer than Example 6.3 but it needs to name the common attributes in the projections needed to obtain relations of the same type for the comparison (though in this particular example the projection of IS_ENROLLED_ON is the identity projection, over the entire heading, and so can be omitted).

In case you are wondering how Example 6.1 might be expressed using ÔÅ†, Example 6.6 shows one rather straightforward way of doing it, as well as perhaps giving a compelling reason why we might prefer not to be compelled to express every constraint in the form r1¬† ÔÅ†¬†r2. Example 6.6: MAX_ENROLMENTS expressed as a relation comparison CONSTRAINT MAX_ENROLMENTS_REV1

RELATION { TUPLE { N COUNT(IS_ENROLLED_ON) } } WHERE N > 20000 ÔÅ† RELATION { N INTEGER } { } ;

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩe G for Engine

Ma

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities ÔøΩree wo work or placements s solve pr
Click on the ad to read more

156
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Explanation 6.6 ‚Ä¢	 The explanation of the first line is as in Example 6.4. The resulting relation is the first ‚Ä¢	 RELATION { N INTEGER } { } is the second operand, denoting the empty relation of the same type as as the first operand. Of course, to be a subset of an empty relation is the same as to be (i.e., be equal to) that empty relation, so the invocation of ‚ÄúÔÅ†‚Äù yields TRUE if and only if the first operand is in fact that empty relation. operand of an invocation of ‚ÄúÔÅ†‚Äù.

Obviously, wherever we can use ‚ÄúÔÅ†‚Äù we could instead use ‚ÄúÔÅ≤‚Äù, from the equivalence of r1¬†ÔÅ†¬†r2 and r2¬†‚äá¬†r2. Moreover, the given explanation of Example 6.6 clearly shows that ‚Äú=‚Äù comparison can be used to express every constraint that can be expressed in the form IS_EMPTY(r) (which could also be written as r = r WHERE FALSE). But the availability of ‚Äú=‚Äù comparisons on values of all types, including relations relational completeness is all that is theoretically needed for complete support for constraints. Now, I claimed that every constraint can be expressed as a single comparison of the form r1¬† ÔÅ†¬†r2. You might be wondering how equality of relations can be expressed using a single invocation of ‚ÄúÔÅ†‚Äù. Clearly, r1¬†=¬†r2 is equivalent to r1¬†ÔÅ†¬†r2 AND r2¬†ÔÅ†¬†r1, but that expression is an invocation of AND, not ‚ÄúÔÅ†‚Äù. Example 6.7 shows one way of doing it with a single invocation of ‚ÄúÔÅ†‚Äù. in particular, is surely required for relational completeness. Under that assumption we could argue that

Example 6.7: Relation equality using a single invocation of ‚ÄúÔÅ†‚Äù ( ( r1¬† MINUS¬†r2 ) UNION ( r2¬† MINUS¬†r1 ) ) { } ‚äÜ RELATION { } { } Explanation 6.7 ‚Ä¢	 Recall: r1 MINUS r2 is equivalent to r1 NOT MATCHING r2 but requires r1 and r2 to be ‚Ä¢	 ( ( r1¬†MINUS¬†r2 ) UNION ( r2¬†MINUS¬†r1 ) ) yields the relation whose body consists of every tuple of r1 that is not also a tuple of r2 and every tuple of r2 that is not also a tuple of r1. This is sometimes called the symmetric difference of r1 and r2 (and a relational language might well provide a dyadic operator as a shorthand for expressing it). Note that the symmetric difference of sets A and B is the empty set if and only if A=B (i.e., they are one and the same set). ‚Ä¢	 Noting that a projection of relation r is empty if and only if r itself is empty, we can test the symmetric difference for being empty by taking its projection over no attributes and testing that projection for being a subset of the empty relation of degree zero (recall that in Tutorial D you can use the name TABLE_DUM for this relation if you prefer). relations of the same type.

157
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

To prove that every expression of the form IS_EMPTY(r) is equivalent to some expression of the form

r1¬†ÔÅ†¬†r2 I merely note that IS_EMPTY(r) is equivalent to r ÔÅ† ( r WHERE FALSE ). And as r1¬†ÔÅ†¬†r2 or just one of our three relation comparison operators with equal expressive power. That gives four single invocation of that operator on one or two relations. There are more! Use of Truth-Valued Aggregate Operators

is equivalent to IS_EMPTY(r1¬† MINUS¬†r2) it is clear that a language can support either IS_EMPTY choices, so far, for the operator that allows us to express any theoretically expressible constraint as a

Our relvar EXAM_MARK really ought to be subject to a constraint requiring every value for the Mark attribute to lie in the range 0 to 100. That is easy enough to express using IS_EMPTY, as Example 6.8 of saying that no mark shall lie outside it. Example 6.8: Restricting exam marks to between 0 and 100 CONSTRAINT Marks_between_0_and_100 shows, but many people would prefer to say that every mark shall lie within the required range instead

IS_EMPTY ( EXAM_MARK WHERE Mark ÔÇ¶ 0 OR Mark ÔÇü 100 ) ;

synonym for aggregate AND. You might find ALL(r,c) more intuitive than AND(r,c).) Use of aggregate other methods we have met so far, as Example 6.9 shows in the case of our constraint on exam marks. in Chapter 5, Section 5.3, Aggregate Operators. Example 6.9: Restricting exam marks to between 0 and 100 using aggregate AND as supported in Version 2 of Tutorial¬†D CONSTRAINT Marks_between_0_and_100_using_AND

r is a relation and c is a condition, is true if and only if every tuple of r satisfies c. (In Rel ALL is a

In Chapter 5 you met the aggregate operator AND, named after its own basis operator. AND(r,c), where

AND allows many constraints to be expressed more succinctly and more clearly than use of any of the Note, however, that this example depends on an enhancement in Version 2 of Tutorial¬† D, as described

AND ( EXAM_MARK, Mark ÔÇ¶ 0 AND Mark ÔÇü 100 ) ;

To show that aggregate AND is in fact yet another candidate for our single additional operator, and that IS_EMPTY(r) and AND(r, FALSE). No tuple satisfies the condition FALSE, so AND(r, FALSE) is false whenever r contains at least one tuple and is true only when r is empty.

in fact every constraint can be expressed as an invocation of that operator, I note the equivalence of

158
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

We have aggregate OR too, so, recalling from Chapter 2 that ‚Äúfor all x, p(x)‚Äù is equivalent to ‚Äúthere does which it follows that AND(r,¬† FALSE) is equivalent to NOT(OR(r,¬† TRUE)). Finally, as OR(r,¬† TRUE) not exist x such that NOT(p(x))‚Äù, we can note that AND(r,¬†c) is equivalent to NOT(OR(r,¬†NOT(c))), from

is false only when r is empty, we can note that OR(r,¬† TRUE) is equivalent to NOT(IS_EMPTY(r)).

Faced with such a plethora of choice for general methods of expressing constraints, Tutorial D does not arbitrate in favour of any of the noted candidates, allowing the user to choose freely from among them whichever is deemed most suitable for each particular purpose. The availability of logical connectives gives the user the further freedom to decide how best to arrange the database constraint into declared constraints, individually named and formulated. Sadly, we cannot say the same for the commercially available DBMSs at the time of writing (2014), for we are not aware of any widely available SQL implementation that supports any of the noted candidates for use in constraints: they don‚Äôt support the international standard‚Äôs CREATE ASSERTION statement, which would be SQL‚Äôs counterpart of Tutorial D‚Äôs CONSTRAINT statement, and they don‚Äôt permit table expressions to appear inside SQL‚Äôs of the kinds described in the next section. so-called ‚Äútable constraints‚Äù. Typically, the SQL user is restricted to certain special-purpose shorthands

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

159
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

6.4	

Useful Shorthands for Expressing Constraints

In Chapter 5 I showed how a relational database language can be extended by defining new relational operators‚Äî‚Äúshorthands‚Äù‚Äîin terms of the existing ones. If the existing language is relationally complete, then such extensions do not increase the language‚Äôs expressive power‚Äîthere is no need for that‚Äîbut, judiciously chosen, they do make some problems easier to solve by providing shorthands that are not only convenient but, by raising the level of abstraction, might also be easier to understand than the longhands on which they are defined. In Chapter 5 I illustrated this point by showing you the handful of such operators that have been ‚Äújudiciously chosen‚Äù for Tutorial D, these having been proposed by various writers over the years. Unfortunately, very little in the way of useful shorthands has been proposed for use in constraints; and what little there is is subject to a certain amount of controversy. Yet the requirement for shorthands seems to be compelling, not just for the convenience of users but also for performance, as I will now explain. Suppose that we require every constraint to be expressed using an expression of the form IS_EMPTY(r).

Then consider a simple constraint such as the one to make sure every exam mark is in the range of 0 to 100 and assume it is expressed as shown in either of Examples 6.8 and 6.9. Suppose that a certain update statement is used to add a single tuple to EXAM_MARK. Whether IS_EMPTY or aggregate AND is chosen for the constraint declaration, a na√Øve evaluation would involve the system in examining each existing EXAM_MARK tuple as well as the one being added. But the existing tuples are all known to satisfy the condition Mark ÔÇ¶ 0 AND Mark ÔÇü 100, for if one of them didn‚Äôt the database would have been visibly inconsistent at the previous statement boundary. If the system could somehow work out that it is sufficient just to check incoming tuples, then simple update operations would be executed very much more quickly. But such optimizations involve sophisticated expression analysis. While we rightly expect industrial-strength DBMSs to attempt such optimizations, their degree of success is likely to be limited in practice. When we can identify a certain class of constraints that lend themselves to more efficient methods of evaluation, one way of guaranteeing that the system will adopt those more efficient methods is to provide an alternative way of expressing the constraint, applicable only to constraints of that class. If that alternative method is easier for the user to write, and perhaps clearer for the reader too, then the addition to the language can be justified even though it is theoretically redundant. I will now describe some of the special classes of constraint that have been identified and the shorthands typically used for expressing them, but please note carefully that with just one exception (key constraints) these shorthands are not available in Tutorial D. For one thing, they are somewhat controversial but, more importantly, many people have been beguiled by the impoverished state of the existing commercial technology into believing that the term ‚Äúconstraint‚Äù, as used in the present context, applies only to what can be expressed using the available shorthands.

160
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Tuple Constraints The shorthand described in this section is actually frowned upon by many people, the present writer included. I describe it because in most SQL implementations it is the only way of expressing constraints other than key constraints and foreign key constraints. Consider a constraint whose condition can be expressed as AND(r,¬† c), equivalently as IS_EMPTY(r¬†WHERE¬†NOT(c)), where r is a relvar name (i.e., not an invocation of a relational operator) and the condition c is an open expression that contains no relvar references. Then c can be evaluated against each tuple of r without any need to access the database beyond what is needed to obtain the tuples of r. Such a constraint is called a tuple constraint and the constraint on exam marks expressed in Examples 6.8 and 6.9 is an example. A typical shorthand for expressing a tuple constraint is to allow the condition c to be written inside the definition of the relvar r to which it applies. The shorthand is fairly obvious and intuitive. Example 6.10 shows the form it would be likely to take in Tutorial D in the extremely unlikely event that the language were ever extended to support the construct. Example 6.10: Shorthand for a tuple constraint (not allowed in Tutorial D) VAR EXAM_MARK BASE RELATION { StudentId SID, CourseId CID, KEY { StudentId, CourseId } Mark INTEGER }

CONSTRAINT Mark_in_range Mark ÔÇ¶ 0 AND Mark ÔÇü 100 ;

As with regular constraint declarations, naming the constraint allows it to be dropped when it is no longer needed. Now, suppose that not all exams are marked out of 100. Instead, each course has its own maximum mark recorded in the COURSE relvar as a value for the attribute MaxExamMark. In that case the required constraint, which is set as one of the exercises for this chapter, isn‚Äôt a tuple constraint because access to another relvar is needed to evaluate it against a given tuple of EXAM_MARK. But, as we have already noted, condition c specified for a tuple constraint expressed in the manner of Example 6.10, inside the definition of relvar r, is equivalent to IS_EMPTY(r WHERE NOT(c)). It might seem unreasonable

if the language allowed some condition to appear as a WHERE condition but not as the condition for a constraint declared inside a relvar definition. If c is permitted to include explicit relvar references, then the performance advantages to be gained by recognition of tuple constraints (where, by definition, c does not include any such references) will accrue only if the DBMS‚Äôs optimizer is capable of recognizing the cases where c does not reference any relvars. That should not be a problem for an industrial strength DBMS. Tutorial D does not support this kind of shorthand because the convenience gains are slight and, for teaching purposes at least, it is thought better practice to write such constraints out in full.

161
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Keys In Tutorial D every relvar declaration must include at least one key specification. In Example 6.10 it is KEY { StudentId, CourseId }. A key for relvar r is a set of attributes of r (i.e., a subset of r‚Äôs for those attributes. Thus, KEY { StudentId, CourseId }, included in the relvar declaration heading) such that at no time does r contain more than one tuple having any given collection of values for EXAM_MARK, specifies a constraint reflecting an integrity rule to the effect that no student can obtain more than one mark for the same exam. Similarly, KEY { StudentId }, included in the relvar is concerned. The constraint implied by declaration of a key is called, unsurprisingly, a key constraint. declaration for IS_CALLED, ensures that no student ever has more than one name as far as the database

To show that KEY {K} included in the declaration for relvar r is indeed a shorthand, I note that the constraint could also be expressed as COUNT(r) = COUNT(r{K}). If the projection of r over the attributes K has the same cardinality as r itself, then each tuple in the projection has exactly one matching matches more than one tuple in r. Now, the constraint expressed by KEY {K} for relvar r captures what is referred to as the uniqueness property of a key. A moment‚Äôs thought reveals that every superset of K that is a subset of the heading of r must also satisfy this uniqueness property. It is clearly important, when specifying a key, not to include any superfluous attributes. By definition, then, a key has also a property of irreducibility: we cannot take any attribute away from a key such that what is left is also a key. A formal definition for key now follows. It uses the term heading to refer to a set of attribute names only, rather than name/type pairs. The projection operator it uses is tuple projection, as defined in Chapter 5, Section 5.10. The definition starts by defining the useful term superkey, referring to a subset of the relevant relvar‚Äôs heading that is a superset of some key for that relvar.
Definitions for superkey and key Let K be a subset of the heading of relvar r. Then K is superkey for r if and only if, at all times, if tuples t1 and t2 both appear in the body of r, and the projection t1{K} is equal to the projection t2{K}, then t1 = t2 (i.e., they are the same tuple). K is a key for r if and only if (a) K is a superkey for r and (b) no proper subset of K is a superkey for r.

tuple in r; otherwise, its cardinality is less than that of r itself and at least one tuple in the projection

A superkey satisfies the uniqueness property but not necessarily the irreducibility property. A key satisfies both properties. A proper superkey is a superkey that isn‚Äôt a key.

162
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Note that a relvar can have more than one key. For example, a relvar representing a company‚Äôs employees might have an attribute Emp# representing employee numbers and an attribute NatIns# representing national insurance numbers. Each of those attributes on its own satisfies the uniqueness property for keys, so the relvar declaration would include KEY {Emp#} KEY {NatIns#}. Don‚Äôt make the common mistake of writing KEY {Emp#, NatIns#} instead! That would mean that employee numbers in combination with national insurance numbers satisfy the uniqueness property, which indeed they do, but that is a weaker constraint, allowing two employees to have the same employee number so long as they have different national insurance numbers (or the same national insurance number so long as they have different employee numbers). Two special cases of keys are worth noting. The first is where the key is the entire heading, as is the case with our relvar IS_ENROLLED_ON. The constraint implied by such a key is such that, were it not enforced, the relvar could at some point in time contain two or more identical tuples‚Äîbut in that case the value assigned to the relvar would not even be a relation! For that reason the fact that Tutorial D requires at least one key to be explicitly specified for each relvar has proved somewhat controversial. Perhaps omission of keys should imply KEY { ALL BUT }. An implication of KEY¬† {¬† ALL¬† BUT¬† } is that no other key can possibly exist for the relvar it applies to. Exercise for the reader: Why is this so?

163
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

The second special case is where the key is the empty set. In this case the corresponding key constraint is equivalent to COUNT(r) = COUNT(r{ }). As projection of r over no attributes yields either TABLE_DEE (when r is not empty) or TABLE_DUM (when it is), it follows that KEY { } specified for relvar r means that r can never contain more than one tuple. An implication of KEY { } is that no other key can possibly exist for the relvar it applies to. Exercise for the reader: Why is this so? Foreign Keys A constraint of the form IS_EMPTY(r1 NOT MATCHING r2) is called a foreign key constraint if and only if r1 and r2 are both relvar references, or relvar references appearing as operands of RENAME, question is called a foreign key and r1 is the referencing relvar of the foreign key; r2 is the referenced relvar. restrictions and is therefore a foreign key constraint: {StudentId, CourseId} is a foreign key in the referencing relvar EXAM_MARK and the referenced relvar of that foreign key is IS_ENROLLED_ON. Example 6.3, IS_EMPTY¬†(¬†EXAM_MARK¬†NOT¬†MATCHING¬†IS_ENROLLED_ON¬†), satisfies those and the common attributes of r1 and r2 constitute a key of r2. In r1, the set of common attributes in

Such constraints are very common in practice and their terminology that I have described is very widely used. SQL includes a special shorthand for such constraints. In fact, most SQL implementations require this shorthand to be used for expressing foreign key constraints. If Tutorial¬† D had a counterpart of SQL‚Äôs shorthand, then the constraint in Example 6.3 could be expressed, inside the declaration of relvar EXAM_MARK, in the following manner: FOREIGN KEY {Student_Id, Course_Id} REFERENCES IS_ENROLLED_ON An invocation of RENAME is needed as the referenced ‚Äúrelvar‚Äù in the case where the attribute names of the relevant key do not correspond to those of the referencing relvar.

Tutorial D does not support such shorthands, for the following reasons: 1.	 The requirement for the common attributes to constitute a key of the referenced relvar seems overly restrictive. 2.	 The requirement for both operands to be simple relvar references (possibly subject to some attribute renaming) also seems overly restrictive. 3.	 The shorthand isn‚Äôt much of a shorthand in any case‚Äîin the example given it is actually longer than the longhand, as you can see, though the extra length is partly a consequence of having to name the common attributes‚Äîyou might prefer to write, for example, IS_ENROLLED_ON{Student_Id, Course_Id} for greater clarity. 4.	 The shorthand is arguably no clearer than the longhand‚Äîand might even be thought rather arcane‚Äîbut, as I have already indicated, the terminology of foreign keys is widely used and understood in the database community. Indeed, I use it myself in the discussion of updating relvars that now follows.
164
Download free eBooks at bookboon.com

EXAM_MARK{Student_Id, Course_Id} ÔÅ†

An Introduction to Relational Database Theory

Constraints and Updating

If the restrictions were lifted, then such a shorthand might be considered‚Äîbut in that case the key words FOREIGN KEY would no longer be appropriate.

6.5	

Updating Relvars

Recall, from Chapter 1, my view of a database as representing a true account of some enterprise. The verb ‚Äúto update‚Äù is used of databases because it refers to the action of bringing the database up to date in line with changes in the state of the enterprise, when the account the database represents would otherwise be incomplete or untruthful. But the database consists of variables (relvars in the case of relational databases), so to update the database is to update one or more of its variables. In computer languages the general method of updating a variable is called assignment, commonly expressed using the symbol :=, as in, for example, x := x + 1. The expression on the right-hand side denotes the value that is to become the value of the variable whose name appears on the left-hand side. The value of the expression on the right is termed the source, the variable on the left the target. It is normal for assignment to be available in a computer language for variables of all types supported by that language, and Tutorial D does indeed allow you to update relvars that way, as illustrated in Example 6.11. Example 6.11: Enrolling a student on a course using assignment IS_ENROLLED_ON := IS_ENROLLED_ON UNION

RELATION { TUPLE { StudentId SID('S3'),

CourseId('C2') } } ;

However, although assignment is theoretically sufficient for updating purposes, it is usually more convenient to use a shorthand expressing the difference between the current value of the target relvar and the new value. Sometimes, as in Example 6.11, that difference is just the addition of one or more tuples to the existing set; sometimes it is just changes to some of the attribute values of some of the existing tuples; and sometimes it is just removal of some of the existing tuples. Shorthands for those three particular cases have been referred to as INSERT, UPDATE, and DELETE, respectively, since time immemorial‚Äîin other words, even before the advent of relational databases, though of course before records, not sets of tuples. Do not confuse relational update operators with the read-only operators described in Chapters 4 and 5, which don‚Äôt update anything. Conversely, update operators do not return values when they are invoked and therefore cannot be used for query purposes. Descriptions of the Tutorial D versions of those update operators now follow. that advent the targets of the updates were files, not relvars or SQL tables, and files were collections of

165
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

INSERT Loosely speaking, INSERT adds tuples to a relvar, retaining all the existing tuples. Example 6.12 shows how INSERT would be used to the same effect as that of Example 6.11.

Example 6.12: Enrolling a student on a course using INSERT INSERT IS_ENROLLED_ON RELATION { TUPLE { StudentId SID('S3'),

CourseId('C2') } } ;

As you can see, ‚ÄúIS_ENROLLED_ON := IS_ENROLLED_ON UNION‚Äù in Example 6.11 has been

replaced by ‚ÄúINSERT IS_ENROLLED_ON‚Äù. We avoid the repeated mention of IS_ENROLLED_ON contained in the first operand of the UNION invocation in Example 6.11.

because, as I have already stated, INSERT implicitly ‚Äúretains all the existing tuples‚Äù, those being the ones

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

166
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

INSERT statement, must have identical headings. It is normal practice to require r and the current value attempt, loosely speaking, to insert a tuple that already exists in the target. The reason for this normal

rv¬† :=¬† rv¬† UNION¬†r, implying that rv and r, now referred to as the target and source, respectively, of the

In general, INSERT rv r, where rv is a relvar name and r denotes a relation, is equivalent to

of rv to have no tuples in common (i.e., their bodies to be disjoint), such that the operation fails on an practice lies in the checking of key constraints. Every relvar is subject to at least one key constraint, even when the key in question is the entire heading, as is the case with IS_ENROLLED_ON. When processing an INSERT statement, the DBMS knows that the current value of the target relvar satisfies all the key constraints, so only the tuples of the source need their key values to be checked for uniqueness. If it encounters a tuple whose key value matches that of an existing tuple or another tuple in the source, the INSERT fails and the value of rv does not change. Having discovered a clash on key values, most systems do not bother to check to see if in fact the clashing tuples are identical, even when the key value is in fact the entire tuple! It is easy to imagine, therefore, that Example 6.11, though equivalent to Example 6.12 in its effect, will Internally, the DBMS is very likely to execute a relvar assignment by first deleting all the existing tuples, right-hand side of the assignment. Remarks similar to those on key constraints apply also to other constraints that can be expressed as a condition to be satisfied by all the tuples of a relvar (i.e., by AND(rv,c) where rv is a relvar name), including definition of that term.) The tuple constraint of Example 6.10 is an obvious case, but consider also foreign key constraints. Suppose we have the constraint condition IS_EMPTY ( IS_ENROLLED_ON NOT effectively defining { StudentId MATCHING IS_CALLED ) AND IS_EMPTY (IS_ENROLLED_ON NOT MATCHING COURSE ), tuple constraints in particular. (Recall that not all such constraints are tuple constraints under the usual take very much longer to execute when the current value of IS_ENROLLED_ON is of high cardinality.

then inserting into the now empty target the tuples of the relation denoted by the expression on the

IS_CALLED and { CourseId } in the same relvar to be a foreign key referencing COURSE. Then the DBMS, executing Example 6.12, need only check that student identifier S3 appears in some tuple of the current value of IS_CALLED and course identifier C2 appears in some tuple of the current value of COURSE. The existing tuples of IS_ENROLLED_ON are all guaranteed to satisfy that constraint and therefore do not need to be reexamined. A DBMS faced with the Tutorial D method of expressing foreign key constraints might find it quite a challenge to determine that it is only necessary to check the source for the INSERT, a simple task for SQL systems that demand such constraints to be expressed using FOREIGN KEY syntax.

} to be a foreign key in IS_ENROLLED_ON, referencing

167
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

The source for an INSERT can be any expression denoting a relation with heading that of the target. In practice the source is very commonly a relation literal, for the obvious reason that the ‚Äúnew information‚Äù being added to the database is indeed new and cannot be derived from the existing value of the database. It is also quite commonly a relation consisting of a single tuple, in which case the syntax for expressing the source for the INSERT appears rather heavy-handed. It would not be unreasonable to provide a ‚Äúsingle tuple insert‚Äù operator in addition to the ‚Äúmultiple tuple insert‚Äù of Tutorial D but such conveniences can must allow more than one tuple to be inserted in a single statement. Example 6.13 illustrates the convenience of allowing any relation expression to be the source for an INSERT. It assumes that all the exam scripts submitted by students have been marked and it has been decided to record marks of zero for students who failed to turn up for an exam they should have sat. Example 6.13: Awarding zero marks to students who failed to take the exam INSERT EXAM_MARK EXTEND ( IS_ENROLLED_ON NOT MATCHING 	 UPDATE (It is regrettable that the key word UPDATE has become so widely accepted as the name of just one particular operator for updating relational databases. Please don‚Äôt shoot the messenger!) muddy the waters for teaching purposes and we prefer to emphasize the point that a relational DBMS

EXAM_MARK ) : { Mark := 0 };

Loosely speaking, UPDATE changes some of the attribute values of some existing tuples of its target

relvar. Thus, although some tuples disappear from the target and others arrive in it, so to speak, the cardinality of the relvar does not change. Suppose the exam board for course C2 decides that the exam has been marked too harshly and everybody‚Äôs mark is to be increased by 5. Example 6.14 shows how. Example 6.14: Adding 5 to all the marks for course C2 UPDATE EXAM_MARK WHERE CourseId = CID('C2') : { Mark := Mark + 5 } ;

The syntax is self-explanatory. The WHERE specification is optional. It defaults to WHERE TRUE, meaning that the specified changes are to be applied to all existing tuples in the target relvar. The expression separated by commas. Mark := Mark + 5 is an attribute assign. When several attribute assigns are needed they are

168
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

As with INSERT, various optimizations are available to the DBMS when it comes to checking constraints.

For example, only the tuples satisfying the WHERE condition need to be examined, after application of discussed in the section on INSERT. Moreover, of those constraints the DBMS need only consider the

the attribute assigns, to see if they satisfy those constraints that can be checked ‚Äúa tuple at a time‚Äù, as ones that involve attributes whose names appear as attribute assign targets in the UPDATE statement. In

Example 6.14 no key or foreign key constraints need to be checked, because Mark is the only attribute assign target and that attribute does not appear in the only key for EXAM_MARK, nor is it a common attribute for any foreign key constraint. But Mark is involved in the constraint to ensure that all marks exam board might have to revise its upgrade policy for that exam! That an UPDATE invocation is indeed shorthand for some assignment is illustrated by Example 6.15, which is equivalent to Example 6.14.

are in the range 0 to 100. If any student has already scored 96 or more in the exam for course C2, the

Example 6.15: Adding 5 to all the marks for course C2, the hard way EXAM_MARK := EXAM_MARK WHERE NOT ( CourseId = CID('C2') ) UNION EXTEND ( ( EXAM_MARK WHERE CourseId = CID('C2') ) { Mark := Xmark + 5 } { ALL BUT Xmark } ; RENAME { Mark AS Xmark } ) :

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

169
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

You can easily see that, compared with INSERT, UPDATE offers quite generous shorthands! Note how the first operand of the UNION invocation preserves, so to speak, the unaffected tuples of EXAM_MARK. DELETE Loosely speaking, DELETE removes some existing tuples from its target relvar. Suppose the university decides that course C3 is to be withdrawn. Example 6.16 shows how. Example 6.16: Withdrawing course C3, using DELETE DELETE COURSE WHERE CourseId = CID('C3') ; Still speaking loosely, every tuple that satisfies the given WHERE condition is deleted and tuples that do not satisfy it remain.

Now, it might seem that, as the only tuples remaining in the target are ones that are already known to satisfy all constraints on the target that can be checked ‚Äúa tuple at a time‚Äù, there is no need for the DBMS to check such constraints at all when executing a DELETE statement. But we have been assuming that { CourseId } in IS_ENROLLED_ON is a foreign key referencing COURSE. If any students are recorded as being currently enrolled on course C3, then the DELETE statement in Example 6.16 must fail, for then the result of IS_ENROLLED_ON NOT MATCHING COURSE would not be empty as required.

Tutorial D also supports a second form of DELETE, where the tuples to be deleted are specified by a relation expression. For example, suppose the INSERT shown in Example 6.12 turned out to be a mistake the word INSERT by DELETE: by an end-user of Rel‚Äôs Dbrowser. Then the user could simply recall the INSERT statement and replace

DELETE IS_ENROLLED_ON RELATION { TUPLE { StudentId SID('S3'),

CourseId('C2') } } ;

So Example 6.16 is actually shorthand for DELETE COURSE COURSE WHERE CourseId = CID('C3') ; !

170
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Of course, if there are any students recorded as enrolled on a course that is being withdrawn, then those records are surely obsolete. To update the database to reflect the real world change and also ensure that it all the enrolments on C3 as well as deleting the course itself. We can do that by taking care to delete the satisfies the foreign key constraint involving IS_ENROLLED_ON and COURSE, we clearly need to delete

enrolments first (a course is allowed to exist with no enrolments) and then delete the course. But there‚Äôs a better solution, avoiding the need for care over the order of events, and having other advantages too. It is called multiple assignment. Multiple Assignment Example 6.17 shows how to delete course C3 and all its current enrolments at a single stroke. Example 6.17: Withdrawing course C3 and deleting any enrolments on C3 DELETE COURSE WHERE CourseId = CID('C3') ,

DELETE IS_ENROLLED_ON WHERE CourseId = CID('C3') ; It might appear at first glance to consist of two DELETE statements, the first of which you would expect single statement, there being only one semicolon. The first invocation of DELETE ends in a comma, not

to fail by violating a (foreign key) constraint. On closer inspection you should notice that it is in fact a a semicolon. Now recall that only semicolons denote statement boundaries, and statement boundaries are the points at which the database is required to be consistent with the database constraint. It is not required to be consistent at a point indicated by a mere comma‚Äîfor at such a point any inconsistency arising would be ‚Äúvisible‚Äù only to the DBMS and not to any user. Separating invocations of update operators‚Äîcalled assigns‚Äîby commas to form a single statement is Tutorial D‚Äôs method of expressing multiple assignment. It is important to realize that the individual assigns are considered to be executed concurrently, in parallel, regardless of the order in which they are written. This implies that all sources must be evaluated before any assigns are executed. Example 6.18, containing two statements but three assigns, illustrates this point using simple assigns to integer variables. Example 6.18: A consequence of simultaneity X := 1; X := X + 1, Y := X + 1 ; The first statement assigns 1 to the variable X. The result of the second statement is then to assign 2 to both variables, X and Y. If we replace the comma by a semicolon, then instead the result of executing what now becomes three statements would be to assign 2 to X and 3 to Y.

171
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

Multiple assignment is more than a mere convenience in certain circumstances. Sometimes a problem arises to which it is the only solution, as shown in the following scenario. Consider the business of taking purchase orders and delivering the purchased items to customers. Each purchase item belongs to a particular delivery and each delivery consists of one or more items. Deliveries are identified by reference numbers. A delivery reference number is attached to each item to identify the delivery it belongs to. The delivery reference number of an item must be that of a known planned or completed delivery and every delivery must contain at least one item‚Äîconsider the consequences if either of those constraints was not in force. So we have the constraint IS_EMPTY ( DELIVERY NOT MATCHING DELIVERY_ITEM ) AND IS_EMPTY ( DELIVERY_ITEM NOT MATCHING DELIVERY ). Without multiple assignment we cannot insert a tuple t into DELIVERY unless some tuple tt, matching t, exists in DELIVERY_ITEM, but tuple tt cannot possibly exist in DELIVERY_ITEM because if it did it would violate the condition IS_EMPTY ( DELIVERY_ITEM NOT MATCHING

DELIVERY ). With multiple assignment we can resolve the apparent impasse by inserting into both both DELIVERY and DELIVERY_ITEM simultaneously.

relvars simultaneously. Similarly, if a delivery is cancelled we need to delete all the relevant tuples from

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
172
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Constraints and Updating

Transactions Although multiple assignment is the recommended method of ensuring a database‚Äôs consistency and completeness, commercial DBMSs at the time of writing do not support it. Instead, they allow several update statements to be batched together to form a transaction, whereby the effects of each individual update statement are visible to the user who submits them to the DBMS, but are not visible to other users until the transaction is committed‚Äîif indeed it is ever committed, for the user also has the option to cancel the transaction, thus undoing all the updates submitted up to the point of cancellation. Typically, the database is permitted to be inconsistent with its declared constraints until the transaction is committed. In SQL, for example, the user may specify that the checking of certain specified constraints be deferred until either (a) that deferment request is cancelled or (b) the transaction is committed. Tutorial D supports transactions but does not support the deferring of constraint checking. Thus, developers of applications and user-defined operators are able to use program code that assumes that the database is consistent whenever that code is executed. Transactions are now just a convenience, whereby the database, though always consistent, might sometimes be incomplete‚Äîthough this incomplete state is visible only to the user owning the transaction. The following statements constitute Tutorial D‚Äôs support for transactions: ‚Ä¢	 BEGIN TRANSACTION is self-explanatory, but note that transactions can be ‚Äúnested‚Äù‚Äîa transaction can be started within an existing transaction. ‚Ä¢	 COMMIT commits the updates of the most recently started transaction and ends that transaction, but those updates become visible to other users only if the transaction in question is an outermost one (i.e., not nested inside another transaction). ‚Ä¢	 ROLLBACK cancels the updates of the most recently started transaction and ends that transaction. The cancelled updates include any resulting from some nested transaction that has been committed. I have now described everything needed for definition, manipulation, and maintaining the integrity of a relational database. Just one more topic needs to be addressed to complete the account of the foundational theory for such databases: database design.

173
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Constraints and Updating

EXERCISES
1.	 (Repeated from the body of the chapter). a)	 An implication of KEY { ALL BUT } is that no other key can possibly exist for the relvar it applies to. Why is this so? applies to. Why is this so? b)	 An implication of KEY { } is that no other key can possibly exist for the relvar it 2.	 Suppose the relvar definition for COURSE is extended to include an attribute

MaxExamMark, whose value in each tuple is the maximum mark obtainable for that

course‚Äôs exam. {StudentId, CourseId} is a foreign key in EXAM_MARK, referencing IS_ENROLLED_ON. A constraint is needed to ensure that no student is awarded a mark greater than the relevant maximum. a)	 Write a Tutorial D CONSTRAINT statement to address this requirement, where the b)	 Complete the following statement to make it equivalent to the one you wrote for part (a): CONSTRAINT ... AND(EXAM_MARK, ... ) ; 3.	 Now suppose that instead of there being a recorded maximum mark of each exam the maximum score for each question in each exam is recorded in the following relvar: VAR EXAM_QUESTION BASE RELATION { CourseId CID, Question# INTEGER, MaxMark INTEGER } KEY { CourseId, Question# } ; constraint condition is an invocation of IS_EMPTY.

For each course, the exam questions are supposed to be numbered sequentially, starting at 1. a)	 Write a Tutorial D CONSTRAINT statement to address this requirement. b)	 Suppose the questions are subdivided into parts, a, b, c and so on, up to a maximum of six parts, and maximum marks are given for each part rather than for each question. Again, the parts for each question must be ‚Äúnumbered‚Äù sequentially, starting at a. Write a c)	 Devise shorthands, in the style of Tutorial D, for expressing constraints of the kinds found in your solutions to a. and b. 4.	 Using Rel, with the suppliers-and-parts database set up for the Rel exercises given at the end of Chapter 4, write Tutorial D integrity constraints to express the following requirements: a)	 Every shipment tuple must have a supplier number matching that of some supplier tuple. b)	 Every shipment tuple must have a part number matching that of some part tuple. c)	 All London suppliers must have status 20. d)	 No two suppliers can be located in the same city. e)	 At most one supplier can be located in Athens at any one time. f)	 There must exist at least one London supplier. g)	 The average supplier status must be at least 10. h)	 Every London supplier must be capable of supplying part P2.
174
Download free eBooks at bookboon.com

Tutorial D CONSTRAINT statement to address this requirement.

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

7	 Database Design I: Projection-Join Normalization
7.1	Introduction
Relational database design takes a statement of requirements and produces a database definition to address those requirements. The definition consists of a collection of relvar and constraint definitions. As Chris Date puts it in [9] under the heading logical database design: Ideally, the goal is to produce a design that‚Äôs independent of all considerations having to do with either physical implementation or specific applications‚Äîthe latter objective being desirable for the good reason that it‚Äôs generally not the case that all uses to which the database will be put are known at design time. The production and format of a precise and complete requirements statement are beyond the scope of this book. Suffice it here just to say that the statement usually takes the form of a collection of ‚Äúbusiness rules‚Äù and/or some kind of ‚Äúentity/relationship model‚Äù presented in some agreed notation. Business rules are expressed in this chapter for some examples, in an intuitive and somewhat informal style thought to be good enough for the purpose at hand. The fact is, though, that even when the requirements are 100% clear there are usually some design choices to be made: in other words, there can be several significantly different designs to implement any given requirement statement. What common kinds of alternative might the designer encounter and in each case what considerations should guide the designer in arriving at the preferred choice? In this book I describe and discuss several common alternatives under the headings Projection-join Normalization (this chapter), Group-Ungroup and Wrap-Unwrap Normalization, Restriction-Union Normalization, Surrogate Keys, and Representing ‚ÄúEntity Subtypes‚Äù. The reader should be warned, though, that relational database theory has very little science to offer regarding database design, and what little science it does offer is almost entirely within the first of these topics, projection-join normalization, to which the rest of this chapter is devoted. For the others, described in Chapter 8, we can do no more than make note of the choices and suggest some guidelines.

7.2	

Avoiding Redundancy

A common issue in database design concerns redundancy‚Äîrecording the same information more than once. For example, redundancy is exhibited in this book‚Äôs very first example of a relation: Figure 1.2 in Chapter 1, where the information that student S1‚Äôs name is Anne is recorded twice. The explanation accompanying this figure indicates that the relation is the current value of a relvar named ENROLMENT, so we can safely conclude that the possibility of redundancy is a consequence of the database design‚Äîa student‚Äôs name is recorded as many times as that student has concurrent enrolments.

175
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

As a rule of thumb we assume that redundancy is normally to be avoided. Intuitively it seems untidy and possibly inefficient to record the same fact more than once. Stating S1‚Äôs name repeatedly for each course she is enrolled on obviously entails more work than stating it just once. What‚Äôs more, we have to be certain she is given the same name, spelled the same way, every time, and making sure of that entails more work too. In Chapter 4, Figure 4.1 shows an alternative design involving the two students‚Äô names are avoided: each name is recorded just once, in IS_CALLED. In the same chapter, IS_ENROLLED_ON is the very one shown in Figure 1.2. Later in the same chapter, Section 4.6 Section 4.4 JOIN and AND, I showed that the relation denoted by the expression IS_CALLED JOIN relvars, IS_CALLED and IS_ENROLLED_ON. In that preferred design the redundant repetitions of

Projection and Existential Quantification, Example 4.5, I showed how we can use projection to decompose ENROLMENT into those two relvars, IS_CALLED and IS_ENROLLED_ON. (Please ignore, Boris‚Äînot represented in Figure 1.2, rendering the designs not exactly equivalent. I‚Äôll come back to this point later.) Each projection gives us (a) the heading for one of those relvars, and (b) the initial value for the same relvar. So, we have two designs‚Äîlet‚Äôs call them Design A and Design B‚Äîthat are equivalent in the following sense: if Design A (single relvar) is chosen, then the current value for Design B can always be obtained using projection, whereas if Design B is chosen, then the current value for Design A can always be obtained using JOIN. Projection-join normalization concerns design choices of that for the moment, the fact that Figure 4.1 actually includes some information‚Äîthat student S5 is called

particular kind.

When something can be expressed in two or more equivalent ways, we sometimes have reason to prefer just one of those ways. For example, the fraction expressing ‚Äútwo thirds‚Äù is normally written as ‚Öî in preference to, say, 4‚ÅÑ6. The term normal form refers to such preferences (canonical form means the same thing, but normal form is the term conventionally used in the relational database context). Various normal forms have been defined for relvars. When a proposed relational database design includes a relvar that does not satisfy a certain normal form, normalization is the process by which that relvar can be replaced by one or more different relvars that do satisfy that normal form and still meet the original requirements. Projection-join normalization is a process whereby normal forms are obtained using projections, such that joins can be used to reverse the process. We need to understand in what circumstances we can indeed use projections for this purpose, in what circumstances it is advantageous to do so, and in what circumstances it might be better not to do so. We turn to these issues in the next section.

176
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

7.3	

Join Dependencies

A given relvar r can be decomposed into two or more relvars to yield an equivalent design only when r is subject to a special kind of constraint called a join dependency. Figure 7.1 depicts the current value of a relvar, WIFE_OF_HENRY_VIII that is subject to such a constraint. (Students of English history during the period of the Tudor dynasty, 1485‚Äì1603, are traditionally taught the mnemonic, ‚Äúdivorced, beheaded, died, divorced, beheaded, survived‚Äù by which to remember what became of each of King Henry VIII‚Äôs six wives.) WIFE_OF_HENRY_VIII
Wife# FirstName LastName

Fate divorced beheaded died divorced beheaded survived

1 2 3 4 5 6

Catherine Anne Jane Anne Catherine Catherine

of Aragon Boleyn Seymour of Cleves Howard Parr

Figure 7.1: Example to illustrate join dependency

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

177
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Note first of all that this design does not exhibit redundancy. The example is given merely to introduce you to the concept of join dependency, using a simple case to illustrate it. The predicate for WIFE_OF_HENRY_VIII is ‚ÄúThe first name of Henry VIII‚Äôs wife number Wife# is FirstName and her last name is LastName and Fate is what became of her.‚Äù The appearances of the word ‚Äúand‚Äù in this predicate indicate that it is ‚Äúdecomposable‚Äù into two or more simpler predicates. For example: 1.	 ‚ÄúThe first name of Henry VIII‚Äôs wife number Wife# is FirstName.‚Äù 2.	 ‚ÄúThe last name of Henry VIII‚Äôs wife number Wife# is LastName and Fate is what became of her.‚Äù The relations corresponding to predicates 1 and 2 are shown, in Figure 7.2, as the current values of relvars W_FN (wives‚Äô first names) and W_LN_F (wives‚Äô last names and fates), respectively. 		W_FN				W_LN_F
Wife# FirstName

Wife# 1 2 3 4
5

LastName of Aragon Boleyn Seymour of Cleves
Howard

Fate divorced beheaded died divorced beheaded survived

1 2 3 4 5 6

Catherine Anne Jane Anne Catherine Catherine

6

Parr

Figure 7.2: A decomposition of WIFE_OF_HENRY_VIII

Note that ‚Ä¢	 W_FN = WIFE_OF_HENRY_VIII {Wife#, FirstName} ‚Ä¢	 WIFE_OF_HENRY_VIII = W_FN JOIN W_LN_F

‚Ä¢	 W_LN_F = WIFE_OF_HENRY_VIII {Wife#, LastName, Fate}

The constraint determining that WIFE_OF_HENRY_VIII can be decomposed and subsequently Example 7.1, Example 7.1: A constraint condition expressing a join dependency WIFE_OF_HENRY_VIII = WIFE_OF_HENRY_VIII {Wife#, FirstName} JOIN

recomposed in these ways is a join dependency. The join dependency can be defined as shown in

WIFE_OF_HENRY_VIII {Wife#, LastName, Fate}

178
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

but, as we shall see, that constraint is actually implied by the KEY specification given in the relvar definition for WIFE_OF_HENRY_VIII and so does not need to be spelled out again. A join dependency, commonly abbreviated JD, is any condition that can be expressed in this form, denoting that a given conventional notation for join dependencies we can write the one in Example 7.1 as follows: * { { Wife#, FirstName }, { Wife#, LastName, Fate } } For convenience, I shall refer to the components of a JD‚Äî{ Wife#, FirstName } and { Wife#, the JD. This one is of degree 2 and is therefore called a binary JD. The symbol * is often used in textbooks

relvar is at all times equal in value to the join of two or more projections of its current value. Using the

LastName, Fate } in this example‚Äîas projections, and the number of projections as the degree of for the join operator. Because the operands of a JD are projections they are indicated by lists of attribute names enclosed in braces; those operands are in turn enclosed in braces because in general a join dependency can involve any number of projections and, thanks to the commutativity and associativity of the join operator, the order in which those projections are written is insignificant. Note that the formulation shown for one of the JDs to which WIFE_OF_HENRY_VIII is subject makes applies. We normally do that by stating whether the given JD holds in that relvar. The JD in our example does indeed hold in WIFE_OF_HENRY_VIII. By contrast, the JD * { { Wife#, FirstName }, { LastName, Fate } } for example, does not hold in that relvar, because the following tuple, among several others, appears in the join of those two projections but does not appear in the current value of WIFE_OF_HENRY_VIII: TUPLE { Wife# 2, FirstName 'Anne',

no mention of that relvar. Whenever we mention a JD it must be clear from the context to which relvar it

LastName 'Parr', Fate 'survived' }

name of wife number 3, for example. Conversely, in the join we ‚Äúgain‚Äù the misinformation represented by those tuples that do not appear in WIFE_OF_HENRY_VIII. To put it more accurately, the predicate is different too. (Exercise for the reader: what predicate does apply to it?) for WIFE_OF_HENRY_VIII does not apply to the result of this join, so the information represented

Note that in the projection over {¬†LastName,¬†Fate¬†} we lose the information that Seymour is the last

Note that a JD cannot possibly hold in its applicable relvar, r, unless each attribute of r appears in at least one of the projections. If that is not the case, then the join of those projections does not have the same heading as r and therefore cannot be equal to r.

179
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

You have probably noticed that W_LN_F, in whose predicate the word ‚Äúand‚Äù still appears, can be further We say that relvar W_FN is an irreducible relvar. We also say that relvar W_FN is in sixth normal form

decomposed. I‚Äôll come back to this point in a moment. W_FN, however, cannot be further decomposed. (6NF), whereas W_LN_F is not in 6NF and nor is WIFE_OF_HENRY_VIII. You are right in guessing

from the name, sixth normal form, that other normal forms have been identified, at least five of which are identified by numbers. In fact several others have been defined around the idea of eliminating certain JDs, varying according to exactly which particular kinds of JD they eliminate. Fortunately, some of them can now safely be regarded as preliminary ideas by researchers, later subsumed by more general and more useful definitions. Nowadays it is sufficient to study just three ‚ÄúJD-eliminating‚Äù normal forms. In this book I refer to them as projection-join normal forms, but please note that the term projection-join normal form (PJ/NF) is used by some writers‚Äîincluding its originator, Fagin [13]‚Äîto refer specifically to just one of these three (namely, 5NF). As it happens, 6NF is the strongest projection-join normal form that can be defined, because the only JDs that can hold in a 6NF relvar are ones that cannot be eliminated at all. 6NF is also perhaps the easiest to understand because the class of JDs eliminated by it is simple to define, as I will now show.

180
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Trivial and Nontrivial JDs 6NF doesn‚Äôt eliminate all JDs. Take W_FN, for example. The following JDs, among others, all hold in W_FN: ‚Ä¢	 * { { Wife#, FirstName }, { Wife# } } ‚Ä¢	 * { { Wife#, FirstName }, { } } ‚Ä¢	 * { { Wife#, FirstName } }

‚Ä¢	 * { { Wife#, FirstName }, { FirstName } }

That last one is a unary JD. Exactly one unary JD holds in every relvar, namely the one whose projection includes all the attributes. It is of no importance, of course. We admit it as a JD simply to avoid a needless complication in the definition of that term. In each of the JDs shown above, one of the projections is the identity projection (i.e., over all the attributes of the applicable relvar). A moment‚Äôs thought should convince you that a JD involving the identity projection cannot fail to hold in its applicable relvar. To spell it out, though, in general, if r2 is a projection of r1, then r1¬†JOIN¬†r2 is equal to r1; for every tuple of r2 is by definition a subset of some tuple of r1 and therefore matches at least one tuple of r1. Moreover, every tuple t2 of r2, when joined with a tuple t1 of r1, yields that tuple t1. We say, therefore, that a JD that includes the identity projection of its applicable relvar is trivial. The classification of JDs into trivial and nontrivial ones enables us easily to define 6NF:
Relvar r is in sixth normal form (6NF) if and only if every join dependency that holds in r is trivial.

We will now complete the decomposition of WIFE_OF_HENRY_VIII into relvars that are all in 6NF. Then we will be able to think about the relative advantages and disadvantages of the two designs. Further Decomposition of WIFE_OF_HENRY_VIII The JD * { { Wife#, LastName }, { Wife#, Fate } } holds in W_LN_F and is nontrivial. W_LN_F can therefore be decomposed as shown in Figure 7.3. 			W_LN				W_F
Wife# 1 2 3 4 5 6 LastName of Aragon Boleyn Seymour of Cleves Howard Parr Wife# 1 2 3 4 5 6 Fate divorced beheaded died divorced beheaded survived

Figure 7.3: Further decomposition of WIFE_OF_HENRY_VIII

181
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Although I decomposed WIFE_OF_HENRY_VIII in two stages, I could of course have done it in a single step. Had I done so, I might have been looking at the following single JD‚Äîa ternary JD (having three projections) that holds in WIFE_OF_HENRY_VIII‚Äîin place of the two that governed my previous two stages:

* { { Wife#, FirstName }, { Wife#, LastName },{ Wife#, Fate } } Now W_LN and W_F are both, like W_FN, in 6NF. By contrast, WIFE_OF_HENRY_VIII is not in 6NF.

Might it be better to decompose it into those 6NF relvars? We must examine the two designs in detail to assess the situation and come to a decision. Assessment of 6NF decomposition

So far we have shown only the structural aspects of two equivalent designs to be considered. Design A is the single relvar design; Design B uses the three 6NF relvars, W_FN, and W_LN, and W_F. Here are the relvar definitions for the two designs: Design A VAR WIFE_OF_HENRY_VIII BASE RELATION { Wife# INTEGER, FirstName CHAR, LastName CHAR, KEY { Wife# } ; Design B VAR W_FN BASE RELATION { Wife# INTEGER, KEY { Wife# } ; Fate CHAR }

FirstName CHAR }

VAR W_LN BASE RELATION { Wife# INTEGER, KEY { Wife# } ;

LastName CHAR }

VAR W_F BASE RELATION { Wife# INTEGER, KEY { Wife# } ; Fate CHAR }

182
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

To assess these alternative designs we need to consider also the constraints that must be applied to those relvars to complete the designs. Assuming that Design A is correct, we can infer some of the requirements, which I express as the following business rules: BR1:	 Every wife has a wife number. BR2:	 No two distinct wives have the same wife number. BR3:	 Every wife has a first name. BR4:	 Every wife has a last name. BR5:	 Every wife has a fate. BR1, BR3, BR4, and BR5 are implied by the very structure of relvar WIFE_OF_HENRY_VIII, because every tuple in the body of a relation has exactly one value for every attribute of that relation, by definition. relvar definitions of Design B, apart from BR1. As things stand, the keys defined for the three relvars BR2 is implied by the specification KEY { Wife# }. But these business rules are not reflected in the prevent any wife from having more than one first name, last name, or fate, but it is possible for a wife to have a wife number but no first name, or no last name, or no fate. So the ‚Äúexactly one‚Äù stipulations of BR3, BR4, and BR5 are not met. As for BR2, all we can say is that no two wives with first names have the same wife number, nor do any two wives with last names, nor do any two wives with fates. To enforce the given business rules we need a constraint to the effect that every wife number appearing in any one of those three relvars appears in the other two as well. In Tutorial D we could express that as shown in Example 7.2.
Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

183
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Example 7.2: Enforcing BRs 1 to 5 in Design B CONSTRAINT BRs_1_to_5

W_FN { Wife# } = W_LN { Wife# } AND W_LN { Wife# } = W_F { Wife# } AND W_FN { Wife# } = W_F { Wife# } ;

(Any one of those three conjuncts can of course be omitted as implied by the other two.) It is this constraint‚Äîhowever it is expressed‚Äîthat makes Design B significantly more complex than Design A. (It gives rise to a performance challenge for the DBMS, too. That could perhaps be addressed by provision of some suitable shorthand but note that in SQL systems, which process foreign key constraints efficiently, we would need no less than six foreign key definitions, two for each relvar.) There are also unpleasant implications for certain kinds of update in Design B. To ‚Äúinsert a new wife‚Äù or ‚Äúdelete a wife‚Äù we need multiple assignment on all three relvars. That‚Äôs not available in existing commercial DBMSs (in 2009) but the alternative solutions typically provided are no less complicated in their implementation. (Foreign keys are discussed in Chapter 6, Section 6.4, under the heading Foreign Keys. Multiple assignment is described in Section 6.5 of that chapter, under the heading Multiple Assignment.) It seems there is little to commend Design B for the particular example at hand, apart, perhaps, from the fact that an update affecting just one of the three relvars will not interfere with other users‚Äô access to the other two while that update is in process. Now, the foregoing analysis assumes that Design A and Design B are both correct. But imagine the database existing during the lifetime of King Henry VIII, the designer having chosen Design A. Anne Boleyn has lost her head and the king has just married Jane Seymour, which wife must now be added to the database. What value is to be given for the attribute Fate? ‚ÄòTo be determined‚Äô, perhaps? Or the empty character string? In either case, the predicate I gave for WIFE_OF_HENRY_VIII, including the words ‚Äúand Fate is what happened to her‚Äù, is no longer applicable. Nor is business rule BR5.

Perhaps a separate relvar for recording the wives‚Äô fates, where known, would be a good idea after all, allowing us to record Jane Seymour‚Äôs wife number, first name, and last name without recording anything regarding the fate of her marriage. Suddenly I am touching on one of the most difficult and controversial issues surrounding relational database theory and practice: the so-called problem of ‚Äúmissing information‚Äù, addressed in SQL by the introduction of an innocent-looking little thing that actually undermines the very foundations of relational theory by allowing this thing‚Äîcalled NULL‚Äîto appear in place of an attribute value (NULL is not a value and consequently gives rise to some very strange phenomena when it appears in place of a value). Further discussion of NULL is beyond the scope of the present book but is dealt with in detail in its companion book SQL: A Comparative Survey. Here we assume that a correct design obviates the need to worry about ‚Äúwhat to put when there is nothing to put‚Äù by not requiring anything to be put! But even then there are choices to consider and these are discussed in Chapter 8, Section 8.4, Representing ‚ÄúEntity Subtypes‚Äù.
184
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Returning to the subject of projection-join normalization, I have explained 6NF and noted that relvar WIFE_OF_HENRY_VIII is not in 6NF but, assuming it is a correct design for the given requirements, is very likely to be preferred to a 6NF design. Although certain nontrivial join dependencies hold in it, name is recorded more than once) and you have already seen how decomposition, into IS_CALLED it exhibits no redundancy. By contrast, ENROLMENT does exhibit redundancy as already noted (Anne‚Äôs with attributes StudentId and Name and IS_ENROLLED_ON with attributes StudentId and that the two projections by which it was achieved constitute a JD that holds in ENROLMENT: * { { StudentId, Name }, { StudentId, CourseId } } If decomposition is desirable for ENROLMENT but not for WIFE_OF_HENRY_VIII, then there

CourseId, addresses that problem. Because this decomposition was available to us, we can conclude

must be some difference in kind between the JD that holds in ENROLMENT and those that hold in WIFE_OF_HENRY_VIII. It is this difference that allows us to define a projection-join normal form hear that it is called fifth normal form (5NF). that is not as strong as 6NF but is much more desirable, in general, than 6NF. You won‚Äôt be surprised to

7.4	

Fifth Normal Form

WIFE_OF_HENRY_VIII is in 5NF. So are IS_CALLED and IS_ENROLLED_ON, but ENROLMENT with its distinguishing feature shown in bold:

is not. What is special about that ternary JD that holds in WIFE_OF_HENRY_VIII? Here it is again,

* { { Wife#, FirstName }, { Wife#, LastName }, { Wife#, Fate} } There are two significant points to be made about the attribute Wife#: a)	 It appears in each projection of the JD. b)	 { Wife# } is a key of WIFE_OF_HENRY_VIII (in fact the only key). By contrast, consider * { { StudentId, Name }, { StudentId, CourseId } }, the JD holding in ENROLMENT. Although its projections have an attribute, StudentId, in common, that common attribute does not constitute a key of ENROLMENT, and that is what gives rise to the redundancy in this

particular case. Although student identifier S1 is always paired with the same name, Anne, that pairing can appear in several different tuples in the current value of ENROLMENT. By contrast, the pairing of a particular wife number with a particular first name, last name, or fate, cannot possibly appear in several different tuples of WIFE_OF_HENRY_VIII, because it is not even possible for the same wife number to appear in more than one tuple, thanks to the constraint implied by the specification KEY { Wife# }. These observations, among others, lead us to a definition for fifth normal form.

185
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Relvar r is in fifth normal form (5NF) if and only if every join dependency that holds in r is implied by the keys of r.

WIFE_OF_HENRY_VIII satisfies this definition because every JD that holds in it is one in which every

projection either includes its only key, {Wife#}, or is redundant. (A projection is redundant if all of its attributes are included in one of the other projections. For example, every trivial JD contains at least a JD that holds, then the resulting JD also holds.) In other words, given the complete relvar definition for WIFE_OF_HENRY_VIII in Tutorial D, thus knowing only its attributes and its single key, we can write down every JD that holds in it: one redundant projection. You can verify for yourself that if a redundant projection is removed from

‚Ä¢	 * { { Wife#, FirstName }, { Wife#, LastName }, { Wife#, Fate} } ‚Ä¢	 * { { Wife#, FirstName, LastName }, { Wife#, Fate} } ‚Ä¢	 ‚Ä¶ and so on ‚Ä¢	 * { { Wife#, FirstName, Fate }, { Wife#, LastName }, {Fate} }

(The third one listed above includes a redundant projection, {Fate}.)

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

186
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

For convenience in the discussion that follows, I use the following terms: ‚Ä¢	 rogue JD for a JD that does not satisfy the condition given in the foregoing definition of 5NF ‚Ä¢	 5NF relvar for a relvar that is in 5NF ‚Ä¢	 non-5NF relvar for a relvar that is not in 5NF Now, a 5NF relvar is guaranteed never to exhibit redundancy of the kind that can be eliminated by projection-join normalization. Contrary to what I wrote here in the first edition of this book, non-5NF relvars do exist that are redundancy-free (i.e., do not exhibit redundancy), but the discovery of such relvars didn‚Äôt come about until after 2009 when the first edition was written. For present purposes, let us assume, albeit falsely, that 5NF is both sufficient and necessary for avoiding such redundancy. It is generally held that we should aim for designs consisting exclusively of 5NF relvars, because of an overarching need to avoid redundancy. In any case, if there appear to be good reasons for not going to that extreme, the designer should be well aware of the potential costs involved in violating 5NF. Let us therefore have a closer look at the non-5NF relvar ENROLMENT to discover the problems caused by the redundancy it exhibits. Here is a relvar definition for it:

VAR ENROLMENT BASE RELATION { StudentId SID, Name NAME, CourseId CID }

KEY { StudentId, CourseId } ; We can infer from this definition that a student, enrolled on a course, has exactly one name in connection with that enrolment. But actually there is a business rule to the effect that every student has exactly one name, regardless of enrolments. Student S1 is always called Anne. That rule is exactly what the JD * { { StudentId, Name }, { StudentId, CourseId } } really means, and we cannot infer that JD from the relvar definition‚Äîthe attributes and key‚Äîalone. To show that we can infer it from the given business rules, consider what happens if S1‚Äôs name is recorded as Anne for course C1 but Ann (without the ‚Äúe‚Äù) for course C2. In that case the tuples TUPLE { StudentId SID('S1'), Name NAME('Anne') } and TUPLE { StudentId SID('S1'), Name NAME('Ann') } both appear in the join of that projection with ENROLMENT{StudentId, CourseId}: TUPLE { StudentId SID('S1'), Name NAME('Anne'), CourseId CID('C1') } appear in the projection ENROLMENT{StudentId, Name} and therefore the following tuples both

TUPLE { StudentId SID('S1'), Name NAME('Ann'), CourseId CID('C1') }

187
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

But the second of those does not appear in ENROLMENT. Therefore the constraint defined by that JD does not hold after all and the business rule it would express is violated. To enforce that business rule we need to define an appropriate constraint. Following Example 7.1 we could write, in Tutorial D, CONSTRAINT JD_in_ENROLMENT

ENROLMENT = JOIN { ENROLMENT {StudentId, Name},

ENROLMENT {StudentId, CourseId} } ;

or, less directly, CONSTRAINT JD_in_ENROLMENT

COUNT (ENROLMENT {StudentId, Name} = COUNT (ENROLMENT {StudentId} ;

there are distinct StudentId values, which implies that no StudentId value is paired with more than one Name value.

meaning that there are as many distinct <StudentId, Name> pairs appearing in ENROLMENT as

Now, look at the database design for the decomposition into IS_CALLED and IS_ENROLLED_ON. First, its structural part:

VAR IS_CALLED BASE RELATION { StudentId SID, KEY { StudentId } ; VAR IS_ENROLLED_ON BASE RELATION { StudentId SID, KEY { StudentId, CourseId } ; We must check the business rules that (presumably) led to the single relvar design, with its constraint JD_in_ENROLMENT, to determine what additional constraints need to be included in the new design. Here are those business rules: BR1:	 An enrolment is uniquely identified by a student identifier and a course identifier. BR2:	 A student enrolled on a course has exactly one name for that enrolment. BR3:	 All enrolments for the same student have the same name for that student. BR4:	 Every student whose name is recorded is enrolled on at least one course.‚Ä© CourseId CID } Name NAME }

188
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Now, how does our proposed new design address those business rules? ‚Ä¢	 BR1 is implied by KEY { StudentId, CourseId } in the declaration for no non-key attributes).

IS_ENROLLED_ON (and is in any case implied by the heading of that relvar, there being

‚Ä¢	 For BR2 we need an additional constraint to ensure that at no time does any tuple in IS_ENROLLED_ON fail to match some tuple in IS_CALLED. That‚Äôs a foreign key constraint on StudentId in IS_ENROLLED_ON, which we might express in Tutorial¬†D as CONSTRAINT Student_must_have_a_name

‚Ä¢	 For BR3 we need to consider the join of IS_CALLED and IS_ENROLLED_ON. Thanks to the key constraint expressed by KEY { StudentId } in the declaration for

IS_EMPTY ( IS_ENROLLED_ON NOT MATCHING IS_CALLED ) ;

tuple in IS_ENROLLED_ON can possibly match more than one tuple in IS_CALLED. So the new design does already enforce BR3. ‚Ä¢	 For BR4 we need a constraint similar to that for BR2 but ‚Äúin the other direction‚Äù, so to

IS_CALLED, that join is always ‚Äúmany-to-one‚Äù, as opposed to ‚Äúmany-to-many‚Äù, because no

speak, to ensure that at no time does any tuple in IS_CALLED fail to match some tuple in IS_ENROLLED_ON: CONSTRAINT Student_must_be_enrolled_on_some_course

(This is not a foreign key constraint. Why not?)

IS_EMPTY ( IS_CALLED NOT MATCHING IS_ENROLLED_ON ) ;

The constraints for BR2 and BR4 together imply that at all times the set of StudentId values appearing we could address those two constraints quite simply like this:

in IS_CALLED must be equal to the set of StudentId values appearing in IS_ENROLLED_ON, so

CONSTRAINT Being_enrolled_equivalent_to_having_a_name

IS_CALLED { StudentId } = IS_ENROLLED_ON { StudentId } ;

Such a constraint is called an equality dependency.

189
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

As we have already seen, equality dependencies are a bit of a challenge for the DBMS and in most commercial DBMSs existing in 2009 it cannot even be expressed. However, in those same DBMSs the JD constraint required for ENROLMENT cannot be expressed either, so neither of the designs is fully implementable in the current technology! (Workarounds for SQL databases, using triggered procedures, are described in depth in reference [14].) If we can express both of those constraints, then, on the evidence so far, there doesn‚Äôt seem to be a lot to choose between the two designs and our decision is more likely to be based on how well the DBMS supports multiple assignments; if we can‚Äôt express the constraints, then the stated requirements cannot be met and we will have to compromise (and perhaps rely on application code to maintain integrity). But efficacy of constraint checking isn‚Äôt the only criterion to guide our choice. What if, for example, student S1‚Äôs name is incorrectly recorded as ‚ÄúAnn‚Äù and needs to be corrected to ‚ÄúAnne‚Äù? In the unnormalized design that correction will entail updates to several tuples in ENROLMENT, whereas in the 5NF design just one tuple in IS_CALLED is affected. On the other hand, a query to give the names of all the students enrolled on course C1 is simpler to express (and might run faster) in the unnormalized design. A frequent complaint about rigorous application of 5NF is that the decomposition causes too many joins to have to be used in queries. Advocates of 5NF respond by pointing out that the query to find the names of all the students is simpler to express (and might run faster) in the 5NF design!

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

190
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

It does seem that the 5NF design has a certain aesthetic appeal, giving a structure that is reduced to simpler terms and is thus in a sense more flexible. Also, an abiding motivation for the relational approach is that in principle the database designer need not anticipate the kinds of queries that will be presented to the DBMS. A 5NF design ‚Äúlevels the playing field‚Äù in keeping with that principle. Moreover, the discussion so far has been based on the assumption that the single relvar design, from which we inferred those business rules, is correct, an assumption we might well question. In particular, we might question BR4: ‚ÄúEvery student whose name is recorded is enrolled on at least one course‚Äù. Does the university really require every student to be always enrolled on at least one course, even during the annual long vacation? What harm comes if that rule is relaxed? In that case the single relvar design becomes incorrect‚Äîand in any case we still need that complex and difficult constraint to express the JD. With the 5NF design the difficult equality dependency becomes replaced by a simple foreign key constraint to address BR2 and BR3. Now, if 5NF is indeed a goal to be earnestly pursued, then some questions arise. How does the designer discover that a relvar under consideration is not in 5NF? How do we spot the rogue JDs‚Äîthe nontrivial ones that do not arise simply as a consequence of keys? Well, there is an algorithm, given by Fagin (see the annotation for reference [13] in Appendix A) for determining whether a given JD is implied by the keys of the relvar to which it pertains, but as I mentioned earlier, some 30 years after the publication of reference [13] 5NF was discovered to be ‚Äútoo strong‚Äù for the purpose at hand. The details are in reference [8], which defines ‚ÄúEssential Tuple Normal Form‚Äù (ETNF). ETNF is both sufficient and necessary for the purpose at hand. Its definition is too complicated to be repeated here but happily it turns out to be easier to test for than 5NF, as we shall eventually see (the test depends on Boyce-Codd Normal Form, which is defined in Section 7.8). Tests on JDs are all very well, but how can we determine the nontrivial JDs that hold in a proposed relvar? You have to examine the business rules and that‚Äôs not always an easy task. However, a certain special kind of JD has been identified such that when it holds in a given relvar r, r is not in ETNF (and therefore not in 5NF). Not all ETNF-violating JDs are of this kind, but in practice most of them are. If we can eliminate such JDs we stand a reasonable chance of achieving ETNF by that action alone and any remaining rogue JDs should be quite easy to detect. A useful theory has been developed around this special kind of JD, making it possible to mechanize certain important aspects of relational database design. This special kind of JD is one that is a direct consequence of another kind of constraint to which a relvar might be subject, called a functional dependency. There now follows a comparatively long dissertation on the concept‚Äîfunctional dependence‚Äîthat surrounds functional dependencies, and, arising from that concept, keys. You need a good grasp of these topics before we can return to this special class of JD and discover the normal form that arises from it.

191
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

7.5	

Functional Dependencies

Here again is the rogue JD that holds in ENROLMENT: * { { StudentId, Name }, { StudentId, CourseId } } Note the following points of significance: 1.	 It is a binary JD. 2.	 One of its two projections involves every attribute of a key of the relvar in which it holds. 3.	 The other projection, {StudentId, Name}, does not involve every attribute of that key (if it did, the JD would not be a rogue JD). 4.	 The relvar, IS_CALLED, arising from that other projection has a key that is a proper subset it is common practice to use the term to refer to a set of unaccompanied attribute names when no confusion can arise.)

of its heading. (Strictly speaking a heading is a set of <attribute name, type name> pairs, but

192
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Consider this last point. We can tell by inspection that it must hold, because otherwise IS_CALLED would represent a many-to-many mapping between student identifiers and names: the same student could have several names and several students could have the same name, in which case {StudentId, CourseId} would not be a key of IS_ENROLLED_ON. We can also tell that the proper subset in question must be {StudentId}. If instead it were {Name}, then again it would be possible for the same

violating its given key constraint. So, in both designs we can say that no StudentId value appears

combination of StudentId and CourseId values to appear in more than one tuple of ENROLMENT,

in combination with more than one Name value in the relvar whose heading contains both of those attributes. In one of those relvars, ENROLMENT, the same combination can appear more than once; in in both of these relvars is called a functional dependency, denoted thus: { StudentId } ‚Üí { Name } The arrow in this notation is often pronounced ‚Äúdetermines‚Äù, so the whole expression can be pronounced ‚ÄúStudentId determines Name‚Äù‚Äîand so it does: given a student identifier we can determine the name that goes with it because there is only one such name. However, we shall soon see that ‚Äúdetermines‚Äù doesn‚Äôt always work so well and sometimes we have to fall back on just ‚Äúarrow‚Äù. The reader with a mathematical bent will recognize that the set of <StudentId, Name> pairs the other, IS_CALLED, it cannot. The condition concerning student identifiers and names that holds

constituting the body of the projection of ENROLMENT over those two attributes is a function, which

justifies the chosen term, functional dependency. By convention and henceforth in this chapter we abbreviate it to FD. The FD {¬† StudentId¬† }¬† ‚Üí¬† {¬† Name¬† } is said to hold in ENROLMENT, also in IS_CALLED. Equivalently, we say that relvars ENROLMENT and IS_CALLED each satisfy that FD.

Note that the left-hand side and right-hand side of an FD are both enclosed in braces, signifying that the enclosed elements constitute a set. The set on the left is called the determinant, that on the right the dependant. The term dependant is also used for each element of the right-hand side. For an example where more than one dependant appears on the right we need go no further than WIFE_OF_HENRY_VIII, in which the FD

{ Wife# } ‚Üí { FirstName, LastName, Fate }

193
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

holds. Wife# determines each of FirstName, LastName, and Fate, so there are three FDs having the same determinant. Our notation allows them to be expressed as a single FD. A similar observation does not apply to the determinant. consider EXAM_MARK, for example, (Chapter 5, Figure 5.1). Its relvar definition is

VAR EXAM_MARK BASE RELATION { StudentId SID, CourseId CID Mark INTEGER }

KEY { StudentId, CourseId } ; So the following FD holds in EXAM_MARK: { StudentId, CourseId } ‚Üí { Mark } Now we see why the pronunciation ‚Äúarrow‚Äù is safer in general than ‚Äúdetermines‚Äù. The pronunciation ‚ÄúStudentId, CourseId determines Mark‚Äù doesn‚Äôt work so well, but nor does making the verb plural to match its subject: ‚ÄúStudentId, CourseId determine Mark‚Äù. The latter pronunciation might lead the listener to conclude, incorrectly, that StudentId determines Mark and CourseId determines

Mark. For each pairing of a StudentId value with a CourseId value in EXAM_MARK there is exactly one mark, but the same student can obtain different marks for different courses and the same course can have different marks for different students. So neither of the FDs {¬†StudentId¬†}¬†‚Üí { Mark } and

{ CourseId } ‚Üí { Mark } holds in EXAM_MARK.

In the following formal definition for FD, note the parallels with the definition of superkey given in Chapter 6, Section 6.4 under the heading Keys. It uses both relational projection and tuple projection
Definition of FD Let A and B be subsets of the heading of relvar r. Then the FD A¬†‚Üí¬†B holds in r if and only if, at all times, if tuples t1 and t2 both appear in the body of the projection r{AÔÄ¥B}, and the projection t1{A} is equal to the projection t2{A}, then t1 = t2 (they are the same tuple)

Given a set of FDs assumed to hold in relvar r, we can infer further FDs that must also hold in r. The inference rules used for this purpose are known as Armstrong‚Äôs Axioms because they first appeared in a paper by Armstrong [2]. One way of expressing these rules is as follows. Let A, B, and C be arbitrary subsets of the heading of r. Then we have the following theorems (using the symbols ‚ÄúÔÄ¥‚Äù and ‚Äú‚Äì‚Äù for set union and set difference, respectively): 1.	 Reflexivity: If B is a subset of A, then A ‚Üí B 2.	 Augmentation: If A ‚Üí B, then A ÔÄ¥ C ‚Üí B ÔÄ¥ C 3.	 Transitivity: If A ‚Üí B and B ‚Üí C, then A ‚Üí C

194
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

From these three we can derive: 4.	 Self-determination: A ‚Üí A 5.	 Decomposition: If A ‚Üí B and C is a subset of B, then A ‚Üí C and A ‚Üí B-C 6.	 Union: If A ‚Üí B and A ‚Üí C, then A ‚Üí B ÔÄ¥ C 7.	 Composition: If A ‚Üí B and C ‚Üí D, then A ÔÄ¥ C ‚Üí B ÔÄ¥ D All of these except the first and fourth can be seen as special cases of 8.	 Unification: If A ‚Üí B and C ‚Üí D, then A ÔÄ¥ (C‚ÄîB) ‚Üí B ÔÄ¥ D Given a relvar r and a set S of FDs assumed to hold in r, theorems 1 and 8 alone are sufficient to determine all the FDs in r that are implied by S. That set of FDs is called the closure of S, written as S+.

195
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Interesting Special Cases of FDs In the following discussions, to save repetition, all FDs mentioned are assumed to hold in relvar r unless otherwise stated, and the symbol C refers to the set of all the FDs that hold in r. Now, in general C contains FDs that are redundant in the sense that they are implied under the given inference rules by other FDs in C. For example, C might contain {a} ‚Üí {b}, in which case it must also contain {a} ‚Üí cover for S2. We are interested in finding proper subsets S of C where S is a cover for C and there is no {a, b}. We say that if S1 and S2 are sets of FDs and every FD in S2 is implied by those in S1, then S1 is a proper subset of S that is also a cover for C. In that case, to enforce all the FDs in C it is sufficient for the DBMS just to enforce those in S‚Äîthe others will all be enforced ‚Äúautomatically‚Äù, as a logical consequence. Consideration of the special classes of FD that now follow helps us to find such sets. Most of the terms defined for these special classes are used conventionally in the literature, but I add some of my own. Empty dependants Because the determinant and dependant of an FD are both sets, we have to consider the possibility of either or both being the empty set, {¬† }. Theorem 5, Reflexivity, tells us that for every subset A of the heading of r, A ‚Üí {¬†} holds in r. In particular {¬†} ‚Üí {¬†} holds in r. If we eliminate from C all the FDs having empty dependants, then the resulting subset is clearly a cover for C. Empty determinants Much more interesting is the case, {¬†} ‚Üí B, where B is nonempty. This FD is satisfied only when each attribute a of B is such that a has the same value in each tuple of r‚Äîin other words, a is constant in r. If you need to be convinced of this fact, check it using the formal definition for FD given earlier. When A is the empty set, t1{A} and t2{A} are both the 0-tuple. It follows that every tuple of r has the same value (the 0-tuple) for the determinant of the FD and must therefore have the same value for the dependant. Note that if some FD in C has an empty determinant and we eliminate from C all the FDs having empty determinants, then the resulting subset is not in general a cover for C. Left-irreducible FDs A ‚Üí B is a left-irreducible FD if and only if there is no proper subset A‚Äô of A such that A‚Äô ‚Üí B also holds. Conversely, if there is such a proper subset, then it is left-reducible. If we eliminate from C all those that are left-reducible, then from the resulting subset S we can recover C by application of Theorem 2, Left Augmentation. Thus, S is a cover for C. Right-irreducible FDs A ‚Üí B is a right-irreducible FD if and only if B contains at most one attribute. If B contains more than one attribute, then the FD is right-reducible. If we eliminate from C all those that are right-reducible, then from the resulting subset S we can recover C by application of Theorem 6, Union. Thus, S is a cover for C.

196
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Right-extendible FDs A ‚Üí B is a right-extendible FD if and only if there is some proper superset B‚Äô of B such that A¬† ‚Üí¬† B‚Äô also holds. If we eliminate from C all those that are right-extendible, then from the resulting subset S we can recover C by application of Theorem 3, Decomposition. Thus, S is a cover for C. Overlapping FDs The FD A ‚Üí B is overlapping if A ÔÄ≥ B (where ‚ÄúÔÄ≥‚Äù denotes set intersection) is nonempty; otherwise it is non-overlapping. If we eliminate from C all those that are overlapping, then from the resulting subset S we can recover C by application of Theorem 6, Union. Thus, S is a cover for C. Trivial FDs The FD A ‚Üí B is trivial if B is a subset of A; otherwise it is nontrivial. Note that if B is empty, then A¬† ‚Üí¬† B is trivial but non-overlapping. If we eliminate from C all those that are trivial, then from the resulting subset S we can recover C by application of Theorem 5, Reflexivity. (Note that this elimination subsumes the elimination of FDs with empty dependants.) Thus, S is a cover for C. Interesting Cases of Sets of FDs We are interested in sets S of FDs, where no proper subset of S is a cover for the closure S+ of S. In general there can be many such subsets of S, of which two kinds are particularly useful. Irreducible covers A set S of FDs is irreducible if and only if it satisfies the following three conditions: 1.	 Every FD is S is right-irreducible. 2.	 Every FD is S is left-irreducible. 3.	 No proper subset of S is a cover for the closure S+ of S. If S does satisfy those three conditions, then it is an irreducible cover for S+. Note that condition 3 implies that S contains no overlapping FDs, no trivial ones, and none that are implied by others under Theorem 4, Transitivity. Some texts‚Äî[3], for example‚Äîuse the term nonredundant for sets that satisfy condition 3 but do not necessarily satisfy conditions 1 and 2. Minimal covers Let S1 be an irreducible cover for S+. Let the set S2 be derived from S1 as follows. Wherever two or more FDs in S1 have the same determinant A, replace those FDs by the single FD A¬† ‚Üí¬† B, where B is the union of the dependants of those FDs. Then S2 is a minimal cover for S+. (Alert: some texts use this term for irreducible covers.)

197
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

For example, the set { { StudentId } ‚Üí { Name } } is both an irreducible cover and a minimal

cover for all the FDs that hold in ENROLMENT. Note in particular that the FD {¬† StudentId, (given) and {¬† CourseId¬†}¬† ‚Üí¬†{¬† CourseId¬†} (self-determination).

CourseId }¬† ‚Üí¬†{¬† Name¬†} follows, under Theorem 8, Unification, from {¬† StudentId¬†}¬† ‚Üí¬†{¬† Name¬†}

7.6	Keys
You might wish to read again the material under the heading Keys in Chapter 6, Section 6.4, which gives the following definitions:
Definitions for superkey and key Let K be a subset of the heading of relvar r. Then K is superkey for r if and only if, at all times, if tuples t1 and t2 both appear in the body of r, and the projection t1{K} is equal to the projection t2{K}, then t1 = t2 (i.e., they are the same tuple). K is a key for r if and only if (a) K is a superkey for r and (b) no proper subset of K is a superkey for r.

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

198
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Appealing to FDs we can now give rather more concise definitions:
Let K be a subset of the heading H of relvar r. Then: ‚Ä¢	 ‚Ä¢	 K is a superkey of r if and only if FD K¬† ‚Üí¬† H holds in r K is a key of r if and only if FD K¬† ‚Üí¬† H is left-irreducible and holds in r

When a key is declared to the DBMS, only its uniqueness property is subsequently checked and maintained. Its irreducibility has to be the database designer‚Äôs responsibility, for at any time r might be assigned a value that satisfies a putative key constraint implied by some proper subset of the declared key. For example, it is probably not a design error if at some point in time no two tuples in that state is perhaps a little surprising (no more than one student on any of the courses). On the other hand, it definitely would be a design error to include Mark along with StudentId and CourseId in the declared key for EXAM_MARK, allowing the same student to score several different marks in the same exam. IS_ENROLLED_ON have the same CourseId value, even though the real world situation reflected by

It must be emphasized that a key is a set of attributes, not an attribute per se. EXAM_MARK has just one key, consisting of two attributes, StudentId and CourseId. It is a common error to misunderstand the definition and refer to the attributes constituting the key as if each one were itself a key. In general

a relvar can have several keys. For example, employees are identified in the company by their employee number but the database might record their national insurance number too, in some relvar that therefore keys are both singleton sets, to omit the braces would (a) be sloppy and (b) perhaps foster the common misunderstanding I mentioned. On the other hand, the term ‚Äúkey attribute‚Äù is acceptable and useful. Chapter 6 draws attention to two special cases of keys: the entire heading as a key, and the empty set as a key. Now you can see how the significance of the empty key arises from that of FDs having empty determinants. has at least two keys, perhaps {Employee#} and {NatIns#}. Note the braces. Even though those two

7.7	

The Role of FDs and Keys in Optimization

This section is a digression, inserted here to show you that database design is not the only area in which the theory of functional dependence is applicable. I take the opportunity to mention one other important application of the theory. It concerns optimization that a relational DBMS is expected to undertake in the interests of efficient evaluation of relational expressions, a process commonly called query optimization.

199
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Just as the value assigned to a variable, by definition, varies from time to time, so also, as a consequence, does the relation denoted by a relational expression that references one or more relvars. Therefore our definition of ‚Äúkey‚Äù can be generalized to apply to relational expressions as well as to relvars. For example, given that {¬† StudentId,¬† CourseId¬†} is a key of EXAM_MARK, we can conclude (for example) that Constraining CourseId values to be constant in the result of that expression means that the FD { } ‚Üí {¬† StudentId¬† } is a key of (for example) EXAM_MARK WHERE CourseId = CID('C1').

{ CourseId } holds in it, because application of Theorem 8, Unification, to { } ‚Üí { CourseId } and {¬†StudentId,¬†CourseId¬†} ‚Üí { Mark } yields {¬†StudentId¬†}¬†‚Üí¬†{¬†Mark,¬†CourseId¬†}. A subsequent projection over just StudentId and Mark (likely to be given because the constant CourseId value the overhead of detecting redundant duplicate tuples‚Äîthere cannot be any‚Äîand eliminating them. If projections more efficiently.

is known) can be performed efficiently just by dropping the CourseId attribute with no need to incur the DBMS can detect projections that preserve at least one key of the operand, then it can evaluate those

.

200
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Now consider the expression EXAM_MARK

COURSE and CourseId is a common attribute for the join, there cannot be more than one matching

JOIN

COURSE. Because { CourseId } is a key of

tuple in COURSE for any given tuple of EXAM_MARK. When the DBMS, evaluating this join, discovers thanks to its knowledge of keys, derived from its application of FD theory, it knows there cannot be finding something that does!

a matching COURSE tuple for a given EXAM_MARK tuple, it doesn‚Äôt need to look for another one: one‚Äîand looking for something that doesn‚Äôt exist usually takes rather longer than looking for and

That completes the discussion of functional dependence and we can now return to projection-join normalization, that special class of JDs that are implied by FDs. In so doing we will discover the normal form that arises from it, called Boyce-Codd normal form after Raymond F. Boyce and E.F. Codd who jointly first defined it, in [6].

7.8	

Boyce-Codd Normal Form (BCNF)

Boyce-Codd normal form (BCNF) is important because (a) in practice, relvars that are in BCNF but not in 5NF are few and far between, and (b) we have a procedure for deriving, from a relvar that is not in BCNF, an equivalent set of relvars that are in BCNF, and that procedure can be automated (there is no known procedure for guaranteeing 5NF). BCNF is defined as follows.
Relvar r is in Boyce-Codd normal form (BCNF) if and only if and only if every functional dependency that is implied by the keys of r.

Equivalently:
Relvar r is in Boyce-Codd normal form (BCNF) if and only if the determinant of every nontrivial functional dependency that holds in r is a superkey of r.

That second definition effectively gives us a convenient test for an FD that isn‚Äôt implied by keys. (The word nontrivial is needed here because all trivial FDs hold and don‚Äôt all have superkeys as determinants. A trivial FD is ‚Äúimplied by keys‚Äù simply because it holds by virtue of itself alone.) Recall that an FD A ‚Üí B is trivial if and only if B is a subset of A. To test for BCNF it is sufficient to consider just the left-irreducible, non-overlapping FDs, whose determinants must then be not merely superkeys, but keys of r. For convenience, I use the term rogue FD for a left-irreducible, non-overlapping FD that holds in r but whose determinant is not a key of r. I introduced the subject of functional dependence by showing the special kind of JD from which a corresponding FD can be derived. In practice the database designer will be looking for FDs that cause BCNF to be violated. When such an FD is discovered, the designer needs to be able to derive the corresponding JD to determine the decomposition needed to rectify the situation.

201
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Let A, B and C be subsets of the heading of relvar r such that every attribute of r appears in at least one of those subsets and the FD A ‚Üí B holds in r. Then, thanks to a theorem due to Heath [15], we can conclude that the JD *{AÔÄ¥B, AÔÄ¥C} holds in r. Heath‚Äôs theorem applies to relations, not relvars. It effectively states that as a consequence of the FD A ‚Üí B holding in the current value of r, that value is equal to the join of its projections on AÔÄ¥B and AÔÄ¥C. As that FD must hold in every value that r can take, we can conclude that the relvar itself is indeed subject to the JD *{AÔÄ¥B, AÔÄ¥C}. Use of Heath‚Äôs theorem is advocated in many texts for determining decompositions to yield relvars that are all in BCNF. In particular, if the following conditions on A, B, and C all hold, then r is not in BCNF: ‚Ä¢	 Every attribute of r is an element of exactly one of A, B, and C. ‚Ä¢	 A is not a key of r. ‚Ä¢	 B is nonempty. ‚Ä¢	 The FD A ‚Üí B is nontrivial and left-irreducible. In that case A ‚Üí B is a rogue FD in r and a decomposition of r into relvars s with heading AÔÄ¥B and t with heading AÔÄ¥C can be considered. If that decomposition is taken, then A ‚Üí B holds in s rather than r and, because A is a key of s, is no longer a rogue FD. For example, consider ENROLMENT again. Then A = {StudentId}, B={Name}, and C¬†=¬†{CourseId}, giving us the decomposition we adopted into IS_CALLED with heading {StudentId, Name} and IS_ENROLLED_ON with heading {StudentId, CourseId}. In this case the two relvars resulting

from the decomposition are both in BCNF, but it does not follow in general that s and t are in BCNF, for there might be other rogue FDs in r, propagated in s or t and remaining as rogues. In any case, when there is more than one rogue FD in r, decomposition into s and t is not always a well-advised step to take towards a design in which each relvar is in BCNF, as you will see in the next section, Dependency preservation. It is easy to see that ENROLMENT is not in BCNF. The determinant, {¬† StudentId¬†}, of the only FD in

its minimal cover of FDs is a proper subkey and therefore by definition not a superkey of ENROLMENT.

Such FDs formed a basis for the definition, by Codd, of second normal form (2NF). Relvars in 2NF are not necessarily in BCNF but it was thought that decomposition to ‚Äújust 2NF‚Äù might be a useful first step in a procedure to derive a complete BCNF design. Codd also defined third normal form (3NF), which covered some additional rogue FDs not covered by 2NF. 3NF was at one time thought to eliminate all cases of redundancy arising from FDs but Boyce showed that conclusion to be incorrect‚Äîhence the eventual arrival of BCNF. Some texts still advance 2NF and 3NF as useful steps on the way to BCNF but the rationale for that escapes the present author and this book shall have no more to say about those normal forms.

202
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Dependency preservation Consider relvar SCDF with attributes S (for student), C (for course), D (for department), and F (for faculty). Throughout the following discussion relvar names reflect the relevant attribute names in similar fashion, allowing a relvar‚Äôs heading to be inferred from its name for convenience. Assume that the set prove that) and SCDF is clearly not in BCNF. If we apply Heath‚Äôs theorem to the FD {C}¬† ‚Üí¬†{D}, we will decompose SCDF into relvars CD and SCF with keys {C} and {S,C}, respectively. CD is in BCNF but {{C} ‚Üí {D}, {D} ‚Üí {F}} is a minimal cover for the FDs in SCDF. Then {S,C} is a key of SCDF (exercise:

SCF is not. Applying Heath‚Äôs theorem to the rogue FD in SCF, we obtain relvars CF and SC, both in BCNF. We now have three relvars, all in BCNF, but no relvar whose heading includes both D and F. As a consequence, the constraint represented by the FD {D} ‚Üí {F} cannot be expressed as a constraint on a single relvar in this BCNF design‚Äîthe FD has been ‚Äúlost‚Äù in the decomposition. On the other hand, if instead we start by applying Heath‚Äôs theorem to the FD {D} ‚Üí {F}, then the resulting relvars are DF

and SCD with keys {D} and {S,C}, respectively. The FDs of the given cover are both ‚Äúpreserved‚Äù in this decomposition, {D}¬†‚Üí¬†{F} in DF and {C}¬†‚Üí¬†{D} in SCD. DF is in BCNF but SCD is not. Applying Heath‚Äôs theorem to the rogue FD in SCD, we obtain relvars CD and SC, both in BCNF. This time, both of the original FDs are preserved in the decomposition.

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

203
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

A conclusion from the foregoing observations is that if repeated application of Heath‚Äôs theorem is the procedure adopted for achieving BCNF designs, then sometimes one has to take care of the order in which binary decompositions are taken if one wishes to avoid needlessly complex constraints. The problem is neatly avoided, where possible, in the following procedure (a simplification of one given by Date in [9], Chapter 12), which guarantees to preserve all FDs but in some comparatively rare cases yields relvars that are still not in BCNF. Let r be a relvar and let S be a minimal cover for the FDs that hold in r. Then: 1.	 Initialize D to the empty set. 2.	 For each FD X ‚Üí Y in S, form the relvar XY with heading XÔÄ¥Y and replace D by the union of D and {XY}. 3.	 If no relvar in D includes in its heading some key of r, then let K be a relvar whose heading consists of the attributes of some key of r, arbitrarily chosen, and replace D by the union of D and {K}. Under Date‚Äôs procedure each FD in S is guaranteed to be preserved in some relvar in D. However, there might be some relvars in D that are still not in BCNF‚Äîwe will come to the circumstances in which these can arise later. To derive a complete BCNF design from D we must add the following step: 4.	 If D contains any relvars that do not satisfy BCNF, then: a)	 Let T be any one of those relvars, let H be the heading of T, and let X¬† ‚Üí¬†Y be a rogue FD in T. b)	 Replace T in D by two relvars, T‚Äô resulting from the projection of T over XÔÄ¥Y and TÀù resulting from the projection of T over H-Y (an application of Heath‚Äôs Theorem). Superkeys of T that do not contain any attribute of Y are superkeys of T‚Äô and X is a superkey of T‚Äô‚Äô. c)	 Declare constraints as needed to compensate for any lost FDs. d)	 Repeat Step 4. All of the relvars produced by this algorithm are guaranteed to be in BCNF, but unfortunately they are not guaranteed to be in 5NF or even ETNF‚Äîwe will look at some examples later in this chapter (Section 7.9, JDs Not Arising from FDs). One could also work from an irreducible cover instead of a minimal one. In an irreducible cover every FD has exactly one attribute on the right-hand side (the dependant). Thus, if we work from an irreducible cover, every resulting relvar that is in 5NF will also be in 6NF. As the discipline of projection-join normalization sometimes leads the designer to question the given assumptions (such as requiring every student to be enrolled on at least one course), perhaps that approach should be considered: start with an irreducible cover and add Step 5, as follows, noting, however, that this one does not obviously lend itself to mechanization.

204
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

5.	 If certain relvars in D have some key in common, consider joining some of them together with a view to eliminating constraints needed to express equality dependencies. For example, application of Date‚Äôs procedure, as stated, to WIFE_OF_HENRY_VIII would result in

no change: the relvar is already in BCNF (and, as it happens, 5NF). Applying it to an irreducible cover instead of a minimal cover would yield the three relvars shown in Design B, discussed in the section following Figure 7.3, headed Assessment of 6NF Decomposition. Application of the suggested Step 6 might indicate combining W_FN and W_LN as W_FN_LN but keeping W_F separate. Now we must look at the circumstances under which Step 4 is needed, and why an FD is inevitably lost in that step. FD Loss Sometimes Inevitable Consider the relvar WXYZ with attributes W, X, Y, and Z. Assume that {{W,X} ‚Üí {Y,Z}, {Y} ‚Üí {X}} is a minimal cover for WXYZ. Then {W,X} and {W,Y} are both keys of WXYZ (exercise: prove that claim), and yields the BCNF relvar XY with key {Y} but retains the non-BCNF relvar WXYZ. In Step 4 we decompose declare a constraint to the effect that {W,X} is a key of WXZ JOIN XY.

WXYZ is not in BCNF because the determinant {Y} is not a superkey. Date‚Äôs procedure (Steps 1 to 3) WXYZ into WXZ and XY, now both in BCNF, but then we lose the FD {W,X} ‚Üí {Y}. We will need to

For a realistic example exhibiting this phenomenon, consider payments made against bank accounts by use of debit cards. Payments are identified within a particular account by transaction numbers, so payments by debit card might be recorded in a relvar with attributes Account#, Transaction#, Card#, Payee, and Amount. {Account#, Transaction#} is a key for this relvar but so is

{Transaction#, Card#} because we have {Card#}¬† ‚Üí¬† {Account#}. (There might be several distinct cards for the same account: for example, if it is a joint account.)

In general, if A, B, C, and D are subsets of the heading of relvar r and FDs A4B‚ÜíC4D and C‚ÜíB hold in r, then A4B and A4C are both keys of r. If each attribute of r appears in exactly one of A, B, C, and D, A and B are each nonempty, and either C or D is nonempty, then a)	 C, a proper subkey, is the determinant of a nontrivial FD and r is therefore not in BCNF. b)	 Steps 1 to 3 will not result in a BCNF decomposition of r. c)	 The nontrivial FD AÔÄ¥B‚ÜíCÔÄ¥D is lost in the decomposition resulting from Step 5.

205
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

One might even question the claim that Steps 1 to 4 guarantee to preserve FDs. Consider the relvar SCF

with attributes S, C, and F, standing for student, course, and faculty as before. This time, however we have the FD {S}¬†‚Üí¬†{F} in addition to {C}¬†‚Üí¬†{F}. Our minimal cover is therefore {{S}¬†‚Üí¬†{F},¬†{C}¬†‚Üí¬†{F}}, from which we can conclude that {S,C}¬† ‚Üí¬† {F} holds in SCF and {S,C} is a key of SCF (exercise:

prove this). Application of Step 2 yields relvars SF and CF and Step 4 yields SC. Have we lost the FD {S,C}¬† ‚Üí¬†{F}, which, although not present in the given minimal cover, is a consequence of that cover? In one sense, no, because it holds in JOIN{SF, CF, SC}, but the fact remains that the decomposition some constraint is declared to make that impossible. With relvar SCF that was not possible. If we been lost, for that can yield a relation in which it does not hold. As with the 6NF decomposition of relvar has to be stated explicitly when a decomposition is taken.

allows a student to be enrolled on a course offered by a faculty other than the student‚Äôs faculty unless consider UNION{JOIN{SC,SF},¬† JOIN{SC,CF}} we can discover a sense in which that FD has indeed WIFE_OF_HENRY_VIII we have a situation where a constraint implied by the very structure of a

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

206
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Another point about the BCNF decomposition of SCF is that if the single relvar design is a correct implementation of the requirements, then we still have redundancy after the decomposition! For on that assumption of correctness we can infer the following business rules: BR1:	 A student can be enrolled on several courses. BR2:	 Several students can be enrolled on a course. BR3:	 At least one student is enrolled on every course. BR4:	 Every student is enrolled on at least one course. BR5:	 Every student belongs to exactly one faculty. BR6:	 Every course is offered by exactly one faculty. BR7:	 Students can only be enrolled on courses offered by their own faculty. Normalizing to BCNF will yield the design shown in Example 7.3. Example 7.3: Decomposing SCF into SF, CF, and SC VAR SF BASE RELATION { S SID, KEY { S } ;

F CHAR }

VAR CF BASE RELATION { C CID, KEY { C } ;

F CHAR }

VAR SC BASE RELATION { S SID,

KEY { S, C } ; CONSTRAINT Only_known_students_can_be_enrolled IS_EMPTY ( SC NOT MATCHING SF ) ;

C CID }

CONSTRAINT Only_known_courses_can_be_enrolled_on IS_EMPTY ( SC NOT MATCHING CF ) ;

CONSTRAINT Every_Student_Enrolled

IS_EMPTY ( SF NOT MATCHING SC ) ;

CONSTRAINT At_least_one_student_on_each_course IS_EMPTY ( CF NOT MATCHING SC ) ;

207
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

CONSTRAINT Same_Faculty_for_Student_and_Course

IS_EMPTY ( JOIN { SC, SF RENAME ( F AS Sfac ), WHERE NOT ( Cfac = Sfac ) ) ;

CF RENAME ( F AS Cfac ) }

But we can obtain a student‚Äôs faculty from SC JOIN CF, so SF is completely redundant and the design can be simplified as shown in Example 7.4.

Example 7.4: Decomposing SCF into just CF and SC VAR CF BASE RELATION { C CID, KEY { C } ;

F CHAR }

VAR SC BASE RELATION { S SID,

KEY { S, C } ; CONSTRAINT Only_known_courses_can_be_enrolled_on IS_EMPTY ( SC NOT MATCHING CF ) ; IS_EMPTY ( CF NOT MATCHING SC ) ; COUNT ( ( CF JOIN SC ) { S } ) = CONSTRAINT At_least_one_student_on_each_course CONSTRAINT FD_student_id_determines_faculty COUNT ( ( CF JOIN SC ) { S, F } ) ; Alternatively, we can obtain the faculty offering a course from SF JOIN SC, allowing us to eliminate CF, as shown in Example 7.5.

C CID }

Example 7.5: Decomposing SCF into just SF and SC VAR SF BASE RELATION { S SID, KEY { S } ;

F CHAR }

VAR SC BASE RELATION { S SID,

KEY { S, C } ;

C CID }

208
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

CONSTRAINT Only_known_students_can_be_enrolled IS_EMPTY ( SC NOT MATCHING SF ) ;

CONSTRAINT Every_Student_Enrolled

IS_EMPTY ( SF NOT MATCHING SC ) ;

CONSTRAINT FD_course_id_determines_faculty COUNT ( ( SF JOIN SC ) { C } ) = COUNT ( ( CF JOIN SC ) { C, F } ) ; So, if those business rules are really correct, then we have a choice of BCNF designs, one of which (Example 7.3) involves redundancy (though not redundancy resulting from FDs) and the other two of which appear to be equal in merit (and significantly less complicated than Example 7.3). But rules BR3 and BR4 are surely open to question. If BR3 is correct but BR4 is not‚Äîit is possible, after all, for a student to exist who isn‚Äôt enrolled on any course‚Äîthen we can choose between Example 7.3, without the constraint Every_Student_Enrolled, and Example 7.4. If BR4 is correct but BR3 is not‚Äîit is possible, after all, for a course to exist on which no student is enrolled‚Äîthen we can choose between Example 7.3, dropping At_least_one_student_on_each_course, and Example 7.5. But if Example 7.6. BR3 and BR4 are both incorrect, then we have to go for the simplification of Example 7.3 shown in

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

209
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Example 7.6: Simplification of Example 7.3, relaxing some constraints VAR declarations as in Example 7.3

CONSTRAINT Only_known_students_can_be_enrolled CONSTRAINT Only_known_courses_can_be_enrolled_on CONSTRAINT Same_Faculty_for_Student_and_Course IS_EMPTY ( SC NOT MATCHING CF ) ; IS_EMPTY ( SC NOT MATCHING SF ) ;

IS_EMPTY ( JOIN { SC, SF RENAME ( F AS Sfac ), WHERE NOT ( Cfac = Sfac ) ) ;

CF RENAME ( F AS Cfac ) }

Of course, Example 7.6 still involves some of the redundancy exhibited in Example 7.3. If a student is enrolled on some courses, then the faculty offering those courses must be that student‚Äôs faculty; and if some students are enrolled on a course, then the faculty offering that course must be the faculty of those students. If we wish to avoid such redundancy, then the constraints become simpler as Example 7.7 shows. Example 7.7: Complication of Example 7.6, avoiding redundancy VAR declarations as in Example 7.3

CONSTRAINT SF_only_for_students_not_enrolled CONSTRAINT SC_only_for_courses_nobody_enrolled_on IS_EMPTY ( CF MATCHING SC ) ; IS_EMPTY ( SF MATCHING SC ) ;

But with that design we cannot even express the constraint requiring students to be enrolled only on courses offered by their own faculty. Moreover, updating becomes complicated. When a student gets enrolled on their very first course we have to use multiple assignment to delete a tuple from SF at the same time as adding one to SC. Similarly, when a course gets its very first enrolment we have to use multiple assignment to delete a tuple from CF at the same time as adding one to SC. And we have to loses its last student. It seems that redundancy is not something to be avoided at all costs. Sometimes ‚Äúall costs‚Äù do outweigh the advantages, as would surely be our judgment in the case of Example 7.7. Also, consider how the chosen design might affect the confidence that users have in the correctness of the database. With Example 7.6 one can be pretty sure of no student/course mismatches on faculty‚Äîthey could arise only when a student‚Äôs dependencies does appear to be worth avoiding, in general, so long as the DBMS lets you declare all the and its ramifications have been well understood for over 30 years at the time of writing. faculty or a course‚Äôs faculty is incorrectly recorded in SF or CF. However, redundancy arising from join

reverse those processes when a student disengages from their only remaining course, and when a course

constraints that are needed. If it doesn‚Äôt, then perhaps somebody should be complaining‚Äîafter all, BCNF

210
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

One little topic remains to be covered before we can leave this chapter: join dependencies that do not arise from FDs. We haven‚Äôt seen any of those yet. There are some, and these are the JDs that can cause a BCNF relvar not to satisfy ETNF (and 5NF).

7.9	

JDs Not Arising from FDs

JDs that do not arise from FDs arise most commonly in ‚Äúall key‚Äù relvars‚Äîrelvars whose only key consists of the entire heading, such as IS_ENROLLED_ON, for example. A minimal FD cover for such a relvar is the empty set. For if A, B, and C are subsets of the heading of relvar r and { A ‚Üí B } (a set consisting of just one FD) is a minimal cover for r, then AÔÄ¥C must be a key of r and B is nonempty by definition of minimal cover. If B is nonempty, then AÔÄ¥C is a proper subset of the heading and r is not ‚Äúall key‚Äù. Clearly, an all-key relvar must be in BCNF. Now consider Example 7.8 Example 7.8: SCT: a relvar in BCNF but not in 5NF VAR SCT BASE RELATION { S SID,

C CID,

Predicate: Student S studies topic T on course C.

KEY { ALL BUT } ;

T CHAR }

The minimal FD cover for SCT is empty‚Äîno right-irreducible FD holds in SCT whose determinant consists of two of those three attributes. Yet the JD *{{S,C}, {C,T}} holds in SCT on the assumption (let other words, if student s1 is shown by some tuple in SCT to be studying topic t1 on course c1, and student us assume it is safe) that a student enrolled on a course is studying every topic covered by that course. In s2 is shown by some tuple in SCT to be studying topic t2 on course c1, then a tuple showing student s1

to be studying t2 on course c1 must also appear in SCT‚Äîotherwise the constraint implied by the given

JD would not be satisfied. A decomposition into relvars SC and CT (with attributes as indicated by the relvar names, as before) is clearly indicated. SCT is in BCNF but not 5NF. SC and CT are both in 5NF. Observations similar to those made in connection with decompositions indicated by FDs apply here

that covers at least one topic must have at least one student on it, and every course on which at least one needs to be declared. But the putative business rule giving rise to a requirement for such a constraint is questionable. Can‚Äôt a course exist before any students are enrolled on it? Does every course have to be subdivided into topics? The decomposition allows enrolments and coverage of topics to be recorded independently of each other‚Äîwhich seems intuitively sensible in any case. student is enrolled must cover at least one topic. A constraint with condition equivalent to SC{C}¬†=¬†CT{C}

too. If the decomposition into SC and CT really is required to be equivalent to SCT, then every course

211
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Now, when BCNF was first introduced it was known that relvars like SCT existed that are in BCNF and yet exhibit redundancy that can be avoided by taking projections. It was some time later that these cases normal forms were defined to fill the remaining gaps left by BCNF. As 2NF and 3NF have already been mentioned as concepts previously essayed but later superseded (by BCNF), you must be wondering about the apparent numerical gap between 3NF and 5NF. Well, SCT is in fact in violation of 4NF as well as 5NF. Observe that the JD *{{S,C}, {C,S}} that causes SCT to violate 5NF is a binary JD in particular. were carefully studied, the concept of JD was formulated as a generalization of FD, and even stronger

It is because that JD is binary that SCT violates 4NF. 4NF was originally defined, not in terms of JDs functional dependency is a special case. However, it turns out that every MVD is equivalent to a certain binary JD, so we no longer really need to study MVDs‚Äîthe interested reader can easily find out about

in general, but in terms of a kind of dependency called multi-valued dependency (MVD), of which a

them in the literature. Suffice it here just to mention that 4NF is weaker than ETNF and therefore does not guarantee to avoid redundancy. It follows from the definition of 4NF that any relvar that is in 4NF but not 5NF must be subject to a nonredundant JD of degree greater than two (where a JD is redundant if and only if at least one of its projections is redundant). Moreover, that JD must be such that it‚Äôs not merely a consequence of two or more binary JDs, unlike the nontrivial ternary JD we noted in WIFE_OF_HENRY_VIII. A relvar subject to such a JD cannot be decomposed into 5NF relvars by a succession of two-way decompositions‚Äî again, unlike WIFE_OF_HENRY_VIII, which we decomposed in two stages. The study of such relvars story of projection-join normalization by showing that such JDs (let‚Äôs call them irreducible non-binary JDs), and therefore such relvars, do indeed exist. Irreducible non-binary JDs Here again is the definition I gave earlier for fifth normal form:
Relvar r is in fifth normal form (5NF) if and only if every join dependency that holds in r is implied by the keys of r.

eventually led to 4NF being subsumed by 5NF (and much later by ETNF). We must now complete the

We can retrospectively define 4NF just by inserting the word ‚Äúbinary‚Äù immediately before ‚Äújoin‚Äù in the definition of 5NF. The JD *{{S,C}, {C,T}} holds in SCT and it is intuitively clear that, given that the only key of SCT is the entire heading, we cannot deduce from that fact alone that this JD holds (as is confirmed by application of the algorithm given under reference [13] in Appendix A).

To discover a case of ‚Äú4NF but not 5NF‚Äù, we need to find a relvar that is subject to an irreducible nonbinary JD. Well, consider Example 7.9, a relvar used by the university library to record which books are recommended by which lecturers for which topics on which courses.

212
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Example 7.9: LBTC: a relvar to illustrate irreducible JDs VAR LBTCS BASE RELATION { L LID,

B ISBN, T CHAR, C CID }

Predicate: Lecturer L recommends book B for topic T on course C. The minimal FD cover for LBTC is empty‚Äîno right-irreducible FD holds in LBTC whose determinant consists of three of those four attributes.

KEY { ALL BUT } ;

Suppose a business rule is applicable, stating that if ‚Ä¢	 a lecturer recommends a certain book at all, and ‚Ä¢	 the book covers a certain topic, and ‚Ä¢	 the lecturer in question teaches that topic on a certain course, then it follows that that lecturer recommends that book for that topic on that course. In that case the ternary JD *{{L,B},{B,T},{L,T,C}} holds in LBTC, but no nontrivial binary JD holds in it: LBTC is in 4NF but not in 5NF, and a three-way decomposition into LB, BT and LTC is indicated.

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

213
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Note the difference in kind between the ternary JD *{{L,B},{B,T},{L,T,C}} and the one we found holding in WIFE_OF_HENRY_VIII:

* { {Wife#, FirstName}, {Wife#, LastName}, {Wife#, Fate} } First, note that application of Fagin‚Äôs algorithm shows that this JD is ‚Äúimplied by the keys‚Äù of WIFE_OF_ HENRY_VIII and so does not give rise to a violation of 5NF. Secondly, we can take the union of any for example: two of those projections to form a nontrivial binary JD that also holds in WIFE_OF_HENRY_VIII,

* { { Wife#, FirstName }, { Wife#, LastName, Fate } } Now, the JD *{{L,B},{B,T},{L,T,C}} in LBTC arose from a certain assumed business rule. Variations on rule might instead state that if ‚Ä¢	 a lecturer recommends a certain book at all, and ‚Ä¢	 the book covers a certain topic, and ‚Ä¢	 the topic is included in a certain course, then it follows that that lecturer recommends that book for that topic on that course. In that case the ternary JD *{{L,B},{B,T},{T,C}} holds in LBTC and a decomposition into LB, BT, and TC is indicated. Or perhaps the business rule states, more strongly, that if ‚Ä¢	 a lecturer recommends a certain book at all, and ‚Ä¢	 the book covers a certain topic, and ‚Ä¢	 the topic is included in a certain course, and ‚Ä¢	 the lecturer teaches on that course, then it follows that that lecturer recommends that book for that topic on that course. In that case the quaternary JD *{{L,B},{B,T},{T,C},{L,C}} holds in LBTC (even though no ternary JD holds) and a decomposition into LB, BT, TC, and LC is indicated.

that assumption lead to different JDs, necessitating different decompositions. For example, the business

Or perhaps the quinary JD *{{L,B},{B,T},{L,T},{T,C},{L,C}} holds, requiring the lecturer not only to teach the relevant course but also to teach the relevant topic (though not necessarily on that course).

214
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Finally, what if the rule, albeit quite unreasonable, were that if a book covers a certain topic and that topic is included in a certain course, then it can be assumed that every lecturer recommends that book for that topic on that course. Then the JD is *{{L},{B,T,C}} and the join is in fact a Cartesian product‚Äî we might call the JD a ‚Äútimes dependency‚Äù. We are led to the observation, interesting from a theoretical point of view, that even a binary relvar can be subject to a nontrivial join dependency. Suppose, for example, that a certain insurance company offers a product that insures its policy holders for driving in every country in the European Union. Then we don‚Äôt need a relvar that pairs every policy holder with every EU member state! Why ETNF is preferred Considering the large number of JDs that might need to be examined in connection with relvars of even quite small degree, we can be grateful to the science offered by functional dependency analysis for giving us ways of getting to grips with the vast majority of them. It seems that when a BCNF design is achieved, no algorithmic procedure has yet been devised to yield a further decomposition that guarantees 5NF. But what about ETNF? It turns out that, although, as I stated earlier, the definition of ETNF is too complicated for this book, there is in fact a simple test for it, an equivalent definition that reference [8] calls a ‚Äúsyntactic characterization‚Äù. At last we have covered all the material that is needed to understand this definition, so here it is:
Relvar r is in essential tuple normal form (ETNF) if and only if r is in BCNF and some component of every nontrivial join dependency that holds in r is a superkey of r.

As you can see, it is somewhat similar to the second definition I gave for BCNF:
Relvar r is in Boyce-Codd normal form (BCNF) if and only if the determinant of every nontrivial functional dependency that holds in r is a superkey of r.

Recall that under Heath‚Äôs theorem, if A, B and C are subsets of the heading of relvar r such that every attribute of r appears in at least one of those subsets, then the FD A¬†‚Üí¬†B holding in r implies that the JD *{A4B, A4C} holds in r. If A is a superkey of r, then that FD satisfies BCNF and that JD satisfies ETNF. By the way, it is also shown in [8] that if A4B is a superkey of r and JD *{A4B, A4C} holds, then FD A¬† ‚Üí¬†B holds. In other words, if we extend Heath‚Äôs theorem to include a statement of the superkeys of the projections mentioned in the JD, then the converse also holds. Most textbooks tell you, correctly, that the converse of Heath‚Äôs theorem as stated does not hold. ETNF doesn‚Äôt guarantee 5NF, but we don‚Äôt need 5NF for avoiding the kind of redundancy in question here. ETNF is sufficient (and necessary!). To obtain an ETNF decomposition of a given relvar we apply the procedure for obtaining BCNF relvars and then look for nontrivial JDs that are not implied by FDs. If we find one in which no component is a superkey, then we have an ETNF violation on our hands and decompose accordingly, repeating the process until all relvars are in ETNF.
215
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

Isn‚Äôt there a 1NF to precede 2NF? I have described, or at least mentioned, projection-join normal forms numbered from 2 to 6 that, among others, have been defined over the years, but surely the numbering doesn‚Äôt start at two? What happened to first normal form, 1NF? That NF has indeed been defined but it is not a projection-join normal form and so does not belong in this chapter. It is discussed in the first section of Chapter 8.

EXERCISES
1.	 (Repeated from the body of the chapter). The predicate for WIFE_OF_HENRY_VIII is ‚ÄúThe first name of the Wife#-th wife of Henry VIII is FirstName and her last name following expression: WIFE_OF_HENRY_VIII { Wife#, FirstName } JOIN WIFE_OF_HENRY_VIII { LastName, Fate } is LastName and Fate is what happened to her.‚Äù Write an appropriate predicate for the

AXA Global Graduate Program
Find out more and apply

216
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

2.	 Consider the following declarations: VAR C1_EXAM_MARK BASE INIT ( EXAM_MARK WHERE CourseId = CID('C1') ) KEY { StudentId } ;

CONSTRAINT C1_only

a)	 Explain why C1_EXAM_MARK is not in BCNF.

AND ( C1_EXAM_MARK, CourseId = CID('C1') ) ;

b)	 Assume that similar relvars are defined for every course, except that this time there are no CourseId attributes. Describe how a query could be expressed to give the course identifier and mark for every exam taken by student S1.

3.	 In Section 7.5 of the chapter, under the heading Functional Dependencies, eight theorems are given concerning FDs. Taking the first three as axioms, prove theorems 4 to 8. 4.	 (Repeated from the body of the chapter). Consider relvar SCDF with attributes S (for student), C (for course), D (for department), and F (for faculty). Assuming that the set SCDF.

{{C}¬† ‚Üí {D}, {D} ‚Üí {F}} is a minimal cover for the FDs in SCDF, prove that {S,C} is a key of 5.	 (Repeated from the body of the chapter). Assume that {{W,X} ‚Üí {Y,Z}, {Y} ‚Üí {X}} is a WXYZ.

minimal FD cover for the FDs in relvar WXYZ. Prove that {W,X} and {W,Y} are both keys of

6.	 The heading of relvar R1 consists of attributes named a, b, c, d, e, f, g, and h. The following set of FDs is a cover for those that hold in R1: FD1:		 FD2:		 FD3:		 FD4:		 FD5:		 FD6:		 {a,b} ‚Üí {d} {b} ‚Üí {e} {c} ‚Üí {f} {g} ‚Üí {h} {d} ‚Üí {b, e} {a,b} ‚Üí {c}

a)	 Describe the single change required to derive an irreducible cover from the given set. b)	 Describe the single change required to derive a minimal cover from your answer to a. c)	 Explain why R1 is not in Boyce-Codd normal form (BCNF). d)	 Decompose R1 into an equivalent set of BCNF relvars. Name your relvars R2, R3,

and so on and for each one list its attribute names and state its key(s). For example: R3{c,d,e} KEY{d} KEY{c,e} if you think this relvar with those two keys is part of the solution.

217
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design I: 
Projection-Join Normalizatio

7.	 Write a complete Tutorial D definition for the database concerning payments made against bank accounts, described in Section 7.8, Boyce-Codd Normal Form (BCNF). Include any other kinds of transaction you can think of in addition to those mentioned in Section 7.8‚Äî for example, you might wish to include payments into the accounts as well as payments out. Include also relvars to record details of accounts, customers, and debit cards. Write down business rules, in the style adopted in the chapter, stating the assumptions on which your design is based. 8.	 Based on your experiences with Exercise 7, suggest enhancements to Tutorial D to make it easier to express any constraints you declared that struck you as being of a common enough kind to warrant an additional shorthand. 9.	 (For students familiar with SQL). Consider the following SQL definitions: CREATE TABLE SF ( StudentId CHAR(4), PRIMARY KEY ( StudentId ) Faculty VARCHAR(50),

CREATE TABLE CF ( CourseId CHAR(4), PRIMARY KEY ( CourseId )

UNIQUE ( StudentId, Faculty ) ; Faculty VARCHAR(50),

CREATE TABLE SCF ( StudentId CHAR(4), CourseId CHAR(4), Faculty VARCHAR(50),

UNIQUE ( CourseId, Faculty );

PRIMARY KEY ( StudentId, CourseId ), FOREIGN KEY ( StudentId, Faculty ) FOREIGN KEY ( CourseId, Faculty ) a)	 What problem was the designer solving here? b)	 What possible problem remains in this solution? c)	 Describe and comment on the particular features of SQL that make this solution possible. REFERENCES SF ( StudentId, Faculty ), REFERENCES CF ( CourseId, Faculty ) ;

218
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

8	 Database Design II: Other Issues
8.1	 Group-Ungroup and Wrap-Unwrap Normalization
Preliminary remarks I should make it clear right away that to most people the term ‚Äúnormalization‚Äù, in the context of databases, means projection-join normalization specifically. But the term does seem to be equally appropriate in connection with other kinds of design choice, hence my decision to use it in the first two sections of this chapter. I promised a discussion of 1NF in this section. It is here, but later.

219
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design II: Other Issues

of Chapter 5. Their current values are repeated here in Figure 8.1. 	COURSE	
CourseId C1 C2 C3 C4 Title Database HCI Op systems Programming StudentId S1 S1 S1 S2 S3 S4
Figure 8.1: Current values of relvars COURSE and EXAM_MARK

Some examples in this chapter refer to the relvars COURSE and EXAM_MARK introduced at the beginning

EXAM_MARK
CourseId C1 C2 C3 C1 C3 C1 Mark 85 49 85 49 66 93

And here again are the relvar definitions for COURSE and EXAM_MARK: VAR COURSE BASE RELATION { CourseId CID, Title CHAR } VAR EXAM_MARK BASE RELATION { StudentId SID, CourseId CID, KEY { StudentId, CourseId }; Group-ungroup normalization In Chapter 5, Example 5.12 illustrates the Tutorial D operator GROUP. The expression EXAM_MARK GROUP { StudentId, Mark } AS ExamResult, operating on the current value of EXAM_ MARK, yields the relation shown in Figure 5.6, repeated here as Figure 8.2 for convenience: Mark INTEGER } KEY { CourseId };

220
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

&RXUVH,G


([DP5HVXOW 6WXGHQW,G 6 6 6


&

0DUN    0DUN 


&

6WXGHQW,G 6

&

6WXGHQW,G 6

0DUN 

Figure 8.2: A relation derived from EXAM_MARK by grouping

Recall also that we can reverse the process by use of UNGROUP. Thus, a relvar defined as in Example 8.1 ‚Äúgrouped‚Äù design genuinely equivalent.

might be considered as a valid alternative to EXAM_MARK, but note the constraints needed to make the Example 8.1: Alternative design for exam marks, using a relation-valued attribute VAR C_ER BASE

INIT ( EXAM_MARK GROUP {StudentId, Mark} AS ExamResult ) KEY { CourseId } ;

CONSTRAINT At_least_one_mark_per_course

IS_EMPTY ( C_ER WHERE IS_EMPTY (ExamResult ) ) ; IS_EMPTY ( C_ER WHERE COUNT (ExamResult{StudentId}) < COUNT (ExamResult) );

CONSTRAINT At_most_one_mark_per_student_per_course

CONSTRAINT CourseId_foreign_key

IS_EMPTY ( C_ER NOT MATCHING COURSE ) ; IS_EMPTY ( ( C_ER UNGROUP ExamResult ) NOT MATCHING IS_CALLED ) ;

CONSTRAINT StudentId_foreign_key

(The definition of relvar C_ER above is able to omit the type specification because in Tutorial D the declared type of a variable can be omitted when an INIT specification is included. The declared type of the variable is then that of the specified expression.)
221
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

course for which nobody sat the exam. It would probably make better sense to disregard that putative

The first of those two constraints reflects the fact that EXAM_MARK by itself cannot accommodate a

requirement and drop the constraint. The second constraint is a key constraint on the attribute values for ExamResult, a logical consequence of KEY { StudentId, CourseId } specified for EXAM_MARK. Tutorial D, one reason being that such a design is in general contraindicated and should be discouraged. Here are some points against it: 1.	 The particular grouping chosen is arbitrary. Why not group on { CourseId, Mark } instead? values to be nonempty. The KEY shorthand could be considered for relation-valued attributes of relvars but it is not included in

2.	 The constraints are more complicated, even if we drop the one requiring ExamResult 3.	 Updating can be particularly awkward. Consider how to write a Tutorial D UPDATE statement to record that mark in the first place.

statement to change student S1‚Äôs mark in course C1. Consider how to write an INSERT

4.	 The playing field for queries, as with non-5NF relvars, is not level. True, some aggregation queries are slightly simplified (try obtaining the average exam mark for each course), but many others become quite complex unless a preliminary invocation of UNGROUP is injected (try obtaining all of student S1‚Äôs exam marks).

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

222
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design II: Other Issues

In short, the asymmetric structure illustrated in Example 8.1 leads to asymmetric queries, asymmetric constraints, and asymmetric updates. Now, C_ER is in 5NF, as you can easily verify, and it exhibits no redundancy. But see, in Figure 8.3, what happens if we apply a similar treatment to our original non-5NF relvar, ENROLMENT, having the attribute Name in place of EXAM_MARK‚Äôs Mark, giving the relvar C_ES with relation-valued attribute EnrolledStudents.
&RXUVH,G


(QUROOHG6WXGHQWV 6WXGHQW,G 6 6 6


&

1DPH $QQH %RULV 'HYLQGHU

&

6WXGHQW,G 1DPH 6


$QQH

&

6WXGHQW,G 1DPH 6 &LQG\

Figure 8.3: C_ES, derived from ENROLMENT by grouping

C_ES is in 5NF but exhibits exactly the same redundancy that ENROLMENT exhibits: in the current value of C_ES, student S1‚Äôs name is recorded twice. For these reasons, perhaps a group-ungroup normal form (GUNF?) could be usefully defined: relvar r is in GUNF if and only if no attribute of r is relation valued; but as far as the present author is aware no such definition is to be found in the literature (apart from this book). Codd proposed a normal form that he called first normal form (1NF), and he included a requirement for 1NF in his definitions for 2NF, 3NF, and subsequently BCNF. Under 1NF as he defined it, relation-valued attributes were ‚Äúoutlawed‚Äù; that is to say, a relvar having such an attribute was not in 1NF. However, certain examples do exist where to avoid a relation valued attribute we have to resort to artifice. Consider, for example, the relvar, in the catalog, to record the keys of all the relvars in the database. The straightforward definition, shown in Example 8.2, involves a relation-valued attribute. Example 8.2: Catalog relvar to record keys of relvars, not in GUNF VAR RELVAR_KEYS BASE RELATION { RelvarName NAME, KEY { ALL BUT } ;

Key RELATION { Attr NAME } }

223
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

We cannot obtain an equivalent design by ungrouping, because a relvar can have several keys‚Äîrecall that a key can have several attributes and note that the same attribute might appear in several keys. A tuple appearing in the ungrouping, simply pairing relvar name r with attribute name a tells, us only that a is a member of some key of r. A truly equivalent design in GUNF is unachievable. The best we can do is probably as shown in Example 8.3, where we have to introduce an extra attribute. Moreover, this design does not admit relvars with empty keys (specified by KEY { })‚Äîthose would have to be represented by a separate relvar in the catalog.

Example 8.3: Catalog relvar to record keys of relvars, in GUNF VAR RELVAR_KEYS_GUNF BASE RELATION { RelvarName NAME, KeyAttr NAME }

KeyNumber INTEGER,

KEY { ALL BUT } ;

Having to number the keys of each relvar is artificial and burdensome. Most of the noted disadvantages of relation-valued attributes are not so relevant here because we expect catalog relvars to be maintained by the DBMS. The natural, non-GUNF design of Example 8.2 is probably preferable. Now, Codd‚Äôs definition of 1NF attempted similarly to outlaw attributes of certain other types too, because relation types are not the only types that, if used for attributes of relvars, give rise to the problems identified with relation types, as we shall now see. Wrap-unwrap normalization Instead of defining C_ES with its relation-valued attribute EnrolledStudents, derived from ENROLMENT using GROUP, we could apply WRAP to derive the relvar C_EST, as shown in Example 8.4. Example 8.4: Alternative design for enrolments, using a tuple-typed attribute VAR C_EST BASE

INIT ( ENROLMENT WRAP {StudentId, Name} AS SIDName ) KEY { CourseId } ;

CONSTRAINT At_most_one_name_per_student

COUNT ( C_EST UNWRAP SIDName { StudentId, Name } ) = COUNT ( C_EST UNWRAP SIDName { StudentId } ) ;

CONSTRAINT CourseId_foreign_key

IS_EMPTY ( C_EST NOT MATCHING COURSE ) ;

224
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

Like C_ER, C_EST is in 5NF and yet still exhibits the same redundancy as ENROLMENT. Codd‚Äôs definition usefully defined along similar lines to the GUNF previously mooted. But even outlawing relation and

of 1NF precluded tuple-typed attributes too. Perhaps a ‚Äúwrap-unwrap‚Äù normal form (WUNF?) could be tuple types wasn‚Äôt sufficient for the purpose at hand. A similar effect can be obtained with user-defined types, as Example 8.5 shows. Example 8.5: Alternative design for enrolments, using a user-defined type TYPE NamedStudent POSSREP { StudentId SID, Name NAME } ; VAR C_ESUDT BASE RELATION { CourseId CID, KEY { CourseId } ;

SIDName NamedStudent }

CONSTRAINT At_most_one_name_per_student WITH ( X := EXTEND C_ESUDT : { StudentId := THE_StudentId(SIDName) ), Name := THE_Name(SIDName) }

	

COUNT ( X { StudentId } ) = COUNT ( X { StudentId, Name } ) ; CONSTRAINT CourseId_foreign_key

) :

IS_EMPTY ( C_ESUDT NOT MATCHING COURSE ) ;

Codd attempted to preclude the use of such types in his definition of 1NF, but unfortunately this definition appealed to an unclear notion of atomicity. To be in 1NF, a relvar‚Äôs attributes all had to be of types consisting of ‚Äúatomic‚Äù values only. However, he did not give a clear definition of what it means for a value to be atomic and we now believe the notion has no absolute meaning. Suffice it just to say that the relational database designer should generally avoid futile attempts, such as those shown in this section, to obtain 5NF without achieving the elimination of redundancy that 5NF is supposed to achieve. In particular, stick, where possible, to GUNF and WUNF.

225
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

8.2	

Restriction-Union Normalization

such that r can be reconstituted by taking the union, r1 UNION r2. If r is in fact a relvar and c1 and c2 are such that at all times r must be equal to (r WHERE c1) UNION (r WHERE c2), then a design using r1 and away that such decomposition, sometimes referred to as ‚Äúhorizontal decomposition‚Äù (appealing to our normal tabular depiction of relations), is usually contraindicated. For one thing, the restriction conditions c1 and c2 now have to become declared constraints on relvars r1 and r2, respectively. For another, if it is possible for some tuple of r to satisfy both conditions, then that tuple must appear in both r1 and r2, in which case the proposed decomposition introduces redundancy where there was none to start with. For an example, consider a horizontal decomposition of EXAM_MARK such that we have a separate relvar for each course. Then our design would have to include the following components for course C1 and similar components for each other course, as shown in Example 8.6.

combined condition c1 OR c2, then we have obtained a decomposition of r into two relations, r1 and r2,

If we take two restrictions of relation r, say r WHERE c1 and r WHERE c2, and every tuple of r satisfies the

r2 in place of r can be considered. However, having taken note of such possibilities, we must add right

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

226
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design II: Other Issues

Example 8.6: Separate exam marks relvars for each course VAR C1_EXAM_MARK BASE

INIT ( EXAM_MARK WHERE CourseId = CID('C1') ) KEY { StudentId } ;

CONSTRAINT C1_only

AND ( C1_EXAM_MARK, CourseId = CID('C1') ) ;

(likewise for all the other courses) That constraint, C1_only, not only ensures that every tuple in C1_EXAM_MARK subsequently satisfies at

all times the restriction condition by which it was originally derived; it also means that C1_EXAM_MARK is not in BCNF! (Exercise for the reader: why is that so?) Now, the designer adopting such a decomposition might be tempted to dispense with the redundant attribute CourseId in C1_EXAM_MARK and all nowhere in the relvars for recording exam marks. How, now, can we express the query to give the course identifier and mark for every exam taken by student S1, for example? (Exercise for the reader.) And how can we express a constraint to the effect that each exam mark tuple must relate to one of the tuples in IS_ENROLLED_ON? (Answer: We can‚Äôt.) Although a small amount of research has been undertaken into the issues raised by horizontal decomposition, no particular restriction-union normal form has been defined and generally accepted as being useful. Suffice it, here, to say that any design involving two or more relvars with identical headings‚Äîor headings such that one can be derived from the other by invocation of RENAME‚Äîshould combination process might involve the use of EXTEND as well as UNION, as shown in Example 8.7. Example 8.7: Reconstituting EXAM_MARK VAR EXAM_MARK BASE UNION UNION be treated with suspicion and the possibility of combining those two relvars should be considered. The

the other similarly derived course-specific relvars. In that case, CourseId values as such appear

INIT ( EXTEND C1_EXAM_MARK : { CourseId := ( CID('C1') } EXTEND C2_EXAM_MARK : { CourseId := ( CID('C2') } ... ) ;

8.3	

Surrogate Keys

Example 8.8 derives from the author‚Äôs personal experience as a tutor for a certain distance learning establishment.

227
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

Example 8.8: Test paper marks VAR MAX_MARK BASE RELATION { CourseId CID,

Year INTEGER, TMA# INTEGER, Question# INTEGER,

KEY { CourseId, Year, TMA#, Question# } ; VAR STUD_MARK BASE RELATION { StudentId SID, CourseId CID, Year INTEGER, TMA# INTEGER,

Max INTEGER }

Question# INTEGER, KEY { StudentId, CourseId, Year, TMA#, Question# } ; CONSTRAINT FK_referencing_MAX_MARK Mark INTEGER }

IS_EMPTY ( STUD_MARK NOT MATCHING MAX_MARK ) ;

CONSTRAINT Marks_no_greater_than_max

IS_EMPTY ( ( STUD_MARK JOIN MAX_MARK ) WHERE Mark > Max ) ;

The abbreviation TMA stands for tutor-marked assignment. Each year, for each course being presented, a certain number of TMAs are devised as test papers for students. A tutor is assigned to each student and one of the tutors‚Äô duties is to mark their students‚Äô TMA submissions. I imagine Example 8.8 as a possible design underpinning the process I, as a tutor, have to follow when I do the marking. MAX_MARK gives each question. the score out of which each question must be marked. STUD_MARK gives each student‚Äôs mark for

Now, some designers would worry about the repetition of attributes CourseId, Year, TMA#, and

Question# in the two relvars of Example 8.8, these attributes constituting the foreign key defined was derived the situation is exacerbated because questions are divided into separately marked parts and had a key consisting of just one attribute, and then STUD_MARK‚Äôs foreign key would in turn consist of a single attribute corresponding to that singleton key in MAX_MARK.

by the constraint FK_referencing_MAX_MARK. (In the actual scenario from which this example subparts, adding two more attributes to both keys.) Somehow it would seem more efficient if MAX_MARK

228
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

Example 8.9: Test paper marks, using a surrogate key VAR MAX_MARK BASE RELATION { QuestionId QID, CourseId CID, Year INTEGER, TMA# INTEGER,

Question# INTEGER, KEY { CourseId, Year, TMA#, Question# } KEY { QuestionId } ; VAR STUD_MARK BASE RELATION { QuestionId QID, StudentId SID, Mark INTEGER } Max INTEGER }

KEY { QuestionId, StudentId } ; CONSTRAINT FK_referencing_MAX_MARK IS_EMPTY ( STUD_MARK NOT MATCHING MAX_MARK ) ; IS_EMPTY ( ( STUD_MARK JOIN MAX_MARK ) WHERE Mark > Max ) ;

CONSTRAINT Marks_no_greater_than_max

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

229
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design II: Other Issues

The singleton key of MAX_MARK is called, slightly inappropriately, a surrogate key. (A surrogate is a person or thing taking the place of another. The key in question here must clearly sit alongside, not in place keys. The thing that really ‚Äútake[s] the place of another‚Äù is the foreign key attribute of STUD_MARK.) Now, it might well be the case that the performance characteristics of the DBMS are such that the design in Example 8.9 speeds up most of the anticipated tasks in maintaining and using the database. But in general the technique should be viewed circumspectly, taking into account the following considerations, possibly negating those perceived performance gains: ‚Ä¢	 Example 8.9 involves an extra key constraint. ‚Ä¢	 Many queries on STUD_MARK need a join with MAX_MARK in Example 8.9, not needed in Example 8.8. ‚Ä¢	 The values for the compound key of MAX_MARK arise in the real world. Those for the of, the one that must be specified in any case‚Äîa point sometimes overlooked by advocates of surrogate

surrogate key have to be ‚Äúmagicked‚Äù from somewhere. That process probably has to be automated, thus incurring overhead not present in Example 8.8. (Some commercial DBMSs do provide facilities for such automation.)

‚Ä¢	 When a tuple is added to STUD_MARK in Example 8.9, how is the required value for Year, TMA#, and Question# values, all of which must be to hand, to obtain the corresponding QuestionId value?

QuestionId to be determined? Don‚Äôt we have to search MAX_MARK for the CourseId,

The best advice concerning use of surrogate keys might well be: if in doubt, don‚Äôt use them (and if not in doubt, reconsider!).

8.4	

Representing ‚ÄúEntity Subtypes‚Äù

Practitioners of Entity-Relationship modelling, sometimes used as a preliminary stage in database design, make a distinction between real world entities and the relationships among those entities. Entities are classified into ‚Äútypes‚Äù, but an entity type is not a type in the sense used elsewhere in this book. For example, the tuples of IS_CALLED and COURSE might be considered to represent ‚Äústudent entities‚Äù of IS_ENROLLED_ON represent relationships between certain student entities and certain course (entities of type ‚Äústudent‚Äù) and ‚Äúcourse entities‚Äù (entities of type ‚Äúcourse‚Äù), respectively, whereas those entities. An entity subtype arises when some entities of a given type ET, but not all, are perceived to have something in common that merits the subset consisting of those particular entities being identified as an entity type in its own right, this being a subtype of ET.

230
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Database Design II: Other Issues

For example, consider payments debited from a bank account. Each can be identified by an account number and a transaction number and includes an amount of money to be debited from the account in question and some identification of the payee. Some payments are made by cheque; these, and only these, have a cheque number in addition to the information common to all payments. Others are made under direct debit arrangements; these, and only these, have additional information concerning the arrangement under which they are made. Yet others are made using a debit card; these, and only these, include a debit card number (for there can be more than one debit card for a joint account). And so on. The designer of the database where payments against bank accounts are to be recorded is faced with the following choice: Option 1:	 Have separate relvars for each payment type, each with attributes for what are common to all payments. Option 2:	 Have just one relvar for the common attributes and separate relvars for the different payment types, each with attributes sufficient to identify the transaction, plus attributes for the data unique to its own payment type.

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

231
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Database Design II: Other Issues

If Option 1 is adopted, then a ‚Äúdisjointness‚Äù constraint is needed to ensure that no account number/ transaction number combination appears in more than one participating relvar. In the example at hand, the situation is further complicated by the fact that for a debit card payment the demands of BCNF mean that the relevant account number must be stored in a separate relvar, as mentioned in Chapter 7, Section 7.8, under the heading FD Loss Sometimes Inevitable. (Recall that a payment by debit card is identified by a transaction number and a debit card number, the account number being implied by the debit card number.) If Option 2 is adopted, then we need a foreign key constraint on each ‚Äúsubtype‚Äù relvar to ensure that every payment of the type in question is indeed in connection with a transaction recorded in the ‚Äúparent‚Äù relvar. We will also need a disjointness constraint on the subtype relvars, and a constraint to ensure that for each tuple in the parent relvar there is a matching tuple in one of the subtype relvars. It seems, then, that on the evidence so far Option 1 might be preferable for being less complicated. And that brings me back, for the last time, to WIFE_OF_HENRY_VIII. The suggested decomposition into W_FN_LN with attributes Wife#, FirstName, and LastName, and W_F with attributes Wife# and Fate can be seen as an implementation of Option 2. Option 1 could be used instead, where W_F is replaced by a relvar with the same heading as the original WIFE_OF_HENRY_VII. Now, if Option 1 is chosen, then only the current wife‚Äôs marriage is missing a Fate value. In that case no more than one tuple can ever appear in W_FN_LN and the empty set, not {Wife#}, is the only key of that relvar. Thus

both of the examples discussed in this section‚Äîbank account debits and King Henry‚Äôs wives‚Äîshow that when several relvars can be perceived as representing subtypes of some common entity type, they do not necessarily have a key in common, contrary to what is stated in some texts on this subject. In the first example, payments by debit card show that they don‚Äôt even have to have a superkey in common. The choice between Option 1 and Option 2 might be influenced by updating issues. The situation is somewhat similar to that described in connection with Example 7.7 in Chapter 7. With Option 1 a multiple assignment is needed to update both relvars simultaneously when the king‚Äôs current marriage is terminated; with Option 2 one merely adds a tuple to W_F. That particular issue doesn‚Äôt arise with the bank account example if we can assume that a payment never changes its type.

232
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Appendix A: References and Bibliography

Appendix A:  References and Bibliography
In addition to the books and papers referenced in the body of the book I include three textbooks ([3], [7], and [14]) that I have chosen from my own collection. [1]	 http://en.wikipedia.org/wiki/Database

	 The article that caused me to reference Wikipedia in Chapter 1 has been significantly revised and no longer includes the text I cited. The article should be treated with caution. For example, in case it still refers to ‚ÄúDate‚Äôs Information Principle‚Äù, please note that the principle in question actually originates from E.F. Codd. [2]	 W.W. Armstrong: ‚ÄúDependency Structures of Data Base Relationships‚Äù, Proc. IFIP Congress, Stockholm, Sweden (1974). [3]	 Paolo Atzeni and Valeria De Antonellis: Relational Database Theory. Redwood City, Ca.: The Benjamin/Cummings Publishing Company, Inc. (1993).

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

233
Download free eBooks at bookboon.com

Click on the ad to read more

An Introduction to Relational Database Theory

Appendix A: References and Bibliography

	 The Preface begins, ‚ÄúThis book presents a systematic treatment of the formal theory of the relational model of data.‚Äù Here you will find many of the topics of the present book‚Äîand some more‚Äîtreated formally. You will need a good grounding in logic. Plenty of exercises. 386 pages. [4]	Luca Cardelli and Peter Wegner: ‚ÄúOn Understanding Types, Data Abstraction, and Polymorphism‚Äù, ACM Comp. Surv. 17, No. 4 (December 1985). [5]	 E.F. Codd. ‚ÄúA Relational Model of Data for Large Shared Data Banks‚Äù, CACM 13, no. 6 (June 1970). Republished in ‚ÄúMilestones of Research‚Äù, CACM 25, No. 1 (January 1982). 	 Usually cited as the seminal paper that first introduced the relation model of data. Actually, Codd originally published his idea a year earlier, in an IBM research report. [6]	 E.F. Codd: ‚ÄúRecent Investigations into Relational Data Base Systems‚Äù, Proc. IFIP Congress, Stockholm, Sweden (1974) and elsewhere. [7]	 Thomas M. Connelly and Carolyn E. Begg: Database Systems, A Practical Approach to Design, Implementation, and Management (3rd edition). Harlow, England: Pearson Education Limited (2002). A massive tome and a popular recommendation for the serious student or practictioner. 1236 pages. [8]	Hugh Darwen, C.J. Date, and Ronald Fagin. ‚ÄúA Normal Form for Preventing Redundant Tuples in Relational Databases‚Äù, Proc. 15th International Conference on Database Theory, Berlin, Germany (March 26th-29th, 2012). 	 A PDF copy is available at www.edbt.org/Proceedings/2012-Berlin/papers/icdt/a02-Darwen.pdf. The paper describes a normal form‚ÄîEssential Tuple Normal Form (ETNF)‚Äîthat is weaker than 5NF but nevertheless sufficient, and in fact necessary, for avoiding the kind of redundancy that can arise from join dependencies. As a matter of fact this paper arose during the drafting of Chapter 7, when I came across the problem mentioned in the annotation to reference [10] below. [9]	C.J. Date: An Introduction to Database Systems (8th edition). Reading, Mass: Addison-Wesley (2004). 	 Perhaps the best known book on the subject, by the best known author. A sine qua non for all database professionals in industry or academe. 983 pages. (But beware of its definition of 5NF, which is not quite correct. For one thing, it fails to take account of JDs containing redundant projections, but more significantly, as noted in reference [8], it actually defines a slightly weaker NF than 5NF, though still stronger than reference [8]‚Äôs ETNF and thus still sufficient but not necessary.)
234
Download free eBooks at bookboon.com

An Introduction to Relational Database Theory

Appendix A: References and Bibliography

[10]	

C.J. Date: The Relational Database Dictionary (extended edition). Berkeley, Ca.: Apress (2008).

	An invaluable booklet for quick reference. (But again, beware of its definition of 5NF. Its condition (a) propagates the error of [9] and its condition (b) is also erroneous.) [11]	 C.J. Date and Hugh Darwen: Database Explorations: Essays on The Third Manifesto and Related Topics. Bloomington, IN: Trafford Publishing (2010). See http://www.trafford.com/Bookstore. [12]	 C.J. Date and Hugh Darwen: Databases, Types, and The Relational Model: The Third Manifesto (3rd edition). Reading, Mass: Addison-Wesley (2007). 	 Related material, including a complete grammar for Tutorial D, can be found at www.thethirdmanifesto.com. [13]	 Ronald Fagin: ‚ÄúNormal forms and relational database operators‚Äù, Proc. 1979 ACM-SIGMOD (ed. P.A. Bernstein) 153‚Äì160. Available at 	 http://www.almaden.ibm.com/cs/people/fagin/sigmod79.pdf

	Here, slightly paraphrased, is the algorithm referred to in Chapter 7, Section 7.4, for determining whether a given JD is implied by the keys of the applicable relvar. 	 Given a relvar R, a set S of keys {K1, ‚Ä¶, Kn} of R, and a JD *{P1, ‚Ä¶, Pm}: Initialize set T as {P1, ‚Ä¶, Pm}. Apply the following rule until it can no longer be applied: If Ki is a subset of the intersection of Y and Z for some i (1ÔÇüiÔÇün) and for distinct member Y and Z of T, then replace Y and Z in T by the set that is the union of Y and Z (so the number of members of T decreases by one). If, when the algorithm terminates, some member of T contains every attribute of R, then the algorithm succeeds and the given JD is implied by the keys of R; otherwise the algorithm fails and the given JD is not implied by the keys of R. [14]	 Lex de Haan and Toon Koppelaars: Applied Mathematics for Database Professionals. Berkeley, Ca.: Apress (2007). 	 An ‚Äúinterestingly different‚Äù book on the theory and practice of relational databases that I personally recommend. The book includes an excellent treatise on the design of procedural methods for overcoming the deficiencies, in the area of integrity checking, of current SQL implementations. These deficiencies are mentioned in Chapters 6 and 7of the present book. [15]	 I.J. Heath: ‚ÄúUnacceptable File Operations in a Relational Database‚Äù, Proc. 1971 ACM SIGFIDET Workshop on Data Description, Access, and Control, San Diego, Calif. (November 1971).

235
Download free eBooks at bookboon.com

