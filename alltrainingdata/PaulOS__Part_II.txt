PaulOS:	Part	II
An	8051	Real-Time	Operating	System Paul	P.	Debono

Download	free	books	at

Paul P. Debono

PaulOS
An 8051 Real-Time Operating System Part II

2
Download free eBooks at bookboon.com

PaulOS: An 8051 Real-Time Operating System Part II 1st edition © 2013 Paul P. Debono & bookboon.com ISBN 978-87-403-0450-3

3
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Contents

Contents
	 	 	 	 	 1	 1.1	 1.2	 1.3	 1.4	 1.5	 Preface	 Acknowledgements	 Dedications	 List of Figures	 List of Tables	 8051 Basics	 Introduction	 Memory Types	 Code Memory	 External RAM	 Register Banks	 Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

4
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Contents

1.6	 1.7	 1.8	 2	 2.1	 2.2	 2.3	 2.4	 2.5	 2.6	 2.7	 2.8	 2.9	 2.10	 2.11	 2.12	

Bit Memory	 Special Function Register (SFR) Memory	 SFR Descriptions	 Basic Registers	 The Accumulator, Address E0H, Bit-addressable 	 The R registers	 The B Register, address F0H, Bit-addressable	 The Data Pointer (DPTR)	 The Program Counter (PC)	 The Stack Pointer (SP), address 81H	 Addressing Modes	 Program Flow	 Low-Level Information	 Timers	 Serial Port Operation	 Interrupts	

Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I

5
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Contents

3	 3.1	 3.2	 3.3	 4	 4.1	 4.2	 4.3	 5	 5.1	 5.2	 5.3	 5.4	

A51 Examples	 Template.a51	 Serial Port Example Program	 Traffic Lights A51 Program	 8032 Differences	 8032 Extras	 256 Bytes of Internal RAM	 Additional Timer 2	 Evaluation Boards	 FLITE-32 Development Board	 Typical Settings for KEIL uV2	 The NMIY-0031 Board	 C8051F020TB	

Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I

6	 Programming in C with KEIL µV2 IDE	 6.1	 6.2	 Byte Ordering – BIG ENDIAN and LITTLE ENDIAN	 Explicitly Declared Memory Types	

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

6
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Contents

6.3	 6.4	 7	 7.1	 7.2	 8	 8.1	 8.2	 8.3	 9	 9.1	 9.2	 9.3	 9.4	 9.5	

Data types:	 Interrupt routines	 Real-Time Operating System	 What is a Real-Time Operating System	 Types of RTOSs	 SanctOS – a Round-Robin RTOS	 SanctOS System Commands	 Variations from the A51 version	 SanctOS example program	 PaulOS – a Co-operative RTOS	 Description of the RTOS Operation	 PaulOS.C System Commands	 Descriptions of the commands	 PaulOS parameters header file	 Example using PaulOS RTOS	

Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

7
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Contents

10	 10.1	 10.2	 11	 11.1	 11.2	 11.3	 11.4	 10.5	 11.6	 11.7	 11.8	 11.9	

MagnOS – a Pre-Emptive RTOS	 MagnOS System Commands	 Detailed description of commands	 Interfacing	 Interfacing add-ons to the 8051	 LEDs	 Input Switches	 Keypad	 LCD Display	 LCD Command Set	 DC Motor 	 DC motor using H-Bridge	 Model Servo Control	

Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I Part I

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

8
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Contents

12	 12.1	 12.2	 12.4	 12.6	 12.8	 12.8	

Programming Tips and Pitfalls	 RAM size	 SP setting	 Port usage	 Serial port (UART)	 RTOSs pitfalls	 C Tips	

11 11 11 12 12 12 13 14 16 17 18 37 123 143 177 246 263 279

12.3	SFRs	 12.5	DPTR	 12.7	Interrupts	

Appendix A ParrOS.a51	 Appendix B PaulOS A51 version	 Appendix C SanctOS.C	 Appendix D PaulOS.C	 Appendix E MagnOS.C	 Appendix F Further Examples	 Appendix G 8086 PaulOS RTOS	 Appendix H 8051 Instruction Set	

Bibliography	281 Index for Part I	 Index for Part II	 End Notes	 283 286 287

9
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

To see Part I download PaulOS Part I

10
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

12	 Programming Tips and Pitfalls
In this final chapter we discuss some programming tips and common pitfalls which should be avoided when programming such micro-controllers.

12.1	

RAM size

The 8051 may only address 64KB of RAM. To expand RAM beyond this limit requires programming and hardware tricks. We may have to do this “by hand” since many compilers and assemblers, while providing support for programs in excess of 64KB, do not support more than 64KB of RAM. This is rather strange since program code can usually fit in 64KB but it is often that data RAM that is lacking. Thus if we need more than 64KB of RAM, we need to check if our compiler supports it, but if it does not, we must be prepared to do it by hand. Some assemblers and compilers offer ways to get around this limit when used with specially wired hardware. However, without such special compilers and hardware, program code is normally limited to 64KB for the standard 8051 micro-controller. Newer derivatives of the 8051, such as the Silicon Labs C8051F120 chip, do have 128KB of in-system programmable flash memory, with special SFRs to handle the extra RAM size. The latest software development tools, such as the KEIL IDE do provide methods for making use of this additional RAM, basically by switching in and out 64KB pages.

12.2	

SP setting

If we only use the first register bank (i.e. bank 0), we may use Internal RAM locations 08h through 1Fh, for our own data use. However if we plan to use register banks 1, 2, or 3 we must be very careful about using addresses below 20h for our variables as we may end up overwriting or corrupting the values stored in our registers. In particular, the SP (used to point to the stack area) by default is loaded with 07 so that the stack starts from location 08. For example, if we are using Bank 1 together with Bank 0, we have to make sure to load SP with a higher value, such as 0Fh which is the address of R7 bank 1 (the highest register in use). Similarly, if our program does not use any bit variables, then we may use Internal RAM locations 20h through 2Fh (Bit-addressable area) for our own use as normal data byte memory locations. On the other hand, if we intend to use some bit variables, we must be very careful as to which address we do initialize SP as once again we may end up overwriting the stored value of our bits whenever we push something on stack. As the stack grows upwards, it starts to over-write locations, starting from 08h. If there are a lot of pushes or calls, it might end up over-writing the bit variable area. Hence once again, the SP might need to be initially set to 2Fh if we need to preserve all the bit-addressable area.

11
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

12.3	SFRs
SFRs are used to control the way the 8051 peripherals functions. Not all the addresses above 80h are assigned to SFRs. However, this area may not be used as additional RAM memory even if a given address has not been assigned to an SFR. Free locations are reserved for future versions of the microcontroller and if we use that area, then our program would not be compatible with future versions of the microcontroller, since those same locations might be used for special additional SFRs in the upgraded version. Moreover, certain unused locations may actually be non-existent, in the sense that the actual cells for that memory would not form part of the memory mask when being manufactured, and hence even if we do write the code to use these locations, no actual data would be stored! It is therefore recommended that we do not read from or write to any SFR addresses that have not been actually assigned to an SFR. Doing so may provoke undefined behaviour and may cause our program to be incompatible with other 8051 derivatives that use those free addresses to store the additional SFRs for some new timer or peripheral included in the new derivative. If we write a program that utilizes the new SFRs that are specific to a given derivative chip (and which therefore were not included in the standard basic 8051 SFR list), our program will not run properly on a standard 8051 where those SFRs simply did not exist. Thus, it is best to use non-standard SFRs only if we are sure that our program will only have to run on that specific micro-controller. If we happen to write code that uses non-standard SFRs and subsequently share it with a third-party, we must make sure to let that party know that our code is using non-standard SFRs and can only be used with that particular device. Good remarks, notes and warnings within the program source listing would help.

12.4	

Port usage

While the 8051 has four I/O ports (P0, P1, P2, and P3), if our hardware uses external RAM or external code memory (i.e. if our program is stored in an external ROM or EPROM chip or if we are using external RAM chips) we cannot use P0 or P2. This is because the 8051 uses ports P0 and P2 to address the external memory. Thus if we are using external RAM or code memory we may only use ports P1 (and perhaps P3 with some bit restrictions depending on the application program, since the P3 bits are also used as RD, WR, T1, T0, INT1, TXD and RXD) for our own use.

12.5	DPTR
DPTR is really a combination of two 8-bit registers DPH and DPL, taken together as a 16-bit value. In reality, we almost always have to deal with DPTR one byte at a time. For example, to push DPTR onto the stack we must first push DPL and then push DPH. We cannot simply push DPTR onto the stack as a 16-bit value in one step.

12
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

Additionally, there is an instruction to increment DPTR (which is INC DPTR). When this instruction is executed, the two bytes are operated upon as a 16-bit value. However, there is no assembly language instruction which decrements DPTR. If we wish to decrement the value of DPTR, we must write our own code to do so, such as: 	
	 	 	 	 	 	 CLR C MOV A,DPL SUBB A,#1 MOV DPL,A MOV A,DPH SUBB A,#0; subtract the carry flag from the first subtraction, if necessary MOV DPH,A

12.6	

Serial port (UART)

To use the 8051’s on-board serial port, it is generally necessary to initialise at least the following four SFRs: SCON, PCON, TCON, and TMOD. This is because SCON on its own does not fully control the serial port. However, in most cases the program will need to use one of the timers to establish the serial port baud rate. In this case, it would be necessary to configure Timer 1 by setting TCON and TMOD. PCON.7 (known also as SMOD bit, but we should note that PCON is not a bit-addressable register), can be set to double the baud rate. In this case therefore, we would also need to program bit 7 of a fourth register PCON. Moreover, if the serial handling routine is to run under interrupt control, then the appropriate interrupt enable bits (ES and EA in the IE SFR) and sometimes even the interrupt priority bit (PS in the IP SFR) have also to be set. This would bring to six the number of SFRs which we may need to set in order to use the UART in interrupt mode. TI flag is normally initialized to 0 if using serial interrupt routines to transmit characters stored in some software buffer. Once SBUF is loaded directly with the first character to be transmitted, the transmission would start, with the start bit, bit 0 to bit 7 of the data, any parity bit, followed by the stop bit. TI would then be set to 1 automatically when this first character transmission is done and the ISR routine is then triggered which would continue to send any remaining characters in the software buffer (TI would need to be reset to 0 every time in the ISR code). If however we are not using serial interrupt routines to transmit data, TI would be intialised to 1 in the first place, since it is usual practice to start the putchar() routine with:

13
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II while (TI==0);		 SBUF = c;		 			 // wait for the transmitter to be ready (TI=1)

Programming Tips and Pitfalls

// store character in SBUF and start transmitting character // TI would be automatically set to 1 once transmission is done

Examples are given in the serial routines in the Appendix.

12.7	Interrupts
Forgetting to protect the PSW register: If we write an interrupt handler routine, it is a very good idea to always save the PSW SFR on the stack and restore it when our interrupt service routine (ISR) is complete. Many 8051 instructions modify the bits within PSW. If our ISR does not guarantee that PSW contains the same data upon exit as it had upon entry, then our program is bound to behave rather erratically and unpredictably. Moreover it will be tricky to debug since the behaviour will tend to vary depending on when and where in the execution of the program, the interrupt happened. Forgetting to protect a Register: We must protect all our registers as explained above. If we forget to protect a register that we will use in the ISR and which might have been used in some other part of our program, very strange results may occur. If we are having problems with registers changing their value unexpectedly or having some arithmetic operations producing wrong answers, it is very likely that we have forgotten to protect some registers. Forgetting to restore protected values: Another common error is to push registers onto the stack to protect them, and then we forget to pop them off the stack (or we pop them in the wrong order) before exiting the interrupt. For example, we may push ACC, B, and PSW onto the stack in order to protect them and subsequently pop only PSW and ACC off the stack before exiting. In this case, since the value of register B was not restored (popped), an extra value remains on the stack. When the RETI instruction is then executed at the end of the ISR, the 8051 will use that value as part of the return address instead of the correct value. In this case, the program will almost certainly crash. We must always ensure that the same number of registers are popped off the stack and in the right order:
PUSH PSW PUSH ACC PUSH B … … … POP B POP ACC POP PSW RETI

14
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

Using the wrong register bank: Another common error occurs when calling another function or routine from within an ISR. Very often the called routine would have been written with a particular register bank in mind, and if the ISR is using another bank, there might be problems when referring to the registers in the called routine. If we are writing our own routine, then in the ISR we could save the PSW register, change the register bank and then restore the PSW register before exiting from the called routine. However, particularly if we are using the C compiler, we might be using functions and procedures prewritten in the compiler and which we do not have any control on, and therefore can result in program not functioning as intended. This problem is particularly serious when using pre-emptive RTOSs (such as SanctOS or MagnOS), where a forced change of task might occur, switching from task A (which was using for example using register bank 1) on to task B which uses bank 2. For the case of co-operative RTOSs (such as PaulOS), we would be in control where the task changes occur and we would be able to take the necessary precautions. Forgetting to re-start a timer: We might turn off a timer to re-load the timer register values or to read the counter in an interrupt service routine (ISR) and then forget to turn it on again before exiting from the ISR. In this case, the ISR would only execute once.

15
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

Forgetting to clear the Timer 2 interrupt flag: When using Timer 2 interrupts, the Timer 2 overflow flag TF2 is not cleared automatically when the ISR is serviced. We have to clear it in the ISR software (using CLR TF2). The same problem occurs if we forget to clear the RI or the TI flags when using the Serial Interrupt. In this case, the ISR keeps on being called repeatedly. Using RET instead of RETI: Remember that interrupts are always terminated with the RETI instruction. It is easy to inadvertently use the RET instruction instead. However the RET instruction will not end our interrupt smoothly. Usually, using RET instead of RETI will cause the illusion of the main program running normally, but the interrupt will only be executed once. If it appears that the interrupt mysteriously stops executing, we must verify that RETI is being used. Certain assemblers contain special features which will issue a warning if the programmer fails to protect registers or commit some other common interrupt-related errors.

12.8	

RTOSs pitfalls

The PaulOS co-operative RTOS is the most robust and secure of the RTOSs which we have introduced in this text book. This is mainly due to the fact that being a co-operative RTOS, the task changes occur when we want them since there cannot be any forced pre-emptive task changes. However there can still be hidden problems. We should take special care when handling global variables which are accessible to all the tasks. We have to make sure that these variables are allowed to be manipulated only when we want them to. Otherwise it might happen that a task starts with one value of a global variable, then it goes on to a wait state, and when it later on resumes to run, it might end up using the wrong value of the same variable. This is a very big problem with the SanctOS and MagnOS pre-emptive RTOSs. The safest way would be to have global variables protected as a resource, allowing them to be changed only when it is safe to do so. These pre-emptive RTOSs (SanctOS and MagnOS) are only written here as a proof of concept and not as a fully functional robust operating system. This has to be always kept in mind. The same problem exists in these RTOSs with register banks and tasks which use the same functions which are non re-entrant.

16
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Programming Tips and Pitfalls

12.8	

C Tips
•	 We should always try to keep functions (or tasks) as simple as possible. •	 Use the correct required types for the variables; do not use int type if we really need byte or bit type. •	 Use signed or unsigned types correctly. •	 Use specified locations for storing pointers. That is use declarations such as

	

char data * xdata str;		 int xdata * data numtab;		 long code * idata powtab;		

/* pointer stored in xdata, pointing to char stored in data */ /* pointer stored in data, pointing to int stored in to xdata */ /* pointer stored in idata, pointing to long stored in code */

•	 In order to improve the performance during code execution or to reduce the memory size requirement for our code, we should analyse the generated list files and assembly code so as to determine which routines can be improved in speed or reduced in size. •	 We should always try to minimize the variable usage by scoping.

17
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Appendix A

Appendix A	 ParrOS.a51
Round-Robin RTOS This is the round-robin real-time operating system version called ParrOS (an acronym for PAul’s RoundRobin Operating System) and is perhaps the simplest operating system which can be written. The operation can be explained as follows: A timer interrupt is generated at regular intervals. This interrupt is used to run periodically a crucial Interrupt Service Routine (ISR). This ISR uses counters to determine accurately whether the specified slot time has passed, at which point a function is called which tackles the task-swapping problem. Mainly this function stores all the stack area for the current task and replaces it with the stack for the next task scheduled to run. At this point the jump is made to the new task and the program continues seamlessly with the new task until its slot time has elapsed. The process repeats indefinitely, looping round through all the tasks. We first start by explaining how the variables are stacked in the internal memory area of the 8051. Table A-1 shows the way the variables used in this RTOS program have been set up. Most of the variables reside in the internal 256 RAM of the 8032 micro-processor. The external RAM (from address 8100H to 9FFFH for the Flight 32 board) is used to store the stacks of all the tasks and of the main idle program. These stacks are then swapped in turn with the area reserved for the stack in the internal RAM whenever a task swap is necessary.

18
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II Label Hex Byte Addr. FF To 80 7F MAIN_STACK to 76 75 to 61 60 to 4C 4B SPTS to 37 35 READYQ to 22 21 0F (NOOFTSKS+1) bytes 0E 0D 0C 0B 0A 09 (NOOFTSKS+1) bytes (NOOFTSKS+1) bytes Remarks Hex bit address Indirect General Purpose RAM (80 – FF) which can be used as a Stack Area Direct and Indirect RAM (00 – 7F) (NOOFTSKS+1) bytes

Appendix A Notes

SP (initially) T_SLOT_RELOAD

Time slot Reload values For each task Time slot Counter For each task Storage area For the SPs Of each task Queue for Tasks ready To run 00 MYBITS 08 Spare bits Storage for any Applications variables See FETCH_STACK See RTOSGOXXX See RTOSGOXXX See RTOSGOXXX See RTOSGOXXX Task number Pointer Register bank Used by the RTOS Register bank used by ALL tasks

T_SLOT

20 1F to TMPSTORE0 GOPARAM DELAYHI DELAYLO TICKCOUNT RUNNING READYQTOP 17 16 15 14 13 12 11 10

07

06

05

04

03

02

01

0F to 08 07 to 00

Currently running task Points to last task in READYQ Register Bank 1 (R0 – R7) Register Bank 0 (R0 – R7)

Table A-1 PARROS.A51 Variables setup, with 20 tasks. (NOOFTSKS=20)

19
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix A

The source listing for the ParrOS A51 program consists of: •	 The header file ParrOS.h •	 The startup file ParrOS_Startup.a51 •	 The main RTOS file ParrOS.a51

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

20
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II
ParrOS.h

Appendix A

/* ParrOS.h */

/* for use with Parros.a51 Round-Robin RTOS program */ /* written by Paul P. Debono - November 2002 */ #define uchar unsigned char #define uint unsigned int

// The following receive parameters, hence are declared // with an underscore prefix in the a51 file void INIT_RTOS(uchar tslot); void RTOSGOMSEC(uchar msec); void RTOSGOSEC(uchar sec); void RTOSGOMIN(uchar min);

void CREATE(uchar task,uchar tslot,uint *taskadd); =============================================================== ParrOS_StartUp.a51 $NOMOD51 ;-----------------------------------------------------------------------------;  This file is part of the C51 Compiler package ;  Copyright (c) 1988-2005 Keil Elektronik GmbH and Keil Software, Inc. ;  Version 8.01 ; ;  *** <<< Use Configuration Wizard in Context Menu >>> *** ;-----------------------------------------------------------------------------;  STARTUP.A51: This code is executed after processor reset. ; ;  To translate this file use A51 with the following invocation: ; ;	 ; ;  To link the modified STARTUP.OBJ file to your application use the following ;  Lx51 invocation: ; ;	 ; ;-----------------------------------------------------------------------------; ;  User-defined Power-On Initialization of Memory ; ;  With the following EQU statements the initialization of memory ;  at processor reset can be defined: ; ;  IDATALEN: IDATA memory size <0x0-0x100> ;	 Note: The absolute start-address of IDATA memory is always 0 Lx51 your object file list, STARTUP.OBJ controls A51 STARTUP.A51

21
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
;		 IDATALEN	 ; ;  XDATASTART: XDATA memory start address <0x0-0xFFFF> ;	 ; ;  XDATALEN: XDATA memory size <0x0-0xFFFF> ;	 ; ;  PDATASTART: PDATA memory start address <0x0-0xFFFF> ;	 ; ;  PDATALEN: PDATA memory size <0x0-0xFF> ;	 ; The length of PDATA memory in bytes. EQU	0H PDATALEN	 The absolute start address of PDATA memory PDATASTART	 EQU	0H The length of XDATA memory in bytes. EQU	0 XDATALEN	 The absolute start address of XDATA memory XDATASTART	 EQU	0 The IDATA space overlaps physically the DATA and BIT areas. EQU	100H

Appendix A

;;-----------------------------------------------------------------------------; ;  Reentrant Stack Initialization ; ;  The following EQU statements define the stack pointer for reentrant ;  functions and initialized it: ; ; Stack Space for reentrant functions in the SMALL model. ;  IBPSTACK: Enable SMALL model reentrant stack ;	 Stack space for reentrant functions in the SMALL model. EQU	 0	 ; set to 1 if small reentrant is used. IBPSTACK	 ;	 ; ; ; Stack Space for reentrant functions in the LARGE model. ;  XBPSTACK: Enable LARGE model reentrant stack ;	 Stack space for reentrant functions in the LARGE model. EQU 0		 ; set to 1 if large reentrant is used. XBPSTACK	 ;	 ; ; ; Stack Space for reentrant functions in the COMPACT model.

;  IBPSTACKTOP: End address of SMALL model stack <0x0-0xFF> Set the top of the stack to the highest location. EQU	 0xFF +1		 ; default 0FFH+1 IBPSTACKTOP	

;  XBPSTACKTOP: End address of LARGE model stack <0x0-0xFFFF> Set the top of the stack to the highest location. EQU	 0xFFFF +1	 ; default 0FFFFH+1 XBPSTACKTOP	

22
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
;  PBPSTACK: Enable COMPACT model reentrant stack ;	 ; ;  PBPSTACKTOP: End address of COMPACT model stack <0x0-0xFFFF> ;	 ; Set the top of the stack to the highest location. EQU	 0xFF +1		 ; default 0FFH+1 PBPSTACKTOP	 Stack space for reentrant functions in the COMPACT model. EQU	 0	 ; set to 1 if compact reentrant is used. PBPSTACK	

Appendix A

;;-----------------------------------------------------------------------------; ;  Memory Page for Using the Compact Model with 64 KByte xdata RAM ;  Compact Model Page Definition ; ;  Define the XDATA page used for PDATA variables. ;  PPAGE must conform with the PPAGE set in the linker invocation. ; ; Enable pdata memory page initalization PPAGEENABLE	 ; ; PPAGE number <0x0-0xFF> ; uppermost 256-byte address of the page used for PDATA variables. PPAGE	EQU	 ; 0 EQU	 0	 ; set to 1 if pdata object are used.

.

23
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II
; SFR address which supplies uppermost address byte <0x0-0xFF> ; most 8051 variants use P2 as uppermost address byte PPAGE_SFR	 ; DATA	0A0H

Appendix A

;;-----------------------------------------------------------------------------; Standard SFR Symbols ACC	 DATA	0E0H B	 SP	 DATA	0F0H DATA	81H

DPL	 DATA	82H DPH	 DATA	83H 		NAME	 ?C_STARTUP ?C_C51STARTUP	 SEGMENT		 		RSEG 	 ?STACK MAIN_STACK:	 DS 	 1 		EXTRN CODE	 (?C_START) 		PUBLIC		?C_STARTUP 				PUBLIC MAIN_STACK 		CSEG	 AT	 0 ?C_STARTUP:	 LJMP	 STARTUP1 		RSEG	 ?C_C51STARTUP STARTUP1: IF IDATALEN <> 0 		 MOV	 R0,#IDATALEN - 1 		CLR	 A IDATALOOP:	 MOV	@R0,A 		 ENDIF IF XDATALEN <> 0 		MOV	 DPTR,#XDATASTART 		 		  ELSE 		MOV	 R6,#HIGH (XDATALEN)  ENDIF 		CLR	 A XDATALOOP:	 MOVX	@DPTR,A 		INC	 DPTR 		 		 DJNZ	 DJNZ	 R7,XDATALOOP R6,XDATALOOP MOV	 MOV	 R7,#LOW (XDATALEN) R6,#(HIGH (XDATALEN)) +1   IF (LOW (XDATALEN)) <> 0 DJNZ	 R0,IDATALOOP CODE ?STACK		SEGMENT		IDATA

24
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
ENDIF IF PPAGEENABLE <> 0 		MOV	 PPAGE_SFR,#PPAGE ENDIF IF PDATALEN <> 0 		 		 MOV	 MOV	 R0,#LOW (PDATASTART) R7,#LOW (PDATALEN)

Appendix A

		CLR	 A PDATALOOP:	 MOVX	@R0,A 		INC	 R0 		 ENDIF IF IBPSTACK <> 0 EXTRN DATA (?C_IBP) 		 ENDIF IF XBPSTACK <> 0 EXTRN DATA (?C_XBP) 		MOV	 ?C_XBP,#HIGH XBPSTACKTOP 		 ENDIF IF PBPSTACK <> 0 EXTRN DATA (?C_PBP) 		 ENDIF 		MOV	 SP,#?STACK-1 ; This code is required if you use L51_BANK.A51 with Banking Mode 4 ; Code Banking ; Select Bank 0 for L51_BANK.A51 Mode 4 #if 0 ;	 <i> Initialize bank mechanism to code bank 0 when using L51_BANK.A51 with Banking Mode 4. EXTRN CODE (?B_SWITCH0) 		 #endif ;		 LJMP	 ?C_START CALL	 ?B_SWITCH0	 ; init bank mechanism to code bank 0 MOV	 ?C_PBP,#LOW PBPSTACKTOP MOV	 ?C_XBP+1,#LOW XBPSTACKTOP MOV	 ?C_IBP,#LOW IBPSTACKTOP DJNZ	 R7,PDATALOOP

		END ParrOS.a51 ; ParrOS.a51 ;  STORES ALL TASK REGISTERS ;

25
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; ================================================================ ;  EACH TASK CAN BE MADE TO USE ANY NUMBER OF TIME SLOTS (1 TO 255) ;  SO THAT NOT ALL TASKS RUN FIOR THE SAME AMOUNT OF TIME. ;  NOMINALLY THEY RUN FOR JUST ONE TIME SLOT ; ================================================================ ; ;  INCLUDES RTOSGOSEC FOR 1 SECOND TICKS ; ;  LATEST - HANDLES 20 TASKS OR MORE, DEPENDING ON ;  EXTERNAL MEMORY AND INTERNAL STACK SPACE ;  CAN BE USED WITH ASSEMBLY LANGUAGE MAIN PROGRAM ; ;  Written by Paul P. Debono – NOVEMBER 2002 ;  University of Malta ;  Department of Communications and Computer Engineering ;  MSIDA MSD 2080; MALTA. ;  Adapted and modified from the RTKS RTOS FOR THE 8032 BOARD ;  Accomodates 20 OR MORE tasks, (take care of the stack size!) ;  STACK MOVING VERSION - MOVES WORKING STACK IN AND OUT OF ;  EXTERNAL MEMORY ;  SLOWS DOWN RTOS, BUT DOES NOT RESTRICT TASK CALLS ;

Appendix A

;  Uses timer 2, in 16-bit auto-reload mode as the time scheduler (time-ticker) ;  All tasks run in bank 0, RTOS kernel runs in bank 1 ;  All tasks must be written as an endless loop. ; ;  IDLE TASK (ENDLESS MAIN PROGRAM HAS A TASK NUMBER = NOOFTASKS) ; ;  COMMANDS AVAILABLE FOR THE C APPLICATION PROGRAM ARE: ;  (valid parameter values are shown in parenthesis) ; ;  INIT_RTOS(TSLOT)		 ;				 ;				 ;				 ;  RTOSGOMSEC(TICKTIME)	 ; ;  THIS IS STILL A SMALL TEST VERSION RTOS. IT IS JUST USED FOR ;  SHOWING WHAT IS NEEDED TO MAKE A SIMPLE RTOS. ;  IT MIGHT STILL NEED SOME MORE FINE TUNING. ;  IT HAS NOT BEEN NOT THOROUGHLY TESTED !!!! ;  WORKS FINE SO FAR. ;  NO RESPONSABILITY IS TAKEN. Initialise variables with default Tslot (for Main) (1-255) TSK# passed in R7 BANK 0 TSLOT passed in R5 BANK 0 TSKADDR in R1 (low byte) and R2 (high byte) BANK 0 Start RTOS going, interrupt every TICKTIME msecs (1-255). ;  CREATE(TSK#,TSLOT,TSKADDR) Create a new task.

26
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
$NOMOD51 #include "reg52.h" 	 USING 1 ;  ASSEMBLER MACROS SetBank MACRO BankNumber IF BankNumber = 0 	 	 ENDIF IF BankNumber = 1   SETB RS0   CLR RS1 ENDIF ENDM Ext2Int MACRO		   MOV R1,#MAIN_STACK   MOV R0,#STACKSIZE NEXT11:   MOVX A,@DPTR   MOV @R1,A   INC DPTR   INC R1   DJNZ R0,NEXT11 ENDM Int2Ext MACRO		 			   MOV R1,#MAIN_STACK   MOV R0,#STACKSIZE NEXT12:   MOV A,@R1   MOVX @DPTR,A   INC DPTR   INC R1   DJNZ R0,NEXT12 ENDM Push_Bank0_Reg MACRO   PUSH ACC   PUSH B   PUSH PSW   PUSH DPL   PUSH DPH   PUSH 00   PUSH 01 CLR RS0 CLR RS1 ; check your own correct path

Appendix A

; MOVES R0 DATA FROM EXT DPTR POINTER TO INTERNAL R1 POINTER

; MOVES R0 DATA FROM INTERNAL R1 POINTER TO EXT DPTR POINTER ; USES R0, R1, ACC AND DPTR

27
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  PUSH 02   PUSH 03   PUSH 04   PUSH 05   PUSH 06   PUSH 07 ENDM Pop_Bank0_Reg MACRO   POP 07   POP 06   POP 05   POP 04   POP 03   POP 02   POP 01   POP 00   POP DPH   POP DPL   POP PSW   POP B   POP ACC ENDM

Appendix A

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

28
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II
; ; NOTE: Functions which receive parameters when ;	 ; 	 ; PUBLIC _RTOSGOMSEC, _RTOSGOSEC, _RTOSGOMIN PUBLIC _CREATE, _INIT_RTOS CLOCK 		 EQU 460		 ; COUNT FOR HALF A MILLISECOND called from within C must have their name start with an underscore in the A51 source file.

Appendix A

; timer clock (11059/12 = 922) counts for 1 msec assuming 11.0592 MHz crystal ; hence 921.6/2 = 460 for half a milli second BASIC_TICK EQU 65535 - CLOCK + 1 ONEMSEC 	 ONESEC 		 HALFMIN 	 XTRAMTOP 	 RAMTOP 		 NOOFTSKS 	 ; ; **************************************************************************** ; 			 I M P O R T A N T ; THIS IS REQUIRED SO THAT THE LOCATION OF THE STACK IS KNOWN ; THIS IS TAKEN FROM THE VALUE WORKED OUR IN PARROS_STARTUP.A51 ; EXTRN IDATA (MAIN_STACK) ; ; **************************************************************************** ; 				 STACKSIZE EQU 30H		 NOOFPUSHES EQU 13 		  				 ; LIMITED ONLY BY STACK/MEMORY SPACE ; 15H MINIMUM ; NUMBER OF PUSHES AT BEGINNING OF RTOS_INT ROUTINE ; WITH LESS TASKS, YOU CAN INCREASE STACKSIZE ; SIZE OF STACK IS CRITICAL AND SYSTEM CAN CRASH EQU 2 		 EQU 2000 	 EQU 60000 	 EQU 0FFFFH	 EQU 0FFH 	 EQU 16 		 ; 2 HALF MSECS EQUAL 1 MSEC ; 2000 1/2 MSEC TICKS = 1 SECOND ; 60000 1/2 MSEC TICKS = 1/2 MINUTE ; FLT32 EXTERNAL RAM TOP ; MAXIMUM VALUE FOR 8032 WOULD BE 0FFH ; CAN HAVE MORE TASKS (numbered 0 to N-1)

					 NOT_TIMING EQU 0FFH IDLE_TASK EQU NOOFTSKS 	

					; IF YOU USE A LARGE OR EVEN A SMALLER VALUE. TRY IT OUT ; main endless loop in C application given ; a task number equal to NOOFTSKS

					 MYBITS SEGMENT BIT RSEG MYBITS   MSECFLAG: DBIT 1 		   SECFLAG: DBIT 1 		

; MARKER TO INDICATE TICKS EVERY X MILLISECONDS ; MARKER TO INDICATE TICKS EVERY X SECONDS ; MARKER TO INDICATE TICKS EVERY X MINUTES	

  MINFLAG: DBIT 1			 VAR1 SEGMENT DATA RSEG VAR1 			

; VARIABLE DATA AREA VAR1,

29
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
 				 ;DSEG AT 10H   READYQTOP: 	 DS 1 		   RUNNING: 	   DELAYLO: 	   DELAYHI: 	   GOPARAM: 	 DS 1 		 ; ADDRESS OF LAST READY TASK ; NUMBER OF CURRENT TASK ; USED FOR RTOSGO..... ; USED FOR RTOSGO..... ; USED FOR RTOSGO..... ; USED FOR RTOSGO.....

Appendix A

  ; range 0x10-0xFF, since we are using Banks 0,1

  TICKCOUNT: 	 DS 1			 DS 1			 DS 1			 DS 1			

  TMPSTORE0: 	 DS 1 		 DSEG AT 22H   READYQ: 	   SPTS: 	   T_SLOT: 	

; USED IN FETCHSTACK

DS (NOOFTSKS + 1) 	 DS (NOOFTSKS + 1) 	 DS (NOOFTSKS + 1) 	

; QUEUE STACK FOR TASKS READY TO RUN ; SP FOR EACH TASK AND 1 FOR THE IDLE TASK ; TIME SLOTS USAGE PER TASK AND MAINS ; RELOAD VALUE FOR TIME SLOTS ABOVE

  T_SLOT_RELOAD: DS (NOOFTSKS + 1) 	

; MAIN_STACK AREA STARTS HERE, NEXT LOCATION AFTER TSKFLAGS. ;SPARE_STACK SEGMENT XDATA 	 ;RSEG SPARE_STACK XSEG AT 1 + XTRAMTOP - (NOOFTSKS + 1) * STACKSIZE   EXT_STK_AREA: DS (NOOFTSKS + 1) * STACKSIZE   ; THIS IS THE ACTUAL SIZE OF STACK AREA ;CSEG AT 8028H 			 32 BOARD CSEG AT 0028H 				 CONTROLLER   CLR TF2 				 automatically)   LJMP RTOS_TIMER_INT MyRTOS_CODE SEGMENT CODE 		 RSEG MyRTOS_CODE ; START OF RTOS SYSTEM ; PREFIX NAME FOR FUNC WITH REG-PASSED PARAMS MUST START WITH AN UNDERSCORE _ _INIT_RTOS: 				 					 ; SYS CALL TO SET UP VARIABLES ; R7 HOLDS THE DEFAULT TSLOT (FOR MAIN) ; STARTS AT 8100H FOR THE FLIGHT32 BOARD ; INTERRUPT VECTOR ADDRESS FOR TIMER 2 ON FLIGHT ; INTERRUPT VECTOR ADDRESS FOR TIMER 2 ON GENERIC 	 ; VARIABLE EXTERNAL DATA

  CLR EA				; ; Clear Timer 2 interrupt flag (not done

; IN THE C ENVIRONMENT, THE KEIL SOFTWARE CLEARS THE INTERNAL RAM FROM 0 TO 7FH ; WHEN THE STARTUP SEQUENCE IS CALLED. ; EVEN THOUGH THE 8032 WITH 0-FFH INTERNAL RAM WAS CHOSEN IN THE TARGET OPTION. ; HENCE CERTAIN VARIABLES STORED FROM 80H TO FFH (SUCH AS TSKFLAGS) MUST BE ; INITIALISED TO ZERO IN THIS INITALISATION ROUTINE. ; ; IN ASM OR A51 (NOT IN C), ALL THE INTERNAL RAM (0-FFH) IS ; CLEARED BY MEANS OF THE CLR_8051_RAM MACRO. ;

30
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  MOV DPTR,#EXT_STK_AREA 		   MOV R0,#(NOOFTSKS + 1)   CLR A NEXT_STACK:   MOV R1,#STACKSIZE CLR_STACK:   MOVX @DPTR,A   INC DPTR   DJNZ R1,CLR_STACK   DJNZ R0,NEXT_STACK   MOV R5,07				   MOV IE,#20H 				   MOV RUNNING,#IDLE_TASK 		   MOV R7,#(NOOFTSKS + 1)		 TASK   MOV R1,#READYQ LOAD_VARS:   MOV @R1,#IDLE_TASK 			 less loop)   INC R1   DJNZ R7,LOAD_VARS 			   MOV READYQTOP,#READYQ ; SET UP ALL TASKS ; STORE DEFAULT TSLOT IN R5 ; ENSURE EA = 0 AND ET2 = 1 ; NEXT CLEAR ALL EXTERNAL RAM STACKS

Appendix A

; IDLE TASK RUNNING (Main program endless loop) ; FILL ONE ADDITIONAL LOCATION, FOR MAIN IDLE

; IDLE TASK IN ALL OF READYQ (Main program end-

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel – as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

31
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II
; INITIALISE ALL STACK POINTERS   MOV R7,#NOOFTSKS			
 

Appendix A

; COUNTER ; MAIN IDLE TASK TAKEN CARE OF BY 1ST INTERRUPT

MOV R0,#SPTS 				

  MOV A,#(MAIN_STACK - 1)   ADD A,#(NOOFPUSHES + 2) SET_UP:   MOV @R0,A 				 PREPARATION   INC R0				   DJNZ R7,SET_UP			 ; ALL SPs POINT TO MAIN_STACK + PUSHES, IN ; FOR THE EVENTUAL RETI INSTRUCTION ; USED TO CHANGE TASKS AFTER AN RTOS INTERRUPT.

; INITIALISE TIME SLOTS, INITIALLY ALL SET TO THE GIVEN DEFAULT VALUE   MOV R7,#(NOOFTSKS +1)   MOV R0,#T_SLOT   MOV R1,#T_SLOT_RELOAD LOAD_SLOTS:   MOV @R0,05   MOV @R1,05   INC R0   INC R1   DJNZ R7,LOAD_SLOTS  RET _CREATE: 					 					 					 					 					   INC READYQTOP   MOV R0, READYQTOP   MOV @R0,07 				   MOV A,#T_SLOT   ADD A,R7   MOV R0,A   MOV @R0, 05 				   MOV A,#T_SLOT_RELOAD   ADD A,R7   MOV R0,A   MOV @R0, 05 				   MOV A,R7   CALL FetchStack   MOV A,R1   MOVX @DPTR,A 				   INC DPTR ; copy low byte R1 into LOW STACK AREA ; PUT GIVEN TIME SLOT (IN R5) INTO RELOAD 					; MEM LOCATION (T_SLOT_RELOAD) ; PUT GIVEN TIME SLOT (IN R5) INTO MEM LOCATION ; PLACE TASK IN READYQ ; SYS CALL ENTRY TO CREATE A TASK ; TASK NUMBER (0 to 7) PASSED IN BANK0 R7 ; TIME SLOT (1 - 255) PASSED IN BANK0 R5 ; TASK START ADDR PASSED IN BANK0 R1,R2,R3 ; LSB in R1, MSB in R2, R3 contains type	

32
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  MOV A,R2   MOVX @DPTR,A 				  RET _RTOSGOMSEC: 				   SETB MSECFLAG 			   CLR SECFLAG   CLR MINFLAG   MOV DELAYLO,#LOW(ONEMSEC)   MOV DELAYHI,#HIGH(ONEMSEC)   SJMP LOAD_REGS _RTOSGOSEC: 				   SETB SECFLAG 				   CLR MINFLAG   CLR MSECFLAG   MOV DELAYLO,#LOW(ONESEC)		 ; EQUAL ONE SECOND   MOV DELAYHI,#HIGH(ONESEC)   SJMP LOAD_REGS _RTOSGOMIN:   SETB MINFLAG   CLR MSECFLAG   CLR SECFLAG   MOV DELAYLO,#LOW(HALFMIN) 		   MOV DELAYHI,#HIGH(HALFMIN) LOAD_REGS:   MOV RCAP2H,#HIGH(BASIC_TICK) 	 					   MOV GOPARAM,07 			   MOV TICKCOUNT,07   MOV T2CON,#04H 			   SETB EA				   SETB TF2 				   RET					 EXIT1: LJMP EXIT			 RTOS_TIMER_INT:			 INTERRUPT 					  Push_Bank0_Reg   SetBank 1 				   CLR C   MOV A, DELAYLO ; SET TO REGISTERBANK 1 ; LOAD RCAPS WITH 1 MILLISECOND COUNT   MOV RCAP2L,#LOW(BASIC_TICK)	 		 ; NOW SAVE THE HIGH ORDER BYTE (R2)

Appendix A

; SYS CALL TO START RTOS FOR R7 MILLISECOND TICKS ; SET MARKER

; SYS CALL TO START RTOS FOR R7 SECOND TICKS ; SET MARKER

; 60000 HALF MILLISECONDS EQUAL HALF MINUTE

; SAVE THEM IN THE AUTO RE-LOAD REGISTERS

; OF TIMER 2 (for Flight 32) ; LOAD TICKS PARAMETER, PASSED IN R7 BANK 0 ; START TIMER 2 IN 16-BIT AUTO RELOAD MODE. ; ENABLE GLOBAL INTERRUPT SIGNAL ; SIMULATE TIMER 2 INTERRUPT ; EFFECTIVELY STARTING THE RTOS. ; STEPPING STONE ; INTERRUPT ENTRY ONLY FROM TIMER2 OVERFLOW

; USES ACC,PSW, (R0,R1 AND R2 FROM BANK 1)

33
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  SUBB A,#1   MOV DELAYLO,A   MOV A,DELAYHI   SUBB A,#0   MOV DELAYHI,A   ORL A,DELAYLO 			 PASSED   MOV DELAYLO,#LOW(ONEMSEC)		   MOV DELAYHI,#HIGH(ONEMSEC)   JB MSECFLAG,CHK_GO_PARAM   MOV DELAYLO,#LOW(ONESEC)   MOV DELAYHI,#HIGH(ONESEC)   JB SECFLAG,CHK_GO_PARAM   MOV DELAYLO,#LOW(HALFMIN)   MOV DELAYHI,#HIGH(HALFMIN)   CPL MINFLAG   JNB MINFLAG, EXIT1 			 CHK_GO_PARAM: ; WAIT FOR ONE MINUTE (TWICE HALF MIN)

Appendix A

; CHECK IF DELAY (1 MSEC, 1 SEC OR 1/2 MIN) HAS ; IF NOT, EXIT

  JNZ EXIT 					

; DELAY OF 1 MSECS

  DJNZ TICKCOUNT, EXIT1		 ; CHECK IF REQUIRED TIME SLOTS HAVE PASSED   MOV TICKCOUNT,GOPARAM 					; QROTATE 					 					   MOV A,#T_SLOT 			   ADD A,RUNNING   MOV R0,A				   MOV A,@R0   DEC A   MOV @R0,A				   JNZ EXIT1				   MOV A,#T_SLOT_RELOAD 		   ADD A,RUNNING		   MOV A,@R1   MOV @R0,A				   MOV A, #SPTS				   ADD A, RUNNING   MOV R0,A   MOV @R0, SP 				   MOV A,RUNNING   MOV R5, A 				   CALL FetchStack ; SAVE CURRENT TASK IN R5 BANK 1 (ADDRESS 0DH) ; store present stack pointer of task. ; RESET ORIGINAL TIME SLOT VALUE ; save SP 		   MOV R1,A				 ; SAVE DECREMENTED TIME SLOT ; TIME SLOT NOT FINISHED, HENCE EXIT WITHOUT ; TIME SLOT PASSED, THEREFORE RELOAD WITH ; ORIGINAL VALUE AND CHANGE TASKS ; R1 POINTS TO T_SLOT_RELOAD OF RUNNING TASK ; R0 POINTS TO T_SLOT OF RUNNING TASK ; SAVE PRESENT RUNNING TASK STACK PTR ; GET NEW RUNNING TASK FROM READYQ ; FIRST CHECK IF REQUIRED TIME SLOT HAS PASSED 					; ROTATE READYQ BY ONE

					; CHANGING TASKS

34
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  Int2Ext 				   MOV R1,#(READYQ + 1)		 	   MOV R0, READYQTOP   DEC R0	 			 SHIFT_DOWN:   MOV A,@R1   DEC R1   MOV @R1,A   MOV A,R1   INC R1   INC R1   CJNE A,08,SHIFT_DOWN	 		   INC R0				   MOV @R0, 0DH 				 RUN_NEW_TASK: ; run new task   MOV A,READYQ   MOV RUNNING,A 			   CALL FetchStack   Ext2Int 				   MOV A,#SPTS   ADD A,RUNNING   MOV R0,A   MOV SP,@R0				 ; SET SP TO NEW TASK STACK AREA ; GET NEW STACK IMAGE ; SET NEW TASK AS RUNNING ; THEY ALL MOVED DOWN SO ; R0 NOW POINTS AGAIN TO READYQTOP ; PLACE CURRENT TASK ON TOP OF QUEUE

Appendix A
; SAVE STACK IN EXTERNAL, READY FOR SWAP ; Now SHIFT Q DOWN 1 ; R0 NOW POINTS TO ONE BYTE BELOW TOP OF QUEUE

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

35
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II
EXIT:  Pop_Bank0_Reg   SetBank 0   SETB EA  RETI ; SUB ROUTINES FetchStack: ; ENTRY A = TASK NUMBER, USES ACC, DPTR, AND R0 ; EXIT DPTR POINT TO START OF STACK AREA FOR TASK   PUSH 00   PUSH 08   MOV TMPSTORE0,A   MOV DPTR,#EXT_STK_AREA   MOV R0,#0 LOOP1:   MOV A,R0   CJNE A,TMPSTORE0,CONT1   POP 08   POP 00  RET CONT1:   MOV A,#STACKSIZE   ADD A,DPL   MOV DPL,A   MOV A,DPH   ADDC A,#0   MOV DPH,A   INC R0   SJMP LOOP1 END

Appendix A

36
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Appendix B	 PaulOS A51 version
The PaulOS RTOS This is the A51 assembly language version of the PaulOS (PAUL’s Operating System) RTOS. It has been superseded by its C language version but we have included it here for the benefit of those who are keen to use the assembly language even in ‘large’ projects. Most of the explanations have already been included in Chapter 9 but are being retained here so as to make it a self-contained appendix. The idea behind the PaulOS RTOS is that any task (part of program) can be in any ONE of three states: RUNNING It can be RUNNING, (obviously in the single 8051 environment, there can only be one task which is running.) WAITING It can be in the WAITING or SLEEPING queue. Here a task could be waiting for any one of the following: •	 a specified amount of time, selected by the user with WAITT command. •	 a specified amount of time, selected by the user with PERIODIC command. •	 a specified interrupt to occur within a specified time, selected by the user with the WAITI command. •	 a signal from some other task within a specified timeout. •	 a signal from some other task indefinitely. •	 finally, a task could be waiting here for ever, effectively behaving as if the task did not exist. This is specified by the KILL command. READY It can also be in the READY QUEUE, waiting for its turn to execute. This can be visualised in Figure 7-1 which shows how the task can move from one state to the other. The RTOS itself always resides in the background, and comes into play: •	 At every RTOS TIMER interrupt (usually Timer 2 or Timer 0, every one millisecond). •	 At any other interrupt from other timers or external inputs. •	 Whenever an RTOS system command is issued by the main program or tasks.

37
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

The RTOS which is effectively supervising all the other tasks, then has to make a decision whether it has to change tasks. There could be various reasons for changing tasks, as explained further on, but in order to do this task swap smoothly, the RTOS has to save all the environment of the presently running task and substitute it with the environment of the next task which is about to run. This is accomplished by saving all the BANK 0 registers, the ACC, B, PSW, and DPTR registers. The STACK too has to be saved since the task might have pushed some data on the stack (apart from the address in the task program, where it has to return to after the interrupt). System Commands Here is a detailed explanation of all the PaulOS RTOS system commands. They are listed in the sequence in which they appear in the PaulOS.A51 source program. Note that certain system commands initiate a task change whilst others do not. The following calls listed in Table B-2 do not receive parameters, hence are not declared with an underscore prefix in the a51 file.

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

38
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

void SET_IDLE_MODE(void)		 void SET_POWER_DOWN(void)	 void DEFER(void)			 void KILL(void)			 uchar SCHEK(void) uchar RUNNING_TASK_ID(void) void WAITV(void)			

- Normally used in Main idle task - Normally used in Main idle task - This commands causes a task change - This commands causes a task change

- This commands causes a task change
Table B-2 System Calls without any parameters

The following calls listed in Table B-3 do require parameters, hence are declared with an underscore prefix in the a51 file. void INIT_RTOS(uchar IEMASK)	 void SIGNAL(uchar task) void WAITI(uchar intnum)		 void WAITT(uint ticks)			 void WAITS(uint ticks)			 void PERIODIC(uint ticks) void RESUME(uchar task)		 - This commands causes a task change - This commands causes a task change - This commands causes a task change - This commands causes a task change if signal is not yet present - Normally used in Main idle task

void RTOSGOMSEC(uchar msecs,uchar prior) - Normally used in Main idle task

void CREATE(uchar task,uint *taskadd) - Normally used in Main idle task

Table B-3 System calls needing some parameters

INIT_RTOS(IEMASK) This system command must be the FIRST command to be issued in the main program in order to initialise the RTOS variables. It is called from the main program and takes the interrupt enable mask (IEMASK) as a parameter. An example of the syntax used for this command is: INIT_RTOS(0x30); which would imply that some task is intended to use the Timer 2 interrupt (IEMASK=20H) for the RTOS as well as the Serial Interrupt (IEMASK=10H). (See Table B-4 ). The default mask is 20H which enables just the Timer 2 interrupt. This 20H is always added (or ORed) by the RTOS automatically to any other mask. Other masks which are valid are:

39
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Interrupt No: 0 1 2 3 4 5 Name External Int 0 Timer Counter 0 External Int 1 Timer Counter 1 Serial Port Timer 2 (8032 only)

IE MASK Binary 00000001 00000010 00000100 00001000 00010000 00100000 Hex 01 02 04 08 10 20

Notes

Default RTOS for 8051

Default RTOS for 8032

Table B-4 IEMASK parameter

This system command performs the following: •	 Clears the external memory area which is going to be used to store the stack of each task. •	 Sets up the IE register (location A8H in the SFR area)}. •	 Selects edge triggering on the external interrupts. (can be amended if different triggering required). •	 Loads the Ready Queue with the main idle task number, so that initially, only the main task will execute. •	 Initialises all task as being not waiting for a timeout. •	 Sets up the SP of each task to point the correct location in the stack area of the particular task. The stack pointer, initially, is made to point to an offset of 14 above the base of the stack [(MAIN\_STACK - 1) + NOOFPUSHES + 2] since NOOFPUSHES in this case is 13. This is done so as to ensure that when the first RET instruction is executed after transferring the stack from external RAM on to the 8032 RAM, the SP would be pointing correctly to the address of the task to be started. This is seen in the QSHFT routine, where before the last RET instruction, there is the Pop_Bank0_Reg macro which effectively pops 13 registers. The RET instruction would then read the correct address to jump to from the next 2 locations. CREATE(Task No:, Task Name) This system command is used in the main program for each task to be created. It takes two parameters, namely the task number (1st task is numbered as 0), and the task address, which in the C environment, would simply be the name of the procedure. An example of the syntax used for this command is: CREATE(0,MotorOn); This would create a task, number 0. This task would in fact be the MotorOn procedure. This system command performs the following:

40
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

•	 Places the task number in the next available location in Ready Queue, meaning that this task is ready to execute. The location pointer in Ready Queue is referred to as READYQTOP in the program, and is incremented every time this command is issued. •	 Loads the address of the start of the task in the bottom of the stack area in external ram allocated to this task. The SP for this task would have been already saved, by the INIT_ RTOS command, pointing to an offset 13 bytes above this. RTOSGOMSEC(Msec, Priority) This system command is used only ONCE in the main program, when the RTOS would be required to start supervising the processes. It takes two parameters, namely: The number of milliseconds, which would be the base reference for other time dependent commands, such as PERIODIC, WAITT and WAITS. The Priority (0 or 1), which if set to 1, implies that tasks placed in the Ready Queue, ready to execute, would be sorted in descending order before the RTOS selects the next task to run. A task number of 0 is assigned to the HIGHEST priority task, and would obviously be given preference during the sorting.

AXA Global Graduate Program
Find out more and apply

41
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

An example of the syntax used for this command is: RTOSGOMSEC(10,1) This would start the RTOS ticking, at a reference time signal of 10 milliseconds. This 10 milliseconds would then become the basic reference unit for other system commands which use any timeout parameter. The RTOS would also be required to execute task sorting prior to any task change. It should be pointed out here, that the RTOS timer would still be generating interrupts every half a millisecond (if the HALFMSEC variable is set to 1 in the file) , so as to respond to external interrupts relatively quickly. This system command performs the following: •	 Loads the variable DELAY (LO and HI bytes), with the number of BASIC_TICKS required to obtain a one millisecond interval. Since BASIC_TICKS correspond to a half second interval in Timer 2, then to get a one millisecond interval, DELAY is simply loaded with 2. •	 Set the PRIORITY bit according to the priority parameter supplied. •	 Load RCAP2H and RCAP2L, the timer 2 registers, with the required count in order to obtain half a millisecond interval between timer 2 overflow interrupts. The value used depends on the crystal frequency used on the board. The clock registers count up at one twelfth the clock frequency, and using a clock frequency of 11.0592 MHz, each count would involve a time delay of 12/11.0592 μsec. (1.085 μsec). •	 Therefore to get a delay of half a millisecond (500 μsecs), 500/1.085 or 460.8 counts would be needed. Since there are a lot of overheads in the Pushes and Pops involved during every interrupt, a count of 450 was used. Moreover, since the timers generate an interrupt when there is an overflow in the registers, then the registers are actually loaded with 65086 or (65536 – 450). •	 Store the reference time signal parameter in GOPARAM and TICKCOUNT. •	 Start timer 2 in 16-bit auto-reload mode. •	 Enable interrupts. •	 Set TF2, which is the timer 2 overflow interrupt flag, thus causing the 1st interrupt. RUNNING_TASK_ID( ) This system command is used by a task to get the number of the task itself. It returns a value (in R7 bank 0). The same task continues to run after executing this system command. An example of the syntax used for this command is: X = RUNNING_TASK_ID(); /* where X would be an unsigned integer */

42
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

SCHEK( ) This system command is used by a task to test whether there was any signal sent to it by some other task. It returns a value (in R7 bank 0): 1 - Signal is not present 0 - Signal is present If the signal was present, it is also cleared before returning to the calling task. The same task continues to run, irrespective of the returned value. An example of the syntax used for this command is: X = SCHEK(); /* where X would be an unsigned integer */ or you may use it in the following example to test the presence of the signal bit: if (SCHEK() == 0) { /* do these instructions if a signal was present */ } SIGNAL(Task No:) This system command is used by a task to send a signal to another task. If the other task was already waiting for a signal, then the other task is placed in the Ready Queue and its waiting for signal flag is cleared. The task issuing the SIGNAL command continues to run, irrespective of whether the called task was waiting or not waiting for the signal. If you need to halt the task after the SIGNAL command to give way to other tasks, you must use the DEFER() system command after the SIGNAL command. This system command performs the following: •	 It first checks whether the called task was already waiting for a signal. •	 If the called task was not waiting, it set its waiting for signal (SIGW) flag and exits to continue the same task. •	 If it was already waiting, it places the called task in the Ready Queue and it clears both the waiting for signal (SIGW) and the signal present (SIGS) flags. •	 It also sets a flag (TINQFLAG) to indicate that a new task has been placed in the Ready Queue. This flag is used by the RTOS_TIMER_INT routine (every half a millisecond) in order to be able to decide whether there has to be a task change. It then exits the routine to continue the same task.
43
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

An example of the syntax used for this command is: SIGNAL(1); // send a signal to task number 1 The following commands perform a change of task: WAITI(Interrupt No:) This system command is called by a task to ’sleep’ and wait for an interrupt to occur. Another task, next in line in Ready Queue would then take over. If the interrupt never occurs, then the task will effectively sleep for ever. If required, this command can be modified to allow another timeout parameter to be passed, so that if the interrupt does not arrive within the specified timeout, the task would resume. A timeout of 0 would leave the task still waiting the interrupt forever. This would be similar to the WAITS command explained further down. This system command performs the following: •	 It sets the bit which correspond to the interrupt number passed on as a parameter. •	 It then calls the QSHFT routine in order to start the task next in line.

44
Download free eBooks at bookboon.com

Click on the ad to read more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

An example of the syntax used for this command is: WAITI(0); // wait for an interrupt from external int 0 The task would then go into the sleep or waiting mode and a new task would take over. WAITS(Timeout) This system command is called by a task to sleep and wait for a signal to arrive from some other task. If the signal is already present (previously set by some other task), then the signal is simply cleared and the task continues on. If the signal does not arrive within the specified timeout period, the task resumes just the same. However, a timeout number of 0 would imply that the task has to keep on waiting for a signal indefinitely. If the signal does not arrive, then the task never resumes to work and effectively kills the task. This system command performs the following: •	 It first checks whether the signal is already present. •	 If it is it clears the signal flag, exits and continues running •	 If signal is not present, then: •	 It sets its own waiting for signal (SIGW) flag. •	 It also sets the waiting for timeout variable according to the supplied parameter. •	 It then jumps to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is: WAITS(50); // wait for a signal for 50 units, the value of the unit depends on // the RTOSGOMSEC parameter used. If for example, the command RTOSGOMSEC(10,1) was used, the reference unit would be 10 milliseconds, and WAITS(50) would then imply waiting for a signal to arrive within 500 milliseconds. or you can use: WAITS(0); // this would wait for a signal for ever In both examples, the task would then go into the sleep or waiting mode and a new task would take over.

45
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

WAITT(Timeout) This system command is called by a task to sleep and wait for a specified timeout period. The timeout period is in units whose value depends on the RTOSGOMSEC parameter used. Valid values for the timeout period are in the range 1 to 655635. A value of 0 is reserved for the KILL command, meaning permanent sleep, and therefore is not allowed for this command. The WAITT system command therefore performs the required check on the parameter before accepting the value. A value of 0 is changed to a 1. This system command performs the following: •	 If the parameter is 0, then set it to 1, to avoid permanent sleep. •	 Saves the correct parameter in its correct place in the TTS table. •	 Jumps to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is: WAITT(60); // wait for a signal for 60 units, the value of the unit depends on // the RTOSGOMSEC parameter used. If for example, the command RTOSGOMSEC(10,1) was used, the reference unit would be 60 milliseconds, and WAITT(60) would then imply waiting or sleeping for 600 milliseconds. If on the other hand, the command RTOSGOMSEC(250,1) was used, the reference unit would be a quarter of a second, and WAITT(240) would then imply waiting or sleeping for 60 seconds or 1 minute. In both examples, the task would then go into the sleep or waiting mode and a new task would take over. KILL( ) This system command is used by a task in order to stop or terminate the task. As explained earlier in WAITT, this is simply the command WAITT with an allowed timeout of 0. The task is then placed permanently waiting and never resumes execution. This system command performs the following: •	 It first clears any waiting for signal or interrupt flags, so that that task would definitely never restart. •	 It then sets its timeout period in the TTS table to 0, which is the magic number the RTOS uses to define any non-timing task. •	 It then sets the INTVLRLD and INTVLCNT to 0, again implying not a periodic task. •	 Jumps to the QSHFT routine in order to start the task next in line.

46
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

An example of the syntax used for this command is: KILL(); /* the task simply stops to execute and a new task would take over.*/ RESUME (Task Number) This system command is used in a task to resume another task which had already KILLed itself. The parameter passed is the task number of the task which has to be restarted. After executing this command, the calling task itself is DEFERred to give up its CPU time to any other task (presumably the resurrected task!) An example of the syntax used for this command is: RESUME(X); 		 /* where X would be a task number */

The task issuing this command, would then be placed in the waiting queue, for one tick time. DEFER( ) This system command is used by a task in order to hand over processor time to another task. The task is simply placed in the Waiting Queue, actually waiting for just 1 tick, while a new task resumes execution.

I’M WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

47
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

This system command performs the following: •	 It sets its timeout period in the TTS table to 1. The task will therefore be ready to execute after the next tick. •	 It then flows on to the QSHFT routine in order to start the task next in line. An example of the syntax used for this command is: DEFER(); /* the task simply stops execution and is placed in the Waiting Queue.*/ /* A new task would then take over. */ Variables Memory Map Table B-5 shows the way the variables used in this RTOS program have been set up. Most of the variables reside in the internal 256 RAM of the 8032 micro-processor. The external RAM (from address 8100H and higher for the Flight 32 board) is used to store the stacks of all the tasks and main idle program. These stacks are then swapped in turn with the area reserved for the stack in the internal RAM whenever a task swap is necessary.

48
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II Label Hex Byte Address FF To 80 MAIN_STACK Remarks Hex bit address Indirect General Purpose RAM (80 – FF) which can Be used as a Stack Area Direct and Indirect RAM (00 – 7F)

Appendix B Notes

7F to 76 75 to 61 60 to 4C 4B

SP (initially) T_SLOT_RELOAD

(NOOFTSKS+1) bytes

Time slot Reload values For each task Time slot Counter For each task Storage area For the SPs Of each task Queue for Tasks ready To run 08 Spare bits 00 MYBITS Storage for any Applications variables See FETCH_STACK RTOSGOMSEC RTOSGOMSEC RTOSGOMSEC

T_SLOT

(NOOFTSKS+1) bytes

SPTS

to 37 35

(NOOFTSKS+1) bytes

READYQ

to 22 21 0F

(NOOFTSKS+1) bytes 0E 0D 0C 0B 0A 09

20 1F to

07

06

05

04

03

02

01

TMPSTORE0 GOPARAM DELAYHI

17 16

15

DELAYLO

14 13 12 11

TICKCOUNT RUNNING READYQTOP

10 0F to 08

RTOSGOMSEC Currently running task Task number Points to last task in READYQ Pointer Register Bank 1 (R0 – R7) Register bank Used by the RTOS

49
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II Label Hex Byte Address 07 to 00 Remarks Hex bit address Register Bank 0 (R0 – R7)

Appendix B Notes Register bank used by ALL tasks

Table B-5 PaulOS.A51 Variables setup, with 18 (12H) tasks. (NOOFTSKS=12H)

The program listing for the assembly code version of PaulOS RTOS now follows. It consists of: •	 The header file PaulOS.h •	 The startup file Startup.a51 •	 The main source file PaulOS.a51 PaulOS.h
/* PaulosV5C.h */ /* for use with PaulosV5C.a51 RTOS program */ #define uchar unsigned char #define uint unsigned int #define ulong unsigned long // The following calls do not receive parameters, hence are not // declared with an underscore prefix in the a51 file void SET_IDLE_MODE(void); void DEFER(void); void KILL(void); void SET_POWER_DOWN(void);

/* written by Paul P. Debono - FEBRUARY 2005 */

uchar SCHEK(void); void WAITV(void);

uchar RUNNING_TASK_ID(void); // The following calls do receive parameters, hence are declared // with an underscore prefix in the a51 file void INIT_RTOS(uchar IEMASK); void SIGNAL(uchar task); void WAITT(uint ticks); void WAITS(uint ticks); void RTOSGOMSEC(uchar msecs,uchar prior); void WAITI(uchar intnum);

void CREATE(uchar task,uint *taskadd); void PERIODIC(uint ticks); void RESUME(uchar task); /* ADD-ON MACROS */

/* ==================================================== 	 /* ==================================================== 	

*/ */

50
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* Macro 'WAITM' Used to wait for a max of 1 MINUTE 			 #define WAITM(s, ms) WAITT((uint)(##s*1000 +##ms)) */ */ */ */ */ \ \ \ \ */ */ */

Appendix B

/* Use with an RTOSGOMSEC(1,0) - 1 milli seconds tick time 		 /* Macro 'WAITH' Used to wait for a max of 18h 12m 			 /* 66535 * 4 * 250 MILLISECONDS 					 /* Use with an RTOSGOMSEC(250,0) - 250 milli seconds tick time 	  			  			  			 WAITT((uint)(3600*##H + 60*##M + ##S)); 	 WAITT((uint)(3600*##H + 60*##M + ##S)); 	 WAITT((uint)(3600*##H + 60*##M + ##S)); 	

#define WAITH(H, M, S) 	 {WAITT((uint)(3600*##H + 60*##M + ##S)); 	

						}

/* Macro 'WAITD' Used to wait for a max of 7D 14h 2m 		 /* 66535 * 40 * 250 MILLISECONDS 					 /* Use with an RTOSGOMSEC(250,0) - 250 milli seconds tick time 	  			  			  			  			  			  			  			  			  			  			  			  			

#define WAITD(D, H, M) 	 {WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	\ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \

If it really matters, make it happen – with a career at Siemens.

siemens.com/careers

51
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
 			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			  			 WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ WAITT((uint)(8640*##D + 360*##H + 6*##M)); 	 \ */ */ */ */ */

Appendix B

			}

/* Macro 'PERIODICA' Used to wait for a max of 4h 33m 		

/* Use with an RTOSGOMSEC(250,0) - 250 milli seconds tick time 	 /* Macro 'PERIODICM' Used to wait for a max of 1 MINUTE 		 #define PERIODICM(s, ms) PERIODIC((uint)(##s*1000 +##ms))

#define PERIODICA(H, M, S) PERIODIC((uint)(14000*##H + 240*##M + 4*##S)) /* Use with an RTOSGOMSEC(1,0) - 1 milli seconds tick time 		 /* ========================================================		

TaskStk.a51
;TASKSTKV5C.a51 $NOMOD51 #include "..\Headers\reg52.h" ; check your own correct path USING 1 	 ; ; SET ASIDE BANK 1

; **************************************************************************** ; 				 INT_VECTOR_BASE EQU 7FFDH 		 TICK_TIMER EQU 2 			 USING_INT EQU 0 			 					 I M P O R T A N T ; INTERRUPT VECTOR TABLE BASE ADDRESS

; SELECT WHICH TIMER TO USE FOR RTOS TICKS ; SET TO 1 IF USING INTERRUPTS (WAITI) ; IF NOT USING PERIODIC COMMAND SET TO ZER0 ; TO CLEAR UP SOME INTERNAL IDATA MEMORY ; SET TO 1 TO CHECK INTERRUPTS EVERY 1/2 MSEC

PERIODIC_CMD EQU 0 			 HALFMSEC EQU 1 			

52
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
 					 NOOFTSKS EQU 7 			 					 MAIN_STACK EQU 0BFH 			 ; ; ; ELSE RTOS WOULD CHECK EVERY 1 MSEC ; CAN BE MORE, SAY 20 TASKS (numbered 0 to 19) ; CONFIRM LOCATION WITH KEIL FILE *.M51 ; see variable ?STACK in IDATA ; 20H MINIMUM

Appendix B

STACKSIZE EQU 25H			

; NOTE ************************************************************************* ; 	 ; ; ***************************************************************************** ; THESE ARE THE FOUR MAIN PARAMETERS WHICH YOU MIGHT NEED TO ADJUST, ; DEPENDING ON YOUR APPLICATION. ; ; MODIFY ABOVE TO REFLECT YOUR APPLICATION PROGRAM AND HARDWARE

; A STACK SIZE OF 20H SHOULD BE ADEQUATE FOR MOST APPLICATIONS. ; **************************************************************************** #include "..\PaulosRTOS\RTMACROSV5C.a51" #include "..\PaulosRTOS\PaulosV5C.a51"

; ****************************************************************************

RTMacros.a51
; ; ; RTMACROSV5C.A51 ; RTOS EQUATES ; 	 	 	 	 	 	 ; 	 	

; FOR USE WITH PAULOSV5C.A51 RTOS. EXT0_INT_VECTOR EQU (INT_VECTOR_BASE + 03H) TIM0_INT_VECTOR EQU (INT_VECTOR_BASE + 0BH) EXT1_INT_VECTOR EQU (INT_VECTOR_BASE + 13H) TIM1_INT_VECTOR EQU (INT_VECTOR_BASE + 1BH) SER0_INT_VECTOR EQU (INT_VECTOR_BASE + 23H) TIM2_INT_VECTOR EQU (INT_VECTOR_BASE + 2BH)

IF (HALFMSEC = 1) RTCLOCK 	 RTCLOCK 	

ELSE 					 ENDIF EQU 922

EQU 461 	

; timer clock (11059/12 = 922) counts for 1 msec ; assuming 11.0592 MHz crystal

BASIC_TICK EQU (65535 - RTCLOCK + 1) NOOFPUSHES EQU 13 			 IDLE_TASK EQU NOOFTSKS 	 NOT_TIMING EQU 0H ; TASK FLAG MASKS SIGS 		 SIGW 		 				 					 	 	 ; Number of pushes at beginning of Task change ; i.e. pushes in PushBank0. ; main endless loop in C application given ; a task number equal to NOOFTSKS

EQU 10000000B		 EQU 01000000B		

; 128 ; 64

53
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
SIGV 		 SER0W 		 EXT1W 		 EXT0W 		   TIM0W 	   TIM1W 	   TIM0W 	   TIM2W 	   TIM1W 	   TIM2W 	 ENDIF EQU 00100000B		 EQU 00010000B		 EQU 00000100B		 EQU 00000001B		 EQU 00000010B		 EQU 00001000B		 EQU 00000010B		 EQU 00001000B		 EQU 00000010B		 EQU 00001000B		 ; 32 ; 16 ; 4 ; 1 ; 2 ; 8 ; 2 ; 8 ; 2 ; 8

Appendix B

IF (TICK_TIMER = 2)

ELSEIF (TICK_TIMER = 1)

ELSEIF (TICK_TIMER = 0)

; ======================================================== ; ======================================================== ; RTOS MACROS ; SetBank MACRO BankNumber IF BankNumber = 0   CLR RS0   CLR RS1

ELSEIF BankNumber = 1   SETB RS0   CLR RS1

ELSEIF BankNumber = 2   SETB RS1   CLR RS0

ELSEIF BankNumber = 3   SETB RS1   SETB RS0 ENDIF ENDM

Ext2Int MACRO 		

  MOV R1,#MAIN_STACK   MOV R0,#STACKSIZE NEXT11:   MOVX A,@DPTR   MOV @R1,A   INC DPTR   INC R1 ENDM 	

; MOVES R0 DATA FROM EXT DPTR POINTER TO INTERNAL R1 POINTER

  DJNZ R0,NEXT11 Int2Ext MACRO 		   MOV R1,#MAIN_STACK   MOV R0,#STACKSIZE NEXT12:   MOV A,@R1 		 ; MOVES R0 DATA FROM INTERNAL R1 POINTER TO EXT DPTR PONTER ; USES R0, R1, ACC AND DPTR

54
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
  MOVX @DPTR,A   INC DPTR   INC R1 ENDM

Appendix B

  DJNZ R0,NEXT12 Push_Bank0_Reg MACRO			   PUSH ACC   PUSH B   PUSH PSW   PUSH DPL   PUSH DPH   PUSH 00   PUSH 01   PUSH 02   PUSH 03   PUSH 04   PUSH 05   PUSH 06   PUSH 07 ENDM Pop_Bank0_Reg MACRO   POP 07   POP 06   POP 05   POP 04   POP 03 ; 13 PUSHES

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

55
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
  POP 02   POP 01   POP 00   POP DPH   POP DPL   POP PSW   POP B ENDM   POP ACC Push_HalfB0_Reg MACRO		 PUSH ACC			 PUSH B PUSH PSW PUSH DPL PUSH DPH PUSH 00 PUSH 01 PUSH 02 ENDM PUSH 03 ; R7 NOT POPPED, USED FOR PASSING PARAMETER ; BACK TO MAIN CALLING PROGRAM ; R7 NOT PUSHED, USED FOR PASSING PARAMETER ; BACK TO MAIN CALLING PROGRAM

Appendix B

Pop_HalfB0_Reg MACRO		   POP 03			   POP 02   POP 01   POP 00   POP DPH   POP DPL   POP PSW   POP B ENDM   POP ACC

DEC2REGS MACRO LowReg, HighReg LOCAL HIGHOK 	 	 	 	 	 	 	 HIGHOK: ENDM MOV	 MOV	 MOV	 MOV	 CLR 	 SUBB	 JNC 	 SUBB	 C 			 ; Clear For SUBB ; Subtract 1 ; Store Back ; Get High Of DPTR ; Move Back

A,LowReg		 A,#1			 HIGHOK LowReg,A		 A,HighReg		 A,#0			 HighReg,A		

; Move Low Of DPTR To A

; Subtract CY If Set

LOADREGSXDATA MACRO LowReg, HighReg MOVX A,@DPTR MOV LowReg,A INC DPTR MOVX A,@DPTR ENDM

MOV HighReg,A

56
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
LOADXDATAREGS MACRO LowReg, HighReg 	 MOV A,LowReg MOVX @DPTR,A INC DPTR MOV A,HighReg MOVX @DPTR,A

Appendix B

	

ENDM 	 	 	 	 	 ENDM

DPTRPLUSA MACRO

ADD A,DPL			 MOV DPL,A			 MOV A,DPH			 ADDC A,#0			 MOV DPH,A			

; Add 'A' To DPL ; Get DPH

; Move Result To DPL ; If Carry Set, This Will Increment ; Move Back To DPH

; ***********************************************

PaulOS.A51
; *********************************************** ; PaulOSV5C.A51 FOR C USE ; Version 5C ; ;

; **************************************************** ; STORES ALL BANK 0 TASK REGISTERS ; NOTE THAT MAIN_STACK WOULD HAVE TO BE VERIFIED ; WITH FILE *.M51 ;

; HANDLES MANY TASKS, DEPENDING ON

; EXTERNAL MEMORY AND INTERNAL STACK SPACE ;

; CAN BE USED WITH ASSEMBLY LANGUAGE MAIN PROGRAM ; Written by Paul P. Debono - FEBRUARY 2005 ; University of Malta ; Department of Communications and Computer Engineering ; MSIDA MSD 06; MALTA. ; ;

;/******************************************************************************/ ;// ;// 		 ;// 	 N O T E

;// Memory Model: LARGE: VARIABLES IN XDATA ;// Code Model: LARGE: 64K Program ;// 		 ;// CODE: 	 ;// RAM: 	 ;// 	 ;// CODE:	 ;// RAM: 	 ;// ;// CODE: 	 ;// RAM: 	 or say START 		 0X8100 		 0XDE00 		 0X8100 		 0XC100 		 0X8100 		 0X9C00 		 SIZE 		 0X5D00 0X2000 0X4000 0X3D00 0X1B00 		 0X400

USE the following settings in Options for Target 1

(32K RAM)

(8K RAM)

57
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
;//

Appendix B

;// Code Model: 	 ;// 		 ;// CODE:	 ;// RAM: 	 ;//

START 		

LARGE: 64K Program SIZE 		 0X8000 0X7E00

0X0000 		 0X8000 		

(32K EPROM)

;/******************************************************************************/ ; STACK MOVING VERSION - MOVES WORKING STACK IN AND OUT OF ; EXTERNAL MEMORY ; ; SLOWS DOWN RTOS, BUT DOES NOT RESTRICT TASK CALLS ; Uses timer 2, in 16-bit auto-reload mode as the time scheduler (time-ticker) ; FOR 8051, TIMER 0 CAN BE USED. ; All tasks run in bank 0, RTOS kernel runs in bank 1 ; All tasks must be written as an endless loop. ;

; Waiting time range for WAITT system calls is 1-65535. ; since a ZERO effectively kills the task, ;

; A zero waiting time parameter is set to 1 by the RTOS itself, ; actually putting it in permanent sleep in the waiting queue!! ; Waiting time range for WAITS system call is 0-65535. 0 means wait for the signal ; forever ; ;

; IDLE TASK (ENDLESS MAIN PROGRAM - TASK NUMBER = NOOFTASKS)

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It’s not what we do. It’s how we do it.

Impact matters.
navigant.com

©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

58
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
; COMMANDS AVAILABLE FOR THE C APPLICATION PROGRAM ARE:

Appendix B

; (valid parameter values are shown in parenthesis, assuming 20 tasks maximum) ; THE TOP FIVE COMMANDS ARE USED ONLY IN THE MAIN (IDLE TASK) PROGRAM. ; THE OTHERS ARE ONLY USED IN THE TASKS. ; ; 			 ; 			

; INIT_RTOS(IEMASK) 	 Initialise variables, SPs and enable required interrupts. ; VALID INTERRUPT NUMBERS USING OLD MONITOR ARE 0, 2, 3 AND 4 ; NOTE THAT IF TIMER 1 IS BEING USED TO GENERATE BAUD RATE, ; THEN YOU CANNOT USE 3 AND 4 SIMULTANEOUSLY ; 0 	 ; 1 	 ; 2 	 ; 3 	 ; 4 	 ; 5 	 ; ; ; EXTERNAL INT 	 0 	 EXTERNAL INT 	 1 	 SERIAL PORT 		

THE FOLLOWING COMMANDS, DO NOT CAUSE A CHANGE OF TASK:

***** THIS MUST BE THE FIRST RTOS COMMAND TO BE EXECUTED *****

; VALID INTERRUPT NUMBERS USING NEW MONITOR OR USER EEPROM ARE 0, 1, 2, 3 AND 4

TIMER COUNTER 	0 	 TIMER COUNTER 	1 	 TIMER COUNTER 	2 	

(IEMASK = 00000001 = 01H) (IEMASK = 00000100 = 02H) (IEMASK = 00000100 = 04H) (IEMASK = 00001000 = 08H) (IEMASK = 00010000 = 10H) (IEMASK = 00100000 = 20H)

; CREATE(TSK#,TSKADDR) Create a new task (0-[n-1]),placing it in the Ready Queue, ; 				 ;			 ;			 ;			 ; ; SET_IDLE_MODE() 	 ; ; RTOSGOMSEC(TICKTIME,PRIORITY) and set up correct task address on its stack.

Start RTOS going, interrupt every TICKTIME (1-255) msecs. PRIORITY = 1 implies Q Priority sorting is required. PRIORITY = 0 implies FIFO queue function.

; SET_POWER_DOWN() 	 ; PERIODIC(TIME) 	 ; SCHEK()	 	

Puts micro-controller in Idle mode 		

Puts micro-controller in Power Down mode 	 Repeat task every TIME msecs.

(IDL, bit 0 in PCON) (PD, bit 1 in PCON)

; 				

Check if current task has its signal set (Returns 1 or 0). Signal is cleared if it was found to be set.

; SIGNAL(TASKNUMBER) 	 Set signal bit of specified task (0-[n-1]). ;

; RUNNING_TASK_ID() 	 Returns the number of the currently executing task ; 			 ; THE FOLLOWING COMMANDS WILL CAUSE A CHANGE IN TASK ONLY WHEN THE SIGNAL IS NOT ALREADY PRESENT.

; 				 ; WAITS(TIMEOUT) 	

; 				 ; WAITV() 		 ; ;

Wait for signal within TIMEOUT ticks (TIMEOUT = 1 - 65535). Or wait for signal indefinitely (TIMEOUT = 0). If signal already present, proceed with current task. If interval already passed, proceed with current task.

; 				 ; 				 ; 			 ; WAITT(TIMEOUT) 	 ; WAITI(INTNUM) 	 ; DEFER()		 ; KILL()		

Wait for interval to pass.

THE FOLLOWING COMMANDS, ALWAYS CAUSE A CHANGE IN TASK: Wait for timeout ticks (1 - 65535).

Wait for the given interrupt to occur.

Stop current task and let it wait for 1 tick.

Kill current task by marking it permanently waiting,

59
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; 				 ; ; (TIMEOUT = 0). Clears any waiting signals.

Appendix B

; RESUME(TASKNUMBER) 	 Resumes the requested task which had previously been KILLed

; THIS IS STILL A SMALL TEST VERSION RTOS. IT IS JUST USED FOR ; SHOWING WHAT IS NEEDED TO MAKE A SIMPLE RTOS. ; IT MIGHT STILL NEED SOME MORE FINE TUNING. ; IT HAS NOT BEEN THOROUGHLY TESTED YET !!!! ; BUT WORKS FINE SO FAR. ; ; ; NO RESPONSABILITY IS TAKEN. ; CHECK YOUR OWN CORRECT FILE NAME INCLUDING CORRECT PATH IF NECESSARY. ; NOTE: Functions which receive parameters when ; 	 ; 	 ; ;

called from within C must have their name

start with an underscore in the A51 source file.

; These two parameters (set in TaskStkV5C.A51) are used to save ; functions are not being used. IF (USING_INT = 1) 	 ENDIF 	 PUBLIC _WAITI

; code and data memory space and increase rtos performance if these

IF (PERIODIC_CMD = 1) ENDIF

PUBLIC WAITV, _PERIODIC ; no parameters ; no parameters ; no parameters

PUBLIC DEFER, KILL, SCHEK 			 PUBLIC RUNNING_TASK_ID 			 PUBLIC _INIT_RTOS, _CREATE PUBLIC _WAITT, _WAITS PUBLIC _RTOSGOMSEC, _SIGNAL, _RESUME

PUBLIC SET_IDLE_MODE, SET_POWER_DOWN 		

; CHECK YOUR OWN CORRECT FILE NAME INCLUDING CORRECT PATH IF NECESSARY. RTOSVAR1 SEGMENT DATA RSEG RTOSVAR1 			  				 	 	 	 	 	 	 RUNNING: 	 READYQTOP:	 DS 1 	 TMPSTORE0: 	DS 1 	 XINTMASK: 	 DS 1 	 TICKCOUNT: 	DS 1		 GOPARAM: 	 DS 1		 DS 1 	 ; VARIABLE DATA AREA VAR1,

; range 0x10-0xFF, since we are using Banks 0,1 ; ADDRESS OF LAST READY TASK ; NUMBER OF CURRENT TASK ; USED IN FETCHSTACK

; MASK SET BY EXTERNAL INTERRUPT TO INDICATE TYPE ; USED FOR RTOSGO..... ; USED FOR RTOSGO.....

MYRTOSBITS SEGMENT BIT RSEG MYRTOSBITS 	 IF (HALFMSEC = 1) ENDIF  	 	

MSECFLAG: DBIT 1 		 INTFLAG: DBIT 1 		 TINQFLAG: DBIT 1 		

; FLAG INDICATING 1 MSEC PASSED ; MARKER INDICATING FOUND TASK WAITING FOR ; TASK TIMED OUT MARKER

					; SOMEINTERUPT

60
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 PRIORITY: DBIT 1 		 ; PRIORITY BIT SET BY RTOSGO....

Appendix B

RSEG RTOSVAR1 ; DIRECTLY ADDRESSABLE AREA 	

READYQ: DS (NOOFTSKS + 2) ; QUEUE STACK FOR TASKS READY TO RUN

; THE FOLLOWING VARIABLES CAN BE IN THE INDIRECTLY ADDRESSABLE RAM (EVEN > 80H) RTOSVAR2 SEGMENT IDATA RSEG RTOSVAR2 	 	 	 TTS:	 SPTS:	

DS (NOOFTSKS + 1) 	 DS 2*NOOFTSKS 	

; SP FOR EACH TASK AND 1 FOR THE IDLE (MAIN) TASK

					; 0 = NOT TIMING

; REMAINING TIMEOUT TIME FOR TASKS, 2 BYTES PER TASK

TSKFLAGS: DS (NOOFTSKS + 1) 	 ; BYTES STORING FLAGS FOR EACH TASK (AND MAIN)

; MAIN_STACK AREA STARTS HERE, NEXT LOCATION AFTER TSKFLAGS. ; CHECK STACK LOCATION IN THE .M51 FILE AFTER COMPILING ; TO CONFIRM THE VALUE OF "MAIN_STACK"

;XSEG AT (XTRAMTOP - (STACKSIZE * (NOOFTSKS + 1)) - (4*NOOFTSKS) + 1) EXTERNDATA SEGMENT XDATA RSEG EXTERNDATA

IF (PERIODIC_CMD = 1) 	 	

INTVALCNT: DS 2*NOOFTSKS	 INTVALRLD: DS 2*NOOFTSKS	

; 0 = NOT TIMING ; 0 = NOT TIMING

ENDIF  	

; ======================================================================

EXT_STK_AREA: DS (NOOFTSKS + 1) * STACKSIZE ; THIS IS THE ACTUAL SIZE OF STACK AREA

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There’s no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives — and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It’s why we employ 135 different nationalities. It’s why we’ve taken proactive steps to increase female representation at the highest levels. And it’s just one of the reasons why you’ll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

61
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
; CSEG AT EXT0_INT_VECTOR ; INTERRUPT VECTOR ADDRESS FOR 	 	 CLR EA MOV XINTMASK,#EXT0W 		 LJMP XTRA_INT ; EXTERNAL 0

Appendix B

 	

IF (TICK_TIMER = 0)		 	

CSEG AT TIM0_INT_VECTOR 		  	 CLR EA				 LJMP RTOS_TIMER_INT 		

; INTERRUPT VECTOR ADDRESS FOR ; TIMER 0 ; USED FOR THE RTOS SCHEDULER

ELSE 	

CSEG AT TIM0_INT_VECTOR  	  	 ENDIF CLR EA MOV XINTMASK,#TIM0W   LJMP XTRA_INT

CSEG AT EXT1_INT_VECTOR 		 	  	  	 CLR EA MOV XINTMASK,#EXT1W		 LJMP XTRA_INT

; INTERRUPT VECTOR ADDRESS FOR ; EXTERNAL 1

IF (TICK_TIMER = 1) 	

CSEG AT TIM1_INT_VECTOR ; INTERRUPT VECTOR ADDRESS FOR  	 CLR EA				 LJMP RTOS_TIMER_INT 		 ; TIMER 1 ; USED FOR THE RTOS SCHEDULER

ELSE 	

CSEG AT TIM1_INT_VECTOR  	  	 ENDIF CLR EA MOV XINTMASK,#TIM1W   LJMP XTRA_INT

CSEG AT SER0_INT_VECTOR 		 	 MOV XINTMASK,#SER0W 		 	 LJMP XTRA_INT IF (TICK_TIMER = 2) 	 	 CLR EA

; INTERRUPT VECTOR ADDRESS FOR ; SERIAL

CSEG AT TIM2_INT_VECTOR 		  	  	 ELSE 	 CLR EA				 CLR TF2 			

; INTERRUPT VECTOR ADDRESS FOR ; TIMER 2 ; Clear Timer 2 interrupt flag (not done automatically)

LJMP RTOS_TIMER_INT		 

CSEG AT TIM2_INT_VECTOR  	  	 ENDIF CLR EA MOV XINTMASK,#TIM2W 		  LJMP XTRA_INT

62
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MyRTOS_CODE SEGMENT CODE 		 RSEG MyRTOS_CODE ; STARTS AT 8100H FOR THE FLIGHT32 BOARD

Appendix B

;========================================================================== ; START OF RTOS SYSTEM ; PREFIX NAME FOR FUNC WITH REG-PASSED PARAMS MUST START WITH AN UNDERSCORE _ SET_IDLE_MODE:				  	 	 RET ; SETS THE MICRO-CONTROLLER IN IDLE MODE ; SETS BIT 0 OF PCON SFR

ORL PCON,#0x01			

SET_POWER_DOWN:			  	 	 RET

ORL PCON,#0x02			

; SETS THE MICRO-CONTROLLER IN POWER DOWN MODE ; SETS BIT 1 OF PCON SFR

_INIT_RTOS: 				 	 	 	 MOV A,R7

					 ANL A,#01111111B 		 ORL A,#00000010B		 MOV IP,#02H 			 ORL A,#00001000B	

; SYS CALL TO SET UP VARIABLES ; R7 HOLDS THE IE MASK

IF (TICK_TIMER = 0)  	 	

; ENSURE EA = 0 (ENABLED LATER FROM RTOSGO...) ; AND ET0 = 1 (USED FOR RTOS TICK TIME)

ELSEIF (TICK_TIMER = 1)

; Timer 0 High Priority, PT0=1, OTHERS ALL LOW ; AND ET1 = 1 (USED FOR RTOS TICK TIME)

 	 	

ELSEIF (TICK_TIMER = 2)

MOV IP,#08H 			 ORL A,#00100000B	

	

; Timer 1 High Priority, PT1=1, OTHERS ALL LOW ; AND ET2 = 1 (USED FOR RTOS TICK TIME)

 	

ENDIF 	

MOV IP,#20H 			

	

; Timer 2 High Priority, PT2=1, OTHERS ALL LOW

; IN THE C ENVIRONMENT, THE KEIL SOFTWARE CLEARS THE INTERNAL RAM FROM 0 TO FFH ; PROVIDED THAT THE C51\LIB FILE STARTUP.A51 IS INCLUDED WITH THE SOURCE GROUP, ; AND WITH THE CORRECT IDATALEN VARIABLE SETTING TO REFLECT 8051 FAMILY TYPE. ; ; IN ASM OR A51 (NOT IN C), ALL THE INTERNAL RAM (0-FFH) IS ; CLEARED BY MEANS OF THE CLR_8051_RAM MACRO. ; IN C it is cleared when using STARTUP.A51 ;

MOV IE,A

; CLEAR PERIODIC INTERVAL TABLE IF BEING USED IF (PERIODIC_CMD = 1) 	 	 	 	 	 MOV DPTR,#INTVALCNT MOV A,#NOOFTSKS RL A 				 CLR A ; DOUBLE THE NUMBER

MOV R0,A 			

; R0 CONTAINS NUMBER OF BYTES TO CLEAR

DPTR_A0: ; POINT DPTR TO CORRECT LOCATION 	 	 MOVX @DPTR,A INC DPTR

 	

ENDIF 	 	 	

DJNZ R0,DPTR_A0

MOV DPTR,#EXT_STK_AREA 	 MOV R0,#(NOOFTSKS + 1) CLR A

; CLEAR ALL EXTERNAL RAM STACKS

63
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
NEXT_STACK: 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 CLR_STACK:

Appendix B

MOV R1,#STACKSIZE MOVX @DPTR,A INC DPTR DJNZ R1,CLR_STACK

DJNZ R0,NEXT_STACK MOV R7,#NOOFTSKS MOV R0,#TTS MOV R1,#READYQ

MOV RUNNING,#IDLE_TASK 	

; IDLE TASK RUNNING (Main program endless loop)

LOAD_VARS:

MOV @R0,#LOW(NOT_TIMING) 	 INC R0 MOV @R0,#HIGH(NOT_TIMING) MOV @R1,#IDLE_TASK 	 INC R0 INC R1	

; NO TIMER ACTION

; IDLE TASK IN ALL OF READYQ (Main program endless loop)

DJNZ R7,LOAD_VARS 		 MOV @R1,#IDLE_TASK		 INC R1				 MOV @R1,#IDLE_TASK		

; SET UP ALL TASKS

; FILL TWO ADDITIONAL LOCATIONS, USED

; DURING THE Q SHIFTING ROUTINE, WITH IDLE TASK. ; THIS ENSURES IDLE TASK WILL ALWAYS BE IN Q IF ; THERE ARE NO OTHER TAKS READY TO EXECUTE. ; COUNTER

						; SET UP SP MOV R7,#(NOOFTSKS + 1)			 MOV R0,#SPTS 				 MOV A, #(MAIN_STACK - 1)

MOV READYQTOP,#READYQ	 	

; INITIALIZE ALL STACK POINTERS ; SIMULATE Push_Bank0_Reg PLUS

						 SET_UP: 	 	 	 MOV @R0,A INC R0 DJNZ R7,SET_UP

ADD A,#(NOOFPUSHES + 2) 		

; SAVING OF RETURN ADDRESS BY INTERRUPT

	RET _CREATE:

						 						 						 						 MOV R0,READYQTOP MOV A,R7 MOV A,R1 INC DPTR MOV A,R2

; SYS CALL ENTRY TO CREATE A TASK

; TASK NUMBER (0 to 19) PASSED IN BANK0 R7 ; TASK START ADDR PASSED IN BANK0 R1,R2,R3 ; LSB in R1, MSB in R2, R3 contains type	 ; POINT TO TOP OF READY READYQ

	 	 	 	 	 	 	 	 	 	 	

INC READYQTOP 				 MOV @R0,07H 				 CALL FETCH_STACK MOVX @DPTR,A 				

; PUT TASK# (R7 bank 0 = 07H) IN READY QUEUE

; COPY LOW BYTE R1 INTO LOW STACK AREA

MOVX @DPTR,A 				 SETB TINQFLAG 				

; NOW SAVE THE HIGH ORDER BYTE (R2)

	RET	

; SIGNAL NEW TASK IN Q, USED TO START QSHIFT

_RTOSGOMSEC: 			

; SYS CALL TO START RTOS FOR R7 MILLISECOND TICKS

64
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 CLR PRIORITY

Appendix B

CJNE R5,#1,PRIORITY_OK 		 SETB PRIORITY	 			

; IF SECOND PARAMETER = 1, THEN

PRIORITY_OK: 	 	

; SET PRIORITY SORTING IS REQUIRED

IF (TICK_TIMER = 0)

MOV TH0,#HIGH(BASIC_TICK) 		 MOV TL0,#LOW(BASIC_TICK)		

; LOAD TH0 AND TL0 WITH BASIC TICK COUNT

 	 	

ELSEIF (TICK_TIMER = 1)

; SAVE THEM IN THE AUTO RE-LOAD REGISTERS ; LOAD TH0 AND TL0 WITH BASIC TICK COUNT

MOV TH1,#HIGH(BASIC_TICK) 		 MOV TL1,#LOW(BASIC_TICK)		

 	  	

ELSE

; SAVE THEM IN THE AUTO RE-LOAD REGISTERS ; LOAD RCAPS WITH 1 MILLISECOND COUNT

MOV RCAP2H,#HIGH(BASIC_TICK) 		

ENDIF ; OF TIMER 2 (FOR FLT-32) 	 	 	 	 	 	 	 	 	 MOV GOPARAM,07 		 MOV TICKCOUNT,07 ANL TMOD,#0F0H

MOV RCAP2L,#LOW(BASIC_TICK)	 	

; SAVE THEM IN THE AUTO RE-LOAD REGISTERS

; LOAD TICKS PARAMETER, PASSED IN R7 BANK 0

IF (TICK_TIMER = 0)

ORL TMOD,#01H 			 SETB TF0 			 ANL TMOD,#0FH

; START TIMER 0 IN 16-BIT MODE 1. ; SIMULATE TIMER 0 INTERRUPT.

ELSEIF (TICK_TIMER = 1)

ORL TMOD,#10H 			 SETB TF1 			

; START TIMER 1 IN 16-BIT MODE 1. ; SIMULATE TIMER 1 INTERRUPT.

ELSEIF (TICK_TIMER = 2)

MOV T2CON,#04H 		

; START TIMER 2 IN 16-BIT AUTO RE-LOAD MODE.

Real drive. Unreal destination.

As an intern, you’re eager to put what you’ve learned to the test. At Ernst & Young, you’ll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You’ll also get to test what you learn. Even better, you’ll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

© 2012 Ernst & Young LLP. All Rights Reserved.

65
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
					 	 	 	 ENDIF ; TIMER 1 CAN BE USED FOR SERIAL BAUD RATE ; SIMULATE TIMER 2 INTERRUPT IMMEDIATELY ; ENABLE GLOBAL INTERRUPT SIGNAL ; EFFECTIVELY STARTING THE RTOS. ; SYS CALL ENTRY CHECK SIGNAL BIT FOR TASK ; SIG. BIT IS CLEARED IF FOUND TO BE SET ; NO NEED FOR BANK SWITCHING

Appendix B

SETB TF2 			 SETB EA				 RET				

	

SCHEK: 					

					 					 CLR EA 				 MOV A,RUNNING MOV B,#SIGS MOV R7,#1

; RETURN 0 IF BIT CLEAR OR 1 IF BIT SET IN R7.

				 	  	 	 	 	 	 	 	 	Push_HalfB0_Reg

; IMMEDIATE RETURN - NO CONTEXT SWITCHING

CALL CHK_CLR_FLAG		 JC SIGNAL_SET 			 DEC R7 				

; SIG IS CLEARED IF IT WAS FOUND TO BE SET ; SIG SET, HENCE RETURN WITH R7=1

SIGNAL_SET: 	

; SIG NOT YET SET, HENCE RETURN WITH R7=0

	Pop_HalfB0_Reg 	RET 				 _SIGNAL: 				 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	Push_Bank0_Reg MOV B,#SIGW ; SYS CALL ENTRY-SET SIGNAL BIT FOR SPECIFIED TASK SETB EA

CLR EA 				 MOV A,R7 			 CALL CHK_CLR_FLAG

; NO NEED FOR BANK SWITCHING - NO CONTEXT SWITCHING ; TASK NUMBER PASSED IN R7 bank 0

JNC NOT_WAITING 		 MOV A,R7 			 MOV B,#SIGS 			 MOV A,#TTS			 ADD A,R7 ADD A,R7 			 MOV R0,A INC R0

; IF TASK NOT ALREADY WAITING, SET SIGNAL BIT ; OTHERWISE PLACE IT ON READY Q ; ENSURE CLEARED SIGNAL BIT

	CALL CLR_FLAG		

; AND MARK TASK AS NOT TIMING ; ADD OFFSET TWICE SINCE 2 TIME-OUT BYTES

					; PER TASK MOV @R0,#LOW(NOT_TIMING) MOV @R0,#HIGH(NOT_TIMING) INC READYQTOP MOV R0,READYQTOP

MOV @R0,07 			

DONT_GIVE_UP: 	 	 	 	 	 	 	

SETB TINQFLAG 			

; PLACE SIGNALLED TASK ON READY Q ; INDICATE, NEW TASK IN Q, BUT

	Pop_Bank0_Reg

SETB EA 			 RET 				 MOV A,R7

; DON'T GIVE UP RUNNING CURRENT TASK. ; (MUST DEFER IF REQUIRED TO DO SO)

NOT_WAITING:

MOV B,#SIGS 			 CALL SET_FLAG SETB EA

; SET SIGNAL BIT OF SIGNALLED TASK

	Pop_Bank0_Reg RET 				 ; AND CONTINUE RUNNING CURRENT TASK

66
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

IF (USING_INT = 1)

_WAITI: 				

; VALID INTERRUPT NUMBERS USING MONITOR ARE 0, 2, 3 AND 4

; SYS CALL ENTRY POINT - WAIT FOR INTERRUPT

; VALID INTERRUPT NUMBERS USING USER EEPROM ARE 0, 1, 2, 3 AND 4 ; NOTE THAT IF TIMER 1 IS BEING USED TO GENERATE BAUD RATE, ; THEN YOU CANNOT USE 3 AND 4 SIMULTANEOUSLY ; INT 5 IS COMPULSORY 		 ; 0 	 ; 1 	 ; 2 	 ; 3 	 ; 4 	 ; 5 	 	 	 	 	 	 	 	 	 	 	 ENDIF EXTERNAL INT 0 	 EXTERNAL INT 1 	 SERIAL PORT 		 (IEMASK = 00100000 = 20H) (IEMASK = 00000001 = 01H) (IEMASK = 00000010 = 02H) (IEMASK = 00000100 = 04H) (IEMASK = 00001000 = 08H) (IEMASK = 00010000 = 10H) (IEMASK = 00100000 = 20H)

TIMER COUNTER 0 	 TIMER COUNTER 1 	 TIMER COUNTER 2 	 CLR EA

	Push_Bank0_Reg CLR A

INC R7 			 SETB C RLC A

; INTERRUPT NUMBER (0 TO 4) PARAMETER PASSED IN R7 bank 0

SHIFT_LEFT: 				 DJNZ R7, SHIFT_LEFT MOV A,RUNNING CALL SET_FLAG

; CONVERT TO INTERRUPT MASK (1,2,4,8,16) BY ROTATING LEFT

MOV B,A 			

; B NOW CONTAINS CORRECT INTERRUPT MASK

LJMP QSHFT 			

; STOP CURRENT TASK AND RUN NEXT TASK IN READY Q

IF (PERIODIC_CMD = 1) WAITV: 	 	 	 	 	 	 	 	 	 	 ENDIF CLR EA 				 MOV A,RUNNING ; UNTIL TIMEOUT PASSED IN R7(LOW),R6(HIGH)

	Push_Bank0_Reg

MOV B,#SIGV 			 CALL CHK_CLR_FLAG JNC NO_INTVAL 			 LJMP DONT_GIVE_UP		 MOV A,RUNNING 			 MOV B,#SIGV CALL SET_FLAG 			 LJMP QSHFT			

; TEST IF SIGNAL ALREADY THERE ; NO SIGNAL YET, SO TASK MUST WAIT ; OR RETURN TO SAME TASK ; RELOAD TASK NUMBER ; SET SIG WAITING BIT, AND ; RUN NEXT TASK IN READY Q

					 NO_INTVAL:

; ELSE, SIGNAL WAS PRESENT, (NOW CLEARED)

_WAITS: 				 	 	 	 	 	 	Push_Bank0_Reg MOV A,RUNNING

CLR EA 				

; SYSTEM CALL - WAIT SIGNAL ARRIVAL

; UNTIL TIMEOUT PASSED IN R7(LOW),R6(HIGH)

MOV B,#SIGS 			 CALL CHK_CLR_FLAG JNC NO_SIGNAL 			

; TEST IF SIGNAL ALREADY THERE ; NO SIGNAL YET, SO TASK MUST WAIT

	 				

; ELSE, SIGNAL WAS PRESENT, (NOW CLEARED)

67
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 LJMP DONT_GIVE_UP		 MOV A,RUNNING 			 MOV B,#SIGW CALL SET_FLAG 			 ; OR RETURN TO SAME TASK ; RELOAD TASK NUMBER ; SET SIG WAITING BIT, AND CONTINUE WITH WAITT ; TO WAIT FOR TIMEOUT

Appendix B

NO_SIGNAL:

 					

CJNE R7,#LOW(NOT_TIMING),SET_TIMEOUT  ; ACCEPT A WAIT TIME OF 0 ; TO WAIT FOR SIGNAL INDEFINITELY

 					 SJMP SET_TIMEOUT_0 CLR EA _WAITT: 				 	Push_Bank0_Reg

CJNE R6,#HIGH(NOT_TIMING),SET_TIMEOUT ; ACCEPT ZERO WAIT TIME IN ORDER TO BE ABLE

; SYS CALL ENTRY POINT - WAIT FOR TIME OUT

CJNE R7,#LOW(NOT_TIMING),SET_TIMEOUT  ; TIME OUT PARAMETER PASSED IN R6 (HIGH) CJNE R6,#HIGH(NOT_TIMING),SET_TIMEOUT ; AND R7 (LOW) BANK 0 MOV R7,#1			 MOV R6,#0 			 CLR 	 CLR 	 MOV 	 CLR 	 MOV 	 C	 		 ; RANGE 1-65535 (0 = PERMANENT SLEEP)

SET_TIMEOUT:

; IF BOTH ARE ZERO, REPLACE WITH A ONE ; PERFORM 65536 - TIME OUT VALUE

SUBB 	 A,R7			 R7,A A

A			

; SO THAT IN RTOS_TIMER_INT WE CAN

; USE 'INC DPTR' EASILY TO UPDATE TIMEOUT

SUBB 	 A,R6 R6,A

SET_TIMEOUT_0:

MOV A,#TTS

ADD A,RUNNING			 ADD A,RUNNING			 MOV R0,A INC R0 MOV @R0,07 			 MOV @R0,06

; ADD OFFSET TWICE SINCE TIMEOUTS ARE ; TWO BYTES PER TASK

; BANK 0 R7,R6 - TIMEOUT PUT IN TABLE (WAITING Q)

LJMP QSHFT 			

; STOP CURRENT TASK AND RUN NEXT TASK IN READY Q ; SYS CALL ENTRY (NO PARAMETERS)

KILL:					 	 	 	 	 	 	 	 	 	 CLR EA

 					 	Push_Bank0_Reg MOV A,RUNNING ADD A,R0 MOV R0,A CLR A MOV @R0,A 			 MOV R0,#TSKFLAGS

; CLEARS ALL WAITING SIGNALS FLAGS

MOV R7,#LOW(NOT_TIMING)	 MOV R6,#HIGH(NOT_TIMING)

; TO CLEAR AND STORE

; KILL PRESENT TASK (PUT IN PERMANENT WAIT)

IF (PERIODIC_CMD = 1) 	 	 	 MOV A,RUNNING

MOV DPTR,#INTVALCNT		 RL A ; DOUBLE THE NUMBER

; clear INTERVAL COUNT if task was PERIODIC

68
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	DPTRPLUSA 	 	 	 	 	 	 	 	 	 	 	 	 ENDIF 	

Appendix B

MOV A,#0			 MOVX @DPTR,A INC DPTR

; SAVE 0 in LOW BYTE

MOVX @DPTR,A			 MOV DPTR,#INTVALRLD MOV A,RUNNING RL A 				 MOV A,#0 			 MOVX @DPTR,A INC DPTR

; SAVE 0 in HIGH BYTE

	DPTRPLUSA

; DOUBLE THE NUMBER ; SAVE 0 in LOW BYTE

MOVX @DPTR,A 			 SJMP SET_TIMEOUT_0 CLR EA 	

; SAVE 0 in HIGH BYTE

_RESUME:			 	Push_Bank0_Reg

; SYS CALL ENTRY (ONE TASK PARAMETER IN R7)

IF (PERIODIC_CMD == 1) 	 	 	 	

; FIRST CHECK IF THE TASK TO BE RESUMED HAPPENS TO BE A PERIODIC ONE MOV DPTR,#INTVALRLD		 MOV A,07 RL A 			

; clear INTERVAL COUNT if task was PERIODIC

	DPTRPLUSA

; DOUBLE THE NUMBER ; GET LOW BYTE

MOVX A,@DPTR 			

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

69
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 JNZ NOW_CAN_RESUME INC DPTR

Appendix B

; NOW_CHECK HIGH BYTE MOVX A, @DPTR		 ; GET HIGH BYTE

; TO RESUME TASK, LOAD INTVALCNT WITH 1 TICK TIME ; AT THIS POINT NOW_CAN_RESUME: 	 	 	 	 	 	 	 ENDIF 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	

JZ NOT_A_PERIODIC

; SINCE THIS TASK HAD BEEN KILLED, THE INTVALCNT MUST BE ZERO

MOV DPTR,#INTVALCNT		 MOV A,07 RL A 			

; clear INTERVAL COUNT if task was PERIODIC

	DPTRPLUSA MOV A,#1

; DOUBLE THE NUMBER ; GET HIGH BYTE

INC DPTR 			 MOVX @DPTR,A LJMP QSHFT

NOT_A_PERIODIC:

MOV A, #TTS

ADD A, RUNNING ADD A, RUNNING MOV R0,A INC R0 MOV @R0,#1 			 MOV @R0,#0 			 LJMP QSHFT CLR EA ; SET WAITING TIME OF 1 TICK FOR DEFERRED TASK ; AND THEN SHIFT Q BELOW ; SYS CALL ENTRY (NO PARAMETERS)

DEFER: 					 	Push_Bank0_Reg MOV A, #TTS ADD A, RUNNING ADD A, RUNNING MOV R0,A INC R0 MOV @R0,#1 		

; SET WAITING TIME OF 1 TICK FOR DEFERRED TASK ; AND THEN SHIFT Q BELOW ; CLR TINQFLAG AND SHIFT READYQ BY ONE, ; GET NEW RUNNING TASK FROM READYQ ; SAVE SP ; USE BANK 1 - MAY HAVE ENTERED FROM INTERRUPT

MOV @R0,#0 			 QSHFT: 			 CLR TINQFLAG 			 SetBank 1			 ADD A, RUNNING MOV R0,A

; SAVE PRESENT RUNNING TASK STACK PTR

					

MOV A, #SPTS 			

MOV @R0, SP 			 MOV A,RUNNING CALL FETCH_STACK

; STORE PRESENT STACK POINTER OF TASK

Int2Ext 			

SHIFT_DOWN:

MOV R1,#(READYQ + 1) 		 MOV A,@R1 DEC R1

; SAVE STACK IN EXTERNAL, READY FOR SWAP ; NOW SHIFT Q DOWN 1

70
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 MOV @R1,A MOV A,R1 INC R1 INC R1

Appendix B

CJNE A,READYQTOP,SHIFT_DOWN DEC READYQTOP	 		 INC READYQTOP			 CJNE A,#READYQ,RUN_NEW_TASK	

; THEY ALL MOVED DOWN BY 1, HENCE DECREMENT RQTOP ; BUT READYQTOP SHOULD NEVER GO BELOW READYQ ; RUN NEW TASK ; SO READYQTOP = READYQ AGAIN, IF IT WAS BELOW ; DO NOT SORT Q IF PRIORITY OPTION IS OFF

RUN_NEW_TASK: 				 LCALL TASK_SORT MOV A,READYQ

JNB PRIORITY,DONT_SORT 	

DONT_SORT:

MOV RUNNING,A 			 CALL FETCH_STACK MOV A,#SPTS MOV R0,A Ext2Int 			 ADD A,RUNNING MOV SP,@R0			 SetBank 0

; SET NEW TASK AS RUNNING ; GET NEW STACK IMAGE

	Pop_Bank0_Reg

; SET SP TO NEW TASK STACK AREA

SETB EA				 RETI 				

; MAY HAVE ENTERED FROM TIMER INTERRUPT   ; OTHERWISE NO HARM ANYWAY

IF (PERIODIC_CMD = 1) 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 CLR EA

_PERIODIC:				; SYSTEM CALL 	Push_Bank0_Reg MOV A,RUNNING

MOV DPTR,#INTVALCNT RL A 			 ; DOUBLE THE NUMBER ; SAVE LOW BYTE, HELD IN R7

	DPTRPLUSA

MOV A,07			 MOVX @DPTR,A MOV A,06 INC DPTR

MOVX @DPTR,A		 MOV A,RUNNING

MOV DPTR,#INTVALRLD

	

; SAVE HIGH BYTE, HELD IN R6

	DPTRPLUSA

RL A ; DOUBLE THE NUMBER MOV A,07 			 MOVX @DPTR,A INC DPTR MOV A,06		 MOVX @DPTR,A SETB EA 	 ; SAVE LOW BYTE, HELD IN R7 ; SAVE HIGH BYTE, HELD IN R6

	Pop_Bank0_Reg 	RET ENDIF 	

TSKRDY_CHK2: 		 		 LJMP TSKRDY_CHK

; JUST A STEPPING STONE

71
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
RTOS_TIMER_INT:		 	Push_Bank0_Reg 	 	 	 	 	 IF (TICK_TIMER = 0) ; INTERRUPT ENTRY ONLY FROM TIMER2 OVERFLOW INTERRUPT ; USES ACC,PSW, (R0,R1 AND R2 FROM BANK 1) ; SET TO REGISTERBANK 1 ; STOP, RELOAD

Appendix B

					

SetBank 1 			 CLR TR0			 	

MOV TH0,#HIGH(BASIC_TICK) MOV TL0,#LOW(BASIC_TICK) SETB TR0			

ELSEIF (TICK_TIMER = 1) 	 	 	 ENDIF 	 	 	 	

; AND RESTART TIMER 0

	CLR TR1				; STOP, RELOAD MOV TH1,#HIGH(BASIC_TICK) MOV TL1,#LOW(BASIC_TICK) SETB TR1			

; AND RESTART TIMER 1

IF (HALFMSEC = 1)

					

JBC MSECFLAG, TSKRDY_CHK2	 SETB MSECFLAG 			 DJNZ TICKCOUNT, TSKRDY_CHK2	 MOV TICKCOUNT, GOPARAM

; ONLY HALF A MILLISECOND PASSED, HENCE CHK FOR ; EXTERNAL INTERRUPT TASKS ONLY ; USED TO DOUBLE 1/2 MSEC TICKCOUNT DELAY ; CHECK IF REQUIRED TICK TIME HAS PASSED

ENDIF

IF (PERIODIC_CMD = 1) CHK_PERIODICS: 	

; FIRST CHECK THE PERIODIC INTERVALS, IF USED MOV R0,#0 		 ; DO ALL TASKS, STARTING WITH TASK 0, HELD IN R0, BANK 1

I joined MITAS because I wanted real responsibili� I joined MITAS because I wanted real responsibili�

Maersk.com/Mitas www.discovermitas.com

�e Graduate Programme for Engineers and Geoscientists

�e G for Engine

Ma

Real work International Internationa al opportunities �ree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities �ree wo work or placements s solve pr
Click Click on on the the ad ad to to read read more more

72
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 MOV DPTR,#INTVALCNT 		 PUSH DPL 			 PUSH DPH MOV A,R2 ORL A,R3 LOADREGSXDATA R2,R3 		 ; DPTR POINTS TO FIRST TASK INTERVAL IN TABLE ; SAVE PTR ; R2 = LOW, R3 = HIGH VALUE OF INTVALCNT

Appendix B

CHECK_VALS:

					 COUNT_DOWNV: 	 	 	 	 	 	 	 	

JZ CHECK_NEXTV 	

; 0=TASK NOT USING PERIODIC INTERVAL, HENCE SKIP, ; DO NOT UPDATE INTERVAL COUNT. ; DECREMENT INTERVAL COUNT

	POP DPH				; GET POINTER POP DPL PUSH DPL 			 PUSH DPH MOV A,R2 ORL A,R3 LOADXDATAREGS R2,R3		

DEC2REGS R2,R3 		

; AND SAVE POINTER AGAIN ; AND STORE NEW DECREMENTED VALUE

JNZ CHECK_NEXTV 		

; TASK NOT TIMED OUT YET, CHECK NEXT TASK ; RELOAD VALUE IS NOOFTSKS*2 - 1 AWAY FROM

VAL_OUT:			

 					 	 	 	 	 	 	 	 	 	 	 	 	 	 ; MOV A, #NOOFTSKS RL A DEC A

; NEW TASK INTERVAL TIMED OUT, HENCE RELOAD INTERVAL

					; PRESENT DPTR VALUE

	DPTRPLUSA LOADREGSXDATA R4,R5 POP DPH POP DPL

PUSH DPL 			 PUSH DPH LOADXDATAREGS R4,R5 MOV A,R0

; SAVE PTR

; TEST INTERVAL FLAG MOV B,#SIGV 			 CALL CHK_CLR_FLAG JNC SET_VFLAG 			 ; TEST IF SIGNAL ALREADY THERE ; NO SIGNAL YET, SO JUST SET FLAG

; IF TASK ALREADY IN Q, DO NOT DUPLICATE

; THIS COULD HAPPEN IN CASE OF BAD TASK PROGRAMMING, WHERE ; THE TASK DURATION IS LONGER THAN THE PERIODIC TIME 	 	 	 	 	 	 	 ; MOV R1,#READYQ MOV A,@R1 XRL A,R0 MOV A,R1 INC R1 JZ CHECK_NEXTV ; IF TASK PROGRAMMING IS OK, THEN THIS CHECK CAN BE ELIMINATED TO REDUCE OVERHEADS. CHK_NXT_IN_Q:

CJNE A,READYQTOP,CHK_NXT_IN_Q

73
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; ; 	 	 	 INC READYQTOP 			 MOV R1,READYQTOP MOV @R1,08 			 ; POINT TO TOP OF READY READYQ ; PUT TASK# (R0 bank 1 = 08H) IN READYQ

Appendix B

	 SETB TINQFLAG 			 IN;TERVAL 	 	 	 	 	 	 	 	 	 	 	 	 ENDIF SET_VFLAG: SJMP CHECK_NEXTV 		 MOV A,R0

; MARK FLAG INDICATING THAT A TASK FINISHED WAITING ; AND PLACED IN READYQ

MOV B,#SIGV

CHECK_NEXTV:

CALL SET_FLAG 			 POP DPH POP DPL INC DPTR 			 INC DPTR INC R0				

; SET INTERVAL READY BIT

; MOVE UP 1 TASK IN PERIODIC INTERVAL TABLE ; INCREMENT TASK NUMBER COUNTER

CJNE R0,#NOOFTSKS,CHECK_VALS 	; END OF ALL TASKS YET? SJMP CHK_FOR_TOUTS		 SJMP TSKRDY_CHK

TSKRDY_CHK1: 				 ; NOW CHECK FOR TIME OUTS CHK_FOR_TOUTS: 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	

; NOW CHECK FOR TIME OUTS ; JUST A STEPPING STONE

MOV R0,#TTS 			 MOV R2,#0 			 MOV A,@R0 			 MOV DPL,A MOV R1,08 			 INC R0 				 MOV A,@R0 MOV DPH,A ORL A,DPL JZ CHECK_NEXT 		

; R0 POINTS TO FIRST TASK TIMEOUT IN TTS TABLE ; CHECK ALL TASKS, STARTING WITH TASK 0 ; GET TIME FOR TASK ; SAVE POINTER TO LOW BYTE IN R1

CHECK_TIMEOUTS:

; SAVE POINTER TO HIGH BYTE IN R0

COUNT_UP: 				

; 0=TASK NOT TIMING, HENCE SKIP, DO NOT DECREMENT TIMEOUT ; DPTR NOW CONTAINS TIMEOUT VALUE ; NOW WE CAN INCREMENT IT

INC DPTR			 MOV @R1,DPL

MOV @R0,DPH			 MOV A,DPH			 ORL A,DPL			 JNZ CHECK_NEXT 		 INC READYQTOP 			 MOV R1,READYQTOP MOV @R1,0AH 			 MOV A,R2

; SAVE NEW TIME OUT VALUE, EVEN IF ZERO ; AND CHECK IF TIMED UP (ROLL OVER TO ZERO) ; ACCUMULATOR EQUALS ZERO IF TIMED OUT ; TASK NOT TIMED OUT YET, CHECK NEXT TASK ; POINT TO TOP OF READY READYQ

TIMED_OUT:				

; NEW TASK TIMED OUT, HENCE PLACE IN READYQ

SETB TINQFLAG 			 MOV B,#SIGW

; PUT TASK# (R2 bank 1 = 0AH) IN READYQ

; MARK FLAG INDICATING THAT A TASK FINISHED WAITING

CHECK_NEXT:

CALL CLR_FLAG 			

; CLEAR SIGNAL WAITING BIT (IF SET)

74
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 INC R0 				 INC R2			 ; MOVE UP 1 IN TTS TABLE

Appendix B

TSKRDY_CHK:

CJNE R2,#NOOFTSKS,CHECK_TIMEOUTS 	 JNB TINQFLAG, EXIT		

	

; INCREMENT TASK NUMBER COUNTER ; END OF ALL TASKS YET?

					 					 					 					 READYQ. CAN_CHANGE: 	 	

; NO TASK ADDED, HENCE EXIT

; NOTE THAT TINQFLAG CAN BE SET BY 4 ROUTINES, ; CREATE, SIGNAL, RTOS_TIMER_INT AND XTRA_INT ; IF CLR (FLAG = 0) => NO NEW TASK PUT IN READYQ

; IF SET (FLAG = 1) => A NEW TASK HAS BEEN PLACED IN

MOV A,RUNNING			

					 					 	 EXIT: 	 	

CJNE A,#IDLE_TASK,EXIT		

; CHECK CURRENT TASK

; NOT IN IDLE STATE, SO DO NOT INTERRUPT YET ; WHEN THE IDLE_TASK MIGHT BE RUNNING.

; BUT LEAVE TINQFLAG SET FOR THE NEXT RTOS INT. CHECK ; IDLE AND NEW TASK TIMED OUT, HENCE CHANGE TASK

LJMP QSHFT 			

	Pop_Bank0_Reg SetBank 0 SETB EA

	RETI XTRA_INT:

IF (USING_INT = 1)

					; EXTRA INTERRUPT SERVICE ROUTINE 					 					

; USED DURING EXTERNAL, TIMER AND SERIAL INTERRUPTS ; CHECKS BITS SET BY WAITI CALL AND PUTS TASK

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

75
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
					 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 					 SetBank 1 MOV B,XINTMASK		 ; WAITING FOR ONE RTOS INTERRUPT IF IT

Appendix B

Push_Bank0_Reg	 		

; WAS WAITING FOR THIS EXTERNAL INTERRUPT

; USES ACC, B, PSW,( R0, R2 AND R3 BANK 1 ) ; GET EXTERNAL INTERRUPT MASK

CLR A	 			

	

TRY_NXT:

CLR INTFLAG 			 MOV R2,A 			 CALL CHK_CLR_FLAG JNC NOT_YET

; NOW CHECK IF ANY TASKS WERE WAITING

; FOR THIS INTERRUPT, STARTING WITH TASK 0 ; STORE TASK NUMBER IN R2 BANK 1

SETB INTFLAG			 MOV A,#TTS			 ADD A,R2 ADD A,R2

; SET MARKER SHOWING THAT AT LEAST ONE ; TASK WAS WAITING FOR THIS INTERRUPT

	MOV R0,A			; HENCE MOV @R0,#LOW(NOT_TIMING) 	 INC R0

; MARK TASK AS NOT WAITING ; MARK TASK AS NOT WAITING ; AND ; PUT FOUND TASK ON READYQ

MOV @R0,#HIGH(NOT_TIMING) 	 INC READYQTOP		 MOV R0,READYQTOP		 MOV @R0,0AH 			 	

NOT_YET: 	 	 	 	 	 	

; QSHFT WILL DO THE REST LATER.

	MOV A,R2			 INC A				 CJNE A,#NOOFTSKS,TRY_NXT JNB INTFLAG, EXIT_INT 		

; CHECK NEXT TASK ; NO TASK FOUND WAITING INT, HENCE EXIT

EXIT_INT_SHFT:

SETB TINQFLAG ; INDICATE THAT A NEW TASK HAS BEEN PUT IN READY Q MOV A,RUNNING			 CJNE A,#IDLE_TASK,EXIT_INT 	 ; CHECK CURRENT TASK ; NOT IN IDLE STATE, SO DO NOT SHIFT TASKS

					 					 OK2SHFT: 	 LJMP QSHFT

; BUT TINQFLAG WILL STILL REMAIN SET SO THAT THE ; RTOS_TIMER_INT ROUTINE CAN HANDLE IT LATER.

EXIT_INT: 	 	

	Pop_Bank0_Reg SetBank 0 SETB EA

ENDIF

	RETI

; SUB ROUTINES USED IN THE RTOS ; *********************************************** SET_FLAG: ; 	 ; ENTRY A = TASK NUMBER ; EXIT REQUIRED BIT IN TASK FLAG BYTE SET PUSH 00 PUSH 08 B = BIT MASK

MOV R0,#TSKFLAGS ADD A,R0 MOV R0,A

76
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MOV A,@R0 MOV @R0,A POP 08 POP 00 RET ; *********************************************** CHK_FLAG: ; 	 ; ENTRY A = TASK NUMBER ; EXIT CARRY SET IF FLAG WAS FOUND TO BE SET PUSH 00 PUSH 08 B = BIT MASK

Appendix B

ORL A,B		

; SET REQUIRED BIT TO 1

MOV R0,#TSKFLAGS ADD A,R0 MOV R0,A CLR C

MOV A,@R0 ANL A,B

  JZ EXIT1		 EXIT1:

  SETB C		 POP 08 POP 00 RET

; BIT WAS CLEARED, CARRY = 0 ; BIT WAS SET, CARRY =1

; *********************************************** CLR_FLAG: CHK_CLR_FLAG:

; BOTH NAMES CORRESPOND TO THE SAME ROUTINE ; ENTRY A = TASK NUMBER ; 	 ; 	 ; 	 B = BIT MASK

; EXIT CARRY SET IF FLAG WAS FOUND TO BE SET CARRY BIT = 0 IF BIT WAS ZERO

AND THEN CLEARS FLAG BEFORE EXITING ROUTINE

PUSH 00 PUSH 08

MOV R0,#TSKFLAGS ADD A,R0 MOV R0,A CLR C

MOV A,@R0 ANL A,B

  JZ EXIT2 		   XRL A,B 		 MOV A,@R0

; BIT WAS CLEAR, HENCE EXIT, CARRY = 0 ; SINCE IT WAS SET, THEN SIMPLY XOR WITH MASK ; TO CLEAR AND STORE ; CARRY = 1 SINCE BIT WAS INITIALLY SET

  SETB C	 	 EXIT2: POP 08 POP 00 RET

MOV @R0,A 		

77
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; *********************************************** FETCH_STACK: ; ENTRY A = TASK NUMBER, USES ACC, DPTR, AND R0 MOV TMPSTORE0,A MOV R0,#0 MOV A,R0 RET

Appendix B

; EXIT DPTR POINTS TO START OF STACK AREA FOR TASK MOV DPTR,#EXT_STK_AREA LOOP1:

  CJNE A,TMPSTORE0,CONT1 CONT1:

  MOV A,#STACKSIZE ADD A,DPL MOV DPL,A MOV A,DPH ADDC A,#0 MOV DPH,A   SJMP LOOP1 ; *********************************************** ; PRIORITY, AND THEREFORE AFTER ONE Q SORT PASS, ; NEXT IN LINE TO EXECUTE. ; ; SORT THE READY Q, LOW TASK NUMBER IS THE HIGHEST ; THE LOWEST NUMBERED TASK ENDS UP AT BOTTOM OF Q, ; IT IS CALLED FROM QSHFT, WHEN REGISTER BANK 1 IS BEING USED. TASK_SORT: PUSH ACC PUSH 08 PUSH B INC R0

MOV R0,READYQTOP 		   CJNE A,#READYQ,NEXT_PAIR   SJMP EXIT_QSORT 		 NEXT_PAIR: MOV A,@R0 MOV B,@R0 DEC R0 CLR C MOV A,R0

; R0 POINTS IN READY Q AREA

; ONLY ONE TASK, HENCE EXIT

  JNC NO_SWAP 			  				 SWAP_NOW: MOV A,@R0 MOV @R0,B INC R0 DEC R0 MOV @R0,A NO_SWAP:

SUBB A,@R0

; ENSURE LOWEST TASK NUMBER (HIGHEST PRIORITY) ; TRICKLES DOWN TO READYQ BOTTOM, READY TO RUN

  CJNE R0,#READYQ,NEXT_PAIR 	 ; ONE PASS DONE, HENCE EXIT EXIT_QSORT: POP B

78
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
POP 08 RET

Appendix B

POP ACC ; *********************************************** END

79
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Other Packages SerIntPrPkg.c
/* SerIntPrPkg.c – see remarks below for program dedtails 	 */ /* Has a 200 byte Receive and a 200-byte Transmit buffer in XDATA 	 */ /* Routines to use with C program when using the on-board UART 	 /* Running under interrupt control, using a stand-alone ISR, not under RTOS */ /* auto baud rate detection used by using a timer to count the bit time */ /* If Baudrate supplied is 0, then Auto Baud Detection is performed */ #include <reg52.h> 		 #include <absacc.h> #include <stdio.h> /* special function registers 8052 */ */

// RXD is bit 0xB0; 		 #define RX_BUFFER_LENGTH 200 #define TX_BUFFER_LENGTH 200

/* Rx Data on internal UART is Port 3 bit 0 */

unsigned char xdata Rx_buffer[RX_BUFFER_LENGTH]; /* software Receive buffer */ unsigned char data In_read_index;

unsigned char xdata Tx_buffer[TX_BUFFER_LENGTH]; /* software Transmit buffer */ /* points to data in software buffer that has been read */ unsigned char data In_waiting_index; /* points to data in software buffer not yet read */ unsigned char data Out_written_index; unsigned char data Out_waiting_index; /* points to data in software buffer that has been sent */ /* points to data in software buffer not yet sent */ void Init_P3_Int (unsigned int baudrate); unsigned int autobaud(void); void uart_P3_isr (void); char putchar (char c);  			

/* This should be created as a function, waiting for serial interrupt */ char _getkey (void); 	 /* This preferably should not be a Wait for Key routine */ /* ========================================== */ void Init_P3_Int (unsigned int baudrate){ unsigned int autobaud(void); ET1 = 0; 		 ES = 0; 		 			

/* It must have some TimeOut facility not to hold other jobs */

/* Disable Timer 1 interrupt just in case */

/* Disable Serial Interrupt initially just in case. */ /* It will then be enabled by the main program */

if (baudrate==0) baudrate = autobaud(); SCON = 0x50; 			 				 				 PCON &= 0x7F; 			 TMOD &= 0x0F; 			 				 /* Setup serial port control register */ /* Mode 1: 8-bit uart var. baud rate */ /* REN: enable receiver, TI=0 */

/* Clear SMOD bit in power ctrl reg (no double baudrate) */ /* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */

80
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
TMOD |= 0x20; 			 RCLK = 0; 			 TCLK = 0; 			 switch (baudrate) {   case 300: 	 TH1 = TL1 = 0xA0; /* Set M1 for 8-bit auto-reload timer mode 2 */ /* USE TIMER 1 FOR RECEIVE BAUD RATE (8032 only) */ /* USE TIMER 1 FOR TRANSMIT BAUD RATE (8032 only) */

Appendix B

	break;   case 600: 	

	break;   case 1200: 	

TH1 = TL1 = 0xD0;

	break;   case 2400: 	

TH1 = TL1 = 0xE8;

	break;   case 4800: 	

TH1 = TL1 = 0xF4;

	break;   case 9600: 	

TH1 = TL1 = 0xFA;

	break;   case 19200: 	 	

TH1 = TL1 = 0xFD;

TH1 = TL1 = 0xFD; PCON |= 0x80; 		

	break;   case 57600: 	 	 }

/* double baudrate, SMOD = 1 */

TH1 = TL1 = 0xFF; 	 PCON |= 0x80; 		

/* Not quite standard */

	break;

/* double baudrate, SMOD = 1 */

In_read_index = In_waiting_index = 0; 	 TR1 = 1; 	 ES = 1;		

Out_written_index = Out_waiting_index = 0; 	 /* Reset Transmit buffer pointers */ /* Start timer 1 for baud rate generation */ /* Enable serial interrupt */

/* Reset Receive buffer pointers */

TI = RI = 0; 	 /* Clear TI and RI */ EA = 1; 	 }

/* Enable global interrupts */

/* Autobaud Calculation */ /* which should be a 1 */

/* Calculates the time for 2 bits (the Start bit and the 1east significant bit, */ /* Assuming you press the ENTER key (13 decimal = 00001101 binary) */ /* 		

/*											*/ /* 		 | |	 0 1 0 1 1 0 0 0 0 1							 */ | |							*/ */

/* start bit--->+ +<--lsb msb-->+ +<---stop bit			 unsigned int autobaud(void){ unsigned char data i; unsigned int data counter;

81
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
unsigned int code count_table[] = {16,64,144,288,576,1152,2304,4608,9216,65535}; unsigned int code baud_table[] = {0,57600,19200,9600,4800,2400,1200,600,300,0}; // Counter running at a rate of 1 count every 12/11.0592 micro seconds // 		 // 	 // 	 // 	 // 	 // 	 // 	 // 	 = 1843200/br // Count reached after a time of 2 bits (bitrate =br) is (2*11059200)/(12*br) // 		 Upper Limit 	 = 65535	(invalid baudrate) = 9216	 <======= = 4608	 <======= = 2304	 <======= = 1152	 <======= = = 576	 <======= 288	 <======= 144	 <======= 64	 <======= 16	 (invalid baudrate)

Appendix B

// if 300 baud, count reached after 2 bits would be 6144 // if 600 baud, count reached after 2 bits would be 3072 1200 	Upper boundary 	 2400 	boundary 	 4800 	boundary 	 9600 	boundary 	 19200 boundary 	 600 	 boundary 	

300 	 Upper boundary 	

// if 1200 baud, count reached after 2 bits would be 1536 // if 2400 baud, count reached after 2 bits would be 768 // if 4800 baud, count reached after 2 bits would be 384 // if 9600 baud, count reached after 2 bits would be 192 =

// if 19200 baud, count reached after 2 bits would be 96 // 	 57600 boundary 	 = =

// if 57600 baud, count reached after 2 bits would be 32 // 		 do {   TMOD &= 0x0F; 	   TMOD |= 0x10; 	 			 Lower boundary 	

/* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */ /* Set M0 for 16-bit timer mode 1 */

Brain power

By 2020, wind could provide one-tenth of our planet’s electricity needs. Already today, SKF’s innovative knowhow is crucial to running a large proportion of the world’s wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

82
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
  TH1 = TL1 = 0; 	   while(RXD){}; 	 TR1 = 1; 		 /* Load counter registers with zero */ /* Start timing */

Appendix B

/* wait for start bit (loop until RXD = 0) */ /* wait for start bit to finish */

  while(!RXD){}; 	   while(RXD){}; 	   TR1 = 0; 		 i=0;

/* wait for 1st one bit (RXD = 1) */

counter = TH1*256 + TL1; 	

/* Stop count => has value of 2 bits */ /* Calculate the count value */

  while (counter > count_table[i]) { 			 		 i++;		 }		

// Find entry in table to correspond with this count // Upper and Lower values of table are not valid // hence loop until found valid baud rate // Valid i values are 1 to 8 only.

				 return(baud_table[i]); }

} while (i==0 || i==9); 	

/* The following is the UART Interrupt Service Routine */

/* It should be run as a function under serial interrupt */ /* 	 'UART P3 ISR': 	

/******************************************************************************/ /******************************************************************************/ void uart_isr (void) interrupt 4 using 1 { 	 /* Runs as a Serial Interrupt Routine */ */

  /* Wait for Serial Interrupt number 4 */ /* Check if interrupt from TI or RI */

  /* TI set by 8032 UART whenever a character has just been transmitted */ /* BOTH RI and TI should be reset by the software */ 	 	 if (TI) {				 TI=0; 				

/* RI is set by the 8032 whenever a complete character has been received in SBUF */

/* Transmitter section */

/* Check if interrupt from TI */ /* Transmitter is ready, hence */

 					 	 					

/* prepare for next transmission */

	   SBUF = Tx_buffer[Out_written_index++];  		 	else

if (Out_written_index < Out_waiting_index)

/* Check if there is anything else to transmit */

/* put data in hardware buffer for Tx */ /* No new data to send, just reset Tx buffer index */

	  {			

	  Out_waiting_index = 0; 	  Out_written_index = 0; 	 } if (RI) }

	

/* Receiver Section = Flag set when full character has been received */ 	RI=0; /* If all old data in software buffer has been read, */

{				

/* Check if interrupt from RI */

/* we can start reading again into index 0 and reset RX buffer index */

83
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 if (In_waiting_index == In_read_index) { In_waiting_index = 0; In_read_index = 0;

Appendix B

		 		 		

		} 	 	

/* Read the data from the UART hardware buffer (SBUF) into the software buffer */ Rx_buffer[In_waiting_index] = SBUF; In_waiting_index++; if (In_waiting_index < RX_BUFFER_LENGTH)

		 	} } {

char putchar (char c) // Writes to software buffer ONLY if there is space. // No error reporting in this simple library unsigned int data TimeOut = 20000; 	

// If no space, keep on trying for a short TimeOut period

	  if (Out_waiting_index < TX_BUFFER_LENGTH) 		 		 	 { Tx_buffer[Out_waiting_index++] = c;

// wait for buffer space only for a TimeOut period

while ((Out_waiting_index >= TX_BUFFER_LENGTH) && (TimeOut-- > 0));

		} 	 } {

TI = 1;	

/* Generate interrupt - Activate TI to start transmission */

return (c);

char _getkey () // No permanent waiting for key press - just waits for a time-out period // Retrieves a character from the software buffer, if available. // The character from the buffer is returned, or if no character // is available, a 0 is returned. 	 	 	 	 unsigned char data c = 0; 	 // Zero is returned if no key is pressed

unsigned int data TimeOut = 20000;

while ((In_read_index >= In_waiting_index) && (TimeOut-- > 0)); if (In_read_index < In_waiting_index) { c = Rx_buffer[In_read_index]; In_read_index++;

		 		 		

// if no new character available, wait for a short TimeOut period

		

			 	 }

if (In_read_index < RX_BUFFER_LENGTH)

		}

return (c);		

// Returns NULL if no new character received

/******************************************************************************/

84
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

SerP2Pkg.c
/******************************************************************************/ /* SerP2Pkg.c */ /* Routines to use with C program when using the additional SCC2691 UART (P2) */ /* on the FLT-32 board. */ /* If baud rate parameter given is zero, auto-baudrate detection is performed */ #include <reg52.h> 			 #include <absacc.h> #include <stdio.h> /* special function registers 8052 	   */

void P2_SetUp(void);

unsigned int Auto_P2_BaudRate(void); char putchar (char c); char _getkey (void); #define RX	 XBYTE [0xFFE8] 	

void Set_P2_BaudRate(unsigned int baud);

					 					 			

// READ RX DATA AT START-UP (RxD Pin on P2) // 	 // 	 (READ BIT 0 OF THIS ADDRESS) USED FOR AUTO-BAUD DETECTION ONLY

#define UART_MR1 	 #define UART_MR2 	 #define UART_SR		 #define UART_CSR	 #define UART_CR		

//		

XBYTE [0XFFF8]	// MR1 - Mode Register 1 XBYTE [0XFFF8]	// MR2 - Mode Register 2

UART BASE ADDRESS on Flite-32 is FFF8H

XBYTE [0XFFF9] // READ SR - Channel Status Register XBYTE [0XFFF9] // WRITE CSR - Clock Select Register XBYTE [0XFFFA] // WRITE CR - Command Register

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT… RUN FASTER. RUN LONGER.. RUN EASIER…
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

85
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
#define UART_RHR	 #define UART_THR	 #define UART_ACR	 #define UART_ISR	 #define UART_IMR	 #define UART_CTU	 #define UART_CTL	 XBYTE [0XFFFB] // READ RHR - Receive Holding Register

Appendix B

XBYTE [0XFFFB] // WRITE THR - Transmit Holding Register XBYTE [0XFFFD] // READ ISR - Interrupt Status Register XBYTE [0XFFFD] // WRITE IMR - Interrupt Mask Register

XBYTE [0XFFFC] // WRITE ACR - Auxiliary Control Register

XBYTE [0XFFFE] // READ/WRITE CTU - Counter Timer Upper Register XBYTE [0XFFFF] // READ/WRITE CTL - Counter Timer Lower Register

/***********************************************************************************/ void P2_SetUp(){ unsigned char c; do {   UART_CR 	   UART_CR 	   UART_CR 	   UART_CR 	   UART_MR1 	   UART_MR2 	   UART_ACR 	   UART_CSR 	   UART_IMR 	   UART_CR 	   UART_CR 	   UART_CR 	   UART_CR 	 } = 0x2A;		 = 0x3A;		 = 0x4A;		 = 0x1A;		 = 0x13;		 = 0x07;		 = 0x38;		 = 0xCC;		 = 0x00;		 = 0x16;		 = 0x2A;		 = 0x3A;		 = 0x4A;		 // reset Rx. Rx and Tx disabled // reset Tx. Rx and Tx disabled // reset Error Status. Rx and Tx disabled // reset MR pointer. Rx and Tx disabled // 8 bit, no parity // 1 stop bit

						

// BRG=0. Set 1 of baud rate table. // 38400 baud

// Counter i/p xtal/16

// No interrupts

  } while (((c=UART_SR) & 0x04) == 0); // Repeat setup if TX not yet ready // reset Rx. Rx and Tx disabled // reset Tx. Rx and Tx disabled

// reset MR pointer. Rx and Tx enabled

// reset Error Status. Rx and Tx disabled

unsigned int Auto_P2_BaudRate(void){ // detect and return baud rate unsigned char c,d,i; unsigned int counter;

unsigned int code count_table[] = {9,18,36,72,144,288,576,1152,2304,3630,5200,65535}; unsigned int code baud_table[] = {0,38400,19200,9600,4800,2400,1200, 				600,300,150,110,0};

// Counter running at a rate of 1 count every 16/3.6864 micro seconds // 	 Invalid Maximum limit 	 110 boundary 	

// Count reached after a time of 2 bits (bitrate=br) is (2*3686400)/(16*br) // 	 = 	 65535 <========= = 	 5200 <=========

// if 110 baud, count reached after 1 bit would be 4189 // 		 // 		 // 		 // 		 // 		 // 		 // 		 // if 150 baud, count reached after 1 bit would be 3072 // if 300 baud, count reached after 1 bit would be 1536 // if 600 baud, count reached after 1 bit would be 768 1200 	 boundary 	 2400 	 boundary 	 4800 	 boundary 	 9600 	 boundary 	 600 	 boundary 	 300 	 boundary 	 150 	 boundary 	

= 3630 <========= = 2304 <========= = 1152 <========= = 576 <========= = 288 <========= = 144 <========= = 72 <=========

// if 1200 baud, count reached after 1 bit would be 384 // if 2400 baud, count reached after 1 bit would be 192 // if 4800 baud, count reached after 1 bit would be 96

86
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
// if 9600 baud, count reached after 1 bit would be 48 // 		 // 		 // 	 do { 19200 	 boundary 	 38400 	 boundary 	

Appendix B

// if 19200 baud, count reached after 1 bit would be 24 // if 38400 baud, count reached after 1 bit would be 12 Invalid lower boundary 	

= 36 <========= = 18 <========= = 9 <=========

  UART_CTU 	   UART_CTL 	   UART_CR 	

P2_SetUp();

= 0xFF;					 = 0xFF;

// Reset counter to 65535

  while (((c=RX) & 0x01) != 0){};	

// counting duration of 2 bits - the start buit and another '1' bit   while (((c=RX) & 0x01) == 0){};	   while (((c=RX) & 0x01) == 1){};	   UART_CR 	 bits) // wait for start bit to pass // wait for '1' bit to pass

= 0x8A;					

// wait for start bit

// start counter

= 0x9A;					

// stop counter (now holding count for 2

c = ~(c = UART_CTU);				 d = ~(d = UART_CTL);				 counter = 256*c + d;				 i=0;

// Since counter counts down, we have to // complement the readings. // Get counter value

  while (counter > count_table[i]) { 					 		 i++;		

// Find entry in table to correspond with this count

} while (i==0 | i==11); 		 return(baud_table[i]);

} // Valid i values are between 1 and 10 ONLY.

// upper and lower values of table are not valid

}

void Set_P2_BaudRate(unsigned int baud) { unsigned char c;

if (baud==0) baud = Auto_P2_BaudRate();   UART_CR 	   UART_CR 	   UART_CR 	   UART_CR 	   UART_MR1 	   UART_MR2 	   UART_ACR 	 = 0x2A;			 = 0x3A;			 = 0x4A;			 = 0x1A;			 = 0x13;			 = 0x07;			 = 0xB8;			 // reset Rx. Rx and Tx disabled // reset Tx. Rx and Tx disabled // reset Error Status. Rx and Tx disabled // reset MR pointer. Rx and Tx disabled // 8 bit, no parity // 1 stop bit

// BRG=1. Set 2 of baud rate table.

  switch(baud) { 	  		 	

case 110:

			 break;  		 	 case 150:

UART_CSR = 0x11;

			 break;  		 case 300:

UART_CSR = 0x33;

			 break;

UART_CSR = 0x44;

87
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 case 600:

Appendix B

 		 	

			 break;  		 	 case 1200:

UART_CSR = 0x55;

			 break; case 2400:

UART_CSR = 0x66;

		 UART_CSR = 0x88; 			 break;  		 	 	 case 4800:

			 break;  		 	 case 9600: default:

UART_CSR = 0x99;

			 break;  		 	 case 19200:

UART_CSR = 0xBB;

			 break;  		  		 	 case 38400:

UART_CSR = 0xCC;

UART_ACR = 0x38; UART_CSR = 0xCC;

			 break; UART_CR 	 }

UART_CTU 	 UART_CTL 	 UART_CR 	 UART_MR1 	 UART_MR2 	 UART_CR 	 UART_CR 	  		

= 0x9A;				 = 0xFF;				 = 0xFF; = 0x1A;				 = 0x13;				 = 0x07;				 = 0x05;				 = 0x85;				

// Stop Counter

// Reload counter with 65535 // reset MR pointer. Rx and Tx disabled // 8 bit, no parity // 1 stop bit // Enable Tx and Rx // Start Counter

while (((c=UART_ISR) & 0x10) == 0){}; UART_CR 	

// Wait for counter to reach zero (just a delay) = 0x95;				 // Stop Counter

while (((c=UART_SR) & 0x01) == 1){ 	 } }

c=UART_RHR;					 UART_CR 	 = 0x45;				

// clear receive FIFO buffer // Reset Error Status. Rx and Tx enabled

char putchar (char c) { unsigned char d; 	 	 while (((d=UART_SR) & 0x04) == 0){}; UART_THR = c; return (c); }

	 	

#if 1

char _getkey (void){ // wait for key for ever char c;  	 } 	 while (((c=UART_SR) & 0x01) == 0){}; return(c=UART_RHR);

88
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#endif #if 0

Appendix B

char _getkey (void){ 	 // wait for key with TIMEOUT char c;  	  	 	 } unsigned long TimeOutLoop = 12000; 	 // just as a test 			 		 		

while ((((c=UART_SR) & 0x01) == 0) && (++TimeOutLoop !=0)){}; if (((c=UART_SR) & 0x01) == 1) else return(c=UART_RHR); return (0); // wait for character or TimeOut

#endif #if 0

char _getkey (void){ // no waiting char c; 	 if (((c=UART_SR) & 0x01) == 1) else return(c=UART_RHR); return (0);

		 	 		

}

#endif

/* =================================================== */

89
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

SerP3Pkg.c
/* =================================================== */ /* SerP3Pkg.c – see remarks below for program details */ /* NOT under interrupt control */ /* Routines to use with C program when using the 8032 on-board UART (P3)*/ /* Uses Timer 1 for Baud rate Generation */

/* Serial and Timer 1 interrupts are disabled. */ /* If Baudrate supplied is 0, then Auto Baud Detection is performed */ #include <reg52.h> 		 #include <absacc.h> #include <stdio.h> /* special function registers 8052 */

// RXD is bit 0xB0; 	 /* Rx Data on internal UART is Port 3 bit 0 */ void Set_P3_BaudRate (unsigned int baudrate); unsigned int P3autobaud(void); char putchar (char c); char _getkey (void);

/* ========================================== */ void Set_P3_BaudRate (unsigned int baudrate){ /* NOT under interrupt control */ if (baudrate==0) baudrate = P3autobaud(); SCON = 0x50; 	 /* Setup serial port control register */ 		 		 /* Mode 1: 8-bit uart var. baud rate */ /* REN: enable receiver */

PCON &= 0x7F; 	/* Clear SMOD bit in power ctrl reg */ 		 /* Clear M1 and M0 for timer 1 */

TMOD &= 0x0F; 	/* Setup timer/counter mode register */ TMOD |= 0x20; 	/* Set M1 for 8-bit auto-reload timer 1 */ RCLK = 0; 	 TCLK = 0; 	 	 /* USE TIMER 1 FOR RECEIVE BAUD RATE */

switch (baudrate) {  		 	 case 300:

/* USE TIMER 1 FOR TRANSMIT BAUD RATE */

		break;  		 	 case 600:

TH1 = TL1 = 0xA0;

		break;  		 	 case 1200:

TH1 = TL1 = 0xD0;

		break;  		 	 case 2400:

TH1 = TL1 = 0xE8;

		break;  		 	 case 4800: 	

TH1 = TL1 = 0xF4;

TH1 = TL1 = 0xFA; break;

90
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 case 9600: 	

Appendix B

 		 	 	

TH1 = TL1 = 0xFD; break;

 		 	

case 19200:

	 	 	 	

TH1 = TL1 = 0xFD; PCON |= 0x80; 		 break;

/* double baudrate, SMOD = 1 */

 		 	

case 57600:

	 	 	 } 	

TH1 = TL1 = 0xFF; 	 PCON |= 0x80; 		 break;

/* Not quite standard */

/* double baudrate, SMOD = 1 */

ET1 = 0; 		 ES = 0;			 TR1 = 1; 		 } TI = 1; 		

/* Disable timer 1 interrupts just in case */ /* Disable serial interrupts just in case */ /* Start timer 1 */ /* Set TI to indicate ready to xmit */

/* Autobaud Calculation */

/* Calculates the time for 1 bit (Start bit only) */

/* Assuming you press the ENTER key (13 decimal = 00001101 binary) */

/*													 		*/ /* 		 /* 		| | | |						*/ /* start bit--->+ +<--lsb msb-->+ +<---stop bit			 0 1 0 1 1 0 0 0 0 1				 */

/* For the baud rate to be detected properly, the key pressed */

*/

/* should have its LSB = 1 (ALL ODD ASCII characters such as A, a) */ unsigned int P3autobaud(void){ unsigned char i;

unsigned int counter;

unsigned int code count_table[] = {10,32,72,144,288,576,1152,2304,3200,65535}; // Counter running at a rate of 1 count every 12/11.0592 micro seconds // 		 = 921600/br

unsigned int code baud_table[] = {0,57600,19200,9600,4800,2400,1200,600,300,0}; // Count reached after a time of 1 bit (bitrate=br) is (1*11059200)/(12*br) // 			 Invalid Maximum limit 		 300 	 600 	 = 65535 <========= = 3200 <========= = 2304 <========= = 1152 <========= = 576 <========= = 288 <========= = 144 <========= = 72 <=========

// 				 // 				 // 				 // 				 // 				 // 				 // 				

// if 300 baud, count reached after 1 bit would be 3072 // if 600 baud, count reached after 1 bit would be 1536 // if 1200 baud, count reached after 1 bit would be 768 // if 2400 baud, count reached after 1 bit would be 384 // if 4800 baud, count reached after 1 bit would be 192 // if 9600 baud, count reached after 1 bit would be 96 19200 	 boundary 	 9600 	 boundary 	 4800 	 boundary 	 2400 	 boundary 	 1200 	 boundary 	 boundary 	

boundary 	

91
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
// if 19200 baud, count reached after 1 bit would be 48 // 				 // 		 do { // if 57600 baud, count reached after 1 bit would be 16 Invalid lower 		 boundary 	 57600 	 boundary 	

Appendix B

= 32 <========= = 10 <=========

TMOD &= 0x0F; 	 			 TMOD |= 0x10; 	 ET1 = 0; 		

/* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */ /* Set M0 for 16-bit timer mode 1 */

TH1 = TL1 = 0; 	

/* Load counter registers with zero */

ES = 0;		 	 while(RXD){}; 	 TR1 = 1; 		 TR1 = 0; 		 i=0; 	

/* Disable timer 1 interrupts just in case */ /* wait for start bit (loop until RXD = 0) */ /* Start timing */ /* wait for start bit to finish */

/* Disable serial interrupts just in case */

while(!RXD){}; 	

counter = TH1*256 + TL1; /* Calculate the count value */ while (counter > count_table[i]) { 			 i++;		

/* Stop count => has value of 1 bit */

// Find entry in table to correspond with this count }			

					 return(baud_table[i]); }

} while (i==0 || i==9); 		

// upper and lower values of table are not valid // hence loop until found valid baud rate

// Valid i values are 1 to 8 only.

/*

* putchar (mini version): outputs charcter only */

char putchar (char c) { while (!TI); 		 TI = 0; }

// If TI=0, previous transmission not yet ready, hence wait

return (SBUF = c);

#if 0

char _getkey () { 		 	 char c=0; if (RI)

// no interrupt, no waiting for key press

  {

c = SBUF; RI = 0; }

}

return (c);

#endif #if 0

char _getkey () { 	 char c=0;

// no interrupt, wait for key press for a time out period // just as a test

unsigned long TimeOutLoop = 12000; 		

while ((!RI) && (++TimeOutLoop !=0)){}; // wait for character or TimeOut

92
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
if (RI) c = SBUF; RI = 0; }

Appendix B

  {

	 }

return (c);

#endif #if 1

char _getkey () { 	 char c;

// no interrupt, wait for key press for ever

while (!RI); // wait here until character received c = SBUF; RI = 0; }

return (c);

#endif /*****************************************************************************/

93
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Flt32Pkg.c
/* =================================================== */ /* Flt32Pkg.c */

/* Routines to use with C programs */

/* Used to initialise 8255, read and write from ports */ /* when using the add-on Applications Board */ /* with the FLT-32 board. */ #include <reg52.h> 		 #include <absacc.h>

/* special function registers 8052 	 */

void Init_8255(unsigned char c);

void WritePort(unsigned char c, unsigned char d); unsigned char ReadPort(unsigned char c); #define PortA 		 #define PortB 		 #define Control 	 #define PortC	 	 XBYTE [0XFF40] 	 XBYTE [0XFF41] 	 XBYTE [0XFF42] 	 XBYTE [0XFF43] 	

// 8255 Port A register // 8255 Port B register // 8255 Port C register // 8255 Control register

/***********************************************************************************/ void Init_8255 (unsigned char c){ } Control = c; 		

// set-up 8255 PIO chip

/***********************************************************************************/ void WritePort (unsigned char c, unsigned char d) 	 { switch (c) case 'A': case 'a': PortA = d;

	 { 		 		 		 		 		 		

		 break;

case 'B': case 'b': default: PortB = d;

		 break;

case 'C': case 'c': PortC = d;

		 break; 		} }

/***********************************************************************************/ unsigned char ReadPort (unsigned char c) 	 	 { unsigned char d; switch (c)

	 { 		

case 'A': case 'a': default:

94
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
		 		 		 		 		 d = PortA;

Appendix B

		 break;

case 'B': case 'b': d = PortB;

		 break;

case 'C': case 'c': d = PortC;

		 break; 		} } return (d);

/* =================================================== */

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
95
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

RTOS Example Programs Using the PaulOS RTOS under the Keil environment is similar to using it to write a normal C program. The files required are shown in the screen shot below in figure B-1. Note that RTMACROSV5C.A51 and PaulosV5C.A51 are declared as text files (right click on them and check the options). This is because they are ‘included’ in TaskStkV5C.A51 file. Note also that the NOFTSKS has to agree with the number of tasks in the application and MAIN_STACK has to agree with the ?STACK value given in the AAA. m51 list file generated by the compiler.

Figure B-1 Keil Screen shot using PaulOS RTOS

The following are some example programs using Paulos rtos so that you can have an idea of its capabilities and syntax.

96
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Light Controller Example Program
/******************************************************************************/ /* 				RTOS */ /* Paul_19.c: MULTI-TASK Light Controller using the C-51 COMPILER 	 /* USE LARGE MODEL, WITH EXTERNAL DATA 	 /* RTOS program 	 /* 	 /* Application Program using Paulos.a51 	 /* Make sure to include the Paulos.a51 program 	 /* 	 with the source group 	 together with the Paulos.h header file 	 (defining the system calls) 	 */ */ */ */ */ */

/* 	

*/ */ */ */ */ */ */ */ */ */ */

/* All tasks run in bank 0, RTOS kernel runs in bank 1 	 /* All tasks must be written as an endless loop. 	 /* VALID INTERRUPT NUMBERS ARE AS FOLLOWS: 	 /* 		 /* 		 0   EXTERNAL INT 0 	 2   EXTERNAL INT 1 	 4   SERIAL PORT 	 1   TIMER COUNTER 0 	 3   TIMER COUNTER 1 	 5   TIMER COUNTER 2 	

(IEMASK = 00100001 = 21H) 		 (IEMASK = 00100010 = 22H) 		 (IEMASK = 00100100 = 24H) 		 (IEMASK = 00101000 = 28H) 		 (IEMASK = 00110000 = 30H) 		 (IEMASK = 00100000 = 20H) 		

/*		 /*		 /*		 /*		 /* 	

/* 			 /* */ //

TIMER 2 IS USED BY THE RTOS, AND ET2 (20H) SHOULD BE ALWAYS SET 	   */ HENCE THE OTHER IEMASKS ARE ALWAYS ORED WITH 20H 	   */

/******************************************************************************/ // 		 N O T E

//   USE the following settings in Options for Target 1 // Memory Model: LARGE: EXTERNAL XDATA // Code Model: LARGE: 64K Program // 	 // CODE: 	 0X8100 	 // RAM: 	 0X8B00 	 START 	 SIZE 0X0A00 0X1500 /* special function registers 8052 */

#include <reg52.h> 			 #include "Paulos.h" 			 #include <absacc.h> #define porta   XBYTE [0xFF40] 		 #define portb   XBYTE [0xFF41] #define portc   XBYTE [0xFF42] #define LEDS portb

/* Paul RTOS system calls definitions */ /* 8255 port mappings on FLT-32 */

#define control XBYTE [0xFF43]

unsigned char data display=0; 	 /* 	

/* place display variable in internal 'data' RAM */ */

/******************************************************************************/ /******************************************************************************/ void lights0 (void){ 			  	  	 	 while(1){ WAITT(1); /* LED operation 	 */ Task 0 'lights0': 							

	  display=display ^ 0x01; SIGNAL(1); 		 /* SIGNAL TO TASK 1 	 */

		 }

		}

WAITS(255); 		

/* WAIT FOR A SIGNAL INDEFINITELY 	

*/

97
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights1 (void){ 		 	 while(1){ 		 /* LED operation 	 */ Task 1 'lights1': */

Appendix B

	   display=display ^ 0x02; 	 WAITT(1); 		} } 	 SIGNAL(2);

WAITS(255);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights2 (void){ 			  	 		 while(1){ WAITS(255); /* LED operation 	 */ Task 2 'lights2': 							 */

	   display=display ^ 0x04; 	 WAITT(1); 	 		} } SIGNAL(3);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights3 (void){ 			  	 		 while(1){ WAITS(255); /* LED operation 	 */ Task 3 'lights3': 							 */

	   display=display ^ 0x08; 	 WAITT(1); 		} } 	 SIGNAL(4);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights4 (void){ 			  	 		 while(1){ WAITS(255); /* LED operation 	 */ Task 4 'lights4': 							 */

	    display=display ^ 0x10; 	 WAITT(1); 		} } 	 SIGNAL(5);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights5 (void){ 			 /* LED operation 	 */ Task 5 'lights5': 							 */

98
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 while(1){ 		

Appendix B

	   display = display ^ 0x20; 	 WAITT(1); 	 		} } SIGNAL(6);

WAITS(255);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights6 (void){ 			 	 while(1){ 		 WAITS(255); /* LED operation 	 */ Task 6 'lights6': 							 */

	   display = display ^ 0x40; 	 WAITT(1); 		} } 	 SIGNAL(7);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights7 (void){ 			 	 while(1){ WAITS(255); /* LED operation 	 */ Task 7 'lights7':							 */

	   display=display ^ 0x80;

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

99
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
	 WAITT(1); 	 		} }

Appendix B

SIGNAL(0);

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights8 (void){ 			 	 while(1){ 		 	 /* LED operation 	 */ Task 8 'lights8': 							 */

		} }

display=0;

WAITI(0); 		

/* wait for INTERRUPT EXT0 	

*/

/******************************************************************************/ /******************************************************************************/ /* 	 /******************************************************************************/ void lights9 (void){ 			  	 	 		 while(1){ /* LED operation 	 */ Task 9 'lights9': 							 */

		} }

display=0XFF;

WAITI(2); 			

/* wait for INTERRUPT EXT1 	   */

/******************************************************************************/ /******************************************************************************/ /*	 /******************************************************************************/ void main (void) 			   INIT_RTOS(0x25); 		 				 CREATE(0,lights0); 		 CREATE(1,lights1); 		 CREATE(2,lights2); 		 CREATE(3,lights3); 		 CREATE(4,lights4); 		 CREATE(5,lights5); 		 CREATE(6,lights6); 		 CREATE(7,lights7); 		   INIT_8255(0x91); 				 { /* program execution starts here 	   */ /* initialise 8255 port 	   */ Main: Initialise and display 					 */

/* initialise RTOS variables and stack 	   */ /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 				 /* start lights task 			 /* start lights task 			 */ */ */ */ */ */ */ */ */ */

/* using timer2 and ext0 & ext1 interrupts 	   */

CREATE(8,lights8); 			 CREATE(9,lights9); 			 display = 0;

RTOSGOMSEC(25,0); /* start RTOS system */   while (1){ } LEDS=display;

}

/******************************************************************************/

100
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Random Example Program
/* ************************************************************************************** * 						PAULOS * * * 					The Real-Time Kernel

* 					 EXAMPLE random06.c */

************************************************************************************** #include <reg52.h> 		 #include <absacc.h> #include <stdio.h> #include <stdlib.h> /* special function registers 8052 		 */

#include "..\Headers\PaulosV5B.h" 		

/* PaulOS C version system calls definitions */

#include "..\Headers\SerP2Pkg.h" #include "..\Headers\Flt32Pkg.h" #include "..\Headers\HYPER_PC.H" /* ************************************************************************************** * 						TASKS */ { ************************************************************************************** void CommonTask (void)  	  	  	  	 uchar x,y,z,s[3]; z = 1 + RUNNING_TASK_ID(); PERIODICA(0,0,z); 		 { /* Run every (1 + Task ID) seconds */

while(1)

 	    x = rand()%80; 	  /* Get X position (0-79) where task number will appear */  	    z = RUNNING_TASK_ID();  	    WritePort('B',z); 	 	

 	    y = 5 + rand()%16;   /* Get Y position (5-20) where task number will appear */  	    PC_DispChar(y,x,z+'A'); 		  	    sprintf(s,"%02bu",z); 	 	 } } PC_DispStr(22,40,s); WAITV(); /* Display the task number on the screen */

/* */

**************************************************************************************

/* */ {

************************************************************************************** void ClearArea (void) 	 	 uchar i,s[3];

PERIODICA(0,0,25); 			

/* Repeat every 25 seconds */

101
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
while(1)    {  	  	 	 	 } 	 	 i = RUNNING_TASK_ID(); sprintf(s,"%02bu",i); WritePort('B', i); PC_DispStr(22,40,s); 		 /* Display the task number on the screen 	

Appendix B

*/

for (i=5;i<=20;i++) PC_DispClr2EndOfRow(i,0); PC_DispStr(22,40,s); 		 WAITV();

 	 } /* */ {

/* Display the task number on the screen 	

*/

************************************************************************************** void RandomSeed (void)    uint x;

   uchar z,s[3]; while(1)    {  	  	  	  	  	 } /* */ /* */ /* */ /* 	 PERIODICA(0,0,4); 				 /* Run every 4 seconds */

z = RUNNING_TASK_ID(); sprintf(s,"%02bu",z); WritePort('B',z); x = (x+1)%0xFFFF; WAITV(); srand(x); PC_DispStr(22,40,s); 		 /* Display the task number on the screen */

		 }

**************************************************************************************

************************************************************************************** /*$PAGE*/ **************************************************************************************

************************************************************************************** * 						MAIN */ ************************************************************************************** /* Using ANSI.SYS Escape control sequence 		 /* Clear Screen 		 /* Position Cursor 		 void main (void) { Esc[row;colH 	 */ */ */

Esc[2J 			 */ 	

/* Clear to end of line Esc[K 			

102
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
uchar i;

Appendix B

   INIT_RTOS(0x20); 			 	 Set_P2_BaudRate (38400);

Init_8255(0x91); 		    /* Initialise the 8255 */

/* initialise RTOS variables and stack */

PC_DispClrScr(); 			

PC_DispStrCntr (1,"PaulOS, The Real-Time 8051 Co-Operative Kernel"); PC_DispStrCntr (3,"Version 5B"); PC_DispStr(22,31,"Task No:"); 	for(i=0;i<=32;i++) 	 { 	 	 	 	 	  	 	 } 	 	 } CREATE(i,CommonTask); 		 CREATE(33,ClearArea); 		 RTOSGOMSEC(250,0); 		 while (1) { }

/* Clear the screen 			

*/

PC_DispStrCntr (2,"by Paul P. Debono - EXAMPLE Random 06 with 35 tasks");

/* CREATE common tasks 			 /* CREATE task 				 /* CREATE task */ /* Start multitasking 				

*/ */ */

CREATE(34,RandomSeed); 	

SET_IDLE_MODE();/* Go to idle mode if doing nothing, to conserve energy 	 */

/*

************************************************************************************** **************************************************************************************

103
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

Multi-Processor Example Program This program is a Master-Slaves example, running under interrupts (not under RTOS). See remarks on the program header for the program details.
/* Multi-Processor Test program number one */ /* Master.c */ /* Use in conjunction with Slave.c */ /* Please include the following with Source Group */ /*				STARTUP.A51				*/ /*				SerP2Pkg.c				*/ /*				Flt32Pkg.c 				*/ // Main routine simply waits for keyboard // input to send messages to slaves // Sends any message to any slave or a General Message to all slaves // Receives a message from the slave in communication // // // 	 // 	 Internal Serial port handles communications (not under interrupt control) Main program prints messages sent/received on the terminal screen via socket P2, 38400 baud. to master microcontroller (socket P3 – up to 345600 baud).

// Timer 2 interrupt service routine toggles the upper 4 leds #include <reg52.h> #include <stdio.h> #include <absacc.h> #include <string.h> #define EOT '~'				 #define EOS '\0'			 // External Functions in SerP2Pkg.c void P2_SetUp(void); void Auto_P2_BaudRate(void); char putchar (char c); char _getkey (void); // END OF MESSAGE // END OF STRING

void Set_P2_BaudRate(unsigned int baud);

// External Functions if using Flt32Pkg.c void Init_8255(unsigned char c); void WritePort(unsigned char c, unsigned char d) large reentrant; unsigned char ReadPort(unsigned char c) large reentrant; // // Functions in this module

void Init_TIMER2 (unsigned char msecs);

void XchgInfo(unsigned char SlaveNum, char s[], char r[]); // Variables

void Init_P3UART (unsigned char mode, unsigned long baudrate); unsigned char data intdisplay; unsigned char data i=1; void Init_TIMER2 (unsigned char msecs) 	 // Timer 2 initialisation

						//causes interrupt every msecs {

104
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
unsigned char data THIGH,TLOW; unsigned int data clock; clock = msecs*922; 			 THIGH = (65536-clock)/256; TLOW = (65536-clock)%256;    RCAP2L = TLOW;    TL2 = TLOW; ET2 = 1; // 922 = 11059/12;

Appendix B

RCAP2H = THIGH;			 TH2 = THIGH; 			

// Re-load values // set up timer 2 (for Flight 32) // timer 2 16-bit auto-reload mode // START TIMER

   T2CON = 0x0; 			 TR2 = 1; 				

} {

void T2ISR (void) interrupt 5 using 1	 // Timer 2 ISR, toggles LEDs TF2 = 0; 	 	 	 	 }

if (i++ == 10)				 { i = 1;

// every 10 interrupts

intdisplay = intdisplay ^ 0xF0; 	 WritePort('B',intdisplay); 	

	}

/* output to leds */

// toggle upper 4 bits (^ => XOR)

void Init_P3UART (unsigned char mode, unsigned long baudrate) {			 ES = 0; 		 /* Disable Serial Interrupt */

/* Initialise 8051 UART for multi-processor comms */ /* Setup serial port control register */

SCON = mode;		 PCON &= 0x7F; 		 switch (baudrate) { 	 case 1200:

/* Clear SMOD bit in power ctrl reg PCON,(no double brate) */

	break; 	 case 2400:

TH1 = TL1 = 0xE8;

	break; 	 case 4800:

TH1 = TL1 = 0xF4;

	break; 	 case 9600:

TH1 = TL1 = 0xFA;

	break; 	 	

TH1 = TL1 = 0xFD;

case 19200:

TH1 = TL1 = 0xFD; PCON |= 0x80; 		

	break; 	 	

/* double baudrate, SMOD = 1 */

case 57600:

TH1 = TL1 = 0xFF; 	 PCON |= 0x80; 		

/* Not quite standard */

	break;

/* double baudrate, SMOD = 1 */

105
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
case 172800: 		 case 345600: 			 break; 			 PCON |= 0x80; 		 /* not strictly speaking standard */ /* crystal/64, SMOD = 0 */ /* crystal/32, SMOD = 1 */ /* not strictly speaking standard */

Appendix B

	 	

	break; }

if (baudrate <= 57600)    { TR1 = 1; 	 /* Start timer 1 (baud rate) */

   ET1 = 0; 		 			

   TMOD &= 0x0F; 	    TMOD |= 0x20; 	 RCLK = 0; 		 TCLK = 0; 		 TI = 1; 		 } }

/* Disable Timer 1 Interrupts just in case */ /* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */

/* Set M1 for 8-bit auto-reload timer 1 */

/* USE TIMER 1 FOR RECEIVE BAUD RATE (8032 only) */

/* USE TIMER 1 FOR TRANSMIT BAUD RATE (8032 only) */ /* Set TI to indicate initially ready to transmit */

void XchgInfo(unsigned char SlaveNum, char s[], char r[]) {					

						// Receives data from addressed slave 	 	 unsigned int data inptr,outptr; unsigned char data c, x; while(!TI){}		

// Sends address/data to a particular slave

						

// wait for any previous transmission to finish

// TI = 1, means ready to load new character in

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

106
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
SBUF for Tx 	 	 	 	

Appendix B

TB8 = 1;		

TI = 0;				 SBUF = SlaveNum;	 while(!TI){}		

// set bit 8, for address transmission

// send slave address

// clr TI since we are going to transmit again

// wait for address to be transmitted

/* This might cause problems, since program might wait here indefinitely if */ /* there is any problem in the network - needs timeout capability */ 	 TB8 = outptr = 0; 	 // address sent, now set for data transmission

	 for(x=0;x<100;x++){} 	 // short delay to give time to affected slaves to switch 						 	 while (s[outptr]!='\0') 	  { 	 	 TI = 0; 		

// over from address to data reception mode

	  while(!TI){}		 				 } inptr = 0;

SBUF = s[outptr++];

// clr TI since we are going to transmit again // wait for byte to be transmitted // may be unnecessary

	  for(x=0;x<100;x++){} 	 // short delay depending on receiving device 	 	

	  {

do			

// Received string expected to end with '~' character // wait for character to be received from slave // RI = 1, means data received // clear RI to wait for next character // read data character sent from slave

	  while(!RI){}	 	 				 	 	 	 	

	  RI = 0;			 r[inptr++] = c; 	 while (c != '~'); 	 }

c = SBUF;			

// and store it

    r[--inptr] = '\0'; 	  				 }

/* loop again until end of data marker '~' */ // overwrite received '~' with '\0'	 // In C a string finishes with a '\0'

void Send2All(char s[]) /* Send a message to ALL slaves - no response expected back */     { 	 	 unsigned int data outptr; unsigned char data x; while(!TI){}		 TB8 = 1;		 // wait for any previous transmission to finish // set bit 8, for address transmission

				 	

// TI = 1, means ready to load new character in SBUF

    TI = 0; // clear TI flag since we are goling to transmit again 	 	 SBUF = 255;		 while(!TI){}		

// send General broadcast slave address (255) // wait for address to be transmitted

/* This might cause problems, since program might wait here indefinitely if */ /* there is any problem in the network - needs timeout capability */ 	 	 	 	 TB8 = outptr = 0; 		 for(x=0;x<200;x++){} 		 while (s[outptr]!='\0') TI = 0; // address sent, now set for data transmission

					 	  {

// short delay to give time for slaves to check address // and switch over from address to data reception mode

107
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 SBUF = s[outptr++];

Appendix B

	    while(!TI){}		 // wait for byte to be transmitted  	 	  	  /* just a delay for receiving device, 	 } { 	 	 	 } for(x=0;x<100;x++){}

since we are not using any handshaking */	

void main(void) unsigned int Msg[256],i; 	 // 256 slaves maximum

unsigned char data SlaveNum;

// 350 characters per message maximum // Initialise all arrays 	  	 	 	 	 for (i=0;i<256;i++) for (i=0;i<350;i++) { Outgoing[i] = 0; } Msg[i] = 1;			

unsigned char Outgoing[350], Incoming[350];

// All start wih message 1

Incoming[i] = 0; // initialise 2SC6911 (P2 socket) for screen and keyboard

Set_P2_BaudRate(38400); 	

// Init_P3UART(0xDA,57600);// initialise UART(P3 socket) for multi-processor comms /* Setup serial port control register SCON = 0xDA, not under interrupt control */ /* Mode 3: 9-bit uart, 57600 baud rate */ /* SM0=1, SM1=1, SM2 = 0, REN = 1 */ /* TB8 = 1, RB8 = 0, TI = 1, RI = 0 */ Init_P3UART(0x9A,345600);// initialise UART(P3 socket) for multi-processor comms /* Mode 2: 9-bit uart, FIXED 345600 baud rate */ /* SM0=1, SM1=0, SM2 = 0, REN = 1 */ /* TB8 = 1, RB8 = 0, TI = 1, RI = 0 */     Init_8255(0x91); // initialise 8255 input/output port intdisplay = 0; Init_TIMER2(50); /* timer 2 interrupt running every 50 milliseconds */     printf("\n\rThis is the MASTER controller\n\r"); EA=1; /* enable global interrupts */ /* Setup serial port control register SCON = 0x9A, not under interrupt control */

    printf("\n\rMake sure you use the _getkey (wait for key) function in SerP2Pkg\n\r");     printf("\n\rLEDs flashing under Timer 2 interrupt.\n\r"); 	 	 	 	 	 	 	 	 while (1) { 	 /* loop forever */

printf("\rValid Slave numbers are:\n\r"); printf(" 	 printf(" 	 255 	

0 - 254 for Individual commands\n\r"); for General Broadcast\n\r");

scanf("%bu",&SlaveNum);

printf("Enter Slave no: ");

getchar();// eliminate carriage return used for entering slave number if (SlaveNum != 255)		 { // talking to just one slave

108
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	  	 	 printf("\n\rEnter message %u for slave number %bu :\n\r", gets (Outgoing, sizeof (Outgoing)); strcat (Outgoing, "~"); Msg[SlaveNum]++,SlaveNum);

Appendix B

	 printf("\n\r 	 Sending the following data\n\r(%s)\n\r 	 r",Outgoing,SlaveNum); 	 // new data read from slave saved in Incoming } XchgInfo(SlaveNum,Outgoing,Incoming);

to slave number: %bu\n\

	

		 		

printf("\n\rSlave number %bu replied :\n\r %s\n\n\n\r",SlaveNum,Incoming); else if (SlaveNum == 255)		 // General Broadcast Message

		   {

		   printf("\n\rEnter General Broadcast Message %u for All slaves:\n\r",Msg[SlaveNum]++);  		 	 	 gets (Outgoing, sizeof (Outgoing)); strcat (Outgoing, "~");	 /* attach end of data marker */

		   printf("\n\rSending data to ALL slaves\n\r"); 		   printf(" (%s)\n\n\r",Outgoing); 		 		 } } Send2All(Outgoing); 		 }

// send data to all slaves

/* Multi-Processor Slave Test program - NO RTOS */ /* Slave.c */ /* Use in conjunction with Master.c */

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

109
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* Please include the following with Source Group */

Appendix B

/*				STARTUP.A51				*/ /*				SerP2Pkg.c				*/ /*				Flt32Pkg.c 				*/ // Timer 2 interrupt toggles the upper 4 bits every 25 msecs. // Internal Serial port interrupt handles communications // 	 // 	 to master microcontroller (socket P3 – up to 345600 baud). screen via socket P2, 38400 baud.

// Main program prints messages sent/received on the terminal #include <reg52.h> #include <stdio.h>

#include <absacc.h> #include <string.h> #define EOT '~'				 #define EOS '\0'			 // External Functions in SerP2Pkg.c void P2_SetUp(void); void Auto_P2_BaudRate(void); char putchar (char c); char _getkey (void); // END OF MESSAGE CHARACTER // END OF STRING CHARACTER

void Set_P2_BaudRate(unsigned int baud);

// External Functions if using Flt32Pkg.c void Init_8255(unsigned char c); void WritePort(unsigned char c, unsigned char d) large reentrant; unsigned char ReadPort(unsigned char c) large reentrant; // // Functions in this module

void Init_TIMER2 (unsigned char msecs);

void Init_P3UART_int (unsigned char mode, unsigned long baudrate); void Byte2Bin (unsigned char CH, char s[]); // Variables bit MasterCalled, Its4Me, Its4All; unsigned char data i; unsigned int data inptr,outptr;

unsigned char data intdisplay, ItIsMe, Broadcast; unsigned char RxString[250], TxString[250]; void Init_P3UART_int (unsigned char mode, unsigned long baudrate) // Set up internal UART (P3) under interrupt control { SCON = mode; 		 PCON &= 0x7F; 		 case 1200:

/* Setup serial port control register */ /* Clear SMOD bit in power ctrl reg */

switch (baudrate) { 	 // set up timer 1 initial count according to baud rate required 	 TH1 = TL1 = 0xE8;

	break; 	 case 2400:

	break;

TH1 = TL1 = 0xF4;

110
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
case 4800:

Appendix B

	

	break; 	 case 9600:

TH1 = TL1 = 0xFA;

	break; 	 	

TH1 = TL1 = 0xFD;

case 19200:

TH1 = TL1 = 0xFD; PCON |= 0x80; 		

	break; 	 	

/* double baudrate, SMOD = 1 */

case 57600:

TH1 = TL1 = 0xFF; 	 PCON |= 0x80; 		

/* Not quite standard */

	break; 	 	

/* double baudrate, SMOD = 1 */ /* not strictly speaking standard */ /* crystal/64, SMOD = 0 */ /* crystal/32, SMOD = 1 */ /* not strictly speaking standard */

case 172800: 		 case 345600: 		 break; 			 PCON |= 0x80; 		

	break; }

if (baudrate <= 56700)   { ET1 = 0;

    TMOD &= 0x0F; 		     TMOD |= 0x20; 		 RCLK = 0; 			 TCLK = 0; 			 TR1 = 1; 			     TI = 0; 			 } ES = 1; 			 				

/* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */ /* Set M1 for 8-bit autoreload timer 1 */

/* USE TIMER 1 FOR RECEIVE BAUD RATE (8032 only) */ /* Start timer 1 (baud rate) */ /* Enable Serial Interrupt */

/* USE TIMER 1 FOR TRANSMIT BAUD RATE (8032 only) */ /* Clear TI to indicate not ready to xmit yet */

} {

void Init_TIMER2 (unsigned char msecs) 	 unsigned char data THIGH,TLOW; unsigned int data clock; clock = msecs*922;

// Timer 2 initialisation

// 922 = 11059/12 = counts required for 1 msec TF2 interrupt delays; THIGH = (65536-clock)/256; TLOW = (65536-clock)%256;     RCAP2L = TLOW; TL2 = RCAP2L; ET2 = 1; RCAP2H = THIGH; TH2 = RCAP2H; 		 // set up timer 2 (for Flight 32) // timer 2 16-bit auto-reload mode // START TIMER 2

    T2CON = 0x0; 		 TR2 = 1; 			

}

111
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix B

void P3uart_isr (void) interrupt 4 using 1 	 /* Runs as a Serial Interrupt Routine */ /* sends TxString and receives RxString */ { unsigned char data c; unsigned int x; // interrupt may be caused either from a TI or an RI flag

// RECEIVER SECTION if(RI)					 // if a character is received     {     RI = 0;				 // reset flag c = SBUF;				 // get character if (RB8==1 && c==ItIsMe) 		 // if received correct address, 	 { 	 SM2 = 0;					 // prepare to read data 	 RB8 = 0; 	 Its4All = 0; 	 Its4Me = 1; 	 inptr = 0; } else if (RB8==1 && c==Broadcast) // if received general broadcast address,     { 	 SM2 = 0;		 // prepare to read data RB8 = 0; Its4All = 1; 	 Its4Me = 0; 	 inptr = 0; }

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

112
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
else if ((SM2==0) && (c != '~')) 	 else if ((SM2==0) && (c == '~')) MasterCalled = 1; // store any received data

Appendix B

    RxString[inptr++] = c;     {

    RxString[inptr] = '\0'; 		 	 } SM2 = 1; 			

// end received string with NULL character

// reset serial port for address reception mode

}

// TRANSMITTER SECTION     { 	

  if(TI && (TxString[outptr] != '\0')) // just sends a message from TxString TI = 0;				 for (x=1;x<500;x++){}; // clr TI in order to transmit

  /* just a delay for receiving no handshaking */     SBUF = TxString[outptr++]; }

  else if(TI && (TxString[outptr] == '\0')) // No more data to send } { TI = outptr = 0;

void T2ISR (void) interrupt 5 using 2 	 TF2 = 0; 	 	 	

// Timer 2 interrupt service routine

if (i++ == 5) 					 { i = 1;

// every 5 interrupts

    WritePort('B',intdisplay); /* output to leds */ 	} } { 	 	 	

intdisplay = intdisplay ^ 0xF0; // toggle upper 4 bits (XOR)

void Byte2Bin (unsigned char CH, char s[]) unsigned char data i, c=CH; for (i=1;i<=8;i++) s[i-1] = (c & Mask ? '1' : '0'); c <<= 1;

unsigned char data Mask = 1<<7;

 	  { 	 	 } { 	 	 	 	 	 }

void main(void) unsigned int data MsgNo = 1; // start with first message unsigned char data SwitchSettings, s[8]; unsigned char SwitchString[80]; Init_8255(0x91); 		 Set_P2_BaudRate(38400); 	

// Initilaise 8255 PIO

// initialise external UART (P2) for keyboard/screen

113
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
//Init_P3UART_int(0xF0,57600);

Appendix B

// initialise internal UART (P3 socket) for multi-processor comms (interrupt) /* Setup serial port control register SCON = 0xF0 */ /* Mode 3: 9-bit uart var. baud rate */ /* SM0 = SM1 = SM2 = REN = 1 */ /* TB8 = RB8 = TI = RI = 0 */ /* under interrupt control */ Init_P3UART_int(0xB0,345600);		

// initialise internal UART (P3 socket) for multi-processor comms (interrupt) /* Setup serial port control register SCON = 0xB0 */ /* Mode 2: 9-bit uart FIXED baud rate */ /* SM0 = 1, SM1 = 0, SM2 = REN = 1 */ /* TB8 = RB8 = TI = RI = 0 */ 	 	 	 	 	 	 intdisplay = 0; 	 Init_TIMER2(50);	 /* under interrupt control */	 // clear display /* timer 2 interrupt running every 50 milliseconds */ /* enable global interrupts */ /* General Broadcast address - all slaves receive this */

EA=1; 				 Broadcast = 255; 	        

printf("\n\rHello, please enter a Unique number for this Slave (0-254) : "); scanf("%bu",&ItIsMe);

	 printf("\n\rEntering main loop (leds flashing under interrupt Timer 2),\n\rwhich will be interrupted\n\n\r"); 	 	 	 	 	 	 	 printf("EITHER\n\r");             printf(" (i) by a message dedicated only to this slave number: %bu\n\r",ItIsMe); printf("(ii) by a Global Broadcast Message.\n\n\n\r"); while (1) { 		 { inptr = outptr = 0;	 // variables used to scan TxString and RxString printf("OR\n\r");

/* loop forever */

 	 	 	 	 	 	 	 	

	 	 	 	 	 	 	 	 	

if(MasterCalled && Its4Me) // message is just for me MasterCalled = Its4Me = 0;

/* Start Timer 2 interrupts */ ET2 = 1; TR2 = 1;

/* They may have been switch off by a Global Message */

	 	 	 	 	 	

/* Get lower four-bit switch settings */ SwitchSettings = ReadPort('A') & 0x0F; Byte2Bin(SwitchSettings,s); sprintf(TxString,  

		 	 ItIsMe,ItIsMe,MsgNo);

"Hello, this is Slave no: %bu, acknowledging your message no: %bu.%u\n\r",

		 sprintf(SwitchString," Lower 4-bit switch settings are: %#bx HEXADECIMAL or %s BINARY.\n\n\n\r", 		 		 		 			 strcat(TxString,SwitchString); strcat(TxString,"~"); SwitchSettings, s);

// Message must end with the '~' character

114
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	  

Appendix B

		 r",TxString); 		 	  	 }

printf("Received from Master, message no: %u.\n\r%s\n\r",MsgNo++,RxString); printf("Now sending to Master this acknowledgement:\n\r (%s)\n\n\n\ TI = 1; // send TxString message (via interrupt routine, UART P3)

		 		

else if(MasterCalled && Its4All) { MasterCalled = Its4All = 0;

	   printf("Received from Master, Global Broadcast message no: %u.\n\r%s\n\ r",MsgNo++,RxString); 		 		  ET2=0; 		 		 		 		 	 } } /* Multi-Processor Slave Test program */ /* SlaveRtosDemo4.c */ /* Compatible with PaulOS RTOS */ /* 7 TASKS */ 	 }     printf(" Switching off LED flashing routine.\n\r");

		    TR2=0;

printf("  This message is not acknowledged back to the Master\n\r"); printf("  and the data would therefore be corrupted.\n\n\n\r");

WritePort('B',0);

printf("  since all the slaves would be doing it at the same time\n\r");

115
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* Disable PERIODIC and enable HALFMSEC in TaskStkV5B.A51 */ /* Use in conjunction with MasterRtosDemo4.c */ /* Please include the following with Source Group */ /*				STARTUP.A51				*/ /*				PaulOS.A51				*/ /*				SerP2Pkg.c				*/ /*				Flt32Pkg.c	 			*/ // One task toggles the lower 4 bits every 25 msecs.

Appendix B

// Other tasks control the motor speed which is set by the master controller // Serial port interrupt handles coms to master microcontroller #include <reg52.h> #include <stdio.h> // Main program prints messages sent/received on the terminal screen #include <absacc.h> #include <string.h>

#include "..\Headers\PaulosV5B.h" 		 // EOM '~'			 // EOS '\0'			 void P2_SetUp(void);

/* PaulOS RTOS system calls definitions */

// END OF MESSAGE // END OF STRING

// External Functions in SerP2Pkg.c void Auto_P2_BaudRate(void); char putchar (char c); char _getkey (void);

void Set_P2_BaudRate(unsigned int baud);

// External Functions if using Flt32Pkg.c void Init_8255(unsigned char c); void WritePort(unsigned char c, unsigned char d) large reentrant; unsigned char ReadPort(unsigned char c) large reentrant; // // Functions in this module

void init_TIMER2 (unsigned char msecs); // Variables

void init_P3UART_int (unsigned char mode, unsigned int baudrate); bit MasterCalled, Its4Me, Its4All, MotorOK; unsigned int data inptr, outptr; unsigned char data ItIsMe, setting, speed, Broadcast; unsigned int data MsgNo; // start with first message unsigned char bdata display; sbit MOTOR = display^7;

unsigned char RxString[250], TxString[250], TempString[50];

void Byte2Binary (unsigned char x, char b[]) {

// Convert a byte to its binary value as an ASCII string of 1's and 0's stored in b[] unsigned char i;

unsigned char Mask = 1 << 7; for (i=0; i <= 7; i++) 	 	     {

    b[i] = (x & Mask ? '1' : '0');

116
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 } x <<= 1; b[8] = '\0';

Appendix B

	}

void init_P3UART_int (unsigned char mode, unsigned int baudrate) // Set up internal UART (P3) under interrupt control { SCON = mode; 		 /* Setup serial port control register */ PCON &= 0x7F; 		 /* Clear SMOD bit in power ctrl reg - No double baud rate yet */ TMOD &= 0x0F; 		 /* Setup timer/counter mode register */ 			 /* Clear M1 and M0 for timer 1 */ TMOD |= 0x20; 		 /* Set M1 for 8-bit autoreload timer 1 */ RCLK = 0; 		 /* USE TIMER 1 FOR RECEIVE BAUD RATE (8032 only) */ TCLK = 0; 		 /* USE TIMER 1 FOR TRANSMIT BAUD RATE (8032 only) */ 			 /* TH1 = 256 - (28800/BR) */ switch (baudrate) { 	 // set up timer 1 initial count according to baud rate required    case 300: 	 TH1 = TL1 = 0xA0; 	break;    case 600: 	 TH1 = TL1 = 0xD0; 	break;    case 1200: 	 TH1 = TL1 = 0xE8; 	break;    	 case 2400: TH1 = TL1 = 0xF4;

	break;    	

case 4800:

	break;    	

TH1 = TL1 = 0xFA;

case 9600:

	break;    	 	

TH1 = TL1 = 0xFD;

case 19200:

TH1 = TL1 = 0xFD; PCON |= 0x80; 		

	break;    	 	

/* double baudrate (SMOD = 1) */

case 57600:

TH1 = TL1 = 0xFF; PCON |= 0x80; 		

	break;    }

/* double baudrate (SMOD = 1) */

ET1 = 0; 		 TR1 = 1; 		 TI = 0; 		 } 			

/* Disable timer 1 interrupts just in case */ /* Start timer 1 (baud rate) */ /* Clear TI to indicate not ready to xmit */ /* Serial Interrupt enabled by the RTOS */

// TASK 0

/* Sends TxString to Master and receives RxString from Master */ void P3uart_isr(void) {

117
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
unsigned char data c,x; while (1) {

Appendix B

WAITI(4); 	

// interrupt may be caused either from a TI or an RI flag // RECEIVER SECTION     { if(RI)					     RI = 0;				    c = SBUF;				 	 {    if (RB8==1 && c==ItIsMe) 		 	 SM2 = 0;		 Its4All = 0; Its4Me = 1; inptr = 0; // if a character is received // reset flag

// wait for a serial interrupt

// get character

// if received correct address,

   RB8 = 0; 	 	 	   }     { 	

// prepare to read data

else if (RB8==1 && c==Broadcast) // if received general broadcast address, SM2 = 0;			 // prepare to read data

   RB8 = 0; 	 	

   Its4All = 1;

Its4Me = 0; inptr = 0;

  }

118
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
else if ((SM2==0) && (c != '~')) // store any received data     RxString[inptr++] = c; else if ((SM2==0) && (c == '~')) // end of received message with ~ character     {     RxString[inptr] = '\0'; // add to end of received message a NULL character 	 SM2 = 1; // reset for address reception mode     MasterCalled = 1; // Set flag to indicate message received    if (Its4Me==1 && MasterCalled==1) 	 SIGNAL(2); // Activate Task 2 - Private Message Reception    else if (Its4All==1 && MasterCalled==1) 	 SIGNAL(3); // Activate Task 3 - Global Message Reception 	} } // TRANSMITTER SECTION   if(TI && (TxString[outptr] != '\0')) 	       {    TI = 0;				 // clr       SBUF = TxString[outptr++]; 		       for (x=0;x<10;x++){} 			    } // just sends a message from TxString

Appendix B

TI in order to transmit // TI will be set to 1, once transmission is ready // just a delay for receiving equipment

  else if(TI && (TxString[outptr] == '\0')) // No more data to send    TI = outptr = 0; } } // TASK 1 void Blinker (void) 	 // Blinks Leds { while(1)       {       display ^= 0x0F;       WritePort('B',display); /* output to leds toggle lower 4 bits (XOR)*/       WAITT(500); 	} } /*****************************************************************************/ // TASK 2 // Private Message Data Reception and Acknowledgement /*****************************************************************************/ void PrivateDataRx (void) { while (1) 	 { 	 WAITS(0);			 // Wait for signal indefinitely 	   MasterCalled = 0; 	 printf("Rx Msg: %u <== %s\n\r",MsgNo++,RxString); 	 if (strncmp ("Speed", RxString, 5)==0) 	 		 { 		 sscanf(RxString,"%*s %bu",&setting); // read received message: 'Speed n' 					 // ignoring 'Speed' and making setting = n 			 sprintf(TxString, "OK. Speed set to %bu", setting); 			MotorOK = 1; 			}

119
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 else if (strncmp ("What Speed?", RxString, 11)==0) else if (strncmp ("LineChk", RxString, 7)==0)

Appendix B

			 			 0123456789"); 	 	 		 	 		

sprintf(TxString, "Current Speed setting %bu", setting); sprintf(TxString, "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG

else if (strncmp ("Stop", RxString, 4)==0) { sprintf(TxString,"OK. Motor stopped");

			MotorOK = 0; 			} 	 		 {

	 else if (strncmp ("Switches", RxString, 8)==0) 			 			 	else 	 	 	 sprintf(TxString, "Switches reading: "); strcat(TxString,TempString);

			Byte2Binary(ReadPort('A'),TempString); 			} 			 	DEFER();

strcat(TxString,"~");

sprintf(TxString, "Command NOT listed. No action taken.");

printf("Tx Msg: ==> %s \n\n\r",TxString);

		 		 }

TI = 1; // if master called, THEN send TxString message // activated with TI=1)

// (via task 0, which is waiting for a serial interrupt routine,

   }

/*****************************************************************************/ // TASK 3 // Global Message Reception void GlobalRx (void) { 	 	 	 	 	 	 	 while (1) { WAITS(0);			 // Wait for signal indefinitely

/*****************************************************************************/

	   MasterCalled = 0;

printf("Rx Global Broadcast Msg: %u.\n\r ( %s )\n\r",MsgNo++,RxString);

    printf("   This message is not acknowledged back to the Master\n\r");     printf("   and the data would therefore be corrupted\n\n\n\r"); if (strncmp ("Start", RxString, 5)==0) {

    printf("   since all the slaves would be replying it at the same time\n\r");

	 		

	   setting = 3; 			 	

			MotorOK = 1; 			} 		 {

printf("Starting motor at a speed setting of 3\n\n\n\r");

    else if (strncmp ("Resume", RxString, 6)==0) printf("Restarting motor at a speed setting of %bu\n\n\n\r",setting);

			

120
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	   MotorOK = 1; 			} 	     else if (strncmp ("Emergency", RxString, 9)==0) 		 { 			 printf("EMERGENCY - Stopping motor\n\n\n\r"); 	   MotorOK = 0; 			} 	 else if (strncmp ("Stop", RxString, 4)==0) 		 { 			 printf("STOP - Stopping motor\n\n\n\r"); 	   MotorOK = 0; 			} 	  } } /******************************************************************************/ /* 	 Task 4 'Main PWM': 	 */ /******************************************************************************/ void MainPWM(void){ 		 /* PWM task 	 */ 	 while(1){ // setting ranges from 1 to 10, value received from master controller // PWM period is going to be 101, hence maximum ON time is being limited to 100 	 speed = 10*setting; 		 SIGNAL(5); 		 /* send signal to task 5 - Motor ON */ 		 WAITT(101); 		 /* wait for timeout (main pwm period) */ 		} } /******************************************************************************/ /* 	 Task 5 'MOTOR ON': 	 */ /******************************************************************************/ void MotorON (void){ 		 /* switch on motor task */ 	 while(1){ 		 WAITS(0); 	 /* wait for signal indefinitely */

Appendix B

	 if (MotorOK) 			 { 			MOTOR = 1; 			 WritePort('B',display); 		 /* switch on motor */ 		 WAITT(speed); 		 /* wait for specified timeout */ 		  } 	 SIGNAL(6);				 /* send signal to task 6 - Motor OFF */ 		} } /******************************************************************************/ /* 	 Task 6 'MOTOR OFF': 	 */ /******************************************************************************/ void MotorOFF (void){ 		 /* switch off MOTOR task */ 	 while(1){ 		 WAITS(0); 	 /* wait for signal indefinitely */ 		 MOTOR = 0; 	 WritePort('B',display); 	 /* switch off motor */ 		} } /*****************************************************************************/ void main(void) {

121
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
unsigned int brate,i;

Appendix B

	 Init_8255(0x91); 		 // Initilaise 8255 PIO       Set_P2_BaudRate(38400); 		 // initialise external UART (P2) for keyboard/screen 	 display = 0; 			 // clear leds    setting = 5;     Broadcast = 255; 		 // Address used to send message to ALL slaves    MsgNo = 1;    MasterCalled = 0; 	 for (i=0;i<250;i++) 	 { 	 TxString[i] = 0; 	       RxString[i] = 0; 	   } 	 for (i=0;i<50;i++) 	 TempString[i] = 0; 	 printf("\n\n\rWelcome to the Master-SLAVE PaulOS RTOS Demo Program 4\n\r"); 	 printf("Input the LINK baud rate required: "); 	 scanf ("%u",&brate); 	 printf("\n\r   8051 Microcontroller link running at %u baud\n\n\n\r",brate); 	 printf("    Written by Paul P. Debono - November 2003.\n\n\n\r"); 	 init_P3UART_int(0xF0,brate); 		 // initialise UART(P3 socket) for multi-processor comms  			 /* Setup serial port control register SCON = 0xF0 */ 			 /* Mode 3: 9-bit uart var. at specified baud rate */ 				 /* SM2, REN set to 1, TB8 = RB8 = 0 */ 	 INIT_RTOS(0x10); /* initialise RTOS,variables, stack with T2 + Serial int. */ 		 /* this must be the first RTOS command to be executed */     CREATE(0,P3uart_isr); 	 /* Tx - Rx UART task */    CREATE(1,Blinker); 		 /* Flash LEDs task */     CREATE(2,PrivateDataRx); 	 /* Decode received private message task */     CREATE(3,GlobalRx); 	 /* Decode received global message task */     CREATE(4,MainPWM); 		 /* MAIN PWM TASK 		 */    CREATE(5,MotorON); 		 /* MOTOR ON task 		 */    CREATE(6,MotorOFF); 	 /* MOTOR OFF task 		 */ 	 printf("\n\r   Please enter a Unique number for this slave (0-254) : "); 	 scanf("%bu",&ItIsMe); 	 printf("\n\r       Leds flashing independently under Task 1\n\n\r");     printf("\n\rEntering main loop, which will be interrupted\n\r"); 	 printf("(apart from the RTOS tick time interrupt),\n\n\r");     printf("EITHER\n\r");     printf(" (i) by a message dedicated only to this slave number: %bu\ (Tasks 0 and 2)\n\n\ r",ItIsMe); 	 printf("OR\n\r");     printf(" (ii) by a Global Broadcast Message (Tasks 0 and 3)\n\n\n\r"); 	 inptr = outptr = 0;	 // variables used to scan TxString and RxString ;	 RTOSGOMSEC(1,1);	 // Start RTOS ticking at 1 msec, with priorities enabled 	 RTOSGOMSEC(1,0);// Start RTOS ticking at 1 msec, with priorities disabled   while (1) 	 { 	 SET_IDLE_MODE(); 		 /* loop forever here, going to idle every time */ 				    /* Awake only for any interrupt */ 	} }

122
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix C

Appendix C	 SanctOS.C
This is the source listing for the SanctOS (Small ANd CompacT Operating System) round-robin operating system written in C. It is practically the C-version of ParrOS.A51 found in Appendix A. It consists of •	 The header file Parameters.h •	 The assembly language include file SanctOS_A01.a51 •	 The header file SanctOS_V01.h •	 The main RTOS program SanctOS.c Parameters.h
/* *************************************************************************** * *			 PARAMETERS.H  ---   RTOS KERNEL HEADER FILE

* For use with SanctOS_V01.C –

* Round-robin RTOS written in C by Ing. Paul P. Debono * for use with the 8051 family of microcontrollers * * File 		 * Date 		 * By	 * : Parameters_V01.H : 8 : February 2006

* Revision 	 	

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

*************************************************************************** */ /*

*************************************************************************** * 						RTOS USER DEFINITIONS */ *************************************************************************** #define STACKSIZE 	 #define CPU		 #define TICK_TIMER 	 #define TICKTIME	 0x10 	 // Max stack size for task - no need to change   2 	     8032 	 // Set to 0, 1 or 2 to select which timer to // use as the RTOS tick timer // Length of RTOS basic tick in msec // set to 8051 or 8032

				

#define NOOFTASKS	 /*

50 		 6		

				// program

// Number of tasks used in the application

*************************************************************************** *************************************************************************** *************************************************************************** */

123
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix C

SanctOS_A01.A51
; SanctOS_A01.A51 ; ; ; SanctOS RTOS PLUS MAIN PROGRAM ; STORES ALL TASK REGISTERS ; Written by Paul P. Debono - JUNE 2006 ; University of Malta ; Department of Communications and Computer Engineering ; MSIDA MSD 06; MALTA. ; ; Accomodates up to 255 tasks ; STACK MOVING VERSION - MOVES WORKING STACK IN AND OUT OF ; EXTERNAL MEMORY ; SLOWS DOWN RTOS, BUT DOES NOT RESTRICT TASK CALLS ;

; IDLE TASK (ENDLESS MAIN PROGRAM - TASK NUMBER = NOOFTASKS) ; THIS IS STILL A SMALL TEST VERSION RTOS. IT IS JUST USED FOR ; SHOWING WHAT IS NEEDED TO MAKE A SIMPLE RTOS. ; IT MIGHT STILL NEED SOME MORE FINE TUNING. ; IT HAS NOT BEEN NOT THOROUGHLY TESTED !!!! ; WORKS FINE SO FAR. $NOMOD51 ; NO RESPONSABILITY IS TAKEN. #include "reg52.h"

#include "Parameters.h"

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

124
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* The MAINSTACK variable points to the start pointer in hardware stack */ /* and is defined in STARTUP.A51 */ extrn idata (MAINSTACK) PUBLIC POP5I PUBLIC _SaveBank0, _RecallBank0 ; RTOS ASSEMBLY CODE MACROS SANCTOS_ASM SEGMENT CODE RSEG SANCTOS_ASM POP5I:                                                                               DEC SP 	 DEC SP POP PSW POP DPL POP DPH POP B POP ACC RETI 	

Appendix C

; BLANK TO POP UNUSED RETURN ADDRESS

SETB EA 	

; re-enable interrupts

; JUMPS TO PREVIOUSLY PRE-EMPTIED TASK HERE ; Address high byte in R6, low byte in R7 bank 1

_SaveBank0:		 MOV DPH,0EH MOV DPL,0FH MOV A,0 MOVX @DPTR,A INC DPTR MOV A,1

MOVX @DPTR,A INC DPTR MOV A,2 MOVX @DPTR,A INC DPTR MOV A,3 MOVX @DPTR,A INC DPTR MOV A,4

MOVX @DPTR,A INC DPTR MOV A,5

MOVX @DPTR,A INC DPTR MOV A,6

MOVX @DPTR,A INC DPTR MOV A,7 RET

MOVX @DPTR,A

_RecallBank0: 	; Address high byte in R6, low byte in R7 bank 1 MOV DPH,0EH MOV DPL,0FH MOV 0,A

MOVX A,@DPTR INC DPTR

MOVX A,@DPTR

125
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
                                        MOV 1,A

Appendix C

INC DPTR MOV 2,A

MOVX A,@DPTR INC DPTR MOV 3,A

MOVX A,@DPTR INC DPTR MOV 4,A

MOVX A,@DPTR INC DPTR MOV 5,A

MOVX A,@DPTR INC DPTR MOV 6,A

MOVX A,@DPTR INC DPTR MOV 7,A RET

MOVX A,@DPTR

END

SanctOS_V01.H
/* **************************************************************** *			 * RTOS KERNEL HEADER FILE

* For use with SanctOS_V01.C * 		 *	 *

* 	   Co-Operative RTOS written in C Use with the 8051 family of microcontrollers : SanctOS_V01.H : 1 : February 2006 by Ing. Paul P. Debono

* File 		 * Date 		 * By	 *

* Revision 	 	

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

*********************************************************** */ /* #include "Parameters.H" *********************************************************** * 				 */ *********************************************************** typedef unsigned char uchar; typedef unsigned int uint; typedef unsigned long ulong; DATA TYPE DEFINITIONS

126
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/*

Appendix C

*********************************************************** * 			 */ 	 	 	 	 *********************************************************** struct task_param { 		 /* 6 bytes + 8 registers + stack */ STRUCTURE AND UNION DEFINITIONS

uchar status1; 	

uint slot_time; 	 uchar stackptr; 	

/* status flags, see details below */ /* slot time reload value */

uint slot_reload; 	

/* slot time allocated for this task */ /* stack pointer SP storage location */ /* registers storage area, */ /* ready for context switching */

				 	 	 	 	 	 	 	 	 	 uchar reg0; uchar reg1; uchar reg2; uchar reg3; uchar reg4; uchar reg5; uchar reg6; uchar reg7;

 				

		}; /*

char stack[STACKSIZE]; 	

/* stack storage area */

*************************************************************************** * 				 */ /* */ *************************************************************************** DATA TYPE DEFINITIONS

*************************************************************************** /* The MAINSTACK pointer variable points to the stack pointer in hardware /* stack and should be defined in STARTUP.A51 */ extern data unsigned char Running; extern idata unsigned char MAINSTACK[STACKSIZE]; /* Functions written in assembly language, found in SanctOS_A01.A51 */ extern void SaveBank0(uchar xdata * Pointer); extern void POP5I(void); /* extern void RecallBank0(uchar xdata * Pointer);

*************************************************************************** * 					FUNCTION PROTOTYPES * * ***************************************************************************

* The following RTOS system calls do not receive any parameters : */

* ---------------------------------------------------------------void OS_RTOS_GO (void);	 // Starts the RTOS running with

127
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* The following commands are simply defined as MACROS below 	 	 	 	 OS_CPU_IDLE() 		

A51 Examples

					(awake every interrupt) 					hardware reset OS_PAUSE_RTOS()	 OS_RESUME_RTOS()	 Disable RTOS Re-enable RTOS OS_CPU_DOWN()	 	

Set the microprocessor into a sleep mode Switch off microprocessor, activate only by

*/ /*

* The following RTOS system calls do receive parameters : * ------------------------------------------------------*/ void OS_INIT_RTOS (uchar iemask);	 					 // Initialises all RTOS variables // Creates a task

void OS_CREATE_TASK (uchar tasknum, uint taskadd, uint slot); /* */ /*

***************************************************************************

*************************************************************************** * 				 */ *************************************************************************** #define MSEC10 9216UL	 // In theory 921.6 counts represent 			 #define TICKS_PER_SEC	 (1000 / TICKTIME) // Ensure that TICKTIME's value is // chosen such that this // quotient and hence all the // following quotients result // value of TICKTIME // to CLOCK = 65535 #define CLOCK	 // in an integer. In theory, maximum // is given by the value corresponding #define TICKS_PER_MIN	 (60000 / TICKTIME) #define BASIC_TICK 	 RTOS TIMING DEFINITIONS

// 1 ms assuming an 11.0592 MHz crystal.

((TICKTIME * MSEC10)/10UL)

// i.e. approx. 70-72 - However // respecting the condition // above, max. acceptable // suitable values are:

(65535 - CLOCK + 1) 	 

// TICKTIME = 50 msecs. Hence all // 1, 2, 4, 5, 8, 10, 20, 25, 40, 50 #define IDLE_TASK NOOFTASKS // Main endless loop in application given a task // number equal to NOOFTASKS

128
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* OTHER #defines */ #define MINUS_ONE 	 #define ZERO 		 #define TEN 		 0xFF 0 0x0A /* slot time in ticks */

A51 Examples

#define HiByte(intval) (##intval)/256; #define LoByte(intval) (##intval)%256; /* */ /* ***************************************************************************

*************************************************************************** * 				RTOS MACROS */ *************************************************************************** #define OS_CPU_IDLE()		 #define OS_CPU_DOWN()		 #if (TICK_TIMER == 0)                         PCON |= 0x01 // Sets the microprocessor in PCON |= 0x02 // Sets the microprocessor in

					// idle mode

					// power-down mode #define OS_PAUSE_RTOS() EA = ET0 = TR0 = 0

#define OS_RESUME_RTOS() TR0 = ET0 = EA = 1 #define OS_PAUSE_RTOS() EA = ET1 = TR1 = 0

#elif (TICK_TIMER == 1)

#define OS_RESUME_RTOS() TR1 = ET1 = EA = 1 #define OS_PAUSE_RTOS() EA = ET2 = TR2 = 0

#elif (TICK_TIMER == 2)

#define OS_RESUME_RTOS() TR2 = ET2 = EA = 1

#endif /* */ /* ***************************************************************************

*************************************************************************** *					COMPILE-TIME ERROR TRAPPING */ 	 *************************************************************************** #if (CPU != 8032) && (CPU != 8051) #endif 	 #error Invalid CPU Setting

#if (NOOFTASKS > 255) #endif 	

#error Number of tasks is too big. MAX 255 (from 0 to 254) tasks

#if ((TICKTIME * 110592 / 120) > 65535)

#error Tick time value exceeds valid range for timer counter setting

129
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#endif #if ((TICKTIME * 110592 / 120) < 65535) && ((1000 % TICKTIME) != 0) #endif #error Undesirable TICKTIME setting (1, 2, 4, 8, 10, 20, 25, 40, 50 ms) #if (CLOCK > 65535) #endif /* */ /*

A51 Examples

#error Timer counter setting exceeded valid range. Check TICKTIME and MSEC

***************************************************************************

* Other functions used internally by the RTOS : * --------------------------------------------*/ void PE_TaskChange (void);			 void RTOS_Timer_Int (void);			 /* // Task swapping function // RTOS Scheduler ISR

*************************************************************************** *************************************************************************** *************************************************************************** *************************************************************************** *************************************************************************** */

STARTUP.A51
$NOMOD51 ;------------------------------------------------------------------------;  This file is part of the C51 Compiler package ; Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.

;------------------------------------------------------------------------;  STARTUP.A51: This code is executed after processor reset. ; ; ; ; ; ; ; ;

;  To translate this file use A51 with the following invocation: ; 	 A51 STARTUP.A51

;  To link the modified STARTUP.OBJ file to your application use the following BL51 invocation:

;  	

BL51 <your object file list>, STARTUP.OBJ <controls>

;-------------------------------------------------------------------------;  User-defined Power-On Initialization of Memory ;  With the following EQU statements the initialization of memory ;  at processor reset can be defined: ; ; 		

; the absolute start-address of IDATA memory is always 0

130
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
;IDATALEN 	 IDATALEN 	 ; ; EQU 	 EQU 	 80H 		 100H 		 ; the length of IDATA memory in bytes. the 8032 (256 bytes).

A51 Examples

					

; the length of IDATA memory in bytes for

XDATASTART 	 XDATALEN 	 ;

EQU 	 EQU 	 EQU 	 EQU 	

0H 		 0H 		 0H 		 0H 		

; the absolute start-address of XDATA memory ; the length of XDATA memory in bytes.

PDATASTART 	 PDATALEN 	 ; ;

; the absolute start-address of PDATA memory ; the length of PDATA memory in bytes.

; 	

Notes: The IDATA space overlaps physically the DATA and BIT areas of

; 	   run-time routines must be set to zero. ; ; ; ; ;

the 8051 CPU. At minimum the memory space occupied from the C51

;-------------------------------------------------------------------------;  Reentrant Stack Initilization ;  The following EQU statements define the stack pointer for reentrant functions and initialise it:

IBPSTACK 	

Stack Space for reentrant functions in the SMALL model. EQU 	 EQU 	 1 		 0FFH+1 		 07FH+1 		

IBPSTACKTOP 	 ; ;

; set to 1 if small reentrant is used.

;IBPSTACKTOP 	 EQU 	

; set top of stack to highest location+1. ; set top of stack to highest location+1.

XBPSTACK 	 ; ;

Stack Space for reentrant functions in the LARGE model. EQU 	 EQU 	 0 	 0FFFFH+1 	 	

XBPSTACKTOP 	

; set to 1 if large reentrant is used.

; set top of stack to highest location+1.

PBPSTACK 	 ; ; ; ; ; ; ; ;

Stack Space for reentrant functions in the COMPACT model. EQU 	 EQU 	 0 	 0FFFFH+1 	 	

PBPSTACKTOP 	

; set to 1 if compact reentrant is used.

; set top of stack to highest location+1.

;-------------------------------------------------------------------------;  Page Definition for Using the Compact Model with 64 KByte xdata RAM ;  The following EQU statements define the xdata page used for pdata in the linker invocation. EQU 	 EQU 	 0 	 0 	

variables. The EQU PPAGE must conform with the PPAGE control used

PPAGEENABLE 	 PPAGE 		 PPAGE_SFR 	 ; 		 ;

; set to 1 if pdata object are used. ; define PPAGE number.

DATA 	 0A0H 	 ; SFR that supplies uppermost address byte (most 8051 variants use P2 as uppermost address byte)

;--------------------------------------------------------------------------

131
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; Standard SFR Symbols ACC 	 B 	 SP 	 DATA 	 0E0H DATA 	 0F0H DATA 	 81H DATA 	 82H DATA 	 83H NAME 	 SEGMENT ?C_STARTUP CODE IDATA

A51 Examples

DPL 	 DPH 	

		 ?STACK 		

?C_C51STARTUP 	SEGMENT #include <parameters.h> MAINSTACK: 	 		 DS 	

		RSEG 	 ?STACK

STACKSIZE

		PUBLIC ?C_STARTUP 		PUBLIC MAINSTACK $IF 	 (MON51)

EXTRN CODE (?C_START)

; MON51 or FLT32 should be defined in the A51 Tab in KEIL 		 		 		 CSEG AT 8000H 	; FOR DEV BOARD MON-51 MONITOR PROG CSEG AT 8100H 	; FOR FLT-32 DEV BOARD MONITOR PROG CSEG AT 0 	 ; FOR EEPROM

$ELSEIF (FLT32) $ELSE

$ENDIF

?C_STARTUP: 	 		 STARTUP1: 		

LJMP 	 STARTUP1

RSEG 	 ?C_C51STARTUP

IF IDATALEN <> 0

		CLR 	 A IDATALOOP: 	  		 ENDIF MOV 	

MOV 	

R0,#IDATALEN - 1 @R0,A

DJNZ 	 R0,IDATALOOP

IF XDATALEN <> 0 		 		   ELSE ENDIF 		

		MOV 	 DPTR,#XDATASTART     IF (LOW (XDATALEN)) <> 0 MOV 	 MOV 	 MOV 	

R7,#LOW (XDATALEN) R6,#(HIGH (XDATALEN)) +1 R6,#HIGH (XDATALEN)

		CLR 	 A XDATALOOP: 	 		 		 ENDIF 		 INC 	

MOVX 	 @DPTR,A DJNZ 	 R7,XDATALOOP DJNZ 	 R6,XDATALOOP DPTR

132
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
IF PPAGEENABLE <> 0 ENDIF

A51 Examples

		MOV 	 PPAGE_SFR,#PPAGE IF PDATALEN <> 0  		  		 PDATALOOP: 	  		 ENDIF 		 		

MOV 	 MOV 	 CLR 	 INC 	

R0,#LOW (PDATASTART) R7,#LOW (PDATALEN) A

MOVX 	 @R0,A DJNZ 	 R7,PDATALOOP R0

IF IBPSTACK <> 0  		 ENDIF

EXTRN DATA (?C_IBP)

MOV 	

?C_IBP,#LOW IBPSTACKTOP

IF XBPSTACK <> 0 		

EXTRN DATA (?C_XBP)  		 ENDIF

MOV 	 MOV 	

?C_XBP,#HIGH XBPSTACKTOP

?C_XBP+1,#LOW XBPSTACKTOP

IF PBPSTACK <> 0  		 ENDIF

EXTRN DATA (?C_PBP)

MOV 	

?C_PBP,#LOW PBPSTACKTOP

		MOV 	 SP,#?STACK-1 ; EXTRN CODE (?B_SWITCH0) ; 		  		 		

; This code is required if you use L51_BANK.A51 with Banking Mode 4 CALL 	 ?B_SWITCH0 ; init bank mechanism to code bank 0 LJMP 	 ?C_START END

133
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

A51 Examples

SanctOS_V01.C
/* *************************************************************************** *	   SanctOS_V01.C 			 * * * * * * 		 RTOS KERNEL SOURCE CODE

Round Robin RTOS written in C by Ing. Paul P. Debono

* ------------------------------------------------------------------------* For use with the 8051 family of microcontrollers * Notes: * Use NOOVERLAY in the linker BL51 Misc (Misc controls) options tab * Use NOAREGS in the compiler C51 (Misc controls) options tab *

* Timer to use for the RTOS ticks is user selectable, Timer 0, 1 or 2 * Naturally, Timer 2 can only be used with an 8032 CPU type. * 	 * 	 *      Baudrate generation      Timer 1 can only be used if it is not required for

* Assign the correct values to * in parameters.h * application *

* 'STACKSIZE', 'TICK_TIMER', 'TICKTIME', 'CPU' and 'NOOFTASKS' * Most of the time you need only to change 'NOOFTASKS' to reflect

.

134
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* If it is noticed that timing parameters are not being met,the system's * TICKTIME can be modified by changing the value 'TICKTIME' in * Parameters.H * * Please adhere to the conditions mentioned in Parameters.H * File 		 * Date 		 * By	 * : SanctOS_V01.C : 8 : February 2006

A51 Examples

* Revision 	 	

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

*************************************************************************** */ /*

*************************************************************************** * 					INCLUDES */ *************************************************************************** #include <reg52.h> 		  				 /* /* 8052 Special Function Registers 8052 */ /* RTOS system calls definitions */ /* (IN PROJECT DIRECTORY)*/

#include <SanctOS_V01.H> 	

*************************************************************************** * 				FUNCTION DEFINITIONS */ *************************************************************************** void PE_TaskChange (void); 		 /* /* used internally by the RTOS */

*************************************************************************** * 			 /* if more flags are needed, use spare bits from status1 variable */ STATUS FLAG DEFINITIONS

*************************************************************************** /* status1 - free bits for future expansion */ #define FLAG0_F 	 #define FLAG1_F 	 #define FLAG2_F 	 #define FLAG3_F 	 #define FLAG4_F 	 #define FLAG5_F 	 #define FLAG6_F 	 #define FLAG7_F 	 0x01 	 /* bit 0 - */ 0x02 	 /* bit 1 - */ 0x04 	 /* bit 2 - */ 0x08 	 /* bit 3 - */ 0x10 	 /* bit 4 - */ 0x20 	 /* bit 5 - */ 0x40 	 /* bit 6 - */ 0x80 	 /* bit 7 - */

struct task_param xdata task[NOOFTASKS]; /*

*************************************************************************** * 				GLOBAL VARIABLES */ ***************************************************************************

135
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
uchar data Running;	 uchar data tsknum; /* */ /* 	 // Current task	 number

A51 Examples

***************************************************************************

*************************************************************************** * RTOS FUNCTION DEFINITIONS */ /* * * * ***************************************************************************

*************************************************************************** * Function name : OS_INIT_RTOS * Function type : Initialisation System call * Description 	 : This system call initialises the RTOS variables, * 		 * task SPs and enables any required interrupts

* Arguments 	

* 			 *			 *			 * * * Returns 	

: iemask Represents the interrupt enable mask which is

Its value determines which interrupts will be enabled during the execution of the user's application. : None

used to set up the IE special function register.

*************************************************************************** */ {	 	 	 void OS_INIT_RTOS(uchar iemask) uchar data i,j; #if (TICK_TIMER == 2)	

	  IE = (iemask & 0x7f) | 0x20;

 	  IP = 0x20; 	 /* Assign scheduler interrupt high priority */	 	 	  IE = (iemask & 0x7f) | 0x08; #elif (TICK_TIMER == 1)				

/* Set up 8051 IE register, using timer 2 */ 	

/* Set up 8051 IE register, using timer 1 */ 	

	  IP = 0x08; 	 /* Assign scheduler interrupt high priority */	 	  IE = (iemask & 0x7f) | 0x02; #elif (TICK_TIMER == 0)				

/* Set up 8051 IE register, using timer 0 */ 	#endif 	

	  IP = 0x02; 	 /* Assign scheduler interrupt high priority */	 Running = IDLE_TASK;		 /* Set idle task, the running task, initially */

    tsknum = MINUS_ONE;

136
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	  	 for (i=0; i < NOOFTASKS; i++) {   task[i].status1 = ZERO; 		 task[i].slot_time = TEN; 		 task[i].slot_reload = TEN; 	 /* status flags (not used) */ /* slot time reload value */

A51 Examples

	  	  	                   

/* slot time counter value */

 	  	  	  	  	  	  	  	  	 }

			

task[i].stackptr = MAINSTACK + 6; /* SP storage */ task[i].reg0 = ZERO; task[i].reg1 = ZERO; task[i].reg2 = ZERO; task[i].reg3 = ZERO; task[i].reg4 = ZERO; task[i].reg5 = ZERO; task[i].reg6 = ZERO; task[i].reg7 = ZERO; /* and clear the stack area */

/* clear bank 0 registers storage area */

		 	}

for (j=0;j<STACKSIZE;j++) task[i].stack[j]=ZERO;

/* */ /* * * *

***************************************************************************

*************************************************************************** * Function name : OS_CREATE_TASK * Function type : Initialisation System call * Description * : This system call is used in the main program for each

*				 * Arguments	 *

task to be created for use in the application.

* 			 * 		 *	 * *

: task_num Represents the task number (1st task is numbered as 0).

*				 * 			 * Returns 	 	

task_add Represents the task's start address, which in

slot_time Represents the number of ticks that this task will run before handing over to the next task

the C environment, would simply be the name * * of the procedure

: None

*************************************************************************** */ { 	 	 	 	 } void OS_CREATE_TASK(uchar task_num, uint task_add, uint slot)  	 task[task_num].status1 	 = ZERO;   /* task flags not used */ = slot; 	

task[task_num].slot_time 	 task[task_num].stack[0] 	

task[task_num].slot_reload 	= slot;

/* slot time value */

task[task_num].stack[1] = HiByte(task_add); 		

= LoByte(task_add); 	 /* Little Endian */ /* Low byte first */

137
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* */ /* * * *

A51 Examples

***************************************************************************

*************************************************************************** * Function name : OS_RTOS_GO * Function type : Initialisation System call * Description * * * : This system calls is used to start the RTOS going such that it supervises the application processes.

*			 * Arguments	 * Returns 	

: None		 : None

****************************************************************************/ void OS_RTOS_GO(void) { 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 #if (TICK_TIMER == 2)			

RCAP2H = HiByte(BASIC_TICK);	 /* Configures Timer 2 in 16-bit 	 T2CON = 0x84; 		

RCAP2L = LoByte(BASIC_TICK);	 /* auto-reload mode for the 8032 	 #elif (TICK_TIMER == 0) TH0 = HiByte(BASIC_TICK);	 TL0 = LoByte(BASIC_TICK);	 /* Configure Timer 0 in 16-bit 	 /* timer mode for the 8051 	 */

*/ */

/* TR2 = TF2 = 1, causes immediate interrupt */

*/

      TMOD &= 0xF0; 	 /* Clear T0 mode control, leaving T1 untouched */ TMOD |= 0x01;	 /* Set T0 mode control */		 TR0 = 1; 	 TF0 = 1;	 	 /* Start timer 0 */

/* Cause first interrupt immediately */

#elif (TICK_TIMER == 1) TH1 = HiByte(BASIC_TICK);	 TL1 = LoByte(BASIC_TICK);	 /* Configure Timer 1 in 16-bit 	 /* timer mode for the 8051 	 */ */

      TMOD &= 0x0F; 	 /* Clear T1 mode control, leaving T0 untouched */ TMOD |= 0x10;	 /* Set T1 mode control */		 TR1 = 1; 	   /* Start timer 1 */

TF1 = 1;		 /* Cause first interrupt immediately */	

	#endif 	 } /* Interrupts are enabled, starting the RTOS at this point. */ EA = 1;

/*

****************************************************************************/ /*

****************************************************************************/

138
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/*

A51 Examples

**************************************************************************** * Function name : PE_TaskChange * *

* Function type : Context Switch (Internal function) * Description 	 : This function is used to perform a forced or pre-emptive * 		   context switch or task swap * * * * Arguments 	 : none

* Notes 	 * 		 * 		 * * *

: This procedure is called from the timer tick interrupt, there would be 5 registers pushed on the stack, saved while the current task was running.

* 		   Push A, B, DPH, DPL and PSW * 		 * Returns 	

Comes here ONLY from an Interrupt Service Routine : None

****************************************************************************/ void PE_TaskChange (void) using 1 { 	 	 uchar data i, temp;

uchar idata * idata internal;

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

139
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* The current task is PRE-EMPTIED, and a */ /* new task is set to run */ /* NOW WORK WITH THE NEW TASK */ 				  	 	 	 tsknum++; 	 internal = MAINSTACK; 	 /* MAINSTACK is the address of the start */ /* valid range 0 to (NOOFTASKS-1) */ /* of main stack defined in STARTUP.A51 */

8032 Differences

if (tsknum == NOOFTASKS) tsknum = ZERO; Running = tsknum; 		

/* set the new task as running */

   /* The new running task's USED stack area is copied to internal RAM */     /* and the stack pointer adjusted accordingly */       temp = task[Running].stackptr; i=0;

      do { 		 	 	 	

} while (internal<=temp); SP = temp;	

*(internal++) = task[Running].stack[i++]; /* The new running task's SP is restored */	

	 	 	

/* Get the new tasks bank 0 registers which were stored externally */ RecallBank0(&task[Running].reg0); POP5I(); /* then pop the SFRs back again and start other task here */

/* it never gets down to here */ }

/*

****************************************************************************/ /*

**************************************************************************** * Function name : RTOS_Timer_Int * *

* Function type : Scheduler Interrupt Service Routine * Description 	 : This is the RTOS scheduler ISR. * 		 * 		 * * * It generates system ticks and calculates any remaining

*		 * Arguments 	 * Returns 	

running time for each task.

: None : None

****************************************************************************/ #if (TICK_TIMER == 0) 	 { 	 	 /* If Timer 0 is used for the scheduler */ 	

void RTOS_Timer_Int (void) interrupt 1 using 1 uchar idata * idata internal; uchar data k;

140
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* After an interrupt, the SP is incremented by 5 by the */ /* compiler to PUSH ACC,B,DPH,DPL and PSW */ 	 	 /* These are popped back before returning from the interrupt */ TH0 = HiByte(BASIC_TICK); 	 /* Timer registers reloaded */ TL0 = LoByte(BASIC_TICK); /* If Timer 1 is used for the scheduler */ 	

8032 Differences

#elif (TICK_TIMER == 1)	 { 	 	

void RTOS_Timer_Int (void) interrupt 3 using 1 uchar idata * idata internal; uchar data k;

/* After an interrupt, the SP is incremented by 5 by the */ /* compiler to PUSH ACC, B, DPH, DPL and PSW */ /* These are popped back before returning from the interrupt */ /* PSW is also pushed because of the 'using 1' command */ 	 	 TL1 = LoByte(BASIC_TICK); TH1 = HiByte(BASIC_TICK); 	 /* Timer registers reloaded */

#elif (TICK_TIMER == 2)	 { 	 	

void RTOS_Timer_Int (void) interrupt 5 using 1 uchar idata * idata internal; uchar data i,k; 		

/* If Timer 2 is used for the scheduler */ 	

/* After an interrupt, the address of the next instruction of the */ /* current task is push on stack (low then high byte). Then SP */ /* is further incremented by 5 by the */ /* Internal stack map at this stage */ /*   High stack RAM 		 /*   PSW <-- SP points to here 	 */ */ /* compiler to PUSH ACC,B,DPH,DPL and PSW */

/*   B 					*/ /*   High byte return address 		 /*   Low byte return address 		 /*   Low stack RAM 			 /*   ACC 				*/ */ */ */

/*   DPH 				*/

/*   DPL 				*/

/* These are normally popped back BEFORE returning from the */ /* interrupt IF the TaskChange function is not called. */ 	 TF2 = 0;			 #endif    EA = 0;       if (Running != IDLE_TASK)       { /* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* A,B,DPH,DPL and PSW are pushed on stack by the compiler after */ /* Timer 2 interrupt flag is cleared */

141
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* the interrupt */

8032 Differences

/* and are saved as part of the task stack */     SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* check if the currently running task slot time has elapsed */ 			task[Running].slot_time--; 			 			 { if (task[Running].slot_time == ZERO)

      /* Current task SP is saved pointing to PSW which is the last one */     /* pushed on stack after the interrupt */ 		 		   internal = MAINSTACK; 		 i = 0; 	 task[Running].stackptr = k = SP;

/* MAINSTACK is declared in STARTUP.A51 */  		 		 	 		 		 do { 	 /* Current task's USED stack area is saved */ 	    } while (internal<=k); PE_TaskChange(); task[Running].stack[i++] = *(internal++);	

task[Running].slot_time = task[Running].slot_reload; 		

/* Force a pre-emptive task change if required */

/* Note that the pushed registers would still be on the saved stack at */ /* this point and would be popped back when task is put into */ /* action again in PE_TaskChange() */ 		 	 } }

/* else if running IDLE (after INIT_RTOS), start a task immediately */ /* run again in this round robin rtos. */

/* without any need to save the stack, since the IDLE TASK will never */   else if (Running == IDLE_TASK) PE_TaskChange(); /* exits here if slot time for current task not yet over */ }   EA = 1;

/* */ /*

***************************************************************************

*************************************************************************** *************************************************************************** *************************************************************************** *************************************************************************** *************************************************************************** */

142
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix D

Appendix D	 PaulOS.C
This is the program source listing for the C version of PaulOS RTOS. It consists of: •	 The header file PaulOS_V14_Parameters.h •	 The header file PaulOS_V14.h •	 The startup file PaulOS_Startup.A51 •	 The main source program PaulOS.C PaulOS_V14_Parameters.h
/* ************************************************************************* * 		 */ ************************************************************************* #ifndef __paulos_v14_params_h__ #define __paulos_v14_params_h__ /************************************************************************/ PaulOS_v14_Params.H -- RTOS USER DEFINITIONS

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel – as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

143
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
// Number of bytes to allocate for the stack #define STACKSIZE	 0x0F

Appendix D

// set to 8051 or 8032

#define CPU			 #define TICK_TIMER 	 2

8032

// Set to 0, 1 or 2 to select which timer to use as the RTOS tick timer // Length of RTOS basic tick in msec - Refer to RTOS timing definitions // Suitable values: 1, 2, 4, 5, 8, 10, 20, 25, 40, 50 #define TICKTIME	 1 2 // Number of tasks used in application #define NOOFTASKS	 // Interrupts - set to 1 to use interrupt as stand alone ISR #define STAND_ALONE_ISR_00 0	 #define STAND_ALONE_ISR_01 1	 #define STAND_ALONE_ISR_02 0	 #define STAND_ALONE_ISR_03 0	 #define STAND_ALONE_ISR_04 0	 #define STAND_ALONE_ISR_05 0	 // EXT0 // TIM0 // EXT1 // TIM1 // SER0 // TIM2

/************************************************************************/ #endif // __paulos_v14_params_h__

PaulOS_V14.h
/* * ************************************************************************* *	 *	 * PaulOS_V14.H

RTOS KERNEL HEADER FILE

* For use with PaulOS_V14.C, * * *

* A Co-Operative RTOS written in C by Ing. Paul P. Debono * ----------------------------------------------------------------------* For use with the 8051 family of microcontrollers * File		 * Date		 : PaulOS_V14.C : 2 : April 2009

* Revision	 * By		

* 			 *			 * *

: Paul P. Debono

B. Eng. (Hons.) Elec. Course University Of Malta

************************************************************************* */ /*

144
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 */ /* MAKE SURE THAT YOU ARE USING THE CORRECT STARTUP.A51 FILE, WHICH SHOULD INCLUDE THE FOLLOWING MAINSTACK DEFINITION. ENSURE ALSO THAT YOU HAVE THE CORRECT CSEG SETTING

Appendix D

				RSEG	 ?STACK MAINSTACK:	 DS	 STACKSIZE	

				EXTRN CODE (?C_START) 				PUBLIC ?C_STARTUP 				PUBLIC MAINSTACK */ #ifndef __PAULOS_V14_H__ #define __PAULOS_V14_H__ /*

; defined in parameters.h

************************************************************************* ************************************************************************* *						 	 DATA TYPE DEFINITIONS

typedef unsigned char uchar; typedef unsigned int uint; typedef unsigned long ulong; /*

*/

#include "PaulOS_V14_Params.h"	

/* in project directory */

************************************************************************* ************************************************************************* */ *						 FUNCTION PROTOTYPES

/*

* The following RTOS system calls do not receive any parameters : */

* ---------------------------------------------------------------// Stops current task and passes control to the next task in queue void OS_DEFER(void); // Kills the currently running task void OS_KILL_IT(void); bit OS_SCHECK(void); void OS_WAITP(void); // Checks if running task's signal bit is set // Waits for end of task's periodic interval // Returns the number of the currently executing (running) task uchar OS_RUNNING_TASK_ID(void); OS_CPU_IDLE()		 OS_CPU_DOWN()		 /* The following commands are simply defined as MACROS below 					mode (awake every interrupt) 					only by hardware reset OS_PAUSE_RTOS()		 OS_RESUME_RTOS()	 */ /* Re-enable RTOS, for stand alone ISR Switch off microprocessor, activate Set the microprocessor into a sleep

Disable RTOS, for stand alone ISR

145
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* The following RTOS system calls do receive parameters : * ------------------------------------------------------// Initialises all RTOS variables void OS_INIT_RTOS(uchar iemask); void OS_RTOS_GO(bit prior); // Signals a task // Starts the RTOS running with priorities if required */

Appendix D

void OS_SIGNAL_TASK(uchar tasknum); void OS_WAITI(uchar intnum); void OS_WAITT(uint ticks); void OS_WAITS(uint ticks);

// Waits for an event (interrupt) to occur // Waits for a timeout period given by a defined number of ticks // Waits for a signal to arrive within a given number of ticks // Sets task to run periodically every given number of ticks void OS_PERIODIC(uint ticks); // Creates a task

void OS_CREATE_TASK(uchar tasknum, uint taskadd); // Resumes a task which was previously KILLed void OS_RESUME_TASK(uchar tasknum); OS_WAITT_A(M,S,ms)	 OS_WAITS_A(M,S,ms)	 */

/* The following commands are simply defined as MACROS below

Absolute WAITT for minutes, seconds, msecs Absolute WAITS for minutes, seconds, msecs

OS_PERIODIC_A(M,S,ms)	 Absolute PERIODIC for minutes, seconds, msecs /************************************************************************/

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

146
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* The stack variable points to the start pointer in hardware stack and */ /* should be defined in PaulOS_STARTUP.A51 */ /* extern idata unsigned char MAINSTACK[STACKSIZE]; ************************************************************************* ************************************************************************* // In theory 921.6 counts represent 1 ms using an 11.0592 MHz crystal. // Hence 9216 counts represent 10 ms. #define MSEC10		 9216UL /* Note on TICKTIME: */ *						 RTOS TIMING DEFINITIONS

Appendix D

Ensure that TICKTIME's value is chosen such that this quotient and hence all the following quotients result in an integer. to CLOCK = 65535, i.e. approx. 70-72. In theory, maximum value of TICKTIME is given by the value corresponding However respecting the condition above, max acceptable TICKTIME is 50 ms. Hence all suitable values are: 1, 2, 4, 5, 8, 10, 20, 25, 40, 50 depending upon the application For reliable time-dependent results a value of 10 or above is recommended

*/

#define TICKS_PER_SEC	 (1000 / TICKTIME) #define CLOCK		

#define TICKS_PER_MIN	 (60000 / TICKTIME) #define BASIC_TICK 	 (65536 - CLOCK) 0

((TICKTIME * MSEC10)/10UL)

//An indefinite period of waiting time in the RTOS is given by a value 0 #define NOT_TIMING		 #define NO_INTERRUPT	 /* // Indicates task not waiting for an interrupt 0xFF

************************************************************************* ************************************************************************* *							RTOS MACROS

// Retrieve High / Low byte

*/

#define HiByte(Num) (uchar)((uint)(##Num)>>8); // Sets the MCU in idle mode #define OS_CPU_IDLE()		 #define OS_CPU_DOWN()		 #if (TICK_TIMER == 0) 	 	 	 	 	 	

#define LoByte(Num) (uchar)((uint)(##Num)& 0x00FF); PCON |= 0x01 PCON |= 0x02

// Sets the MCU in power-down mode // Pause / Resume RTOS functions

#define OS_PAUSE_RTOS() EA = ET0 = TR0 = 0

#elif (TICK_TIMER == 1)

#define OS_RESUME_RTOS() TR0 = ET0 = EA = 1 #define OS_PAUSE_RTOS() EA = ET1 = TR1 = 0

#elif (TICK_TIMER == 2)

#define OS_RESUME_RTOS() TR1 = ET1 = EA = 1 #define OS_PAUSE_RTOS() EA = ET2 = TR2 = 0

#define OS_RESUME_RTOS() TR2 = ET2 = EA = 1

147
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#endif /* ************************************************************************* ************************************************************************* #if (CPU != 8032) && (CPU != 8051) 	 #endif 	 #error Invalid CPU Setting */ *						COMPILE-TIME ERROR TRAPPING

Appendix D

#if (NOOFTASKS > 254) #endif #if 0 	

#error Number of tasks is greater than 254 tasks

		

#if (CPU == 8032)

			 	

#if ((MAINSTACK + STACKSIZE) > 0x100)

		#endif 		

#error Out of RAM Space. Please shift variables to XDATA

#elif (CPU == 8051)

			 	#endif #endif 	

#if ((MAINSTACK + STACKSIZE) > 0x80)

		#endif

#error Out of RAM Space. Please shift variables to XDATA

#if ((TICKTIME * 110592 / 120) > 65535) #endif

#error Tick time value > valid range of the timer counter setting

#if ((TICKTIME * 110592 / 120) < 65535) && ((1000 % TICKTIME) != 0) #endif 	

#error Undesirable TICKTIME. Valid values 1,2,4,8,10,20,25,40 or 50 ms #if (CLOCK > 65535) #endif /*

#error Timer > valid range. Please check TICKTIME and MSEC.

************************************************************************* ************************************************************************* *						 TASK-RELATED DEFINITIONS

#define FLAG_SIG_RCVD	 0x80 // Signal-received flag mask	 1000 0000 #define FLAG_SIG_WAIT	 0x40 // Waiting-for-signal flag mask 0100 0000 #define FLAG_PERIODIC	 0x20 // Periodic Interval flag mask 0010 0000 /* */ Interrupt Number used for tasks waiting for an interrupt event 0x00	 // External 0 Interrupt number 0 0x01	 // Timer 0	 0x03	 // Timer 1	 0x05	 // Timer 2	 0x02	 // External 1 Interrupt number 2 0x04	 // UART 0	 Interrupt number 4 Interrupt number 5 Interrupt number 3 Interrupt number 1

*/

#define EXT0_INT	 #define TIM0_INT	 #define EXT1_INT	 #define TIM1_INT	 #define SER0_INT	 #define TIM2_INT	

// Main endless loop in application given a task number equal to NOOFTASKS #define IDLE_TASK NOOFTASKS /*

************************************************************************* *				 ENHANCED EVENT-WAITING ADD-ON MACROS *************************************************************************

148
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
*

Appendix D

* These macros perform the same functions of WAITT, WAITS and PERIODIC * calls but rather than ticks they accept absolute time values as * parameters in terms of days, hours, minutes, seconds and millisecs. * This difference is denoted by the _A suffix - eg. WAITT_A() is the * absolute-time version of WAITT() * *

* Range of values accepted, (maximum 65535 TICKTIMES): * Using a minimum TICKTIME of 1 msec : *		 *

from 1 msecs to 1 min, 5 secs, 535 msecs

* Using a recommended TICKTIME of 10 msec : *		 *

from 10 msecs to 10 mins, 55 secs, 350 msecs

* Using a maximum TICKTIME of 50 msec : *		 *

from 50 msecs to 54 mins, 36 secs, 750 msecs

* If the conversion from absolute time to ticks results in 0 (all * parameters being 0 or overflow) this result is only accepted by * WAITS() by virtue of how the WAITT(), WAITS() and PERIODIC() calls were * written. In the case of the WAITT() and PERIODIC() calls the tick count * would automatically be changed to 1 meaning an interval of * eg. 50 msecs in case the TICKTIME is defined to be 50 msecs * * Liberal use of parentheses is made in the following macros in case the * arguments might be expressions *

************************************************************************* #define TPM(M) (TICKS_PER_MIN*(##M)) #define TPS(S) (TICKS_PER_SEC*(##S)) #define TPMS(ms) ((##ms)/TICKTIME) #define OS_WAITT_A(M,S,ms) OS_WAITT((uint)(TPM(M) + TPS(S) + TPMS(ms))) #define OS_WAITS_A(M,S,ms) OS_WAITS((uint)(TPM(M) + TPS(S) + TPMS(ms))) /* #define OS_PERIODIC_A(M,S,ms) OS_PERIODIC((uint)(TPM(M)+TPS(S)+TPMS(ms))) ************************************************************************* *				 */ ************************************************************************* // Task swapping function void QShift(void); // RTOS Scheduler ISR Other functions used internally by the RTOS */

void RTOS_Timer_Int(void);

// Function used by ISRs other than the RTOS Scheduler void Xtra_Int(uchar task_intflag); // External Interrupt 0 ISR #if (!STAND_ALONE_ISR_00) void Xtra_Int_0(void); #endif // Timer 0 ISR

#if ( (TICK_TIMER != 0 ) && (!STAND_ALONE_ISR_01) )

149
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
void Xtra_Int_1(void); #endif // External Interrupt 1 ISR #if (!STAND_ALONE_ISR_02) void Xtra_Int_2(void); #endif // Timer 1 ISR

Appendix D

#if ( (TICK_TIMER != 1 ) && (!STAND_ALONE_ISR_03) ) void Xtra_Int_3(void); #endif // Serial Port ISR

#if (!STAND_ALONE_ISR_04) void Xtra_Int_4(void); #endif

// Interrupt 5 (Timer 2) - NOT AVAILABLE ON THE 8051 #if ( (TICK_TIMER != 2 ) && (!STAND_ALONE_ISR_05) ) void Xtra_Int_5(void); #endif

/************************************************************************/ #endif // __PAULOS_V14_H__

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

150
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click Click on on the the ad ad to to read read more more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

PaulOS An 8051 Real-Time Operating System Part II

Appendix D

PaulOS_STARTUP.A51
$NOMOD51 ;------------------------------------------------------------------------; This file is part of the C51 Compiler package ; Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc. ; PaulOS_STARTUP.A51: This code is executed after processor reset. ; ; ; ; To translate this file use A51 with the following invocation: ; A51 PaulOS_STARTUP.A51 ; To link the modified PaulOS_STARTUP.OBJ file to your application use ; the following ; ; ; ; ; BL51 invocation: ; BL51 <your object file list>, PaulOS_STARTUP.OBJ <controls> ;------------------------------------------------------------------------; User-defined Power-On Initialization of Memory ; With the following EQU statements the initialization of memory ; at processor reset can be defined: ;

;-------------------------------------------------------------------------

; the absolute start-address of IDATA memory is always 0 ;

IDATALEN EQU 100H ; the length of IDATA memory in bytes for the 8032 (256 bytes). XDATASTART EQU 0H ; the absolute start-address of XDATA memory XDATALEN EQU 0H ; the length of XDATA memory in bytes. ;

PDATASTART EQU 0H ; the absolute start-address of PDATA memory PDATALEN EQU 0H ; the length of PDATA memory in bytes. ;

;Notes: The IDATA space overlaps physically the DATA and BIT areas of the ; 8051 CPU. At minimum the memory space occupied from the C51 ; run-time routines must be set to zero. ; ;

;------------------------------------------------------------------------; Reentrant Stack Initilization ; The following EQU statements define the stack pointer for reentrant ; functions and initialise it: ;

; Stack Space for reentrant functions in the SMALL model. IBPSTACK EQU 0 ; set to 1 if small reentrant is used. IBPSTACKTOP EQU 0FFH+1 ; set top of stack to highest location+1. ;

;IBPSTACKTOP EQU 07FH+1 ; set top of stack to highest location+1. ; Stack Space for reentrant functions in the LARGE model. XBPSTACK EQU 0 ; set to 1 if large reentrant is used. ; XBPSTACKTOP EQU 0FFFFH+1; set top of stack to highest location+1.

151
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; Stack Space for reentrant functions in the COMPACT model. PBPSTACK EQU 0 ; set to 1 if compact reentrant is used. ; ; ; PBPSTACKTOP EQU 0FFFFH+1; set top of stack to highest location+1. ;------------------------------------------------------------------------; Page Definition for Using the Compact Model with 64 KByte xdata RAM ; The following EQU statements define the xdata page used for pdata ; in the linker invocation. ; ; ;

Appendix E

; variables. The EQU PPAGE must conform with the PPAGE control used

PPAGEENABLE EQU 0 ; set to 1 if pdata object are used. PPAGE EQU 0 ; define PPAGE number. PPAGE_SFR DATA 0A0H ; SFR that supplies uppermost address byte ; (most 8051 variants use P2 as uppermost address byte) ;

;------------------------------------------------------------------------; Standard SFR Symbols ACC DATA 0E0H B DATA 0F0H SP DATA 81H

DPL DATA 82H DPH DATA 83H NAME ?C_STARTUP

?C_C51STARTUP SEGMENT CODE ?STACK SEGMENT IDATA RSEG ?STACK #include "PaulOS_V14_Params.h" MAINSTACK: DS STACKSIZE EXTRN CODE (?C_START) PUBLIC ?C_STARTUP PUBLIC MAINSTACK

; FLT32 or MON51 should be define in A51 TAB in Target Options $IF (MON51) CSEG AT 8000H ; FOR DEV BOARD MON-51 MONITOR PROG CSEG AT 8100H ; FOR FLT-32 DEV BOARD MONITOR PROG CSEG AT 0 ; FOR EEPROM

$ELSEIF (FLT32) $ELSE

$ENDIF

?C_STARTUP: LJMP STARTUP1 STARTUP1: RSEG ?C_C51STARTUP

IF IDATALEN <> 0 CLR A

MOV R0,#IDATALEN - 1

IDATALOOP: MOV @R0,A ENDIF DJNZ R0,IDATALOOP

IF XDATALEN <> 0

MOV DPTR,#XDATASTART

152
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MOV R7,#LOW (XDATALEN)

Appendix E

IF (LOW (XDATALEN)) <> 0 ELSE

MOV R6,#(HIGH (XDATALEN)) +1 MOV R6,#HIGH (XDATALEN) ENDIF CLR A

XDATALOOP: MOVX @DPTR,A INC DPTR DJNZ R7,XDATALOOP ENDIF DJNZ R6,XDATALOOP

IF PPAGEENABLE <> 0 ENDIF

MOV PPAGE_SFR,#PPAGE

IF PDATALEN <> 0

MOV R0,#LOW (PDATASTART) MOV R7,#LOW (PDATALEN) CLR A

PDATALOOP: MOVX @R0,A INC R0 DJNZ R7,PDATALOOP

ENDIF

IF IBPSTACK <> 0

EXTRN DATA (?C_IBP) ENDIF

MOV ?C_IBP,#LOW IBPSTACKTOP

AXA Global Graduate Program
Find out more and apply

153
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
IF XBPSTACK <> 0

Appendix E

EXTRN DATA (?C_XBP)

MOV ?C_XBP,#HIGH XBPSTACKTOP

ENDIF

MOV ?C_XBP+1,#LOW XBPSTACKTOP

IF PBPSTACK <> 0

EXTRN DATA (?C_PBP) ENDIF

MOV ?C_PBP,#LOW PBPSTACKTOP MOV SP,#?STACK-1

; This code is required if you use L51_BANK.A51 with Banking Mode 4 ; EXTRN CODE (?B_SWITCH0) LJMP ?C_START END ; CALL ?B_SWITCH0 ; init bank mechanism to code bank 0

PaulOS_V14.c
======================================================================== /* * ************************************************************************* *	 *	 * * * * * *	 PaulOS_V14.C

RTOS KERNEL SOURCE CODE Co-Operative RTOS written in C by Ing. Paul P. Debono

* ----------------------------------------------------------------------* For use with the 8051 family of microcontrollers * Notes: * Timer to use for the RTOS ticks is user selectable, Timer 0, 1 or 2 * Naturally, Timer 2 can only be used with an 8032 CPU type. *

* Assign the correct values to 'TICK_TIMER', 'CPU', 'MAINSTACK' * and 'NOOFTASKS' in PaulOS_V14_parameters.h *

* If it is noticed that timing parameters are not being met,

* the system's TICKTIME can be modified by changing the value 'TICKTIME' *

* in PaulOS_V14_parameters.H - please adhere to the conditions mentioned. * File		 * Date		 : PaulOS_V14.C : 2 : April 2009

* Revision	 * By		

* 			 *			 * *

: Paul P. Debono

B. Eng. (Hons.) Elec. Course University Of Malta

************************************************************************* /* */

154
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
************************************************************************* ************************************************************************* // 8052 Special Function Registers 8032 #include "reg52.h" // RTOS system calls definitions (in project directory) #include "PaulOS_V14.h" /* */ *								 INCLUDES

Appendix E

************************************************************************* ************************************************************************* */ *						 STRUCTURE DEFINITIONS

// Task Parameters 	 	 	 	 	 	 	 };

struct task_param {

uchar stackptr;			 uchar flags;			 uchar intnum;		

uint timeout;			

// Interrupt number task is waiting for // Timeout task is waiting for

// Flags

// Stack pointer

uint interval_count;	 // Interval counter value uint interval_reload;	 // Interval reload value char stack[STACKSIZE];	 // Stack contents

// Create instance for each user task (and IDLE task) struct task_param xdata task[NOOFTASKS + 1]; /*

************************************************************************* ************************************************************************* *							GLOBAL VARIABLES

// Flag - task waiting for interrupt was found bit bdata IntFlag; // Flag - task timed out and ready to be placed in Ready Queue bit bdata TinQFlag; bit bdata Priority; // Flag - priority is enabled/disabled // Address of last ready task (pointer) uchar data * data ReadyQTop; uchar data Running; // Number of the current running task // Queue stack for tasks ready to run uchar data ReadyQ[NOOFTASKS + 2]; /*

*/

************************************************************************* ************************************************************************* *						 FUNCTION DEFINITIONS

/* * * *

*/

************************************************************************* * Function name : OS_INIT_RTOS * Function type : Initialisation System call

155
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Description : This system call initialises the RTOS variables, *				 * * Arguments	

Appendix E

task SPs and enables any required interrupts

*					 *					 *					 *					 * * * Returns	 : None

: iemask	

Represents the interrupt enable mask which

is used to set up the IE special function register. Its value determines which execution of the user's application. interrupts will be enabled during the

************************************************************************* void OS_INIT_RTOS(uchar iemask) { 	 	 	 #if (TICK_TIMER == 0)				 IP = 0x02;				 uchar i, j; */

IE = (iemask & 0x7f) | 0x02; 	// Set up 8051 IE register, timer 0

#elif (TICK_TIMER == 1)				 	 	 IP = 0x08;				

#message "Using Timer 0 for the PaulOS rtos tick timer"

// Give scheduler high priority

IE = (iemask & 0x7f) | 0x08;	 // Set up 8051 IE register, timer 1

#elif (TICK_TIMER == 2)	 	 	

#message "Using Timer 1 for the PaulOS rtos tick timer"

// Give scheduler high priority

IE = (iemask & 0x7f) | 0x20;	 // Set up 8051 IE register, timer 2 IP = 0x20;				

#message "Using Timer 2 for the PaulOS rtos tick timer"

// Give scheduler high priority

156
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
#endif 	 	 	 	

Appendix E

// Set idle task as running task Running = IDLE_TASK; // Initialize each task

		 		 		 		 		 		 		 	} 	 	 	 	 	 	 	

for (i = 0; i < NOOFTASKS; i++) {

// Clear timing, interrupt, interval & reload variables task[i].timeout = NOT_TIMING; task[i].intnum = NO_INTERRUPT;

task[i].interval_count = NOT_TIMING;

		

task[i].interval_reload = NOT_TIMING; // Fill READY queue with the idle task ReadyQ[i] = IDLE_TASK;

// Fill READY queue with the idle task ReadyQ[NOOFTASKS] = IDLE_TASK; ReadyQ[NOOFTASKS + 1] = IDLE_TASK; ReadyQTop = ReadyQ; // For each task

// Pointer to last task made to point to base of the queue

		/* 		 		 		 we have

for (i = 0; i < NOOFTASKS + 1; i++) { Initialise task SP values

SP initially set to point to MAINSTACK - 1

		 store PSW (done automatically by KEIL) in Qshift since 		 		 		 		 		 		 		 		 the USING 1 keyword.

2 locations used to push return address and another push to

		*/

Hence stackptr made to point to SP + 3 = MAINSTACK + 2

task[i].stackptr = MAINSTACK + 2; // Initialise task status bytes task[i].flags = 0;

// Clear stack contents

			 	} } /* * * *

for (j = 0; j < STACKSIZE; j++) { task[i].stack[j] = 0;

		}

************************************************************************* * Function name : OS_CREATE_TASK * Function type : Initialisation System call * Description : This system call is used in the main program for each *				 * * Arguments	 *

task to be created for use in the application.

*							 *		

: tasknum	

Represents the task number

(1st task is numbered as 0).

taskadd	 Represents the task's start address, which in

157
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
*					 * * the C environment, would simply be the name

Appendix E

*					of the procedure : None

* Returns	

************************************************************************* void OS_CREATE_TASK(uchar tasknum, uint taskadd) { 	 	 	 	 	 } /* * * * 	ReadyQTop++; */

// Add task to next available position in the READY queue *ReadyQTop = tasknum;

// Store task address (Little ENDIAN) on stack, ready for RET inst. task[tasknum].stack[0] = LoByte(taskadd); task[tasknum].stack[1] = HiByte(taskadd);

************************************************************************* * Function name : OS_RTOS_GO * Function type : Initialisation System call * Description : This system calls is used to start the RTOS going such *				 *

that it supervises the application processes.

* Arguments : prior	 Determines whether tasks ready to be executed *					 * *				 *				 *				 *				 *				 *				 *				 *				 *				 * * * Returns	 : None

are sorted prior to processing or not.

If prior = 0 a FIFO queue function is implied. If prior = 1 the queue is sorted by task number in ascending order, as a higher number (task 0 would have the highest priority is associated with smaller task priority), such that the first task in the

queue, which would eventually run, would be the highest priority.

the one with the smallest task number having

************************************************************************* void OS_RTOS_GO(bit prior) { 	 	 	 	 	 	 	 	 Priority = prior; */

// Checks if tasks priorities are to be enabled

#if (TICK_TIMER == 2)

// Configures Timer 2 in 16-bit auto-reload mode for the 8032 RCAP2H = HiByte(BASIC_TICK); RCAP2L = LoByte(BASIC_TICK);

#elif (TICK_TIMER == 0)

T2CON = 0x84; // TR2 = TF2 = 1 // Configure Timer 0 in 16-bit timer mode for the 8051 TH0 = HiByte(BASIC_TICK);

158
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 } /* * * * #endif TL0 = LoByte(BASIC_TICK);

Appendix E

TMOD &= 0xF0;	 // Clear T0 mode control, leaving T1 untouched TMOD |= 0x01;	 // Set T0 mode control TR0 = 1;		 TF0 = 1;		 // Start timer 0

#elif (TICK_TIMER == 1)

// Cause first interrupt immediately

// Configure Timer 1 in 16-bit timer mode for the 8051 TH1 = HiByte(BASIC_TICK); TL1 = LoByte(BASIC_TICK);

TMOD &= 0x0F;	 // Clear T1 mode control, leaving T0 untouched TMOD |= 0x10;	 // Set T1 mode control TR1 = 1;		 TF1 = 1;		 // Start timer 1

// Cause first interrupt immediately

// Signals scheduler that tasks have been added to the queue TinQFlag = 1;

// Interrupts are enabled, starting the RTOS EA = 1;

************************************************************************* * Function name : OS_RUNNING_TASK_ID * Function type : Inter-task Communication System call

I’M WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

159
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* Description : This system call is used to check to get the number of *				 * * * Arguments	 * Returns	 * : None : Number of currently running task from which it must be the current task.

Appendix E

*				 called

************************************************************************* uchar OS_RUNNING_TASK_ID(void) { 	 } return (Running); */

/* * * *

************************************************************************* * Function name : OS_SCHECK * Function type : Inter-task Communication System call * Description : This system call is used to check if the current task *			 *		 * * * signal sent to it by some other task. : None : bit 1 if its signal bit is set, 0 if not set

has its signal set. It tests whether there was any

* Arguments	 * Returns	

************************************************************************* bit OS_SCHECK(void) { 	 	 	 	 EA = 0; */

// Disable interrupts // If a signal is present, clear it and return 1 if (task[Running].flags & FLAG_SIG_RCVD) { EA = 1; task[Running].flags &= ~FLAG_SIG_RCVD;

		 		 	} 	 	

		return 1; // If a signal is not present, return 0 else { EA = 1;

		 	} } /* * * *

		return 0;

************************************************************************* * Function name : OS_SIGNAL_TASK * Function type : Inter-task Communication System call * Description : This system call is used to send a signal to another * *				 task.

160
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Arguments	 * * : tasknum	 Represents the task to which a signal is

Appendix E

*							required to be sent. : None

* Returns	

************************************************************************* void OS_SIGNAL_TASK(uchar tasknum) { 	 	 	 	 	 // Disable interrupts EA = 0; */

// If the task has been waiting for a signal if (task[tasknum].flags & FLAG_SIG_WAIT) {

		 		 		 		 		 		 	} 	 	

// Clear its signal sent/wait flags

task[tasknum].flags &= ~FLAG_SIG_RCVD; task[tasknum].flags &= ~FLAG_SIG_WAIT; task[tasknum].timeout = NOT_TIMING; *ReadyQTop = tasknum; TinQFlag = 1;

		ReadyQTop++;

// If it was not waiting, then set its signal sent flag else { task[tasknum].flags |= FLAG_SIG_RCVD;

		 	} 	

If it really matters, make it happen – with a career at Siemens.

siemens.com/careers

161
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
	 	 } /* * * * // Re-enable interrupts EA = 1;

Appendix E

************************************************************************* * Function name : OS_WAITI * Function type : Event-Waiting System call * Description : This system call causes task to wait for a given event *			 *			 *			 *			 *			 *			 * * Arguments	 has to wait for. Once identified - the task's

(interrupt). It identifies which interrupt the task appropriate flag is set and the task is put in the waiting state by causing a task swap - the task would wait indefinitely for the interrupt if its

timeout variable would be set to 0 (NOT_TIMING). : intnum	 Represents the interrupt number associated calling task intends to wait

*					 *					 * * * Returns	 : None

with the given interrupt for which the

************************************************************************* void OS_WAITI(uchar intnum) { 	 	 	 // Disable interrupts EA = 0; switch (intnum) { */

#if (!STAND_ALONE_ISR_00) 		 		case 0: 			

// Interrupt number 0 // Task made to wait for external interrupt 0

			task[Running].intnum = EXT0_INT; 			QShift(); 			break; #endif

#if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) 		 		case 1: 			 // Interrupt number 1

			task[Running].intnum = TIM0_INT; 			QShift(); 			break; #endif #if (!STAND_ALONE_ISR_02) 		 		case 2: 			

// Task made to wait for timer 0 interrupt

// Interrupt number 2 // Task made to wait for external interrupt 1

			task[Running].intnum = EXT1_INT; 			QShift(); 			break;

162
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#endif

Appendix E

#if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) 		 		case 3: 			 // Interrupt number 3

			task[Running].intnum = TIM1_INT; 			QShift(); 			break; #endif #if (!STAND_ALONE_ISR_04) 		 		case 4: 			

// Task made to wait for timer 1 interrupt

// Interrupt number 4 // Task made to wait for serial port interrupt

			task[Running].intnum = SER0_INT; 			QShift(); 			break; #endif

#if ( (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) ) 		 		case 5: 			 // Interrupt number 5

			task[Running].intnum = TIM2_INT; 			QShift(); 			break; #endif 		

// Task made to wait for timer 2 interrupt

		default:

// Default action, do nothing

			EA = 1; 			break; 	} } /* * * *

************************************************************************* * Function name : OS_WAITT * Function type : Event-Waiting System call * Description : This system call causes a task to go in the waiting *				 * * Arguments	 number of RTOS ticks.

*				 state for a timeout period given by a defined

*					 *					 *					 *					 *					 * *

: ticks	

Represents the number of ticks for which the task will wait. Valid range for this parameter is 1 to 65535.

A zero waiting time parameter is set to 1 by the RTOS itself, since a zero would effectively kill the task, making it wait

*					forever. : None

* Returns	

************************************************************************* */

163
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
void OS_WAITT(uint ticks) { 	 	 	 	 	 	 } EA = 0; // Just a precaution

Appendix E

if (ticks == 0) ticks = 1; // waiting state.

// Task's timeout variable is updated and the task then enters the task[Running].timeout = ticks;

	QShift(); /* * * *

************************************************************************* * Function name : OS_WAITS * Function type : Event-Waiting System call * Description : This system call causes a task to wait for a signal to *			 *			 * arrive within a given number of RTOS ticks. If the signal is already present, the task continues

*			 to execute. * Arguments	 : ticks	

*					 *					 *					 *

Represents the number of ticks for which the

task will wait for a signal to arrive.

Valid range for this argument is 0 to 65535. A value of 0 means waiting forever for a

*					signal to arrive.

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

164
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* Returns	 * : None

Appendix E

************************************************************************* void OS_WAITS(uint ticks) { 	 	 	 	 EA = 0; */

// Disable interrupts // If signal already sent, clear the signal and continue to run task if (task[Running].flags & FLAG_SIG_RCVD) { EA = 1; task[Running].flags &= ~FLAG_SIG_RCVD;

		 		 	} 	 	 	

// If signal is not present send task to waiting state // by causing a task switch else {

		 		 	} } /* */ /* * * *

task[Running].flags |= FLAG_SIG_WAIT; task[Running].timeout = ticks;

		QShift();

*************************************************************************

************************************************************************* * Function name : OS_WAITP * Function type : Event-Waiting System call * Description : This system call is used by a task to wait for the *			 * * *

*			 already passed, the task continues to execute. * Arguments	 * Returns	 : None : None

end of its periodic interval. If the interval has

************************************************************************* void OS_WAITP(void) { 	 	 	 	 	 EA = 0; */

// Disable interrupts // If the periodic interval time has elapsed, clear flag and // the task continues to execute if ((task[Running].flags & FLAG_PERIODIC) == FLAG_PERIODIC) { task[Running].flags &= ~FLAG_PERIODIC; EA = 1;

		 		 	} 	 	

// Else put task into waiting state else { task[Running].flags |= FLAG_PERIODIC;

		 	} }

		QShift();

165
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* * * *

Appendix E

************************************************************************* * Function name : OS_PERIODIC * Function type : Event-Waiting System call * Description : This system call causes a task to repeat its function *				 * every given number of RTOS ticks.

* Arguments : ticks	 Represents the length of the periodic *				 *				 *				 * * * Returns	 : None

interval in terms of RTOS ticks, after which parameter is from 1 to 65535.

the task repeats itself. Valid range for this

************************************************************************* void OS_PERIODIC(uint ticks) { 	 	 	 	 	 	 	 	 	 	 } /* * * * // Disable interrupts EA = 0; // Just a precaution */

if (ticks == 0) ticks = 1;

// Initialise task's periodic interval count and reload vars task[Running].interval_count = ticks; task[Running].interval_reload = ticks; // Re-enable interrupts EA = 1;

************************************************************************* * Function name : OS_DEFER * Function type : Task Suspension System call * Description : This system call is used to stop the current task in *			 * * *

*			 order for the next task in the queue to execute. *			 waiting queue, just waiting for 2 ticks. * Arguments	 * Returns	 : None : None

In the meantime the current task is placed in the

************************************************************************* void OS_DEFER(void) { 	 	 	 EA = 0; */

// Disable interrupts

166
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
// Make task wait for 2 ticks, thus giving up its time for other tasks 	 } 	QShift(); /* * * * task[Running].timeout = 2;

Appendix E

************************************************************************* * Function name : OS_KILL_IT * Function type : Task Suspension System call * Description : This system call kills the current task, by putting it *			 *			 * * * * Arguments	 * Returns	 : None : None

*			 permanently waiting, such that it never executes again. It also clears any set waiting signals which the task might have.

************************************************************************* void OS_KILL_IT(void) { 	 	 	 	 	 EA = 0; */

// Disable interrupts // Clear task's flags

task[Running].flags = 0;

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It’s not what we do. It’s how we do it.

Impact matters.
navigant.com

©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

167
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 	 	 	 } // Set it to wait forever

Appendix E

task[Running].timeout = NOT_TIMING; // Set periodic interval count to zero (note reload is left intact!) task[Running].interval_count = 0;

// No longer wait for any interrupt event task[Running].intnum = NO_INTERRUPT; // Cause a task switch

	QShift(); /* * * * * * *

************************************************************************* * Function name : OS_RESUME_TASK * Function type : Inter-task Communication System call * Description : This system call is used to resume another KILLed task. * Arguments : tasknum	 Represents the task which is to be restarted. * Returns	 : None

************************************************************************* void OS_RESUME_TASK(uchar tasknum) { 	 	 	 	 // Disable interrupts EA = 0; */

// If task was periodic, resume periodic task if (task[tasknum].interval_reload != 0) { task[tasknum].interval_count = 1;

		 	} 	 	

// Otherwise resume a normal waiting task after 1 tick else { task[tasknum].timeout = 1;

		 	} 	 	 	 }

// Make RUNNING task wait for 2 ticks, task[Running].timeout = 2;

// thus giving up its time for other tasks

	QShift(); /* * * *

************************************************************************* * Function name : QShift * Function type : Context Switcher (Internal function) * Description : This function is used to perform a context switch *				 * i.e. voluntarily swaps task

168
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Arguments	 * * * Returns	 : None : None

Appendix E

************************************************************************* void QShift(void) using 1 { 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 uchar data i, temp; */

// Variables used below uchar data * idata internal; uchar data * idata qtask; uchar data * idata qptr; TinQFlag = 0;

// Clear task in queue flag // Save SP of current task temp = SP;

task[Running].stackptr = SP; // Save USED stack area of current task internal = MAINSTACK; i = 0; do {

		

} while (internal <= temp); qtask = ReadyQ;

task[Running].stack[i++] = *(internal++);

// Shift READY queue down by one position qptr = ReadyQ + 1;

		 	} 	 	

while (qtask <= ReadyQTop) { *qtask++ = *qptr++;

// Ensure that this pointer is never below the start of the READY queue 		 	 	 	 	 if (ReadyQTop < ReadyQ) ReadyQTop = ReadyQ;

ReadyQTop--; // Decrement pointer to last task in queue

	/*

If task priorities are enabled, the queue is sorted such that the the smallest task number.

highest priority task becomes the running task, i.e. the one having

	*/ 		 		 		

if (Priority == 1) {

// Scan just once through the list qptr = ReadyQTop; while (qptr > ReadyQ) { if (*qptr > *(qptr + 1)) { *qptr = *(qptr + 1); *(qptr + 1) = temp;

			qptr--; 			

				temp = *qptr; 				 				 		} 	} 	 	 	

			}

// The first task in the READY queue becomes the new running task Running = ReadyQ[0];

169
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 	 	 	 } /* * * * // The new running task's USED stack area is copied to internal RAM temp = task[Running].stackptr; internal = MAINSTACK; i = 0; do {

Appendix E

		

// Restore new running task's SP such that the new task will execute. SP = temp;

} while (internal <= temp);

*(internal++) = task[Running].stack[i++];

// Re-enable interrupts EA = 1;

************************************************************************* * Function name : RTOS_Timer_Int * Function type : Scheduler Interrupt Service Routine ( Tick Timer ) * Description : This is the RTOS scheduler ISR. It generates system *				 *				 * * * * Arguments	 * Returns	 : None : None

ticks and calculates any remaining waiting and periodic interval time for each task.

************************************************************************* #if (TICK_TIMER == 0) 	 	 	 	 	 	 uchar data k; */

void RTOS_Timer_Int(void) interrupt 1 using 1 { uchar data * idata q; bit data On_Q; // Reload timer registers TH0 = HiByte(BASIC_TICK); TL0 = LoByte(BASIC_TICK);

#elif (TICK_TIMER == 1) 	 	 	 	 	 	 uchar data k;

void RTOS_Timer_Int(void) interrupt 3 using 1 { uchar data * idata q; bit data On_Q; // Reload timer registers TH1 = HiByte(BASIC_TICK); TL1 = LoByte(BASIC_TICK);

#elif (TICK_TIMER == 2) 	 	 	 	 uchar data k;

void RTOS_Timer_Int(void) interrupt 5 using 1 { uchar data * idata q; bit data On_Q;

170
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 #endif // Clear timer 2 interrupt flag TF2 = 0;

Appendix E

// Loop over each task

for (k = 0; k < NOOFTASKS; k++) { // Update the task's periodic intervals (if applicable) if (task[k].interval_count != NOT_TIMING) {

		 		

			task[k].interval_count--; 			 			 			

// Has the periodic interval elapsed?

				task[k].interval_count = task[k].interval_reload; 				 		 		 		 // If the task has been waiting for the period to elapse, // place it in the READY queue (if not there already) if ((task[k].flags & FLAG_PERIODIC) == FLAG_PERIODIC) { task[k].flags &= ~FLAG_PERIODIC;

if (task[k].interval_count == NOT_TIMING) {

					

					q = ReadyQ; 					On_Q = 0; 					 						

while (q <= ReadyQTop) { if (k == *q) {

							On_Q = 1; 							break; 						} 					} 					 						q++; if (On_Q == 0) {

						ReadyQTop++;

						*ReadyQTop = k; 						TinQFlag = 1; 					} 				} 				 				 				 				

// If the task was not waiting for this event, // do not place in the ready queue. else {

					 			} 		} 		 		

				}

task[k].flags |= FLAG_PERIODIC;

// Update the task's timeout variables (if applicable) if (task[k].timeout != NOT_TIMING) {

			task[k].timeout--; 			 			 			 			

// If timeout elapses,

// place task in READY queue

				ReadyQTop++;

if (task[k].timeout == NOT_TIMING) {

				*ReadyQTop = k; 				TinQFlag = 1; 				 		} 	} 			} task[k].flags &= ~FLAG_SIG_WAIT;

171
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 } // If the idle task is running, and tasks are known to reside in the // queue, a task switch is purposely induced so these tasks can run. if ((TinQFlag == 1) && (Running == IDLE_TASK))

Appendix E

		QShift(); /* * * *

************************************************************************* * Function name : Xtra_Int_0 * Function type : Interrupt Service Routine * Description : This is the external 0 interrupt ISR whose associated *				 * * * * Arguments	 * Returns	 : None : None interrupt number is 0.

************************************************************************* #if (!STAND_ALONE_ISR_00) 	 	 } #endif EA = 0; */

void Xtra_Int_0(void) interrupt 0 using 1 { Xtra_Int(EXT0_INT); // Pass EXT0_INT for ident purposes

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There’s no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives — and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It’s why we employ 135 different nationalities. It’s why we’ve taken proactive steps to increase female representation at the highest levels. And it’s just one of the reasons why you’ll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

172
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* * * *

Appendix E

************************************************************************* * Function name : Xtra_Int_1 * Function type : Interrupt Service Routine * Description : This is the Timer 0 ISR whose associated interrupt *			 *			 * *			 *			 *		 *		 *		 *		 * * * *

number is 1. It is only enabled if the 8051 Timer 0 is not already being used as the RTOS scheduler.

Timer 0 interrupt is usually used for RTOS on the basic 8051.

*				

For the FLT-32 8032 it can only be used with the modified version 2 monitor EPROM, or you are intending to write it on an EEPROM, since it is used for the single step in the old version monitor EPROM.

* Arguments	 * Returns	

: None : None

************************************************************************* #if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) void Xtra_Int_1(void) interrupt 1 using 1 { 	 	 } #endif /* * * * ************************************************************************* * Function name : Xtra_Int_2 * Function type : Interrupt Service Routine * Description : This is the external 1 interrupt ISR whose associated *				 * * * * Arguments	 * Returns	 : None : None interrupt number is 2. EA = 0; */

Xtra_Int(TIM0_INT); // Pass TIM0_INT for ident purposes

************************************************************************* #if (!STAND_ALONE_ISR_02) 	 	 } EA = 0; */

void Xtra_Int_2(void) interrupt 2 using 1 { Xtra_Int(EXT1_INT); // Pass EXT1_INT for ident purposes

173
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#endif /* * * * ************************************************************************* * Function name : Xtra_Int_3 * Function type : Interrupt Service Routine * Description : This is the Timer 1 ISR whose associated interrupt *				 * * * * Arguments	 * Returns	 : None : None number is 3.

Appendix E

************************************************************************* #if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) void Xtra_Int_3(void) interrupt 3 using 1 { 	 	 } #endif /* * * * ************************************************************************* * Function name : Xtra_Int_4 * Function type : Interrupt Service Routine * Description : This is the serial port ISR whose associated interrupt *				 * * * * Arguments	 * Returns	 : None : None number is 4. EA = 0; */

Xtra_Int(TIM1_INT); // Pass TIM1_INT for ident purposes

************************************************************************* #if (!STAND_ALONE_ISR_04) 	 	 } #endif /* * * * ************************************************************************* * Function name : Xtra_Int_5 * Function type : Interrupt Service Routine * Description : This is the Timer 2 ISR whose associated interrupt EA = 0; */

void Xtra_Int_4(void) interrupt 4 using 1 { Xtra_Int(SER0_INT); // Pass SER0_INT for ident purposes

174
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
*				 * * * * Arguments	 * Returns	 : None : None number is 5.

Appendix E

************************************************************************* #if ( (CPU == 8032) && (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) ) void Xtra_Int_5(void) interrupt 5 using 1 { 	 	 	 } #endif /* * * * ************************************************************************* * Function name : Xtra_Int * Function type : Interrupt Handling (Internal function) * Description : This function performs the operations required by the *				 * previous ISRs. EA = 0; TF2 = 0; */

Xtra_Int(TIM2_INT); // Pass TIM2_INT for ident purposes

* Arguments : int_num	 Represents the flag mask for a given *				 *				 *				 *				 *				 * * * Returns	 : None

interrupt against which the byte

storing the flags of each task will be compared in order to determine whether any task has been waiting for the interrupt in question.

************************************************************************* void Xtra_Int(uchar int_num) using 1 { 	 	 	 	 	 	 uchar data k; IntFlag = 0; // To show if tasks have been affected by this interrupt // For each task */

for (k = 0; k < NOOFTASKS; k++) { // If task has been waiting for the given interrupt if (task[k].intnum == int_num) {			 // Clear the interrupt wait

		 		

			

			task[k].intnum = NO_INTERRUPT;			 			IntFlag = 1; 			ReadyQTop++; 		} 	} 			task[k].timeout = NOT_TIMING; 			*ReadyQTop = k;

175
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 // If the IDLE task is running, and tasks are known to reside in the // READY queue, task switch is purposely induced so tasks can run. if ((IntFlag == 1) && (Running == IDLE_TASK)) { TinQFlag = 1;

Appendix E

		 	} 	 	 	

		QShift();

// Otherwise if not IDLE task, the ISR exits after interrupts are // re-enabled, since RTOS cannot pre-empt task TinQFlag = 1; EA = 1; else if ((IntFlag == 1) && (Running != IDLE_TASK)) {

		 		 	} 	 	 } /*

// Otherwise exit normally else EA = 1;

************************************************************************* ************************************************************************* ************************************************************************* ************************************************************************* */

Real drive. Unreal destination.

As an intern, you’re eager to put what you’ve learned to the test. At Ernst & Young, you’ll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You’ll also get to test what you learn. Even better, you’ll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

© 2012 Ernst & Young LLP. All Rights Reserved.

176
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

Appendix E 	 MagnOS.C
This is the source listing of the RTOS program MagnOS (MAGNus Operating System, the latin word ‘magnus’ means great). It consists of: •	 The assembly language ‘include’ file MagnOS_A01.A51 •	 The main program MagnOS.c •	 The header file MagnOS.h •	 The header file Parameters.h MagnOS_A01.A51
; MagnOS_A01.A51 ; ; ; MagnOS RTOS PLUS MAIN PROGRAM ; STORES ALL TASK REGISTERS ; Written by Paul P. Debono - JUNE 2006 ; University of Malta ; Department of Communications and Computer Engineering ; MSIDA MSD 06; MALTA. ; Adapted and modified from the RTKB RTOS ; published in the book (CHAPTER 15) ; "C and the 8051 - 3rd Edition" ; ;

; by Thomas W. Schultz; Prentice Hall; ISBN 1-58961-237-X ; Accomodates many tasks, (take care of the stack size!) ; STACK MOVING VERSION - MOVES WORKING STACK IN AND OUT OF ; EXTERNAL MEMORY ; SLOWS DOWN RTOS, BUT DOES NOT RESTRICT TASK CALLS ;

; IDLE TASK (ENDLESS MAIN PROGRAM - TASK NUMBER = NOOFTASKS) ; THIS IS STILL A SMALL TEST VERSION RTOS. IT IS JUST USED FOR ; SHOWING WHAT IS NEEDED TO MAKE A SIMPLE RTOS. ; IT MIGHT STILL NEED SOME MORE FINE TUNING. ; IT HAS NOT BEEN THOROUGHLY TESTED !!!! ; WORKS FINE SO FAR. $NOMOD51 ; NO RESPONSABILITY IS TAKEN. #include "reg52.h" ; check your own correct path #include "Parameters.h" /* The MAINSTACK variable points to the start pointer in hardware stack and */ /* is defined in STARTUP.A51 */ extrn idata (MAINSTACK)

PUBLIC _SaveBank0, _RecallBank0 PUBLIC _SaveSFRs, _RecallSFRs PUBLIC POP5, POP0 PUBLIC POP5I, POP0I

177
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; RTOS ASSEMBLY CODE MACROS MAGNOS_DATA SEGMENT DATA RSEG MAGNOS_DATA TEMP1: DS 1 TEMP2: DS 1 TEMP3: DS 1 TEMP4: DS 1 TEMP5: DS 1 MAGNOS_ASM SEGMENT CODE RSEG MAGNOS_ASM POP5:

Appendix E

DEC SP ; BLANK TO POP UNUSED RETURN ADDRESS DEC SP POP PSW POP DPL POP DPH POP B POP ACC SETB EA RET ; JUMPS TO PREVIOUSLY PRE-EMPTIED TASK HERE

POP0:

DEC SP ; BLANK TO POP UNUSED RETURN ADDRESS DEC SP SETB EA

RET ; JUMPS TO PREVIOUSLY PRE-EMPTIED TASK HERE POP5I: DEC SP ; BLANK TO POP UNUSED RETURN ADDRESS DEC SP POP PSW POP DPL POP DPH POP B POP ACC SETB EA POP0I: RETI ; JUMPS TO PREVIOUSLY PRE-EMPTIED TASK HERE DEC SP ; BLANK TO POP UNUSED RETURN ADDRESS DEC SP SETB EA

RETI ; JUMPS TO PREVIOUSLY PRE-EMPTIED TASK HERE _SaveSFRs: MOV TEMP1,ACC ; STORE A IN TEMP1 MOV TEMP2,B ; STORE B IN TEMP2 MOV TEMP3,DPH ; STORE DPH IN TEMP3 MOV TEMP4,DPL ; STORE DPL IN TEMP4 MOV ACC,PSW ANL A, #0E7H ; ensure stored PSW refers to bank 0 --> RS0=RS1=0 BANK 0 MOV TEMP5,A ; STORE PSW in TEMP5 MOV DPH,0EH ; R6 bank 1

178
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MOV DPL,0FH ; R7 bank 1 MOV A,TEMP1 INC DPTR MOVX @DPTR,A ; SAVE ACC MOV A,TEMP2 INC DPTR

Appendix E

MOVX @DPTR,A ; SAVE B MOV A,TEMP3 INC DPTR

MOVX @DPTR,A ; SAVE DPH MOV A,TEMP4 INC DPTR

MOVX @DPTR,A ; SAVE DPL MOV A,TEMP5 RET

MOVX @DPTR,A ; SAVE PSW _RecallSFRs: MOV DPL,0Fh

MOV DPH,0Eh ; get task store address, R6 bank 1 MOVX A,@DPTR ; GET ACC INC DPTR

MOV TEMP1,A ; STORE A IN TEMP1 MOVX A,@DPTR ; GET B INC DPTR

MOV TEMP2,A ; STORE B IN TEMP2 MOVX A,@DPTR ; GET DPH

MOV TEMP3,A ; STORE DPH IN TEMP3

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

179
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
INC DPTR

Appendix E

MOVX A,@DPTR ; GET DPL INC DPTR

MOV TEMP4,A ; STORE DPL IN TEMP4 MOVX A,@DPTR ; GET PSW

MOV TEMP5,A ; STORE PSW IN TEMP 5 MOV ACC,TEMP1 ; RESTORE A MOV B,TEMP2 ; RESTORE B

MOV DPH,TEMP3 ; RESTORE DPH MOV DPL,TEMP4 ; RESTORE DPL MOV PSW,TEMP5 ; RESTORE PSW RET _SaveBank0:		 MOV DPH,0EH MOV DPL,0FH MOV A,0 MOVX @DPTR,A INC DPTR MOV A,1 ; Address high byte in R6, low byte in R7 bank 1

MOVX @DPTR,A INC DPTR MOV A,2

MOVX @DPTR,A INC DPTR MOV A,3

MOVX @DPTR,A INC DPTR MOV A,4

MOVX @DPTR,A INC DPTR MOV A,5

MOVX @DPTR,A INC DPTR MOV A,6

MOVX @DPTR,A INC DPTR MOV A,7 RET

MOVX @DPTR,A _RecallBank0: 			 MOV DPH,0EH MOV DPL,0FH MOV 0,A ; Address high byte in R6, low byte in R7 bank 1

MOVX A,@DPTR INC DPTR MOV 1,A

MOVX A,@DPTR INC DPTR MOV 2,A

MOVX A,@DPTR INC DPTR

MOVX A,@DPTR

180
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MOV 3,A

Appendix E

INC DPTR MOV 4,A

MOVX A,@DPTR INC DPTR MOV 5,A

MOVX A,@DPTR INC DPTR MOV 6,A

MOVX A,@DPTR INC DPTR MOV 7,A RET END

MOVX A,@DPTR

I joined MITAS because I wanted real responsibili� I joined MITAS because I wanted real responsibili�

Maersk.com/Mitas www.discovermitas.com

�e Graduate Programme for Engineers and Geoscientists

�e G for Engine

Ma

Real work International Internationa al opportunities �ree wo work or placements

Month 16 I was a construction Mo supervisor ina const I was the North Sea super advising and the No he helping foremen advis s solve problems Real work he helping fo International Internationa al opportunities �ree wo work or placements s solve pr
Click Click on on the the ad ad to to read read more more

181
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

MagnOS_V01.C
/*
*	 * * * * * *************************************************************************** MagnOS_V01.C RTOS KERNEL SOURCE CODE

* Pre-Emptive RTOS written in C by Ing. Paul P. Debono * ------------------------------------------------------------------------* For use with the 8051 family of microcontrollers * Notes: * Use NOOVERLAY in the linker BL51 Misc (Misc controls) options tab * Use NOAREGS in the compiler C51 (Misc controls) options tab *

* Timer to use for the RTOS ticks is user selectable, Timer 0, 1 or 2 * Naturally,	 * 		 * *		 Timer 2 can only be used with an 8032 CPU type. Baudrate generation Timer 1 can only be used if it is not required for

* Assign the correct values to * in parameters.h * application *

* 'STACKSIZE', 'TICK_TIMER', 'TICKTIME', 'CPU' and 'NOOFTASKS' * Most of the time you need only to change 'NOOFTASKS' to reflect the

* If it is noticed that timing parameters are not being met,the system's * Please adhere to the conditions mentioned in Parameters.H * * File : MagnOS_V01.C * Revision : 8 * By	 * * Date : February 2006

* TICKTIME can be modified by changing the value 'TICKTIME' in Parameters.H

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

*************************************************************************** */ /*

*************************************************************************** * 					INCLUDES */ *************************************************************************** #include <reg52.h> 		  				 /* /* 8052 Special Function Registers 8052 */ /* RTOS system calls definitions */ /* (IN PROJECT DIRECTORY)*/

#include <MagnOS_V01.H> 	

182
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
*************************************************************************** * 				FUNCTION DEFINITIONS *************************************************************************** */ void V_TaskChange (void); /* used internally by the RTOS */ void PE_TaskChange (void); /* used internally by the RTOS */ /* *************************************************************************** * 		 STATUS FLAG DEFINITIONS /* if more flags are needed, use spare bits from status1 or status2 * variable *************************************************************************** */ /* status1 – has some free bits for future expansion */ #define #define #define #define WAIT4I_F 	 WAIT4V_F 	 WAIT4S_F 	 WAIT4M_F 	 0x01 0x02 0x04 0x08 /* /* /* /* bit bit bit bit 00 01 02 03 task task task task waiting waiting waiting waiting for an interrupt */ periodic interval */ for a semaphore */ for a message */

Appendix E

/* status2 – has some free bits for future expansion */ #define #define #define #define PREEMP_F 	 0x01 FIRST_TIME_F 	 0x02 TASK_KILLED_F 	 0x04 NO_MBOX_FREE_F 	 0x08 /* /* /* /* bit bit bit bit 00 01 02 03 task was pre-emptied */ task running the first time */ task killed */ no mailbox space */

struct task_param xdata task[NOOFTASKS + 1]; struct letter xdata mbox[MBXSIZE]; /* 			 /* /* MBXSIZE messages: destination, source, length */

plus 16 data characters per message */

*************************************************************************** * 				GLOBAL VARIABLES */ *************************************************************************** bit bdata TinQFlag; 			

/* Flag indicating new higher priority task timed out and */ /* put in ReadyQ */		 uchar data Resource[8]; 		 uchar data Running;	 /* */ /* 		 // 8 resources available // Current task number		

uchar data * data ReadyQTop;		 uchar data ReadyQ[NOOFTASKS + 3];	

// Address of last ready task (point) // Queue stack for tasks ready to run	

***************************************************************************

*************************************************************************** * RTOS FUNCTION DEFINITIONS */ ***************************************************************************

183
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* * * *

Appendix E

*************************************************************************** * Function name : OS_INIT_RTOS * Function type : Initialisation System call * Description 	: This system call initialises the RTOS variables, task *			 * * Arguments 	 SPs and enables any required interrupts

* 			 * 			 * 			 * *

: iemask Represents the interrupt enable mask which is Its value determines which interrupts will be enabled during the execution of the user's

used to set up the IE special function register.

* 			application. * Returns 	 : None

*************************************************************************** */ {	 	 	 void OS_INIT_RTOS(uchar iemask) uchar data i,j; #if (TICK_TIMER == 2)	

	 IE = (iemask & 0x7f) | 0x20;

/* Set up 8051 IE register, using timer 2 */

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

184
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
 	 	 IP = 0x20; 	 /* Assign scheduler interrupt high priority */	     IE = (iemask & 0x7f) | 0x08;

Appendix E

	  #elif (TICK_TIMER == 1)				 /* Set up 8051 IE register, using timer 1 */ 	

	 IP = 0x08; 	 /* Assign scheduler interrupt high priority */	 	 IE = (iemask & 0x7f) | 0x02; #elif (TICK_TIMER == 0)				

/* Set up 8051 IE register, using timer 0 */ 	#endif 	 	 	 	

	 IP = 0x02; 	 /* Assign scheduler interrupt high priority */	

Running = IDLE_TASK;	 {

/* Set idle task as the running task */

for (i=0; i <= NOOFTASKS; i++) 		 task[i].catalog = i; 		 task[i].status1 = ZERO; /* task id */

 		  	  	  	 	 	 	 	

/* status flags, see below for details */ /* status flags, see below for details */ task[i].semaphore = ZERO; task[i].resource = FREE; task[i].status2 = ZERO;

task[i].priority = LOWEST; /* priority flag */

/* counting semaphore for each task */ /* resources requested for each task */ task[i].intnum = NO_INTERRUPT; task[i].timeout = NOT_TIMING;

task[i].stackptr = MAINSTACK + 1; /* SP storage */

/* task not waiting for any interrupt */ /* task not waiting for any timeout */

		 task[i].interval_count = ZERO; /* task not periodic */ 		 task[i].interval_reload = ZERO; /* periodic interval reload value */ /* clear registers storage area */  	  	  	 	 task[i].rega = ZERO; task[i].regb = ZERO; task[i].rdph = ZERO; task[i].rpsw = ZERO; task[i].reg0 = ZERO; task[i].reg1 = ZERO; task[i].reg2 = ZERO; task[i].reg3 = ZERO; task[i].reg4 = ZERO; task[i].reg5 = ZERO; task[i].reg6 = ZERO; task[i].reg7 = ZERO; for (j=0;j<STACKSIZE;j++) task[i].stack[j]=ZERO; }					 ReadyQ[i] = IDLE_TASK;	 /* Fill the READY queue */	 /* with the idle task */

	 task[i].rdpl = ZERO;  	  	  	  	  	  	  	  	  	 	

/* clear stack storage area */ 		

185
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 ReadyQ[NOOFTASKS + 1] = IDLE_TASK; ReadyQ[NOOFTASKS + 2] = IDLE_TASK; ReadyQTop = ReadyQ;	 /* Pointer to last task made to point to */ /* base of the queue. */

Appendix E

				

/* Now clear mailboxes */   {  	  	  	 	  	 for (i=0;i<MBXSIZE;i++) mbox[i].dest = FREE;

mbox[i].src = FREE;	  mbox[i].len = ZERO;	    for(j=0;j<DATASIZE;j++)

	}

  mbox[i].dat.string.s[j] = ZERO;

/* Now clear resources */ for (i=0;i<NOOFRESOURCES;i++)   { 	 } /* */ /* * * * *************************************************************************** 	 Resource[i] = FREE; }

*************************************************************************** * Function name : OS_CREATE_TASK * Function type : Initialisation System call * Description : This system call is used in the main program for each * 			 * *				 task to be created for use in the application.

* Arguments : 	task_num Represents the task number * 		 * * 		 (1st task is numbered as 0). task_add	

* 				

Represents the task's start address, which in the C environment, would simply be the name of the

*					 *		 * *

* 				procedure * 			 * Returns : None

task_priority Represents the priority of the task

0 is low priority, 255 is the highest (top) priority

************************************************************************** */ void OS_CREATE_TASK(uchar task_num, uint task_add, uchar task_priority) {		

186
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 	 ReadyQTop++; /* Increment queue pointer. Task is added to next */	 *ReadyQTop = task_num;/* available position in the READY queue.*/	 task[task_num].stack[0] = LoByte(task_add); /* Little Endian */	 task[task_num].stack[1] = HiByte(task_add); /* Low byte first */ task[task_num].priority = task_priority; task[task_num].catalog = task_num; task[task_num].status2 |= FIRST_TIME_F;

Appendix E

/* task running for 1st time */ } /* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_RTOS_GO * Function type : Initialisation System call * Description 	 : This system calls is used to start the RTOS going such * 			 * * * *				 * Arguments 	 * Returns 	 that it supervises the application processes.

: None		 : None

************************************************************************** */ { 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 void OS_RTOS_GO(void) #if (TICK_TIMER == 2)			

RCAP2H = HiByte(BASIC_TICK);	 /* Configures Timer 2 in 16-bit 	 T2CON = 0x84; /* TR2 = TF2 = 1 */				 #elif (TICK_TIMER == 0) TH0 = HiByte(BASIC_TICK);	 TMOD &= 0xF0; 	 TL0 = LoByte(BASIC_TICK);	 TMOD |= 0x01;		 TR0 = 1; 	 /* Configure Timer 0 in 16-bit 	 /* timer mode for the 8051 	 */

RCAP2L = LoByte(BASIC_TICK);	 /* auto-reload mode for the 8032 	

*/ */

*/

/* Clear T0 mode control, leaving T1 untouched */ /* Start timer 0 */ /* Set T0 mode control */		

TF0 = 1;			 #elif (TICK_TIMER == 1)

/* Cause first interrupt immediately */	

TMOD &= 0x0F; /* Clear T1 mode control, leaving T0 untouched */ TMOD |= 0x10;		 TR1 = 1; 		 /* Set T1 mode control */		 /* Start timer 1 */

TH1 = HiByte(BASIC_TICK);	 TL1 = LoByte(BASIC_TICK);	

/* Configure Timer 1 in 16-bit 	 /* timer mode for the 8051 	 */

*/

187
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 TF1 = 1;			 /* Cause first interrupt immediately */	

Appendix E

	#endif 	 	 } 		 TinQFlag = 1; /* Signals scheduler that tasks have been	 EA = 1;	 /* added to the READY queue, so that they may start to run. */ */

/* Interrupts are enabled, starting the RTOS at this point. */ /* */ /*

**************************************************************************

************************************************************************** * Function name : OS_CHECK_TASK_PRIORITY * *

* Function type : Inter-task Communication System call * Description : This system call is used to get the priority of the *				 requested task. * * * * Arguments : None * Returns : Relevant task priority ************************************************************************** */

188
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
uchar OS_CHECK_TASK_PRIORITY(uchar task_num) { 	 } /* */ /* * * * return task[task_num].priority;

Appendix E

**************************************************************************

************************************************************************** * Function name 	 * Function type 	 * Description 		 * * * : OS_CHANGE_TASK_PRIORITY : Inter-task Communication System call : This system call is used to change the priority of the

*				 requested task. * Arguments 		 * Returns 		 : None : None

************************************************************************** */ { void OS_CHANGE_TASK_PRIORITY(uchar task_num, uchar new_prio) 	 	 } 	 EA=0; EA=1;

task[task_num].priority = new_prio;

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_RUNNING_TASK_ID * Function type : Inter-task Communication System call * Description 	 : This system call is used to check to get the number of * 			 * * * Arguments 	 * Returns 	 * the current task.

: None : Number of currently running task from which it must be called

* 			

************************************************************************** */ { 	 } uchar OS_RUNNING_TASK_ID(void) return (Running);

189
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* */ /* * * *

Appendix E

**************************************************************************

************************************************************************** * Function name : OS_CHECK_TASK_SEMA4 * Function type : Inter-task Communication System call * Description 	 : This system call is used to get the semaphore of the *				 requested task. * * * * Arguments 	 * Returns 	 : None : Relevant task semaphore

************************************************************************** */ { 	 } /* */ /* * * * uchar OS_CHECK_TASK_SEMA4(uchar task_num) return task[task_num].semaphore;

**************************************************************************

************************************************************************** * Function name : OS_SEMA4_PLUS * Function type : Add Units to a Semaphore System call * Description 	 : This system adds units to a semaphore of a particular * 			task * 			 * * Arguments 	 * 		 * * No task change is involved Represents the task number

: task_num		   units 	 : None

Number of units to add to semaphore

* Returns 	

****************************************************************************/ void OS_SEMA4PLUS (uchar task_num, uchar units) { EA = 0; 	

if (units > (255-task[task_num].semaphore)) else task[task_num].semaphore += units; EA = 1; } task[task_num].semaphore = MAXSEM;

190
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* */ /* * * *

Appendix E

**************************************************************************

************************************************************************** * Function name : OS_SEMA4_MINUS * Function type : Subtracts Units to a Semaphore System call * Description 	 : This system subtracts units from semaphore of particular * 		  * 		 * * 		  * Arguments 	 * *   task If semaphore reaches ZERO, a voluntary task switch is invoked

* 			

: 	

task_num	 units 		

Represents the task number

Number of units to add to semaphore

* Returns : None ************************************************************************* */ { void OS_SEMA4MINUS (uchar task_num, uchar units)   uchar data i, temp;	

  uchar idata * idata internal;

Brain power

By 2020, wind could provide one-tenth of our planet’s electricity needs. Already today, SKF’s innovative knowhow is crucial to running a large proportion of the world’s wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

191
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
EA = 0; /*	 	 store current task registers just in case task change is required */ RS0 = 1; /* USE BANK 1 */

Appendix E

	SaveSFRs(&task[Running].rega);	 	SaveBank0(&task[Running].reg0); 	 RS0 = 0; /* RETURN TO BANK 0 */ task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ /* Current task's USED stack area is saved */ 		 		 		 i = 0;

		 		

do { 					

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

if (units > task[task_num].semaphore) task[task_num].semaphore = ZERO; else task[task_num].semaphore -= units; { 	 	 	 if ((task[task_num].semaphore==ZERO)&&(task[task_num].status1&WAIT4S_F)) 	 	 task[task_num].status1 &= ~WAIT4S_F;	 /* clear flag	 */

/* mark task as NOT pre-emptied */ task[Running].timeout = 5; /* Either use */ /* or use */ //	 //	

task[Running].status2 &= ~PREEMP_F;

task[task_num].timeout = 1;

//	 task[task_num].timeout = NOT_TIMING;	 /* clear flag	 */ ReadyQTop++; *ReadyQTop = task_num;

/* place the task which had been waiting for */ /* the semaphore in the ReadyQ */ 	 	} } EA = 1; V_TaskChange();

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : 	 * Function type : 	 * Description 	 : 	 * 			 * 			 * 			 OS_WAIT4SEM Event-Waiting System call This system call causes a task to wait for a semaphore to reach zero (within a given timeout), calling a voluntary task change. 0 timeout implies wait forever. If the semaphore is

*				 already zero, the task continues to execute.

192
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
*

Appendix E

* Arguments : ticks		 * 			 *			 *			 * * * Returns 	 : 	

task will wait for the semaphore. Valid range for this argument is 0 to 65535. A value of 0 means waiting forever for the semaphore. None

Represents the number of ticks for which the

************************************************************************** */ { void OS_WAIT4SEM (uint ticks) 	 uchar data i, temp;	 EA = 0;	 RS0 = 1; /* use bank 1 */

		 	 	

uchar idata * idata internal;

/* store current task registers just in case task change is required */ /* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

/* Current task's SP is saved */ i = 0;

		 		 	 	

do { 		   /* Current task's USED stack area is saved */		 } while (internal<=temp); task[Running].stack[i++] = *(internal++);	

if (!task[Running].semaphore) 	

		 	 	} 	 	

{						 /* zero it clears the */

/* If semaphore already */

task[Running].status1 &= ~WAIT4S_F;	 /* flag and the task */		 /* continues to run. */

EA = 1;				

	else 		 		 	 	 }

{					 /* If semaphore is not present */	 task[Running].status1 |= WAIT4S_F; /* task is sent in the */ task[Running].timeout = ticks; /* waiting state, setting */ /* a task switch. 	 */

task[Running].status2 &= ~PREEMP_F; /* mark task NOT pre-emptied */ V_TaskChange();			

	}								 /* */ /* *

**************************************************************************

**************************************************************************

193
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Function name : OS_RELEASE_RES * * * Function type : Releases a resource System call * Description 	 : This system releases a resource for other tasks to use * 		   If there are other tasks waiting, the task with the * 		 * * * * 		   task switch is invoked * Arguments 	 * Returns : None ************************************************************************** */ { void OS_RELEASE_RES (uchar Res_Num) uchar data i, temp, tp;	 bit found; EA = 0; /* store current task registers just in case task change is required */ 	 	 	 	 RS0 = 1; /* USE BANK 1 */ SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* RETURN TO BANK 0 */ : res_num		     highest priority is made ready to execute and a voluntary

Appendix E

Represents the resource number

uchar idata * idata internal;

		 		 		  	 	 i = 0;

task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ /* Current task's USED stack area is saved */

			task[Running].stack[i++] = *(internal++);	 			} while (internal<=temp); 	 	 tp=0; found=0;

do { 					

/* first find highest priority task that was waiting for this resource */ /* or variable to be free */     {  	 	 	 	 } for(i=0;i<NOOFTASKS;i++)

    if ((task[i].resource==Res_Num) && task[i].priority>tp) { temp=i; tp= task[i].priority; found=1;

}

if(found) 	  	 	 	 		 {

/* temp now contains task number of the highest priority */ /* task that was waiting for the resource */

//	 task[temp].status1 &= ~WAIT4R_F;	 /* clear flag	 */ task[temp].resource = FREE;

Resource[Res_Num] = temp;/* mark resource as being used by new task */

194
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* mark task no longer waiting for resource */ 	 	 // 	

Appendix E

task[Running].timeout = 3; /* put running task as waiting timeout */

task[Running].status2 &= ~PREEMP_F; /* mark task as NOT pre-emptied */ task[temp].timeout = 1;

/* Either use */ /* or use */ 	 	 	 	 } else { 	 	 } }

	 task[temp].timeout = NOT_TIMING;	 /* clear flag	 */ ReadyQTop++; *ReadyQTop = temp; 	 /* place the task which had been waiting for */ 			 /* the semaphore in the ReadyQ */ V_TaskChange();

Resource[Res_Num] = FREE; EA = 1;

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_WAIT4RES * Function type : Event-Waiting System call * Description 	 : This system call causes a task to wait for a resource to * 		 * 		   calling a voluntary task * 			 * If the resource is     become zero (within a given timeout),

* 		   change. 0 timeout implies wait forever. *				 already available, the task continues to execute. * Arguments 	 : ticks	 	 Represents the number of ticks for which the this argument is 0 to 65535. A value of 0 means

* 				 * 				 * * * Returns 	 : None

*					

task will wait for the semaphore. Valid range for

waiting forever for the semaphore.

************************************************************************** */ { 	 	 void OS_WAIT4RES (uchar Res_Num,uint ticks) uchar data i, temp;	 EA = 0;	

uchar idata * idata internal;

195
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* store current task registers just in case task change is required */ 	 /* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ /* Current task's USED stack area is saved */		 RS0 = 1; /* use bank 1 */

Appendix E

/* Current task's SP is saved */ i = 0;

		 		 	 	

do { 			

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

if (Resource[Res_Num]==FREE) /* If resource already */ Resource[Res_Num]=Running;	

		 	 	

{						 /* available it takes the */ task[Running].resource=FREE;

/* resource and the task */			 /* continues to run. */

	} 	

EA = 1;						

	else //		

{					 /* If resource is being used */	 task[Running].status1 |= WAIT4R_F; task[Running].resource = Res_Num; task[Running].timeout = ticks;

/* the task is sent in the */ 		 		

/* waiting state, task change */

/* mark task as NOT pre-emptied */ 	 }

task[Running].status2 &= ~PREEMP_F;

	}								 /* */ /* * * *

V_TaskChange();			

/* a task switch. 	

*/

*************************************************************************

************************************************************************* * Function name : OS_SEND_MSG * Function type : task suspension system call * Description 	 : this system call sends a message to another task *				 * * Arguments 	 * 		 * * Returns 	 change is invoked.

* 		   If other task was already waiting, a voluntary task

:  message, with the following structure :   none

    struct letter{uchar dest,src;union dataformat dat;}

***************************************************************************/

196
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
void OS_SEND_MSG(struct letter xdata *msg) { uchar i,j,temp,dest_task,msg_len; uchar idata * idata internal; bit waiting,mboxfree; EA=0; /* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there isa need for a voluntary task swap */ 	SaveSFRs(&task[Running].rega);	 	SaveBank0(&task[Running].reg0); 	 	 	 i = 0; RS0 = 0; /* use bank 0 */ RS0 = 1; /* use bank 1 */

Appendix E

task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

		 		 i=0;

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

waiting=0;

dest_task = msg[0].dest; msg_len = msg[0].len;  	  		 do {

if((mbox[i].dest==dest_task) && (mbox[i].src==FREE) && (mbox[i].len==ZERO) &&

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT… RUN FASTER. RUN LONGER.. RUN EASIER…
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

22-08-2014 12:56:57

197
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
(task[dest_task].status1 & WAIT4M_F))

Appendix E

/* there is already task waiting for message */    voluntary task change */ 	 waiting=1; {

/* Hence transfer message, clear mailbox and make a 		  	  	  	  	

mbox[i].src = msg[0].src; mbox[i].len = msg_len; for (j=0;j<msg_len;j++)

/* Place the task that was waiting for message, in Ready Q */ /* Leave the WAIT4M_F still set, since it will be used */ /* and cleared later on */ /* Either use */ 		 		 //	 /* by the GET_MSG routine */ task[dest_task].timeout = NOT_TIMING;

mbox[i].dat.string.s[j] = msg[0].dat.string.s[j];

		 ReadyQTop++; /* or use */ 		

/* mark task as NOT waiting for timeout */ *ReadyQTop = dest_task;

task[dest_task].timeout = 1;

/* mark task as waiting for 1 timeout */

/* and then the task change is made here */

/* where the running task enters a waiting state */

/* The mailbox has to be cleared by issuing the 'clear message command' */ /* immediately after using the 'wait message' command */ 		 	 task[Running].timeout = 2; /* This is done automatically when you use the 'wait4msg' command */ task[Running].status2 &= ~PREEMP_F; V_TaskChange();		 /* a task switch. 	 */

/* mark task as NOT pre-emptied */ 	 		} 		 	 i++;

/* Else, find free mailbox location /* and leave message */ if(!waiting) { i=0; do

} while((i<MBXSIZE) && !waiting);

  mboxfree=0;    { 	 	

/* there is a free mailbox location */ {

			  		  		  		  		  		

if((mbox[i].dest==FREE) && (mbox[i].src==FREE) && (mbox[i].len==ZERO)) mboxfree=1;

mbox[i].dest = dest_task; mbox[i].src = msg[0].src; mbox[i].len = msg[0].len; for (j=0;j<msg_len;j++)

198
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
 	 	 } mbox[i].dat.string.s[j] = msg[0].dat.string.s[j]; i++;

Appendix E

		}  	 EA=1;

} while ((i<MBXSIZE) && !mboxfree);

}

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_CLEAR_MSG * Function type : Task suspension system call * Description 	 : This system call clears a message from mailbox for a task * 		  number * * * * Arguments 	 * Returns 	

: task number : none

************************************************************************** */ { void OS_CLEAR_MSG(uchar task_num) uchar i; EA=0;

  for(i=0;i<MBXSIZE;i++) {  	  	  	  	    }   } } EA=1;

   if((mbox[i].dest==task_num)&&(mbox[i].src!=FREE)&&(mbox[i].len!=ZERO)) /* find relevant mailbox */ mbox[i].dest = FREE; mbox[i].src = FREE; mbox[i].len = ZERO;

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_CHECK_MSG * Function type : Check message presence system call

199
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Description 	 : System call checks if there is a message for task in * 		 *     mailbox

Appendix E

* Arguments 	 * 		 *

    struct letter{uchar dest,src,len;union dataformat dat;} : bit 1 if messge present

: message, with the following structure

* Returns 	 *

* 		   bit 0 if message not present ************************************************************************** */ { bit OS_CHECK_MSG(uchar task_num) if((mbox[task_num].dest==Running) && mbox[task_num].len>ZERO) 	 	 else } return (1); return (0);

/* */ /*

**************************************************************************

*************************************************************************** * Function name : OS_GET_MSG * *

* Function type : Get message from mailbox system call

This e-book is made with

SetaPDF

SETASIGN

PDF components for PHP developers

www.setasign.com
200
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* Description 	 : System call checks if there is a message for task in * mailbox *

Appendix E

* Arguments 	 * 		 *

    struct letter{uchar dest,src,len;union dataformat dat;} : bit 1 if messge present

: message, with the following structure

* Returns 	 *

* 		   bit 0 if message not present ************************************************************************** */ { void OS_GET_MSG(struct letter xdata *msg) uchar i,temp,j; bit present; EA = 0; do  	 	 { */ 	 	 {

i=present=0;

if((mbox[i].dest==Running) && mbox[i].len>ZERO && (task[Running].status1 & WAIT4M_F)) /* If message was waiting for message, and then the message was placed*/ later by a send message command */ present = 1; /* get message, clear mailbox and return to same task */ msg[0].dest = mbox[i].dest;	 msg[0].src = mbox[i].src;		 for (j=0;j<temp;j++) /* task number of destination */ /* task number of source */

 	  	  	  	

 		  	  	  	  	  	 } i++;

msg[0].len = temp = mbox[i].len;

 			

msg[0].dat.string.s[j] = mbox[i].dat.string.s[j];

mbox[i].dest = FREE; /* clear space in mailbox */ mbox[i].src = FREE; mbox[i].len = ZERO; task[Running].status1 = ZERO; task[Running].status2 = ZERO;

} while ( (i<MBXSIZE) && !present ); EA = 1; /* */ /* * * * }

**************************************************************************

************************************************************************** * Function name : OS_WAIT_MESSAGE * Function type : task waiting for message system call

201
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Description 	 : this system call waits for a message * * Arguments 	 * Returns 	 * : message, with the following structure : none

Appendix E

* 		   struct letter{uchar dest,src,len;union dataformat dat;}

************************************************************************** */ { void OS_WAIT_MESSAGE(struct letter xdata *msg, uint ticks) uchar i,j,temp;

uchar idata * idata internal; bit present,mboxfree; EA=0; /* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case*/ /* there is a need for a voluntary task swap */ SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ 	 	 i = 0; task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ 	 RS0 = 1; /* use bank 1 */

		 		 do  	 	 { {

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

i=present=0;

if((mbox[i].dest==Running) && mbox[i].len>ZERO) /* If message already present */ present = 1;

	

/* get message, clear mailbox and return to same task */  	  	  	  	  	  	  	  	  	   } msg[0].dest = mbox[i].dest;	 msg[0].src = mbox[i].src;		     for (j=0;j<temp;j++) /* task number of destination */ /* task number of source */

msg[0].len = temp = mbox[i].len;

 		

msg[0].dat.string.s[j] = mbox[i].dat.string.s[j];

mbox[i].dest = FREE; /* clear space in mailbox */ mbox[i].src = FREE; mbox[i].len = ZERO; task[Running].status1 = ZERO; task[Running].status2 = ZERO;

 i++;

} while ( (i<MBXSIZE) && !present );

202
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* it executes this code if no message was present, */ /* hence it has to wait */ if (!present) {

Appendix E

i=mboxfree=0;   { 	  	  	 	  	  	  	 	 do

if((mbox[i].dest==FREE) && (mbox[i].src==FREE) && (mbox[i].len==ZERO)) /* If mailbox available */ { mboxfree=1;

mbox[i].dest = Running; /* book mailbox by setting destination */ mbox[i].src = FREE; mbox[i].len = ZERO; /* task change made here */

/* and the task then enters the waiting state */ 					 /* flag used also by OS_GET_MSG */ task[Running].timeout = ticks; V_TaskChange();			 } i++; } task[Running].status2 &= ~PREEMP_F; /* mark task as NOT pre-emptied */ /* a task switch. 	 */ task[Running].status1 |= WAIT4M_F; /* mark task as waiting for message */

} while((i<MBXSIZE) && !mboxfree);

/* if no spare mailboxes, signal flag and return */

In the past four years we have drilled

81,000 km
That’s more than twice around the world.
Who are we?
We are the world’s leading oilfield services company. Working globally—often in remote and challenging locations—we invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

203
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
if ( !present && !mboxfree ) EA = 1; } /* */ /* * * * **************************************************************************

Appendix E

 	

task[Running].status2 |= NO_MBOX_FREE_F; /* mark space for mailbox */

************************************************************************** * Function name : OS_WAITT * Function type : Event-Waiting System call * Description 	 : This system call causes a task to go in the waiting state * 		   for a timeout period given by a defined number of *		 * 	 RTOS ticks.

* Arguments 	

* 					 * 					

: ticks		

Represents the number of ticks for which the is 1 to 65535.

task will wait. Valid range for this parameter A zero waiting time parameter is set to 1 by the RTOS itself, since a zero effectively kills the task, making it wait forever.

*					 *			 		 * 					 * * * Returns : None

************************************************************************** */ { 	 	 void OS_WAITT (uint ticks) uchar data i, temp;	 EA = 0;

		

uchar idata * idata internal;

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ * there is a need for a voluntary task swap */ 	SaveSFRs(&task[Running].rega);	 	SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ 	 	 i = 0;

   RS0 = 1; /* use bank 1 */

task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

		 		 	 	 		

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=temp); ticks = 1;		

if (ticks == 0)			 task[Running].timeout = ticks;

/* Task's timeout variable is updated */

204
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* and the task then enters the	 waiting state */

Appendix E

task[Running].status2 &= ~PREEMP_F; /* mark task as NOT pre-emptied */ V_TaskChange();			 /* Make a voluntary task change */

}

/* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_WAITP * Function type : Event-Waiting System call * Description 	 : This system call is used by a task to wait for the end of * 		   its periodic interval. *		 * * *     execute. : None : None *		   If the interval has already passed, task continues to

* Arguments 	 * Returns 	

************************************************************************** */ { 	 void OS_WAITP(void) unsigned char i,temp; EA = 0;

		 		

uchar idata * idata internal;

/* store current task bank 0 registers just in case there is */ /* a need for a voluntary task swap */ RS0 = 1; /* USE BANK 1 */ SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* RETURN TO BANK 0 */ 	 	 	 i = 0; task[Running].stackptr = temp = SP;	 /* Current task's SP is saved */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ /* Current task's USED stack area is saved */

		 		

do { 					

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* if periodic interval has not yet passed, as is generally the case */ { 	 task[Running].status1 |= WAIT4V_F;	 /* set task to wait */ 	 task[Running].status2 &= ~PREEMP_F; /* mark task as NOT pre-emptied */ 	 V_TaskChange();	 /* make a voluntary context switch */

if (!(task[Running].status2 & WAIT4V_F))

205
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
} else 				 /* if periodic time already elapsed, */ { task[Running].status2 &= ~WAIT4V_F; /* clear waiting flag and */ EA = 1; /* do nothing else and continue running */ 	 }	 } /* ************************************************************************** */ /* ************************************************************************** * * Function name : OS_PERIODIC * * Function type : Event-Waiting System call * * Description 	 : This system call causes a task to repeat its function * 		   every given * 		   number of RTOS ticks. * * Arguments 	 * 				 * 				 *				 * : ticks	 interval in terms 	

Appendix E

Represents the length of the periodic

* 				itself.

of RTOS ticks, after which the task repeats Valid range for this parameter is 1 to 65535.

206
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* Returns 	 * : None

Appendix E

************************************************************************** */ { 	 	 	 	 void OS_PERIODIC (uint ticks) EA = 0;

if (!ticks) ticks = 1;	 	

/* Task's periodic interval count */

task[Running].interval_count = ticks;

/* just a pre-caution */

/* and reload variables are initialised.	 	EA = 1;			 } /* */ /* * * *

task[Running].interval_reload = ticks;

*/

**************************************************************************

************************************************************************** * Function name : OS_WAITI * Function type : Event-Waiting System call * Description 	 : This system call causes a task to wait for a given event * 		   (interrupt). It identifies *		 *		 *		 *		 *		 *   - the task's appropriate   a task swap - the task   would be set to 0 *		   for which interrupt the task has to wait. Once identified *		   flag is set and the task is set in the waiting state by causing *		   would wait indefinitely for the interrupt as its timeout variable   (NOT_TIMING) either during initialisation of the RTOS or after   prior invocations of wait-inducing system calls. : intnum 	 Represents the interrupt number associated with interrupt for which the calling task intends to

*		   expiry of its timeout period due to other

* Arguments 	

* 				the given * 				 * * * 				wait * Returns 	 : None

************************************************************************** */ void OS_WAITI(uchar int_num) unsigned char i,temp; EA = 0;	

{ 							 			 	 	 uchar idata * idata internal;

							

207
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	  	  	 switch (int_num) { #if (!STAND_ALONE_ISR_00)

Appendix E

		 		 	

task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ task[Running].intnum = EXT0_INT;	

case 0: /* Interrupt number 0 */

						 /* external interrupt 0 */ RS0 = 1; /* use bank 1 */

/* Task made to wait for */

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK;

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */ i = 0; do { 			 /* Current task's USED stack area is saved */		

		 		 	 	 	  	  	

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* mark task as NOT pre-emptied */ 		 break;

task[Running].status2 &= ~PREEMP_F; V_TaskChange();			 #endif /* Make a voluntary task change */

		 		 		 	

#if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ 			 	 /* timer 0 interrupt */ case 1: /* Interrupt number 1 */

task[Running].intnum = TIM0_INT; /* Task made to wait for */

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK;

RS0 = 1; /* use bank 1 */

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */ 	 i = 0;

 	

		 		 	

do { 		

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* Current task's USED stack area is saved */		

/* mark task as NOT pre-emptied */

task[Running].status2 &= ~PREEMP_F;

208
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 V_TaskChange();			 /* Make a voluntary task change */

Appendix E

		break;  	  	 	 #endif

		 		 	

#if (!STAND_ALONE_ISR_02)

task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ task[Running].intnum = EXT1_INT; 	

case 2: 			

/* Interrupt number 2 */

								 RS0 = 1; /* use bank 1 */

/* Task made to wait for */

/* external interrupt 1 */

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK;

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */ 	 i = 0; do { 		 /* Current task's USED stack area is saved */		

 	

		 		 	 	 	  	  	

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* mark task as NOT pre-emptied */ 		 break;

task[Running].status2 &= ~PREEMP_F; V_TaskChange();			 #endif /* Make a voluntary task change */		

		 		

#if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ task[Running].intnum = TIM1_INT; 	 case 3: /* Interrupt number 3 */

						 /* timer 1 interrupt */ RS0 = 1; /* use bank 1 */

/* Task made to wait for */

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK;

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */ 	 i = 0;

 	

		 		 	

do { 		

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* Current task's USED stack area is saved */		

/* mark task as NOT pre-emptied */

task[Running].status2 &= ~PREEMP_F;

209
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 V_TaskChange();		 #endif #if (!STAND_ALONE_ISR_04) case 4: 		 /* Make a voluntary task change */

Appendix E

	break;

 	  	

		 		 	

/* Interrupt number 4 */\				 /* Task made to wait for */

task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ task[Running].intnum = SER0_INT; 	

						 	 /* serial port interrupt */ /* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK; RS0 = 1; /* use bank 1 */

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */  	 	 i = 0; do { 		 /* Current task's USED stack area is saved */		

		 		 	

task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

/* mark task as NOT pre-emptied */

task[Running].status2 &= ~PREEMP_F;

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await — share your passion at Bio-Rad!

www.bio-rad.com/careers

210
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
	 V_TaskChange();			 #endif /* Make a voluntary task change */

Appendix E

		break; 	

 	  	

		 		 	

#if ( (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) ) task[Running].status1 |= WAIT4I_F; /* mark task as waiting int */ task[Running].intnum = TIM2_INT; 	 case 5: /* Interrupt number 5 */

						 /* timer 2 interrupt */ RS0 = 1; /* use bank 1 */

/* Task made to wait for */

/* store current task A,B,DPH,DPL SFRs and bank 0 registers just in case */ /* there is a need for a voluntary task swap */ 	 	 	 	 	 SaveSFRs(&task[Running].rega);	 SaveBank0(&task[Running].reg0); RS0 = 0; /* use bank 0 */ task[Running].stackptr = temp = SP;	 internal = MAINSTACK;

/* Current task's SP is saved */

/* MAINSTACK is declared in STARTUP.A51 */  	 	 i = 0; do { 	 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=temp);

		 		 	 	

/* mark task as NOT pre-emptied */ 		break; 	 #endif

task[Running].status2 &= ~PREEMP_F; V_TaskChange();			 /* Make a voluntary task change */

		default:	 		 		break;		 } EA = 1;		

	}									 /* */ /* * * *

**************************************************************************

************************************************************************** * Function name : OS_KILL_TASK * Function type : Task Suspension System call * Description 	 : This system call kills the current task, by putting it * 		   permanently waiting, such that *		 * 		   waiting signals * *     it never executes again. It also clears any set

* 		   which the task might have. * Arguments 	 : Task number to be killed

211
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Returns 	 * : None

Appendix E

***************************************************************************/ void OS_KILL_TASK(uchar task_num) { unsigned char temp,i; bit found; 	

uchar data * idata qptr; EA = 0; if (task[task_num].status2 & TASK_KILLED_F) else

	 {;} 	 	 	 {

task[task_num].status2 |= TASK_KILLED_F; for(i=0;i<MBXSIZE;i++)

/* check if task waiting for some message */

	 {

	  if (mbox[i].dest == task_num) 	   { 		 mbox[i].dest = FREE; 		 mbox[i].src = FREE; 		 mbox[i].len = ZERO; 		 } 	 	 }

/* if task happens to be the present running one */ 	 { 	 task[Running].status1 = ZERO;	  	 task[Running].status2 = ZERO;	  	 /* Killed by clearing its flags */ /* setting it to wait forever */	 /* Periodic interval count 0*/ task[Running].timeout = NOT_TIMING; /* Killed by clearing its flags */

if (task_num == Running)

	 task[Running].interval_count = ZERO; 	 task[Running].interval_reload = ZERO; /* Periodic interval count 0 */ 	 	 task[Running].priority = LOWEST; /* lowest priority setting */ 	 	 task[Running].status2 |= TASK_KILLED_F; 	 } V_TaskChange(); /* and then cause a task switch. */

/* Otherwise, search the ready queue, and if it is there, simply change its    found = 0; 	 	 	 number to that of the idle task */ qptr = ReadyQ;

	 { 		

while (qptr <= ReadyQTop) if (*qptr == task_num)

		 { *qptr = IDLE_TASK; found = 1;} 		 qptr++; 		}

212
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* The Ready Queue is ALWAYS sorted before ATTEMPTING any task change */ if ((ReadyQTop != ReadyQ) && found)  	 		 {				 qptr = ReadyQ; 	 /* the queue is sorted such */ /* that the idle task	 */

Appendix E

		

		

while (qptr < (ReadyQTop-1)) /* ends at ReadyQTop */ {			  {		 if (*qptr == IDLE_TASK)

			 			

				temp = *qptr;				 				 				 *qptr = *(qptr + 1); *(qptr + 1) = temp;

			} 		} 	 ReadyQTop--;	 }

		qptr++;					 	 /* to eliminate double IDLE_TASKS */

	 {

if(!found) /* if task is waiting for some event or timeout */

	 task[task_num].status1 = ZERO;	  /* Killed by clearing its flags */ /* Killed by clearing its flags */ 	 	 /* changing id to IDLE_TASK */ 	 task[task_num].status2 = ZERO;	  task[task_num].catalog = IDLE_TASK;	 task[task_num].timeout = NOT_TIMING;

/* setting it to wait forever */	

	 task[task_num].interval_count = ZERO;

678'<)25<2850$67(5©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¤ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

213
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* Periodic interval count 0 */ /* Periodic interval count 0 */

Appendix E

	 task[task_num].interval_reload = ZERO; 	 task[task_num].priority = LOWEST; /* Periodic interval count 0 */ 	 task[task_num].status2 |= TASK_KILLED_F; }

} }

EA = 1;

								 /* */ /* * * * **************************************************************************

************************************************************************** * Function name : V_TaskChange * Function type : Context Switch (Internal function) * Description 	 : This function is used to perform a voluntary context * 		   switch i.e. task swapping * * * * * Arguments 	 * Notes 	 * Returns 	 : none : : None

************************************************************************** */ { 	 	 	 	 	 	 void V_TaskChange (void) uchar data i, temp;

uchar idata * idata internal; uchar data * idata qtask; uchar data * idata qptr; TinQFlag = 0; internal =	 MAINSTACK;

/* MAINSTACK is the address of the start of */ 	 			 				

/* the main internal stack defined in */ /* STARTUP.A51 */

/* The Ready Queue is ALWAYS sorted before ATTEMPTING any task change */ if (ReadyQTop != ReadyQ) 	 { /* the queue is sorted such that */

		

qptr = ReadyQTop; /* the highest priority task	 {			  {		

		

while (qptr > ReadyQ) /* becomes the first in ready queue */ if (task[*qptr].priority > task[*(qptr - 1)].priority)

*/

			 			

214
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
				temp = *qptr;				 				 				 *qptr = *(qptr - 1); *(qptr - 1) = temp;

Appendix E

			} 		} 	 	 }

	 qptr--;					

/* READY queue is shifted down by one position only after a task change */				 							 	 	 	 qptr = qtask + 1;	 { 	 qtask = ReadyQ;	

Running = ReadyQ[0];	 /* set the new task as running */

while (qtask <= ReadyQTop) *qtask++ = *qptr++;		 /* Pointer to last task in queue is decremented */ /* Ensure that this pointer is never */

		 	} 	 	

ReadyQTop--;	

		

if (ReadyQTop < ReadyQ)	

ReadyQTop = ReadyQ;/* below the start of the READY queue */

/* The new running task's USED stack area is copied to internal RAM */ 	 temp = task[Running].stackptr; i=0; do 	 	 internal = MAINSTACK; {

		 	

} while (internal<=temp); SP = temp;	

*(internal++) = task[Running].stack[i++]; /* The new running task's SP is restored */	

if (task[Running].status1 & WAIT4I_F)  	  	  	 	 	 	 	 	 {

/* if new task was waiting for interrupt, */ task[Running].status1 &= ~WAIT4I_F; /* Get the new tasks registers which were stored externally */ RS0 = 1; /* USE BANK 1 */ RecallBank0(&task[Running].reg0);

/* then clear interrupt flag */

RS0 = 0; /* RETURN USING BANK 0 */ }

POP5(); /* starts other task here */

else if (task[Running].status2 & PREEMP_F)  	 	 /* if new task was pre-emptied before, */ {

/* then clear pre-emptied flag */  	 	 	 	 	 	  	 	

task[Running].status2 &= ~PREEMP_F; /* Get the new tasks registers which were stored externally */ RS0 = 1; /* USE BANK 1 */ RecallBank0(&task[Running].reg0);

RS0 = 0; /* RETURN USING BANK 0 */ }

POP5(); /* starts other task here */

else if (task[Running].status2 & FIRST_TIME_F) { 			 task[Running].status2 &= ~FIRST_TIME_F;

/* if new task running for the 1st time, */

215
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* then clear the flag */ 	 	 else 	 	 	 	 	 } /* */ /* * * * 	 } {

Appendix E

SP = temp; /* The new running task's SP is restored */	

 	

RS0 = 1; /* USE BANK 1 */

RecallBank0(&task[Running].reg0); RecallSFRs(&task[Running].rega); } RS0 = 0; /* RETURN USING BANK 0 */ EA = 1;

**************************************************************************

************************************************************************** * Function name : PE_TaskChange * Function type : Context Switch (Internal function) * Description 	 : This function is used to perform a forced or pre-emtive * 		 *     i.e. context switch or task swapping

Linköping University – innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master’s degree.

Click here!

216
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
* Arguments 	 * * : none

Appendix E

* Notes 	

* 		   there would be 5 registers pushed on the stack, saved * 		   while the current task was running. * 		 *     Push A, B, DPH, DPL and PSW

: This procedure is called from the timer tick interrupt,

* 		   Comes here ONLY from an Interrupt *				 * Returns 	 * : None

(Tick Timer or other)

************************************************************************** */ { 	 	 	 	 	 void PE_TaskChange (void) using 1 uchar data i, temp;

uchar idata * idata internal; uchar data * idata qtask; uchar data * idata qptr; TinQFlag = 0;

/* The Ready Queue is ALWAYS sorted before ATTEMPTING any task change */ 					 if (ReadyQTop != ReadyQ) 	

{ /* the queue is sorted such that */

		

qptr = ReadyQTop; /* the highest priority task	 {			  {		

		

while (qptr > ReadyQ) /* becomes the first in ready queue */ if (task[*qptr].priority > task[*(qptr - 1)].priority)

*/

			 			

				temp = *qptr;				 				 				 *qptr = *(qptr - 1); *(qptr - 1) = temp;

			} 		} 	 }

		qptr--;					

/* The first task in the READY queue has a higher priority than the current */ /* one, therefore the current task is PRE-EMPTIED, Queue shifted down */ /* the current task is placed at the top of the Ready Queue again */ /* so that */ /* it can continue to run when its priority allows it to and a */ /* new task is set to run */ 	 	 temp = Running; task[Running].status2 |= PREEMP_F; /* mark old task as pre-emptied */

/* NOW WORK WITH THE NEW TASK */ 	 	 	 			

internal = MAINSTACK; /* MAINSTACK is the address of the start */ Running = ReadyQ[0];	 /* set the new task as running */ /* of main stack defined in STARTUP.A51 */

217
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

/* READY queue is shifted down by one position only after a task change */				 							 	 	 	 qptr = qtask + 1;		 { 	 qtask = ReadyQ;

while (qtask <= ReadyQTop) *qtask++ = *qptr++;		 /* Pointer to last task in queue is decremented */

		 	} 	 	

ReadyQTop--;	

		 	

if (ReadyQTop < ReadyQ)	

ReadyQTop = ReadyQ; /* below the start of the READY queue */

/* Ensure that this pointer is never */

ReadyQTop++;

*ReadyQTop = temp; /* the old task is placed in the ready queue. */

/* The new running task's USED stack area is copied to internal RAM */ /* and the stack pointer adjusted accordingly */ 	 temp = task[Running].stackptr; internal = MAINSTACK; {

i=0; do 	 	

		 	

} while (internal<=temp); SP = temp;	

*(internal++) = task[Running].stack[i++]; /* The new running task's SP is restored */	

if (task[Running].status1 & WAIT4I_F)  	  	  	 	 	 	 	  	 	 	 {

/* if new task was waiting for interrupt, */ task[Running].status1 &= ~WAIT4I_F; /* Get the new tasks registers which were stored externally */ RecallBank0(&task[Running].reg0); } POP5I(); /* starts other task here */ else if (task[Running].status2 & PREEMP_F) /* if new task was pre-emptied before, */ { task[Running].status2 &= ~PREEMP_F; /* Get the new tasks registers which were stored externally */ RecallBank0(&task[Running].reg0); } { POP5I(); /* starts other task here */

/* then clear interrupt flag */

 	 	 	 	  	 	

/* then clear pre-emptied flag */

else

 		 		 	 }  	 	 else

if (task[Running].status2 & FIRST_TIME_F)

{ /* if new task running for the 1st time, */ task[Running].status2 &= ~FIRST_TIME_F;

/* then clear the flag */

POP0I(); /* starts other task here */

{ /* if new task had voluntarily given up before, do nothing */ /* Get the new tasks registers */

218
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 } } RecallBank0(&task[Running].reg0); RecallSFRs(&task[Running].rega); } POP0I(); /* starts the other task here */

Appendix E

EA = 1;

/* */ /* *	 * *

**************************************************************************

************************************************************************** * Function name : Xtra_Int_0 * Function type : Interrupt Service Routine * Description 	 : This is the external 0 interrupt ISR whose associated * 		   interrupt number is 0. * * * * Arguments 	 * Returns 	 : None : None

************************************************************************* */

219
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
#if (!STAND_ALONE_ISR_00) { 	 	 	

Appendix E

void Xtra_Int_0 (void) interrupt 0 using 1 uchar idata * idata internal; uchar data i,k; EA = 0;

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* A,B,DPH,DPL and PSW are pushed on stack by the compiler after the interrupt */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP; SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ 	 /* push on stack after the interrupt */ i = 0; internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

		 		

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

	Xtra_Int(EXT0_INT);

/* Passes EXT0_INT for identification purposes */ }					 #endif /* * * *

************************************************************************** * Function name : RTOS_Timer_Int * Function type : Scheduler Interrupt Service Routine * Description 	 : This is the RTOS scheduler ISR. It generates system ticks * 		   and calculates any remaining *		 * * * 	 waiting and periodic interval time for each task.

* Arguments 	 * Returns 	

: None : None

************************************************************************** */ 	 { 	 	 	 	 #if (TICK_TIMER == 0)

void RTOS_Timer_Int (void) interrupt 1 using 1 uchar idata * idata internal; uchar data k;		 bit bdata On_Q;

/* If Timer 0 is used for the scheduler */ 	

uchar data * idata q; /* used for scheduling.			

/* For the 8051, Timer 0 is often */

*/

/* After an interrupt, the SP is incremented by 5 by the */

220
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* compiler to PUSH ACC,B,DPH,DPL and PSW */ 	 	 TH0 = HiByte(BASIC_TICK); 	 TL0 = LoByte(BASIC_TICK);

Appendix E

/* These are popped back before returning from the interrupt */ /* Timer registers reloaded */

#elif (TICK_TIMER == 1)	 { 	 	 	 	

void RTOS_Timer_Int (void) interrupt 3 using 1 uchar idata * idata internal; uchar data k;		

/* If Timer 1 is used for the scheduler */ 	

uchar data * idata q; /* for scheduling, provided it is not */ bit bdata On_Q; /* needed as UART baud rate generator */

/* For the 8051, Timer 1 can be used */

/* After an interrupt, the SP is incremented by 5 by the */ /* compiler to PUSH ACC,B,DPH,DPL and PSW */ /* These are popped back before returning from the interrupt */ /* PSW is also pushed bexause of the using 1 command */ 	 	 TH1 = HiByte(BASIC_TICK); 	 TL1 = LoByte(BASIC_TICK); /* Timer registers reloaded */

#elif (TICK_TIMER == 2)	 { 	 	 	 	

void RTOS_Timer_Int (void) interrupt 5 using 1 uchar idata * idata internal; uchar data i,k; 		 bit bdata On_Q;	 uchar data * idata q; 	

/* If Timer 2 is used for the scheduler */ 	

/* For the 8032, Timer 2 is used */ /* for scheduling.			

*/

/* After an interrupt, the address of the next instruction of the */ /* current task is push on stack (low then high byte). Then SP */ /* is further incremented by 5 by the */ /* Internal stack map at this stage */ /* High stack RAM */ /* DPL */ /* DPH */ /* B */ /* ACC */ /* PSW <-- SP points to here */ /* compiler to PUSH ACC,B,DPH,DPL and PSW */

/* High byte return address */ /* Low byte return address */ /* Low stack RAM */

/* These are normally popped back BEFORE returning from the */ /* interrupt IF the TaskChange function is not called. */ 											 	 TF2 = 0;		 /* Timer 2 interrupt flag is cleared */ #endif

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */

221
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* after the interrupt */ 	 	 	

Appendix E

/* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

 	

		 i = 0;

		 	 	

do { 			 /* Current task's USED stack area is saved */		 } while (internal<=k); task[Running].stack[i++] = *(internal++);	

	 { 		 		

for (k = 0; k < NOOFTASKS; k++)

/* check those tasks that are PERIODIC */

if (task[k].interval_count != ZERO) /* Updates the tasks */ {				 /* periodic intervals. */ if (task[k].interval_count == ZERO) {

			task[k].interval_count--; 			 			 		

				 	  				 {

task[k].interval_count = task[k].interval_reload;

if (task[k].status1 & WAIT4V_F)

/* If periodic interval 	 /* has elapsed and the 	 /* task has been waiting 	 /* task is placed in the 	 /* READY queue, if it is 	 /* verified that the task 	 /* in the queue, as now 	 /* the task no longer 		 /* requires to wait. 		 /* does not already reside 	

*/

*/	 */	 */	 */	

task[k].status1 &= ~WAIT4V_F;		 q = ReadyQ; On_Q = 0;

/* for this to occur, the 	

*/ {		 */		 */ 		 */ 	

while (q <= ReadyQTop) if (k == *q) {		 On_Q = 1;			 }

*/ break; */		

	

/* This can happen due to BAD programming, */ /* with a task taking much longer */

/* to execute than the periodic interval requested */ 					 	 }  				  					 	 				 if 	 (!On_Q) { 					q++;

					ReadyQTop++;

/* put in ready queue */		  				

*ReadyQTop = k;

					TinQFlag = 1; 					 	 	

if (task[k].priority > task[Running].priority) /* mark new higher priority task in Q */ /* setting flag to start pre-emption */ }

 					 			}

			

222
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* If however the task was not waiting for this event */

Appendix E

/* the task is not placed in the ready queue, but a flag is */ 			else

/* set to indicate that the periodic time has already passed */  				 		 } task[k].status1 |= WAIT4V_F;		

			 }

/* Now, check for any tasks waiting for a timeout */				 		 if (task[k].timeout != NOT_TIMING)  	 			 			  		 {	 				 /* Updates the tasks' */	

task[k].timeout--; /* timeout variables. */ if (task[k].timeout == ZERO)

				 				  			 				

{

ReadyQTop++; /* If a waiting task's */ *ReadyQTop = k; /* timeout elapses */ task[k].status1 &= ~WAIT4M_F;

/* Clear flags just in case it had been */

/* waiting message + timeout */ 				 			

/* need to take care of message case, (timeouts before message arrives) */ /* waiting semaphore + timeout*/ 	 task[k].status1 &= ~WAIT4S_F;

 			

if (task[k].priority > task[Running].priority) TinQFlag = 1;	  /* set flag to start pre-emption */

/* the task is placed in the ready queue. */

				}								 		 }	

223
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
		 	 	 		 /* If any new task higher priority task was placed in */

Appendix E

	}  	 {

/* pre-emptive task switch by calling TaskChange, Option 0 */	 if (TinQFlag)

/* in the ready queue, then we need to do a */

		PE_TaskChange();

/* Force a pre-emptive task change if required */ /* stack at */ 	 }

/* Note that the pushed task registers would still be on the saved */ /* this point and would be popped back when task is put into action again */ /* else return to original running task, popping the pushed registers */ /* automatically by the KEIL compiler. */ EA = 1; } /* */ /* */ /* * * *

**************************************************************************

**************************************************************************

************************************************************************** * Function name : Xtra_Int_1 * Function type : Interrupt Service Routine * Description 	 : This is the Timer 0 ISR whose associated interrupt number * 		   is 1. * 		   It is only enabled in

* 		   case an 8032 microcontroller is being used in combination * 		   with an EEPROM. The reason * 		   on the 8032 and in case of *		 * 		  scheduler. * * * * 		   being is that without an EEPROM Timer 0 is not available the 8051 Timer 0 is already being used as the RTOS

* 		   It is also available if using the version 2 monitor ROM. * Arguments 	 * Returns 	 : None : None

************************************************************************** */ #if ( (TICK_TIMER != 0) && (!STAND_ALONE_ISR_01) ) /* Timer 0 interrupt is usually used for RTOS on the basic 8051 */ /* For the FLT-32 8032, it can only be used with the modified monitor */

224
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* or user eprom */

Appendix E

/* it is used for the single step in the old version monitor eprom */ void Xtra_Int_1 (void) interrupt 1 using 1 {	 	 	 	 uchar idata * idata internal; uchar data i,k; 		 EA = 0;

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* after the interrupt */ 	 	 	 	 /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK;

 	

		 	

/* MAINSTACK is declared in STARTUP.A51 */ i = 0; do { 			 /* Current task's USED stack area is saved */		

 	

		 		

task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

	Xtra_Int(TIM0_INT); }

/* Passes TIM0_INT for identification purposes */ #endif /* */ /* * * * **************************************************************************

************************************************************************** * Function name : Xtra_Int_2 * Function type : Interrupt Service Routine * Description 	 : This is the external 1 interrupt ISR whose associated * 		   interrupt number is 2. * * * * Arguments 	 * Returns 	 : None : None

************************************************************************** */ #if (!STAND_ALONE_ISR_02) {	

void Xtra_Int_2 (void) interrupt 2 using 1

225
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 uchar idata * idata internal; uchar data i,k; EA = 0;	

Appendix E

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* after the interrupt */ 	 	 	 /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK;

 	

		 i = 0;

/* MAINSTACK is declared in STARTUP.A51 */ do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

		 		

	Xtra_Int(EXT1_INT); }

/* Passes EXT1_INT for identification purposes */ #endif /* */ **************************************************************************

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

226
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* * * *

Appendix E

************************************************************************** * Function name : Xtra_Int_3 * Function type : Interrupt Service Routine * Description 	 : This is the Timer 1 ISR whose associated interrupt number * 		   is 3. * * * * Arguments 	 * Returns 	 : None : None

************************************************************************** */ #if ( (TICK_TIMER != 1) && (!STAND_ALONE_ISR_03) ) void Xtra_Int_3 (void) interrupt 3 using 1 { 	 	 	 uchar idata * idata internal; EA = 0; uchar data i,k; 		

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* after the interrupt */ 	 	 	 	 /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK; 		 /* MAINSTACK is declared in STARTUP.A51 */

 	

		 i = 0;

		 		

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

	Xtra_Int(TIM1_INT); }

/* Passes TIM1_INT for identification purposes */ #endif /* */ /* * * * **************************************************************************

************************************************************************** * Function name : Xtra_Int_4 * Function type : Interrupt Service Routine

227
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Description 	 : This is the serial port ISR whose associated interrupt * 		   number is 4. * * * * Arguments 	 * Returns 	 : None : None

Appendix E

************************************************************************** */ #if (!STAND_ALONE_ISR_04) { 	 	 	

void Xtra_Int_4 (void) interrupt 4 using 1 uchar idata * idata internal; uchar data i,k; 		 EA = 0;

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* after the interrupt */ 	 	 	 /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */

 	

		 	 	

 	

i = 0;

		 		

do { 			 /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

	Xtra_Int(SER0_INT); }

/* Passes SER0_INT for identification purposes */ #endif /* */ /* * * * **************************************************************************

************************************************************************** * Function name : Xtra_Int_5 * Function type : Interrupt Service Routine * Description 	 : This is the Timer 2 ISR whose associated interrupt * 		   number is 5. * * * * Arguments 	 * Returns 	 : None : None

228
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
************************************************************************** */ #if ( (CPU == 8032) && (TICK_TIMER != 2) && (!STAND_ALONE_ISR_05) ) void Xtra_Int_5 (void) interrupt 5 using 1 { 	 	 	 uchar idata * idata internal; uchar data i,k; 		 TF2 = 0; EA = 0;

Appendix E

/* store current task bank 0 registers just in case there is */ /* a need for a pre-emptive task swap */ /* after the interrupt */ 	 	 	 /* A,B,DPH,DPL and PSW are pushed on stack by the compiler */ /* and are saved as part of the task stack */ task[Running].stackptr = k = SP;

SaveBank0(&task[Running].reg0); /* store R0 - R7 bank 0 */ /* Current task SP is saved pointing to PSW which is the last one */ /* push on stack after the interrupt */ internal = MAINSTACK; /* MAINSTACK is declared in STARTUP.A51 */ /* Current task's USED stack area is saved */		 task[Running].stack[i++] = *(internal++);	 } while (internal<=k);

 	

		 i = 0; do { 		

		 		

	Xtra_Int(TIM2_INT); }

/* Passes TIM2_INT for identification purposes */ #endif /* */ /* * * * **************************************************************************

************************************************************************** * Function name : Xtra_Int * Function type : Interrupt Handling (Internal function) * Description 	 : This function performs the operations required by the * 		   previous ISRs. * * Arguments 	 : task_intflag		 * 					 * 					 * 					 *

Represents the flag mask for a given interrupt against which the byte storing the flags of each task determine whether any task has been

*						 *						

will be compared in order to waiting for the interrupt in

*						question.

229
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
* Returns 	 * : None

Appendix E

************************************************************************** */ { 	 	 	 void Xtra_Int (uchar current_intnum) using 1 uchar data k; for (k = 0; k < NOOFTASKS; k ++) {						 {

		 		

		

if (task[k].intnum == current_intnum) task[k].intnum = NO_INTERRUPT;

		 task[k].status1 &= ~WAIT4I_F; //		

/* mark task as not waiting int */				

		 if (task[k].priority > task[Running].priority) TinQFlag = 1;	 		 		 		 		 	 /* If it found that a task */ task[k].timeout = NOT_TIMING; ReadyQTop++;		 /* has been waiting for the */	 /* given interrupt, it no	 /* longer requires to wait */	

task[k].timeout = ONE; /* If it found that a task */

				 /* It will be handled at the next tick */ } EA = 1;

				

}			

}			

*ReadyQTop = k;	 	

*/	

/* on the READY queue.	 */

/* and is therefore placed */

.

230
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/*

Appendix E

************************************************************************** ************************************************************************** ************************************************************************** ************************************************************************** ************************************************************************** */

Think Umeå. Get a Master’s degree!
• modern campus • world class research • 31 000 students • top class teachers • ranked nr 1 by international students Master’s programmes: • Architecture • Industrial Design • Science • Engineering

Sweden www.teknat.umu.se/english

231
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

MagnOS.h
************************************************************************** *				 * RTOS KERNEL HEADER FILE

* For use with MagnOS_V01.C - Co-Operative RTOS written in C * 		 * *				 * File 		 * Date 		 * By	 * by Ing. Paul P. Debono Use with the 8051 family of microcontrollers

* Revision 	 	

: MagnOS_V01.H : 1 : February 2006

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

************************************************************************** */ /* #include "Parameters.H" ************************************************************************** * 				 */ ************************************************************************** typedef unsigned char uchar; typedef unsigned int uint; /* typedef unsigned long ulong; ************************************************************************** * 			 */ ************************************************************************** #define DATASIZE 	 		  		  		 16 STRUCTURE AND UNION DEFINITIONS DATA TYPE DEFINITIONS

union dataformat{struct{ulong HI1,LO1,HI0,LO0;}dblwords;

  struct{uint Hi3,Lo3,Hi2,Lo2,Hi1,Lo1,Hi0,Lo0;}words;   struct{uchar hi7,lo7,hi6,lo6,hi5,lo5,hi4,lo4,   struct{char s[DATASIZE];}string;};

				hi3,lo3,hi2,lo2,hi1,lo1,hi0,lo0;}bytes; struct letter{uchar dest,src,len;union dataformat dat;}; struct task_param { 	 /* 13 bytes + 13 registers + stack per task */  	  	 	 	 	 	 	 	 uchar catalog; 	 uchar status1; 	 uchar status2; 	 uchar priority; 	 /* task id */ /* status flags, see below for details */ /* status flags, see below for details */ /* priority number, low = high priority */ /* resource number required */

uchar semaphore; 		 uchar resource; 		 uchar stackptr; 	 uchar intnum; 		

/* counting semaphore for each task */

/* stack pointer SP storage location */

	 uint timeout; 		 /* task waiting for this timeout in ticks, */ 					 /* 0 = not waiting */

/* task waiting for this interrupt number */

232
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
uint interval_count; /* time left to wait for this periodic */ 					 /* interval task in ticks */ 	 uint interval_reload;/* periodic tick interval reload value */  	 uchar rega;		 /* registers storage area, ready for context */ 				 /* switching use */ 	 uchar regb; 	 uchar rdph; 	 uchar rdpl; 	 uchar rpsw; 	 uchar reg0; 	 uchar reg1; 	 uchar reg2; 	 uchar reg3; 	 uchar reg4; 	 uchar reg5; 	 uchar reg6; 	 uchar reg7;  	 char stack[STACKSIZE]; /* stack storage area */ 		 }; /* ************************************************************************** */ /* ************************************************************************** */ /* The MAINSTACK pointer variable points to the start pointer in */ /* hardware stack and should be defined in STARTUP.A51 */ extern idata unsigned char MAINSTACK[STACKSIZE]; extern void SaveBank0(uchar xdata * Pointer); extern void SaveSFRs(uchar xdata * Pointer); extern void POP5(void), POP0(void); /* 	

Appendix E

/* Functions written in assembly language, found in MAGNOS_A01.A51 */ extern void RecallBank0(uchar xdata * Pointer); extern void RecallSFRs(uchar xdata * Pointer); extern void POP5I(void), POP0I(void); ************************************************************************** * 				FUNCTION PROTOTYPES * * **************************************************************************

* The following RTOS system calls do not receive any parameters : */

* ---------------------------------------------------------------void OS_RTOS_GO (void);	 void OS_WAITP (void); 		 // Starts the RTOS running with prioities if

					// required

uchar OS_RUNNING_TASK_ID(void); // Returns the number of the currently  				  // executing (running) task 	 /* The following commands are simply defined as MACROS below 				 (awake every interrupt)

// Waits for end of task's periodic interval

OS_CPU_IDLE() 	Set the microprocessor into a sleep mode OS_CPU_DOWN()	 Switch off microprocessor, activate only by

 	

233
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
hardware reset

Appendix E

OS_PAUSE_RTOS()	 */ /*

OS_RESUME_RTOS()	

Disable RTOS, used in a stand alone ISR

Re-enable RTOS, used in a stand alone ISR

* The following RTOS system calls do receive parameters : * ------------------------------------------------------*/ void OS_INIT_RTOS (uchar iemask);	 void OS_WAITI (uchar intnum);		  					 					 					 void OS_WAITT (uint ticks);	 	 // Initialises all RTOS variables // Waits for an event (interrupt) // by a defined number of ticks // Waits for a timeout period given

uchar OS_CHECK_TASK_PRIORITY(uchar task_num);

void OS_CHANGE_TASK_PRIORITY(uchar task_num, uchar new_prio); void OS_RELEASE_RES (uchar Res_Num);

// Gets the requested task priority // Sets the requested task priority

void OS_WAIT4RES (uchar Res_Num,uint ticks); void OS_SEND_MSG(struct letter xdata *msg); void OS_CLEAR_MSG(uchar task_num); bit OS_CHECK_MSG(uchar task_num);

void OS_GET_MSG(struct letter xdata *msg); uchar OS_CHECK_TASK_SEMA4(uchar task_num); 				 				

void OS_WAIT_MESSAGE(struct letter xdata *msg, uint ticks); // Gets the requestes task semaphore // Subtracts units from a semaphore

void OS_SEMA4MINUS (uchar task_num, uchar units); 					 				

void OS_SEMA4PLUS (uchar task_num, uchar units);

// Causes task change if semapphore=0

void OS_WAIT4SEM (uint ticks); // Waits for a signal to arrive 				

// Adds units to a semaphore

void OS_PERIODIC (uint ticks); // Sets task to behave periodically 					 void OS_CREATE_TASK (uchar tasknum, uint taskadd, uchar priority); 					// Creates a task void OS_KILL_TASK (uchar tasknum);// Kills the selected task /* The following commands are simply defined as MACROS below 	 	 	 	 OS_WAITT_A(M,S,ms) 	 OS_WAITS_A(M,S,ms) 	 OS_WAIT4MSG(m,t) 	

// within a given number of ticks

// every given number of ticks

Absolute WAITT for minutes, seconds, msecs Absolute WAITS for minutes, seconds, msecs Waits for message and gets message, clearing mailbox

OS_PERIODIC_A(M,S,ms) 	 Absolute PERIODIC for minutes, seconds, msecs

				 */ /* */

************************************************************************** #define STAND_ALONE_ISR_00 0 	 // EXT0 - set to 1 if using this interrupt 				 // as a stand alone ISR

234
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#define STAND_ALONE_ISR_01 0 	 // TIM0 - set to 1 if using this interrupt #define STAND_ALONE_ISR_02 0 	 // EXT1 - set to 1 if using this interrupt 				 				 				 				 /* */ /* #define STAND_ALONE_ISR_03 0	 #define STAND_ALONE_ISR_04 0	 #define STAND_ALONE_ISR_05 0	 // as a stand alone ISR // as a stand alone ISR // as a stand alone ISR // as a stand alone ISR // TIM1 - set to 1 if using this interrupt // SER0 - set to 1 if using this interrupt // TIM2 - set to 1 if using this interrupt 				 // as a stand alone ISR

Appendix E

**************************************************************************

************************************************************************** * 				 */ ************************************************************************** #define MSEC10 9216UL			 // 1 msec assuming an // In theory 921.6 counts represent // 11.0592 MHz crystal. // Ensure that TICKTIME's value is // quotient and hence all the RTOS TIMING DEFINITIONS

						 						

#define TICKS_PER_SEC	 (1000 / TICKTIME) 	 

#define TICKS_PER_MIN	 (60000 / TICKTIME) 	

							// chosen such that this 						// following quotients result // the maximum

							// in an integer. In theory,  						 							// value of TICKTIME 						

								// is given by the value #define CLOCK ((TICKTIME * MSEC10)/10) // i.e. approx. 70-72 - However #define BASIC_TICK 	 // corresponding to CLOCK = 65535

						// respecting the condition 							// TICKTIME = 50 msecs. // Hence all suitable values are: // For reliable time-dependent // results a value of 10 or // upon the application /* OTHER #defines */ #define MBXSIZE 	 #define FREE 0xFF 	 // 1, 2, 4, 5, 8, 10, 20, 25, 40, 50 (65535 - CLOCK + 1) 	 // above, max. acceptable

// above is recommended depending

20

#define EMPTY 0xFF 	 #define ZERO 		

/* mailbox location is available */ /* mailbox location is available */ 0 1 0	 // An indefinite period of waiting time in the RTOS // is given by a value of 0

#define NOOFRESOURCES 	 8 #define ONE 		

#define NOT_TIMING		 #define NO_INTERRUPT 	 0xFF 				

235
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
// signifies task is not waiting for any interrupt event #define LOWEST 		 #define HIGHEST 	 #define MAXSEM 		

Appendix E

0x00 /* lowest priority number */

0xFF /* highest priority number */

0xFF /* maximum number of units in a semaphore */

#define HiByte(intval) (##intval)/256; #define LoByte(intval) (##intval)%256; /* or you may use */ // #define HiByte(intval) (unsigned char)(((##intval)& 0xFF00)>>8) // #define LoByte(intval) (unsigned char)((##intval) & 0x00FF) /* */ /*

**************************************************************************

************************************************************************** * 				 */ ************************************************************************** #define OS_CPU_IDLE()		 #define OS_CPU_DOWN()		 	 	 	 #if (TICK_TIMER == 0) PCON |= 0x01 PCON |= 0x02 RTOS MACROS

// Sets the microprocessor in idle mode

// Sets the microprocessor in power-down mode

#define OS_PAUSE_RTOS() EA = ET0 = TR0 = 0

#define OS_RESUME_RTOS() TR0 = ET0 = EA = 1

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel – as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

236
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
#elif (TICK_TIMER == 1) 	 	

Appendix E

#define OS_PAUSE_RTOS() EA = ET1 = TR1 = 0

#define OS_RESUME_RTOS() TR1 = ET1 = EA = 1 #define OS_PAUSE_RTOS() EA = ET2 = TR2 = 0

#elif (TICK_TIMER == 2)

#define OS_RESUME_RTOS() TR2 = ET2 = EA = 1 #endif /* /* ***************************************************************************/ ************************************************************************** *		 */ 	 ************************************************************************** #if (CPU != 8032) && (CPU != 8051) #endif #error Invalid CPU Setting COMPILE-TIME ERROR TRAPPING

#if (NOOFTASKS > 254) #endif 	

#error Number of tasks is too big. The ReadyQ can store up to 254 tasks #if ((TICKTIME * 110592 / 120) > 65535) #endif

#error Tick time value exceeds valid range for timer counter setting

#if ((TICKTIME * 110592 / 120) < 65535) && ((1000 % TICKTIME) != 0) #endif

#error Undesirable TICKTIME setting (1, 2, 4, 8, 10, 20, 25, 40, 50 ms) #if (CLOCK > 65535) #endif /* */ /*

#error Timer counter setting exceeded valid range. Check TICKTIME and MSEC

**************************************************************************

************************************************************************** * 				TASK-RELATED DEFINITIONS */ ************************************************************************** /* Interrupt numbers, used for tasks waiting for some interrupt event */ #define EXT0_INT 0x00	 	 #define TIM0_INT 0x01		 #define EXT1_INT 0x02		 #define TIM1_INT 0x03		 #define SER0_INT 0x04		 #define TIM2_INT 0x05		 // External 0 Interrupt number 0 // Timer 0 Interrupt number 1 // Timer 1 Interrupt number 3 // Serial Interrupt number 4 // Timer 2 Interrupt number 5 // External 1 Interrupt number 2

237
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#define IDLE_TASK NOOFTASKS

Appendix E

// Main endless loop in application given a task // number equal to NOOFTASKS /* */ /*

**************************************************************************

************************************************************************** * 			 * *************************************************************************** * These macros perform the same functions of the WAITT, WAITS and * PERIODIC calls * but rather than ticks they accept absolute time values as parameters in * terms of days, hours, minutes, seconds and millisecs * absolute-time version of WAITT() * * * This difference is denoted by the _A suffix - eg. WAITT_A() is the ENHANCED EVENT-WAITING ADD-ON MACROS

* Range of values accepted, (maximum 65535 TICKTIMES): * Using a TICKTIME of 1 msec : 1 msecs - 1 min, 5 secs, 535 msecs

* Using a TICKTIME of 10 msec : 10 msecs - 10 mins, 55 secs, 350 msecs * Using a TICKTIME of 50 msec : 50 msecs - 54 mins, 36 secs, 750 msecs * If the conversion from absolute time to ticks results in 0 * (all parameters * being 0 or overflow) this result is only accepted by WAITS() * by virtue of how * the WAITT(), WAITS() and PERIODIC() calls were written. * In the case of the * changed to 1 * be 50 msecs * * WAITT() and PERIODIC() calls the tick count would automatically be * meaning an interval of eg. 50 msecs in case the TICKTIME is defined to

* Liberal use of parentheses is made in the following macros in case the * arguments might be expressions *

***************************************************************************/ #define TPM(M) (TICKS_PER_MIN*(##M)) #define TPS(S) (TICKS_PER_SEC*(##S)) #define TPMS(ms) ((##ms)/TICKTIME) #define OS_WAITT_A(M,S,ms) OS_WAITT((uint)(TPM(M) + TPS(S) + TPMS(ms))) #define OS_WAITS_A(M,S,ms) OS_WAITS((uint)(TPM(M) + TPS(S) + TPMS(ms))) #define OS_PERIODIC_A(M,S,ms) OS_PERIODIC((uint)(TPM(M)+TPS(S)+TPMS(ms))) #define OS_WAIT4MSG(m,t) OS_WAIT_MESSAGE(##m,##t); OS_GET_MSG(##m) /* */ **************************************************************************

238
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/*

Appendix E

* Other functions used internally by the RTOS : * --------------------------------------------*/ void V_TaskChange (void);			 // Task swapping function // Task swapping function // RTOS Scheduler ISR

void PE_TaskChange (void);			 void RTOS_Timer_Int (void);			 void Xtra_Int (uchar task_intflag);	 #if (!STAND_ALONE_ISR_00) #endif 	

// Function used by ISRs other than the RTOS Scheduler void Xtra_Int_0 (void);			 // External Interrupt 0 ISR

#if ( (TICK_TIMER != 0 ) && (!STAND_ALONE_ISR_01) ) #endif void Xtra_Int_1 (void);			

// Timer 0 ISR

#if (!STAND_ALONE_ISR_02) #endif 	

void Xtra_Int_2 (void);		

// External Interrupt 1 ISR

#if ( (TICK_TIMER != 1 ) && (!STAND_ALONE_ISR_03) ) #endif void Xtra_Int_3 (void); 			

// Timer 1 ISR

#if (!STAND_ALONE_ISR_04) #endif

void Xtra_Int_4 (void);				

// Serial Port ISR

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

239
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
#if ( (TICK_TIMER != 2 ) && (!STAND_ALONE_ISR_05) ) 				// on the 8051 #endif /*

Appendix E

void Xtra_Int_5 (void); // Interrupt 5 (Timer 2) is not available

************************************************************************** ************************************************************************** ************************************************************************** ************************************************************************** */

240
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

Parameters.h
/* ************************************************************************** *			 * PARAMETERS.H --- RTOS KERNEL HEADER FILE

* For use with MagnOS_V01.C *			 * * File 		 * Date 		 * By	 *

* Co-Operative RTOS written in C by Ing. Paul P. Debono

for use with the 8051 family of microcontrollers

* Revision 	 	

: Parameters_V01.H : 8 : February 2006

: Paul P. Debono B. Eng. (Hons.) Elec. Course University Of Malta

* 			 * 			 *

************************************************************************** */ /*

************************************************************************** * 				 */ ************************************************************************** #define STACKSIZE 0x10 		 #define CPU		 RTOS USER DEFINITIONS

// Max size of stack for each task - no need to change 8032	 	 // Set to 0, 1 or 2 to select which timer to // use as the RTOS tick timer // - refer to the RTOS // timing definitions // Length of RTOS basic tick in msec // set to 8051 or 8032

#define TICK_TIMER 2 		 				 #define TICKTIME	 				 				 #define NOOFTASKS	 /*

50 		

6	 // Number of tasks used in the application program

************************************************************************** ************************************************************************** ************************************************************************** */

241
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix E

Startup.a51
$NOMOD51 ;------------------------------------------------------------------------; This file is part of the C51 Compiler package ; Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc. ;------------------------------------------------------------------------; STARTUP.A51: This code is executed after processor reset. ; ; To translate this file use A51 with the following invocation: ; ; A51 STARTUP.A51 ; ; To link the modified STARTUP.OBJ file to your application use the following ; BL51 invocation: ; ; BL51 <your object file list>, STARTUP.OBJ <controls> ; ;------------------------------------------------------------------------; ; User-defined Power-On Initialization of Memory ; ; With the following EQU statements the initialization of memory ; at processor reset can be defined: ; ; 				 ; the absolute start-address of IDATA memory is always 0 ;IDATALEN 	 EQU 	 80H 	 ; the length of IDATA memory in bytes. IDATALEN 	 EQU 	 100H 	 ; the length of IDATA memory in bytes for ; 			 	 the 8032 (256 bytes). ;

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

242
Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click Click on on the the ad ad to to read read more more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

PaulOS An 8051 Real-Time Operating System Part II
XDATASTART 	 ; memory ; XDATALEN 	 PDATASTART 	 PDATALEN 	 ; ; Notes: 	 ; 		 ; 		 ; 		 ; ; EQU 	 EQU 	 EQU 	 EQU 	 0H 	 0H 	 0H 	 0H 	 ; the absolute start-address of XDATA ; the length of XDATA memory in bytes. ; the absolute start-address of PDATA ; the length of PDATA memory in bytes. memory

Appendix E

; 				

The IDATA space overlaps physically the DATA and BIT areas of the 8051 CPU. At minimum the memory space occupied from the C51 run-time routines must be set to zero.

;------------------------------------------------------------------------; Reentrant Stack Initilization ; The following EQU statements define the stack pointer for reentrant ; functions and initialise it: ;

; Stack Space for reentrant functions in the SMALL model. IBPSTACK 	 IBPSTACKTOP 	 ; EQU 	 EQU 	 1 	

;IBPSTACKTOP 	 EQU 	

0FFH+1 	 ; set top of stack to highest location+1. 07FH+1 	 ; set top of stack to highest location+1.

; set to 1 if small reentrant is used.

; Stack Space for reentrant functions in the LARGE model. XBPSTACK 	 ; XBPSTACKTOP 	 EQU 	 EQU 	 0 	

0FFFFH+1 ; set top of stack to highest location+1.

; set to 1 if large reentrant is used.

; Stack Space for reentrant functions in the COMPACT model. PBPSTACK 	 ; ; ; PBPSTACKTOP 	 EQU 	 EQU 0FFFFH+1	 0 	

; set to 1 if compact reentrant is used.

; set top of stack to highest location+1.

;------------------------------------------------------------------------; Page Definition for Using the Compact Model with 64 KByte xdata RAM ; The following EQU statements define the xdata page used for pdata ; in the linker invocation. ; ; ; PPAGEENABLE 	 PPAGE 		 PPAGE_SFR 	 ; 		 ; EQU 	 EQU 	 0 	 0 	

; variables. The EQU PPAGE must conform with the PPAGE control used

; set to 1 if pdata object are used. ; define PPAGE number.

DATA 	 0A0H 	 ; SFR that supplies uppermost address byte (most 8051 variants use P2 as uppermost address byte)

;------------------------------------------------------------------------; Standard SFR Symbols ACC 	 B 	 SP 	 DATA 	 0E0H DATA 	 0F0H DATA 	 81H DATA 	 82H DATA 	 83H

DPL 	 DPH 	

243
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
		 NAME 		 ?C_STARTUP CODE IDATA ?STACK STACKSIZE 	 ; defined in parameters.h

Appendix E

?C_C51STARTUP 	SEGMENT 	 ?STACK S	 		 EGMENT 		 RSEG 		 DS 		

#include <parameters.h> MAINSTACK: 	 		 		 		 $IF (FLT32) 		 		 		

EXTRN CODE (?C_START) PUBLIC ?C_STARTUP PUBLIC MAINSTACK

; FLT32 or MON51 should be define in A51 TAB in Target Options CSEG 	 AT 	 CSEG 	 AT 	 CSEG 	 AT 	 8100H	 ; for FLT-32 8000H	 ; for MON-51 0 	 ; for simulator etc

$ELSEIF (MON51) $ELSE

$ENDIF

?C_STARTUP: 	 		 STARTUP1:

LJMP 	 STARTUP1 RSEG 	 ?C_C51STARTUP

IF IDATALEN <> 0 		 		

MOV 	 CLR 	 MOV 	

R0,#IDATALEN - 1 A @R0,A

IDATALOOP: 	  		 ENDIF

DJNZ 	 R0,IDATALOOP

IF XDATALEN <> 0  		 		 ELSE 		 ENDIF 		 		 		

MOV 	 MOV 	 MOV 	 MOV 	 CLR 	 INC 	

DPTR,#XDATASTART

IF (LOW (XDATALEN)) <> 0

R7,#LOW (XDATALEN) R6,#(HIGH (XDATALEN)) +1 R6,#HIGH (XDATALEN) A

XDATALOOP: 	  		  		 ENDIF

MOVX 	 @DPTR,A DJNZ 	 R7,XDATALOOP DJNZ 	 R6,XDATALOOP DPTR

IF PPAGEENABLE <> 0 ENDIF 		

MOV 	

PPAGE_SFR,#PPAGE

IF PDATALEN <> 0  		  		 		

MOV 	 MOV 	 CLR 	

R0,#LOW (PDATASTART) R7,#LOW (PDATALEN) A

244
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
PDATALOOP: 	  		 ENDIF 		 MOVX 	 @R0,A INC 	 DJNZ 	 R7,PDATALOOP R0

Appendix E

IF IBPSTACK <> 0  		 ENDIF

EXTRN DATA (?C_IBP)

MOV 	

?C_IBP,#LOW IBPSTACKTOP

IF XBPSTACK <> 0 		

EXTRN DATA (?C_XBP)  		 ENDIF

MOV 	 MOV 	

?C_XBP,#HIGH XBPSTACKTOP

?C_XBP+1,#LOW XBPSTACKTOP

IF PBPSTACK <> 0  		 ENDIF 		

EXTRN DATA (?C_PBP)

MOV 	 MOV 	

?C_PBP,#LOW PBPSTACKTOP SP,#?STACK-1

; This code is required if you use L51_BANK.A51 with Banking Mode 4 ; EXTRN CODE (?B_SWITCH0) ; 		  		 		 CALL ?B_SWITCH0 ; init bank mechanism to code bank 0 LJMP ?C_START END

AXA Global Graduate Program
Find out more and apply

245
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix F

Appendix F 	 Further Examples
We list here some interesting examples for the 8032 microprocessor. Some of them do not use any RTOS at all, but rely solely on interrupts. Timer 0 in Mode 3 (split timer) and Timer 1 as a baudrate generator The first example is a program showing how we can use Timer 0 in the split mode. This is not often found detailed in books, probably because nowadays, most of the advanced versions of the 8051 have 4 or more timers available. However, if still using the original 8051, this mode 3 would effectively increase the number of timers available. In this example, the two timers from Timer 0 (here labeled as Timer 00 and Timer 000) both run as an 8-bit timer, generating interrupts. The main program checks if the required number of interrupts have been generated, and prints a statement accordingly. Timer 1 is used as a baudrate generator and since Timer 0 is running in mode 3, the only way to switch on and off the timer is by changing its mode. If timer 1 is set to mode 3, it is stopped. Thus as an example, we are starting the timer only before printing and switching it off once we are done with the printing command.
/* TimersMode3.c */ /* Timer 0 runs in mode 3 mode, thus splitting it into two timers, Timer00 and Timer000: Timer 00 generates interrupts every 156.25us, counting 144 		 		 		 */ Timer 000 generates interrupts every 78.125us, counting 72 hence 6400 interrupts would be equivalent to 1 second hence 38400 interrupts would be equivalent to 3 seconds. by swsitching it out of and into its own mode 3.

Timer 1 is used as the baud-rate generator, switching it on and off

#include <reg51.h> #include <stdio.h> void SetUp_Timer0_M3 (void); void SetUp_Timer1_M3 (void); char putchar (char c); /* Global variables */

bit T00_FLAG, T000_FLAG; // flags to indicate timer timeouts /* ------------------------------------------------ */ /*

* putchar : outputs character, used by the printf command */

246
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
char putchar (char c) { TI = 0; }

Appendix F

while (!TI);	 /* wait for transmitter to be ready */ return (SBUF = c);

/* ------------------------------------------ */ /* set up Timer 0 mode 3, GATE = C/T = 0 */ /* Assuming 11.0592 MHz clock */ /* splitting into two timers, Timer00 and Timer000 */ /* 156.25 microsecond overflow for TF0 (normal Timer 00) */ /* 78.125 microsecond overflow for TF1 (extra Timer 000) */ void SetUp_Timer0_M3 (void) {

TMOD &= 0xF0;	// clear Timer 0 control bits only TL0 = 112; 	 TH0 = 184; 	 TR1 = 1; 	

TMOD |= 0x03;	// mode 3 (two split timers), GATE = C/T = 0 // 256 - 72 ==> 78.125us for extra Timer 000 // Timer 000 ON // Timer 00 ON

// 256 - 144 ==> 156.25us for normal Timer 00

TR0 = 1;		 ET0 = 1;		 } ET1 = 1;		

// Enable TF0 interrupt, from Timer 00 overflow

// Enable TF1 interrupt, from Timer 000 overflow

/* ------------------------------------------ */ /* Set up timer 1 in mode 2, 8-auto re-load, GATE = C/T = 0 */ /* for 57600 baudrate generator */ /* Assuming 11.0592 MHz clock */

/* Since Timer 0 is in mode 3, then Timer 1 will be switched on and off /* Set also the UART */ {

by setting it to mode 2 (on) or mode 3 (off) in the application program */

void SetUp_Timer1_M3 (void) TMOD &= 0x0F;		 TMOD |= 0x30; 	 PCON |= 0X80;		 SCON = 0X52; 		 } TH1 = TL1 = 0xFF; 	 // clear timer 1 control bits only (momentarily set T1 to mode 0) // set initially to mode 3, i.e. timer off // SMOD = 1 so as to double the baudrate // transmitter ready TI = 1	 // set for 28800 or 57600 baudrate (reload value in TH1) // 8-bit UART, variable baudrate, receiver disabled ,

/* ------------------------------------------ */ /* ------------------------------------------------ */ void TF0_ISR (void) interrupt 1 using 1 { static data unsigned int TF0_OVF;	 // counts TF0 overflows TF0_OVF++; TL0 = 112;  	 {

if (TF0_OVF == 6400)

247
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
		 		 	} } TF0_OVF = 0;

Appendix F

T00_FLAG = 1;

/* ------------------------------------------------ */ void TF1_ISR (void) interrupt 3 using 2 {

static data unsigned int TF1_OVF;	 // counts TF1 overflows TF1_OVF++; TH0 = 184;  	 {

if (TF1_OVF == 38400) TF1_OVF = 0;

		 		 	} }

T000_FLAG = 1;

/* ------------------------------------------------ */ /* ------------------------------------------------ */ /* Main program */ void main(void) {

SetUp_Timer0_M3 ();	 SetUp_Timer1_M3 ();	 				

	 	

// Timer 0 mode 3 - split timer // Timer 1 (off) mode 3, // 8-bit auto reload value as a baudrate generator // initially set in mode 3, not running.

248
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
EA = 1; while(1) // Timer 1 is switched on and off just to show that we can still control it. if (T00_FLAG == 1) { {

Appendix F

// It is switched only for use as the baud rate generator before the printf command  	 	

	 TMOD = 0x23; 	// set Timer 1 to mode 2, start it as the baudrate generator 				 				 // leaving Timer 0 set to mode 3 // This method is used instead of: // TMOD &= 0x0F; 	 // TMOD |= 0x20; 	 // TH1 = 0xFF; 	 // clear timer 1 control bits only // (momentarily set T1 to mode 0) // set to mode 2, i.e. Timer 1 on // set reload value

T00_FLAG = 0;

				// 			

				 				

						

				// 				 				 				 	 TMOD = 0x33; 		 				 } if (T000_FLAG == 1) { T000_FLAG = 0; 				

// which would have placed Timer 1 momentarily in mode 0 // and thus modifying the reload value held in TH1 // (hence the baudrate) before setting it to mode 2

// Hence the need to set the reload value in TH1 every time. // Thus TMOD = 0x23 is much quicker and neater this time! // set Timer 1 to mode 3 to stop the baudrate generator // leaving Timer 0 set to mode 3

	 printf ("Timer 00 timeout every 1 second\n");

 	 	

	 TMOD = 0x23;		 				

// set Timer 1 to mode 2, start it as the baudrate generator // leaving Timer 0 set to mode 3

	 printf ("Timer 000 timeout every 3 seconds\n"); 	 TMOD = 0x33; 		 				 } }

// set Timer 1 to mode 3 to stop the baudrate generator // leaving timer 0 set to mode 3

}

249
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix F

UART using Timer 2 as the baud rate generator
/* SerialTimer2.c */ /* Timer 0 runs in mode 2 mode (8-bit auto reload) 		 		

Timer 0 generates interrupts every 156.25us, counting 144

hence 6400 interrupts would be equivalent to 1 second

Timer 1 runs in mode 2 mode (8-bit auto reload) 		

Timer 1 generates interrupts every 78.125us, counting 72

hence 38400 interrupts would be equivalent to 3 seconds.

 		 */

Timer 2 is used as the baud-rate generator, switching it on and off just when printing is needed (just for demo).

#include <reg52.h>	 // use 8052/8032 SFR registers #include <stdio.h> void SetUp_Timer0_M2 (void); void SetUp_Timer1_M2 (void); char putchar (char c); /* Global variables */ void SetUp_Timer2_Serial (void);

bit T0_FLAG, T1_FLAG; // flags to indicate timeout /* ------------------------------------------------ */ /* * putchar : outputs character, used by the printf command */

char putchar (char c) { TI = 0; }

while (!TI);	 /* wait for transmitter to be ready */ return (SBUF = c);

/* ------------------------------------------ */ /* Set up Timer 0 mode 2, 8-bit timer auto reload, GATE = C/T = 0 */ /* Assuming 11.0592 MHz clock */ void SetUp_Timer0_M2 (void) { /* 156.25 microsecond overflow for TF0 */

TMOD &= 0xF0;	// clear timer 0 control bits only TL0 = 112; 	 TH0 = 112; 	

TMOD |= 0x02;	// mode 2 (8-bit reload), GATE = C/T = 0 // reload value in TH0 // Timer 0 ON

// 256 - 144 = 112 ==> 156.25us for Timer 0 // Clear overflow flag // Enable TF0 interrupt, from Timer 0 overflows

TF0 = 0;		 TR0 = 1;		 } ET0 = 1;		

/* ------------------------------------------ */

250
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
/* Set up Timer 1 in mode 2, 8-bit auto reload, GATE = C/T = 0 */ /* Assuming 11.0592 MHz clock */ /* 78.125 microsecond overflow for TF1 */ void SetUp_Timer1_M2 (void) { TMOD &= 0x0F;		 TMOD |= 0x20; 	 TF1 = 0;		 TR1 = 1; 		 } ET1 = 1;		 TH1 = TL1 = 184; 	

Appendix F

// clear Timer 1 control bits only (momentarily set T1 to mode 0) // set to mode 2 // 256 - 72 = 184 ==> 78.125us for Timer 1 (reload value in TH1) // Clear overflow flag // Timer 1 ON

// Enable TF1 interrupt, from Timer 1 overflows

/* ------------------------------------------ */ /* Set up Timer 2 in mode 2, 16-bit auto reload, GATE = C/T = 0 */ /* for 345600 baudrate generator */ /* Assuming 11.0592 MHz clock */

/* Serial Port is also set to use Timer 2 as the baud rate generator for Tx and Rx */ void SetUp_Timer2_Serial (void) { C_T2 = 0;			 // Timer 2 in timer mode // reload values

TH2 = TL2 = 0xFF; 		 RCLK = TCLK = 1; 		 SCON = 0X52; 		

RCAP2H = RCAP2L = 0xFF;	

// set for 345600 baudrate (reload value in TH1) // use Timer 2 as the baud rate generator for Rx and Tx

transmitter ready TI = 1	 }

// 8-bit UART, variable baudrate, receiver disabled ,

/* ------------------------------------------ */ /* ------------------------------------------------ */ void TF0_ISR (void) interrupt 1	 { using 1

static data unsigned int TF0_OVF;	 // counts TF0 overflows TF0_OVF++; { if (TF0_OVF == 6400) TF0_OVF = 0; T0_FLAG = 1;

 	

		 		 	} }

/* ------------------------------------------------ */ void TF1_ISR (void) interrupt 3	 { using 2

static data unsigned int TF1_OVF;	 // counts TF1 overflows TF1_OVF++; { if (TF1_OVF == 38400) TF1_OVF = 0; T1_FLAG = 1;

 	

		 		 	}

251
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
} /* ------------------------------------------------ */ /* ------------------------------------------------ */ /* Main program */ void main(void) {

Appendix F

SetUp_Timer0_M2 ();	 SetUp_Timer1_M2 ();	

	 	

// Timer 0 mode 2 // Timer 1 mode 2 // Timer 2 and serial port set up.

SetUp_Timer2_Serial ();	 				 EA = 1;		 while(1) { 		

// Timer 2 as the 345600 baud rate generator. // enable the 8051 to accept interrupts

// Timer 2 is switched on and off just to show that we can still control it. // It is usually left running throught the whole program // (unless you want to reduce battery consumption!)  	 	 	 	 if (T0_FLAG == 1) { T0_FLAG = 0;

// It is switched on only for use as the baud rate generator before the printf command

	 printf ("Timer 0 timeout every 1 second\n"); } { TR2 = 0; 	 	

TR2 = 1;		

// start Timer 2 as the baudrate generator // stop the baudrate generator

 	 	 	 	

if (T1_FLAG == 1) T1_FLAG = 0;

	 printf ("Timer 1 timeout every 3 seconds\n"); } } TR2 = 0; 	 	

TR2 = 1;		

// start Timer 2 as the baudrate generator // stop the baudrate generator

}

Serial routine with full XON/XOFF capability The next example program here is a serial routine with full XON/XOFF handshaking capability. This was adapted from a program by Sasha Jevtic (sjevtic@ece.northwestern.edu). It uses two circular buffers, one to hold the received bytes and another separate one for the bytes to transmitted. The principle behind this XON/XOFF protocol is explained below, and uses two special characters to control the transmission flow of data. CTRL-S which is 17 decimal or 11 hexadecimal, used to stop the transmission. CTRL-Q which is 19 decimal or 13 hexadecimal, used to continue (resume) the transmission.

252
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix F

For the RECEIVER side, a character reception from some external source, causes an RI interrupt. The RI ISR routine therefore handles any characters which are received. If there is space in the RX buffer, it simply stores it there but if the buffer approached the limit, it will store that character and causes the TX to send an XOFF character to the external source (which should also be running under an XON/ XOFF protocol) so that the external source pauses its transmission. Data from the RX buffer would be handled by the main program which should ensure that the buffers are emptied regularly of any data. Once the RX buffer is emptied, an XON character would be sent to the external source so that it can resume with its transmission. If an XOFF character is received, this would cause the TX to be disabled immediately (since this would imply that the external source RX buffer is full). It would be re-enabled once an XON character is received. For the TRANSMITTER side, data from the main program would be written to the buffer. As soon as there is some data in the TX buffer, the TI ISR would be triggered to start the transmission. Since the TI is itself set once a character has been transmitted, this would ensure that the TX buffer is always emptied once the transmission is started (unless it is stopped by an XOFF character from the external device). Therefore the TI ISR handles the transmission from the buffer on to some external device. The main program ‘printing’ routine would place characters directly in the TX buffer for transmission, if there is space. If the TX buffer is full, it would simply wait for room in the buffer, since the transmission would be taking place under interrupt control. Since this protocol uses XON/XOFF as special characters, it is generally used for text data (which does not have the XON/XOFF characters) and it cannot be used as it is with any random data since they might have these XON/XOFF characters as part of the data itself. Further details can be found in the remarks within the program listings.
/* */ ** XONXOFF.H #ifndef SERIAL_H #define SERIAL_H #include <reg52.h> // Some commonly used non-printing ASCII codes. #define CTRL_C 		 #define CTRL_Q 		 #define CTRL_S 		 #define DEL 		 #define CR 		 #define LF 		 //#define CTRL_Q 	 //#define CTRL_Q 	 0x03 0x11 0x13 0x7F 0x08 0x0D 0x0A 0x07 'q'	 // for testing 's'	 // for testing

#define BACKSPACE 	

#define BELL 		

253
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#ifdef SMALLBUFFER #define TXLEN 		 #define RXLEN 		 #else

Appendix F

128 16 /* Rx Threshhold for sending XOFF */

#define RXThreshHold 	 8 	 #define TXLEN 		 #define RXLEN 		 1024 1024

#endif

#define RXThreshHold 	 512 	

/* Rx Threshhold for sending XOFF */

void putbuf(char c); char _getkey(void);

char putchar(char c); void init_serial(unsigned int br); #endif	 // SERIAL_H ** XonXoff.c **	 ** Modified by Paul Debono (2007) from -----------------------********************-------------------------------

** RTMS 2.0 I/O: serial.c v1.0.0 (16/03/05) ** ** ** */ #include "XonXoff.h"

** By Sasha Jevtic (sjevtic@ece.northwestern.edu) ** Implements an interrupt controlled serial port interface ** TRANSMITS,RECEIVES AND REACTS TO XON/XOFF characters for flow control

typedef enum {NORMAL, FULL, DRAINING, EMPTY} RECV_STATE_T; /*The way the pointers work is as follows: Pointers are always incremented by 1, modulus LEN That is if LEN = 32, pointers range form 0 to 31 Tx Buffer:

Data for transmission is placed in the buffer in the location pointed to by 't_in'. Data is passed on to SBUF for transmission via UART using pointer 't_out'. Thus 	 t_out points to the next character to be sent to SBUF. In each case, the pointer is moved AFTER reading or writing from/to buffer,  	 t_in points to the location where the next character will be placed

		 in Tx buffer for future transmission If AFTER incrementing 't_out', 		 	 	

't_in' and 't_out' point to the same location, then the buffer is empty.

If AFTER incrementing 't_in', 	 	

't_in' = 't_out' point to the same location, then the buffer is full

Rx Buffer:

Data is received in the buffer in the location pointed to by 'r_in' Data is read from the buffer using pointer 'r_out' In each case, the pointer is moved AFTER reading or writing from/to buffer

254
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
Thus r_out points to the next character to be read. when it is received.

Appendix F

	

		 	 	 	

r_in points to the location where the next character will be placed

If AFTER incrementing 'r_out',

'r_in' and 'r_out' point to the same location, then the buffer is empty.

If AFTER incrementing 'r_in', 	 	

'r_in' = 'r_out' point to the same location, then the buffer is full

SERIAL INTERRUPTS ARE DISABLED WHEN HANDLING BUFFERS Meanings of receiver states (and related policies) are as follows: 			 	 - FULL:	 		 - NORMAL: 	 Receive buffer is empty or filling, but is not full. Reception should proceed normally.

Receive buffer has been marked full. We need to send an

				buffer. 	 		

XOFF character so that the sender allows us to relieve our

- EMPTYING: 	 Receive buffer is full or emptying, but is not empty.

				 				 				 				 				 		

An XOFF character has already been sent, so reception should

be suspended until the buffer is empty. If we permitted

reception prior to completely emptying the buffer, we would buffer would soon fill up again. This would be inefficient,

put ourselves in a situation where it is very likely that the as we wish to keep the XON/XOFF : data byte ratio very low.

This hysteresis helps to achieve that goal.

I’M WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

255
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
- EMPTY:	 		 Receive buffer has been marked empty. We need to send an XON character so that the sender begins sending us data again.

Appendix F

It is worth noting that for Windows communication, a significant receive

buffer is required. Furthermore, the threshhold level at which XOFF is sent must be significantly below the buffer's capacity. This is required for a couple of reasons.

First, there might already be an incoming byte working its way through the from the DTE to our XOFF, if space does not become available in the buffer Secondly, and moreover, Windows seems to be very slow in responding to our XOFF; that is, it continues to send data for a significant period before Received data integrity is a priority. honoring our stop request. So, we need space to buffer that incoming data. */

UART at the time that XOFF is sent. Even assuming an instantaneous response prior to the firing of the receive interrupt for this byte, it will be lost.

#ifdef SMALLBUFFER	 // use IDATA, character size pointers unsigned char data t_out; 	 unsigned char data t_in; 	

/* transmission buffer start index 	 */ /* transmission buffer end index 	 */

char idata TxBuffer[TXLEN]; 	/* storage for transmission buffer 	 */ // It seems we need 128 bytes of buffer to run at 57600 or 115200 kbps. // when receiving characters from a PC (Windows) unsigned char data r_out; 	 unsigned char data r_in; 	 // These values depend on sender reaction time (to XOFF) and on the baudrate /* receiving buffer start index 	 /* receiving buffer end index 	 */ */ */

char idata RxBuffer[RXLEN]; 	/* storage for receiving buffer 	 #else // LARGEBUFFER - use XDATA, integer size pointers unsigned int data t_out; 	 unsigned int data t_in; 	 /* transmission buffer start index */ /* transmission buffer end index */

char xdata TxBuffer[TXLEN]; 	/* storage for transmission buffer */ // It seems we need 128 bytes of buffer to run at 57600 or 115200 kbps. // when receiving characters from a PC (Windows) unsigned int data r_out; 	 unsigned int data r_in; 	 #endif // buffer size // These values depend on sender reaction time (to XOFF) and on the baudrate /* receiving buffer start index 	 /* receiving buffer end index 	 */ */ */

char xdata RxBuffer[RXLEN]; 	/* storage for receiving buffer 	

bit TxBfull; 			 bit TxActive; 			 bit TxStop; 			 bit TxBusy; 			

/* flag: marks transmit buffer full 	 */ /* flag: marks transmitter active 	 /* flag: marks XOFF character 		 /* flag: marks transmitter busy 	 */ */ */

bit TxBempty;			 bit RxBempty;			 bit RxBfull;			 RECV_STATE_T recvstate; 	

/* flag: marks transmit buffer empty 	 */ /* flag: marks receive buffer empty 	 */ /* flag: marks receive buffer full 	 /* receiver state, for flow control 	 */ */

enum {FALSE,TRUE} CONDITION_T;

256
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
#ifdef SMALLBUFFER {

Appendix F

unsigned char RxBufUsed() unsigned char size; if(r_in >= r_out) else size = (r_in - r_out); size = (RXLEN-(r_out - r_in)); } { } return(size);

bit RxBufOverTHLD() return(RxBufUsed()>RXThreshHold ? TRUE : FALSE);

#else {

unsigned int RxBufUsed() unsigned int size;  	  	 } { } if(r_in >= r_out) else size = (r_in - r_out); size = (RXLEN-(r_out - r_in));

return(size);

bit RxBufOverTHLD() return(RxBufUsed()>RXThreshHold ? TRUE : FALSE);

#endif /*****************************************************************************/ /* 	 /*****************************************************************************/ void putbuf(char c) { if (!TxBfull) { 			 /* transmit only if buffer not full 	 */ putbuf: write a character to SBUF or transmission buffer */

/*

Note that if buffer is full, waiting is handled by putchar routine which calls putbuf.

*/

ES = 0; 				 if (!TxActive && !TxStop) { 		 	 } TxActive = 1; 			 SBUF = c; 			

/* disable serial interrupt 		 /* if transmitter not active: 	

*/ */ */

 	

/* transfer the first character direct */ /* to SBUF to start transmission 	 /* otherwise: */

 	 	

else { 				

TxBuffer[t_in] = c; 		

	 TxBempty = 0;			  	 if (t_in == t_out) {

t_in = ++t_in & (TXLEN-1); 	 /* at the same time incrementing 	

/* transfer char to transmit buffer 	 */ /* the pointer in circular fashion 	 */ */

257
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
 	 } 	 } } TxBfull = 1; 			 /* set flag if buffer is full 		 */

Appendix F

  }

ES = 1; 			

/* enable serial interrupt 		

*/

/*****************************************************************************/ /* 	 putchar: 						*/ /* 	 /* 	 Places character in Tx buffer if there is space 	 otherwise wait (space created by serial ISR) 	 */ */

/*****************************************************************************/ char putchar(char c) { if (c == '\n') { 		 while (TxBfull) {;} 		 putbuf (0x0D); 		 } 			 /* expand new line character: 	 /* can omit if not needed 		 */ */

				 	

/* wait for transmission buffer space */ /* which is cleared by the serail ISR */ /* send CR before LF for <new line> 	 */

while(TxBfull) {;} /* wait for transmission buffer space */ putbuf(c); /* send character */ } return(c); /* return character: ANSI requirement */

/*****************************************************************************/

If it really matters, make it happen – with a career at Siemens.

siemens.com/careers

258
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
/* 	 _getkey: 								*/ /* 	 /*	 Waits if no character, until one is received via serial ISR 	 char _getkey(void) { unsigned char data c; while (RxBempty) {;} /* wait for a character in Rx buffer, 	 Read data from Rx buffer (using scanf say) 				 */ */

Appendix F

/*****************************************************************************/

in the mean time, any RI interrupt will fill buffer, */

and therefore RX buffer will no longer remain empty

ES = 0;

c = (RxBuffer[r_out]); 		 r_out = ++r_out & (RXLEN-1); if(r_out==r_in) RxBempty = 1;

/* take next char from buffer 	

*/

if ((recvstate == DRAINING) && 	 (RxBempty)) { 			 TI = 1; 				 } ES = 1; } recvstate = EMPTY; 			

/* if RX was full and now emptying... */ /* ...and RX actually has emptied 	 /* prepare to send XON 		 /* force TI so as to send XON 	 */ */ */

return(c);

/*****************************************************************************/ /* 		 /*****************************************************************************/ serial () interrupt 4 using 1 	 { unsigned char c; /* use registerbank 1 for interrupt 	 */ serial: serial receiver / transmitter interrupt */

bit start_trans = 0;

if (RI) { 				 c = SBUF; 				 RI = 0; 				 switch (c) { 				 TxStop = 1; 				 break;  	  	 	 case CTRL_Q:				 TxStop = 0; break;

/* if receiver interrupt 		 /* read character 			 /* process character 			 /* if Control+S stop transmission 	 /* XON */ /* clear interrupt request flag 	

*/ */ */ */ */

case CTRL_S:				/* XOFF 				*/

start_trans = TxStop; 		

/* if Control+Q start transmission 	 */

default: 				 if (!RxBfull) {

/* put all other characters into RxBuffer */

 	

RxBuffer[r_in] = c;

259
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
		 } r_in = ++r_in & (RXLEN-1); /* check if over thresh hold is done*/

Appendix F

		 RxBempty = 0;			 /* below instead of just checking if full */ 		  	 	  	 { /* check if RX above XOFF threshhold */

if (RxBufOverTHLD())

			 	 } } }

		

if (recvstate == NORMAL) { 	 RxBfull = 1;

recvstate = FULL; 		

/* prevent "oscillations" 		

/* prepare to send XOFF 		

*/

*/

break; if (TxBusy) return;	 /* do not send anything until transmitter free 	 }							// end of RI start_trans || 	 */ */ */ */ */ */ */ */ */ */ */ */ */ */ */ */

 			

/* It will return to the ISR when TI=1 after tx 	 /* if transmitter interrupt 			

if (TI || 			 	  	 	 	

(recvstate == FULL) || /* or we need to send an XOFF 		 (recvstate == EMPTY)) {/* or we need to send an XON 			 TxBusy = 0; 		 TI = 0; 		

/* or we received an XON and must start 	

if (TI) {

 	

/* TX interrupt means not busy anymore 	 /* clear interrupt request flag 		 /* we need to send an XOFF 			 /* send XOFF command to other sender 		

	}  	 	 	 }  	 	 	 }

if (recvstate == FULL) { 	 TxBusy = 1; SBUF = CTRL_S;		

recvstate = DRAINING; /* slowly wait for RX buffer to drain 	

else if (recvstate == EMPTY) { /* we need to send an XON 			 TxBusy = 1; SBUF = CTRL_Q;				 /* send XON to sender 	

recvstate = NORMAL; 	 /* we are back in business, receiving 	 /* if more characters in buffer and 		 /* if not received Control+S (XOFF) 		

else if (!TxBempty) { 	  	  	  	 if ((!TxStop) && 		 TxBusy = 1;

(recvstate == NORMAL)) { /* and receive buffer isn't overwhelmed 	 */ SBUF = TxBuffer[t_out]; /* transmit character 			 t_out = ++t_out & (TXLEN-1); if (t_out==t_in) TxBempty =1; */

		 		 } } }

TxBfull = 0; /* clear 'TxBfull' flag */

else TxActive = 0; 		 }

/* if all transmitted sender not active 	

*/

260
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
void init_serial(unsigned int baudrate) { SCON = 0x50; 			 				 				 PCON &= 0x7F; 			 TMOD &= 0x0F; 			 TMOD |= 0x20; 			 RCLK = 0; 			 TCLK = 0; 			 switch (baudrate) {  	 case 600: TH1 = TL1 = 0xD0; 				 /* Setup serial port control register */ /* Mode 1: 8-bit uart var. baud rate */ /* REN: enable receiver, TI=0 */

Appendix F

/* Clear SMOD bit in power ctrl reg (no double baudrate) */ /* Setup timer/counter mode register */ /* Clear M1 and M0 for timer 1 */ /* Set M1 for 8-bit auto-reload timer 1 */ /* USE TIMER 1 FOR RECEIVE BAUD RATE (8032 only) */ /* USE TIMER 1 FOR TRANSMIT BAUD RATE (8032 only) */

		 break;  	 case 1200:

		 break;  	 case 2400:

TH1 = TL1 = 0xE8;

		 break;  	 case 4800:

TH1 = TL1 = 0xF4;

		 break;

TH1 = TL1 = 0xFA;

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

261
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
case 9600:

Appendix F

 	

		 break;  	 case 19200:

TH1 = TL1 = 0xFD;

		 PCON |= 0x80; /* double baudrate */ 		 break;  	 case 57600:

TH1 = TL1 = 0xFD;

		 PCON |= 0x80; /* double baudrate */ 		 break; }

TH1 = TL1 = 0xFF;

// Make sure we start in a clean state. TxBempty = 1; TxBfull = 0; TxStop = 0; TxBusy = 0; RxBempty = 1; RxBfull = 0; t_out = 0; t_in = 0; r_in = 0; r_out = 0; TI = RI = 0; recvstate = NORMAL; TxActive = 0;

TR1 = 1; /* Start timer 1 for baud rate generation */ ES = 1;					 } EA = 1;					

/* enable serial interrupts */ /* enable global interrupts */

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------*/

262
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix G

Appendix G	 8086 PaulOS RTOS
8086 PaulOS RTOS Demo Program Sometimes, we had encountered instances where students wanted to use some 8086-based development board as their embedded system. An 8086 version of the basic PaulOS RTOS was therefore developed and is being given here just for the benefit of those who are keen on the 8086 processor. This is in fact just a demonstration version of the PaulOS RTOS program, written for the Intel 8086/8088 micro-processor. It can be compiled on the latest PCs using any good 8086 assembler (such as MASM) to produce the .COM file which can then be executed directly. It is composed of four modules: •	 The main module CLOCK1.ASM, which basically contains the application program and ‘includes’ the other .INC files •	 The RTOS ‘include’ file OSTICKHD.INC – header •	 The RTOS ‘include’ file OSTICKMD.INC – middle •	 The RTOS ‘include’ file OSTICKFT.INC – footer The .INC files are the actual PaulOS RTOS program, written in assembly language for the 8086.

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It’s not what we do. It’s how we do it.

Impact matters.
navigant.com

©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

263
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II

Appendix G

The main program is a simple clock, displaying time in HH:MM:SS format. It uses three tasks, one task for the hour, another task for the minute and the last task for the second. The MINUTE and HOUR tasks are always waiting for a signal while the SECOND task is simply waiting for a time delay of 1 second. Once 60 seconds have passed, it sends a signal to the MINUTE task. Similarly once 60 minutes have passed, the MINUTE task would send a signal to the HOUR task.
; CLOCK1.ASM ;	 ; ; ; ; ;	 Using BIOS INT to get time ticks since midnight Used to generate rtos ticks

;	

Written by Paul P. Debono ( JAN 2012 )

;======================================================== ; EQUATES ; APPLICATION SETTINGS NUM_OF_TASKS 	 EQU 3 IDLE_TASK 	 include ostickhd.inc EQU NUM_OF_TASKS

;============================================================ ;============================================================ CODESEG 	 ASSUME 		 SEGMENT CS:CODESEG, DS:CODESEG, SS:CODESEG ; advices MASM ; which segments to use

					

ORG 100H ; start at offset 100H FOR COM FILE START: 		 	 	 	 	 	 	 MOV AX, CS MOV DS,AX MOV SS,AX

	 	

MOV SP, OFFSET TOP_OF_STACK JMP MAIN

 			

MOV WORD PTR [MY_CODE_SEG], CS ; STORAGE FOR CS, WHENEVER NEEDED

;============================================================ ;============================================================ include ostickmd.inc ;============================================================ ;============================================================ ;============================================================ ;============================================================ ; START OF MAIN TEST (APPLICATION) PROGRAM ;============================================================ ;============================================================

264
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MAIN: 	 	 	 	 	 	

Appendix G

; PARAMETERS FOR OS_CREATE ARE THE TASK NUMBER AND THE TASK ROUTINE NAME OS_CREATE_TASK 0, SEC OS_CREATE_TASK 1, MIN OS_CREATE_TASK 2, HR MOV AH, 9 ; PRINT DOLLAR TERMINATED STRING MOV DX, OFFSET MESSAGE01 INT 21H

TOP: 	 OS_RTOS_CHECK_TICK  	  	  	  	  	  	 HALT: 	 	 	 	 MOV AH,01H ; CHECK FOR ANY KEY PRESS TO HALT PROGRAM INT 16H ; BUT DO NOT WAIT FOR THE KEYPRESS JZ TOP CMP AL, 'X' JE HALT JE HALT CMP AL, 'x' JMP TOP ; PROGRAM LOOPS HERE MOV AH, 4CH ; EXIT TO OS INT 21H

; ==================================================== ; ; ; ; SEC PROC NEAR SEC_TASK:  		  		  		  		 		 		 		 		 OS_PERIODIC 1000/TICKTIME_MS ; PERIOD SET FOR 1s OS_WAIT_PERIOD JE SKIP1S JE SKIP2S ; 		 ; 	 TASKS

ALL TASKS MUST BE ENDLESS LOOPS

CMP WORD PTR [SECONDS], 3935H ;59 ASCII INVERTED CMP BYTE PTR [SECONDS + 1], '9' INC BYTE PTR [SECONDS + 1] CALL DISPLAY_CLOCK JMP SEC_TASK

 		 		 		

SKIP2S: 	

MOV BYTE PTR [SECONDS + 1], '0' INC BYTE PTR [SECONDS] CALL DISPLAY_CLOCK JMP SEC_TASK

 		 SKIP1S:  		  		 SEC ENDP 		

MOV WORD PTR [SECONDS], 3030H OS_SIGNAL_TASK 1 JMP SEC_TASK

265
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
MIN PROC NEAR MIN_TASK:  		  		  		  		 		 		 		 OS_WAITS 	 JE SKIP1M JE SKIP2M ; WAIT FOR 'END OF MINUTE' SIGNAL

Appendix G

CMP WORD PTR [MINUTES], 3935H

CMP BYTE PTR [MINUTES + 1], '9' INC BYTE PTR [MINUTES + 1] CALL DISPLAY_CLOCK JMP MIN_TASK

 		 		 		

SKIP2M: 	

MOV BYTE PTR [MINUTES + 1], '0' INC BYTE PTR [MINUTES] CALL DISPLAY_CLOCK JMP MIN_TASK

 		 SKIP1M:  		  		 MIN ENDP HR_TASK: HR PROC NEAR  		  		  		  		 		 		 		

MOV WORD PTR [MINUTES], 3030H OS_SIGNAL_TASK 2 JMP MIN_TASK

OS_WAITS ; WAIT FOR 'END OF HOUR' SIGNAL JE SKIP1H JE SKIP2H

CMP WORD PTR [HOURS], 3332H ; 23 ASCII INVERTED CMP BYTE PTR [HOURS + 1], '9' INC BYTE PTR [HOURS + 1]

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There’s no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives — and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It’s why we employ 135 different nationalities. It’s why we’ve taken proactive steps to increase female representation at the highest levels. And it’s just one of the reasons why you’ll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

266
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
		 CALL DISPLAY_CLOCK JMP HR_TASK MOV BYTE PTR [HOURS + 1], '0' INC BYTE PTR [HOURS] CALL DISPLAY_CLOCK JMP HR_TASK

Appendix G

 		 SKIP2H: 	 		 		

 		 SKIP1H:  		  		 HR ENDP 		

MOV WORD PTR [HOURS], 3030H CALL DISPLAY_CLOCK JMP HR_TASK

;******************************* ;

; THIS ROUTINE DISPLAYS THE CLOCK DISPLAY_CLOCK: 	 	 	 	 RET 	 MOV 	 MOV 	 INT 	 POP	

PUSH 	 DX AH, 9 ; PRINT DOLLAR TERMINATED STRING DX, OFFSET FRONT_SPACE 21H DX

;******************************* ;start of our data area (if neeeded) ; ; ; APPLICATION DATA AREA ; variable to store original ; value of SI register. FRONT_SPACE 	 HOURS 		 COLON1 		 COLON2 		 DB " " DB ':' DB ':' DB "23" DB "58" DB "40",13,'$'

MINUTES 	 SECONDS 	  		 ; ;

MESSAGE01 	

DB 13,10,10," RTOS CLOCK DEMO PROGRAMME", 13,10 DB " (PRESS X OR x TO EXIT)", 13,10,10,'$'

include ostickft.inc TOP_OF_STACK DB 0 CODESEG ENDS END START ;================================================== ; OSTICKHD.INC ; ; ; 		 ;end of our data area

;========================================================

Written by Paul P. Debono ( JAN 2012 )

;========================================================

267
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; EQUATES ; RTOS SETTINGS TICKTIME_MS 		 STACK_SIZE 		 PARAM_SIZE 		 PARAM_SIZE_REDUCED 	 EQU 55 ; APPROXIMATELY 55ms TICKTIME EQU 40 EQU 50 ; 10 + STACK_SIZE

Appendix G

			 ; SEE END OF FILE, WHEN DECLARING TASK_PARAM ; RTOS PARAMETERS OFFSETS, FOR EACH TASK SIGNAL_FLAG 		 INT_NUM 		 SP_STORE 		 TIME_OUT 		 EQU 0 ; DB 0 EQU 1 ; DB 0 EQU 2 ; DW 0 EQU 4 ; DW 0 EQU 6 ; DW 0 EQU 8 ; DW 0 EQU 49 ; PARAM_SIZE - 1

EQU 10 ; USED IF A LARGE NUMBER OF TAKS ARE BEING USED

PERIOD_CURRENT 	 PERIOD_RELOAD 		 STACK_AREA 		 ; EQUATES

; points to top of stack

;============================================================ ;============================================================ ; MACROS USED BY THE RTOS PUSH_ALL_REGS MACRO 		 		 		 		 		 		 		 		 	 ENDM REG_PUSHES EQU 7 ; NUMBER OF PUSHED REGISTERS IN PUSH_INT_REGS PUSHF

PUSH AX PUSH BX PUSH CX PUSH DX PUSH BP PUSH DI PUSH SI

POP_ALL_REGS MACRO 		 		 		 		 		 		 		 		 	 ENDM

POP SI POP DI POP BP POP DX POP CX POP BX POP AX POPF

PUSH_INT_REGS MACRO 		 		 		 		 		 		 		 	 ENDM

PUSH AX PUSH BX PUSH CX PUSH DX PUSH BP PUSH DI PUSH SI

268
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
POP_INT_REGS MACRO 		 		 		 		 		 		 		 	 ENDM

Appendix G

POP SI POP DI POP BP POP DX POP CX POP BX POP AX

OS_CREATE_TASK MACRO TASKNUM, TASKNAME 		 		 		 ; ; 	 ENDM MOV DX, OFFSET TASKNAME MOV AL,TASKNUM CALL CREATE_TASK

; COMMANDS WHICH CAUSE A TAK CHANGE NEED TO HAVE TWO ADDITIONAL ; TICK TIME ISR. ; ;

; REGISTER PUSHES, SINCE A TAKS CHANGE MAY ALSO BE CALLED BY THE ; HENCE WE NEED TO SIMULATE AN INTERRUPT CALL WHERE NEEDED

OS_WAITT MACRO TIMETICKS 		 		 PUSHF 		

MOV DX, TIMETICKS PUSH CS 	

 		  		 	 ENDM

; USED TO SIMULATE AN INTERRUPT CALL ; USED TO CALL RTOS ROUTINES WHICH ; CAUSE A TASK CHANGE

CALL WAITT 	

OS_PERIODIC MACRO TIMETICKS 		 		 	

MOV DX, TIMETICKS CALL PERIODIC

ENDM

OS_WAIT_PERIOD MACRO  		  		 	 ENDM 		

PUSHF ; USED TO SIMULATE AN INTERRUPT CALL PUSH CS ; USED TO CALL RTOS ROUTINES WHICH CALL WAIT_PERIOD ; CAUSE A TASK CHANGE

OS_WAITS MACRO  		  		 	 ENDM 		

PUSHF ; USED TO SIMULATE AN INTERRUPT CALL PUSH CS ; USED TO CALL RTOS ROUTINES WHICH CALL WAITS ; CAUSE A TASK CHANGE

OS_SIGNAL_TASK MACRO TASKNUM 		 		 	

MOV AL, TASKNUM

ENDM

CALL SIGNAL_TASK

OS_RTOS_CHECK_TICK MACRO

; GET the new number of ticks since midnight.

; if there was a new tick, then the RTOS Tick TImer ISR

269
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; routine must be called. 		  		  		  		 		 		 		 		 MOV AH, 0 INT 1AH CMP CS:WORD PTR [OldTick], DX ; compare with old JE NOCHANGE PUSHF MOV CS:WORD PTR [OldTick], DX ; and save it PUSH CS

Appendix G

NOCHANGE: NOP 	 ENDM

					

CALL OS_TICK_TIMER 	

; call ticktimer ISR,

; simulating an interrupt call

;============================================================ ;============================================================ ;============================================================ ; OSTICKMD.INC ; 	 ; Written by Paul P. Debono ( JAN 2012 )

;============================================================ ;============================================================ ;============================================================ ; RTOS TICK TIMER INTERRUPT SERVICE ROUTINE (ISR) ; ; THIS IS THE MAIN RTOS ISR ROUTINE WHICH COMES INTO PLAY ; ;

; AT EVERY TICK TIME, AND SCHEDULES ANY TASK CHANGES REQUIRED. ; A NORMAL TICK TIME INTERVAL WOULD BE EVERY 1 MILLISECOND. ; IT DECREMENTS WAITING TICK TIMES FOR EACH TASK, IF WAITING ; AND FORCES A TASK CHANGE IF REQUIRED ; BY CHANGING THE STACK CONTENTS. OS_TICK_TIMER PROC NEAR

			PUSH_INT_REGS ; FIRST CHECK THE PERIODIC INTERVAL TASKS	 	 		 	 MOV CX,NUM_OF_TASKS MOV DL,PARAM_SIZE MOV AL,CL 	 DEC AL 		 MUL DL MOV BX,OFFSET TASK_PARAM ; TASK NUMBERS RANGE = ( 0 TO NUM_OF_TASKS - 1) ; AL NOW CONTAINS THE HIGHEST TASK NUMBER

 		  		 		 		

CHECK0: 	

 		  		  		  		

MOV SI,AX ; SI CONTAINS OFFSET IN TASK RECORD CMP WORD PTR [BX + SI + PERIOD_RELOAD],0 JZ NEXT_CHECK0 ; SKIP IF TASK IS NOT WAITING PERIODICALLY DEC WORD PTR [BX + SI + PERIOD_CURRENT] ; DECREMENT TIME JNZ NEXT_CHECK0

; IF PERIODIC TIME OUT HAS FINISHED,  		  		

; FIRST RELOAD PERIODIC CURRENT COUNTER

MOV AX,WORD PTR [BX + SI + PERIOD_RELOAD]

MOV WORD PTR [BX + SI + PERIOD_CURRENT],AX

270
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; THEN PLACE THAT TASK IN THE READY QUEUE PUT_IN_Q0: 	  		  		  		 NEXT_CHECK0: 		 		 		 INC WORD PTR [TOP_OF_Q] MOV AL,CL MOV SI, WORD PTR [TOP_OF_Q] DEC AL ; AL NOW CONTAINS THE TASK NUMBER

Appendix G

MOV BYTE PTR [SI],AL ; PLACE TASK ON READY QUEUE AND

MOV BYTE PTR [NEW_TASK_IN_Q],1 ; INDICATE THAT A NEW TASK WAS PLACED IN Q LOOP CHECK0 ; REPEAT FOR THE NEXT TASK MOV CX,NUM_OF_TASKS MOV DL,PARAM_SIZE MOV AL,CL MUL DL

; NOW CHECK TASKS AGAIN FOR ANY NORMAL TIME OUTS 	 		 	 MOV BX,OFFSET TASK_PARAM

 		  		 		 		

CHECK1: 	

DEC AL ; AL NOW CONTAINS THE TASK NUMBER MOV SI,AX ; SI CONTAINS OFFSET IN TASK RECORD CMP WORD PTR [BX + SI + TIME_OUT],0 JZ NEXT_CHECK1 ; SKIP IF TASK IS NOT WAITING FOR ANY TIMEOUT DEC WORD PTR [BX + SI + TIME_OUT] ; DECREMENT TIMEOUT JNZ NEXT_CHECK1

 		  		  		  		

; IF TIME OUT FINISHED, THEN PLACE THAT TASK IN THE READY QUEUE PUT_IN_Q: INC WORD PTR [TOP_OF_Q]  		 		 		 		 NEXT_CHECK1: 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 MOV AL,CL MOV SI, WORD PTR [TOP_OF_Q] DEC AL ; AL NOW CONTAINS THE TASK NUMBER

MOV BYTE PTR [SI],AL ; PLACE TASK ON READY QUEUE AND

MOV BYTE PTR [NEW_TASK_IN_Q],1 ; INDICATE THAT A NEW TASK WAS PLACED IN Q LOOP CHECK1 ; CHECK THE NEXT TASK CMP BYTE PTR [NEW_TASK_IN_Q],1 JNE CARRY_ON CMP BYTE PTR [RUNNING], IDLE_TASK

;CHECK IF THERE IS A NEED FOR A TASK CHANGE

JNE CARRY_ON ; RTOS CAN ONLY INTERRUPT THE IDLE TASK MOV BYTE PTR [NEW_TASK_IN_Q],0 ; CLEAR NEW TASK IN Q FLAG MOV BX,OFFSET TASK_PARAM MOV DL,PARAM_SIZE

; A TASK CHANGE IS REQUIRED

; NOW SAVE STACK POINTER FOR CURRENT TASK

MOV AL,BYTE PTR [RUNNING] ; GET CURRENT TASK NUMBER MUL DL ; AX = AL * DL

MOV SI,AX ; SI CONTAINS OFFSET IN TASK RECORD ; NOW INITIATE A TASK CHANGE

MOV WORD PTR [BX + SI + SP_STORE],SP ; SAVE SP FOR THIS TASK ; GET THE NEXT TASK NUMBER WHICH IS READY TO RUN

		CALL SHIFT_READYQ

271
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
		 		 		 		 		 		 		 CARRY_ON: 		 ; NOW RESTORE STACK POINTER FOR THE NEW TASK MOV BX,OFFSET TASK_PARAM MOV DL,PARAM_SIZE MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS NEW TASK NUMBER MUL DL ; AX = AL * DL

Appendix G

MOV SI,AX ; SI CONTAINS OFFSET IN TASK RECORD

MOV SP,WORD PTR [BX + SI + SP_STORE] ; GET SP FOR THIS TASK

		POP_INT_REGS OS_TICK_TIMER ENDP

IRET ; CONTINUES WITH A NEW TASK IF TASK CHANGED

;============================================================ ;============================================================ ; SHIFT READY QUEUE DOWN ONE PLACE SHIFT_READYQ PROC NEAR 		PUSH DI 		PUSH SI 		PUSH DX 		PUSH ES 		PUSH AX 		 		 		 		 		 		 SHIFT:		 MOV DI,OFFSET RUNNING

MOV SI,OFFSET RUNNING + 1

MOV DX,WORD PTR [TOP_OF_Q] ; GET POINTER TO TOP_OF_Q ADD DX,2 ; AND POINT 2 BYTES UP MOV AX,WORD PTR [MY_CODE_SEG] CLD 	

		MOV ES,AX

			 		

MOVSB 	 ; MOVE BYTE FROM LOCATION DS:SI INTO LOCATION ES:DI CMP SI,DX JNE SHIFT

; MOVSB WILL INCREMENT SI AND DI AUTOMATICALLY

; INC SI and INC DI done automatically in above instruction

		 		 		 		 		

MOV SI, WORD PTR [TOP_OF_Q] MOV DI, OFFSET RUNNING

		CMP DI,SI

JE LIMIT ; TOP_OF_Q CAN NEVER GO BELOW 'RUNNING' DEC WORD PTR [TOP_OF_Q]

LIMIT: POP AX

		POP ES 		POP DX 		POP SI 		POP DI 		RET SHIFT_READYQ ENDP

;============================================================ ;============================================================ ; CREATE A TASK ; ON ENTRY: ;		 ;		 ; DX POINTS TO START OF TASK

AL CONTAINS THE TASK NUMBER

; SET UP THE TASK ADDRESS ON STACK AND

272
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
; PLACE IT IN READY QUEUE CREATE_TASK PROC NEAR 		PUSH_ALL_REGS 		 		 		 		 		 		 		

Appendix G

; PUT TASK NUMBER IN READY QUEUE

INC WORD PTR [TOP_OF_Q] ; TOP_OF_Q IS A POINTER MOV SI, WORD PTR [TOP_OF_Q] MOV BYTE PTR [SI],AL

MOV BYTE PTR [NEW_TASK_IN_Q],1 MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL ; AX = AL*CL

; FIND THE STACK FOR THE TASK NUMBER HELD IN AL

		MOV SI,AX

; TASK ADDRESS HAS NOW TO BE SAVED ON THE TASK STACK

; SINCE ALL THE PROGRAM RESIDES ON ONE SEGMENT, ALL CALLS ARE NORMALLY NEAR ; HERE WE SIMULATE PUSHF, PUSH CS, PUSH IP CARRIED OUT BY THE INTERRUPT  		  		  		 		 		 		 		 		  			  			  			 MOV WORD PTR [BX + SI + STACK_AREA - 1],0

MOV WORD PTR [BX + SI + STACK_AREA - 3],CS MOV WORD PTR [BX + SI + STACK_AREA - 5],DX MOV CX,BX ADD CX,SI

; STORE FLAGS OF TASK, INITIALLY ALL ZERO (LOW BYTE FIRST) ; STORE CS OF TASK (LOW BYTE FIRST) ; STORE IP OF TASK (LOW BYTE FIRST)

 		  		

ADD CX,(STACK_AREA - 2*REG_PUSHES - 5) ; CX NOW CONTAINS CORRECT SP OFFSET ; READY FOR POP_ALL_REGS AND IRET IN TIMER ROUTINE POP_ALL_REGS RET MOV WORD PTR [BX + SI + SP_STORE],CX ; SAVE SP FOR THIS TASK

CREATE_TASK ENDP

;============================================================ ;============================================================ ; SET TASK TO EXECUTE PERIODICALLY, EVERY CERTAIN NUMBER OF TICKS ; ON ENTRY: ; 	 DX CONTAINS THE NUMBER OF TICKS TO WAIT FOR

; NO TASK CHANGE 		 		

PERIODIC PROC NEAR

PUSH_ALL_REGS

 		  		 		 		

MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL ; AX=AL*CL MOV SI,AX

MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS CURRENT TASK NUMBER

 		  		  		 		 		

MOV WORD PTR [BX + SI + PERIOD_CURRENT],DX MOV WORD PTR [BX + SI + PERIOD_RELOAD],DX POP_ALL_REGS RET ; TIMEOUT DATA NOW SAVED ON TASK PARAMETER STORAGE

273
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
PERIODIC ENDP ;============================================================ ;============================================================ ; PLACE A TASK IN A WAIT STATE, JUST WAITING FOR THE ; PREVIOUSLY ASSIGNED PERIODIC INTERVAL TO PASS WAIT_PERIOD PROC NEAR 		 		 		 		 		 PUSH_INT_REGS

Appendix G

; SAVE STACK POINTER FOR CURRENT TASK MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS NEW TASK NUMBER

		MUL CL 		 		 		 		 		 		 		 		

		MOV SI,AX

MOV WORD PTR [BX + SI + SP_STORE],SP ; SAVE SP FOR THIS TASK ; NOW INITIATE A TASK CHANGE ; SHIFT DOWN READY QUEUE BY ONE, AND

		CALL SHIFT_READYQ

; GET NEXT TASK NUMBER WHICH IS READY TO RUN ; NOW RESTORE STACK POINTER FOR THE NEW TASK MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS NEW TASK NUMBER

		MUL CL

		MOV SI,AX

Real drive. Unreal destination.

As an intern, you’re eager to put what you’ve learned to the test. At Ernst & Young, you’ll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You’ll also get to test what you learn. Even better, you’ll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

© 2012 Ernst & Young LLP. All Rights Reserved.

274
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
		 		 MOV SP,WORD PTR [BX + SI + SP_STORE] ; GET SP FOR THIS TASK IRET ; START NEW TASK WITH THIS IRET INSTRUCTION

Appendix G

		POP_INT_REGS WAIT_PERIOD ENDP

;============================================================ ;============================================================ ; PLACE A TASK IN A WAIT STATE, JUST WAITING FOR A CERTAIN NUMBER OF TICKS ; ON ENTRY: ; 		 ; 		 WAITT PROC NEAR 		 		 		 		 DX CONTAINS THE NUMBER OF TICKS TO WAIT FOR

CS:IP ALREADY PUSHED ON STACK BY THE 'CALL OS_WAITT' PUSH_INT_REGS

MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE

MOV AL,BYTE PTR [RUNNING] 	

; AL NOW CONTAINS CURRENT TASK NUMBER

		MUL CL 				; AX=AL*CL 		MOV SI,AX 		 		 		 		 		 		 		 		 		 		 		 		 		 		 MOV WORD PTR [BX + SI + TIME_OUT],DX

; TIMEOUT DATA NOW SAVED ON TASK PARAMETER STORAGE ; NOW SAVE STACK POINTER FOR CURRENT TASK ; NOW INITIATE A TASK CHANGE MOV WORD PTR [BX + SI + SP_STORE],SP ; SAVE SP FOR THIS TASK ; SHIFT DOWN READY QUEUE BY ONE, AND

		CALL SHIFT_READYQ

; GET NEXT TASK NUMBER WHICH IS READY TO RUN ; NOW RESTORE STACK POINTER FOR THE NEW TASK MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL 		 MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS NEW TASK NUMBER ; AX=AL*CL

		MOV SI,AX

		POP_INT_REGS WAITT ENDP

MOV SP,WORD PTR [BX + SI + SP_STORE] ; GET SP FOR THIS TASK IRET ; START NEW TASK WITH THIS IRET INSTRUCTION

;============================================================ ;============================================================ WAITI PROC NEAR WAITI ENDP 		RET ;============================================================ ;============================================================ ; PLACE A TASK IN A WAIT STATE, JUST WAITING FOR A SIGNAL ; IF SIGNAL ALREADY PRESENT, CLEAR SIGNAL AND CONTINUE ; OTHER WIASE MAKE A TASK CHANGE ; ON ENTRY: ;		 ;		

DX CONTAINS THE NUMBER OF TICKS TO WAIT FOR

CS:IP ALREADY PUSHED ON STACK BY THE 'CALL OS_WAITT'

275
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
WAITS PROC NEAR ; STAY WAITING FOR A SIGNAL - TASK CHANGE 		PUSH_INT_REGS 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 		 CONT1:		 EXIT1:		 		 WAITS ENDP MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL ; AX=AL*CL CMP BYTE PTR [BX + SI + SIGNAL_FLAG],1

Appendix G

MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS CURRENT TASK NUMBER

		MOV SI,AX

JE CONT1 ; SIGNAL ALREADY PRESENT, HENCE CONTINUE ; IF NOT, THEN SET FLAG AND MAKE A TASK CHANGE MOV BYTE PTR [BX + SI + SIGNAL_FLAG],1 ; NOW SAVE STACK POINTER FOR CURRENT TASK ; NOW INITIATE A TASK CHANGE

MOV WORD PTR [BX + SI + SP_STORE],SP ; SAVE SP FOR THIS TASK ; SHIFT DOWN READY QUEUE BY ONE, AND

		CALL SHIFT_READYQ

; GET NEXT TASK NUMBER WHICH IS READY TO RUN ; NOW RESTORE STACK POINTER FOR THE NEW TASK MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL ; AX=AL*CL MOV SP,WORD PTR [BX + SI + SP_STORE] ; GET SP FOR THIS TASK JMP EXIT1 MOV BYTE PTR [BX + SI + SIGNAL_FLAG],0 POP_INT_REGS IRET ; START NEW TASK WITH THIS IRET INSTRUCTION, IF REQUIRED MOV AL,BYTE PTR [RUNNING] ; AL NOW CONTAINS NEW TASK NUMBER

		MOV SI,AX

;============================================================ ;============================================================ ; SEND A SIGNAL TO TASK. ; IF TASK WAS ALREADY WAITING FOR THE SIGNAL, THEN THAT TASK ; IS PLACED IN THE READY QUEUE. ; ON ENTRY: ;		

AL CONTAINS THE TASK NUMBER TO BE SIGNALLED ; NO TASK CHANGE IS MADE ; SAVE TASK NUMBER

SIGNAL_TASK PROC NEAR 	 ; SEND A SIGNAL TO A TASK SO THAT IT CAN RESUME 			 	 	  	 	 	 	  	 	 	 	 PUSH_ALL_REGS PUSH AX 	

MOV BX,OFFSET TASK_PARAM MOV CL,PARAM_SIZE MUL CL ; AX=AL*CL MOV SI,AX

CMP BYTE PTR [BX + SI + SIGNAL_FLAG],0 POP AX ; GET TASK NUMBER AGAIN JE TASK2WAIT ; TASK WAS NOT WAITING, HENCE JUST SET FLAG ; TASK WAS ALREADY WAITING, HENCE PUT IT IN READY QUEUE

276
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II
	 	 	 	 	 	 MOV BYTE PTR [BX + SI + SIGNAL_FLAG],0 MOV SI, WORD PTR [TOP_OF_Q] MOV BYTE PTR [SI],AL JMP EXIT2

Appendix G

INC WORD PTR [TOP_OF_Q] ; TOP_OF_Q IS A POINTER

MOV BYTE PTR [NEW_TASK_IN_Q],1 MOV BYTE PTR [BX + SI + SIGNAL_FLAG],1 POP_ALL_REGS RET

TASK2WAIT:	 EXIT2:		 		

SIGNAL_TASK ENDP

;============================================================ ;============================================================ ;======================================================== ; OSTICKFT.INC ; ; ;

; 	

Written by Paul P. Debono ( JAN 2012 )

;======================================================== ; RTOS DATA AREA ; ;

MY_CODE_SEG 	

DW 0 ; STORAGE FOR THE CODE SEGMENT REGISTER

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

277
Download free eBooks at bookboon.com

Click Click on on the the ad ad to to read read more more

PaulOS An 8051 Real-Time Operating System Part II
; The OldTick variable holds the old value of the low word ; (DX) returned by INT 1AH to get the system time in ticks ; since midnight in CX:DX OldTick 	 TOP_OF_Q 	 RUNNING 	 READY_Q 	 ; ; DW 0 DW OFFSET RUNNING ; pointer to the top of the ready queue DB (NUM_OF_TASKS + 2) DUP (IDLE_TASK)

Appendix G

NEW_TASK_IN_Q 	DB 0

DB IDLE_TASK ; contains the task number of the currently running task

; STRUCTURE DEFINITIONS, UNFORTUNATELY NOT SUPPORTED BY EMU8086 ; 50 BYTES (PARAM_SIZE) PER TASK ; ;TASK_PARAM STRUC ; 	 ; 	 ; 	 ; 	 ; 	 ; 	

SIGNAL_FLAG DB 0 INT_NUM DB 0 SP_STORE DW 0

;	 TIME_OUT DW 0

PERIOD_CURRENT DW 0 PERIOD_RELOAD DW 0 STACK_AREA DB 40 DUP (0)

;TASK_PARAM ENDS

TASK_PARAM DB PARAM_SIZE * (NUM_OF_TASKS + 1) DUP (0) ;==================================================

278
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix H

Appendix H	 8051 Instruction Set
8051 Alphabetical List of the Instruction Set •	 ACALL	 •	 AJMP 	 •	 ANL 		 •	 CJNE 		 •	 CLR 		 •	 CPL 		 •	 DA 		 •	 DEC 		 •	 DIV 		 •	 DJNZ 		 •	 INC 		 •	 JB 		 •	 JBC 		 •	 JC 		 •	 JMP 		 •	 JNB 		 •	 JNC 		 •	 JNZ 		 •	 JZ 		 •	 LCALL 	 •	 LJMP 		 •	 MOV 		 •	 MOVC 	 •	 MOVX 	 •	 MUL 		 •	 NOP 		 •	 ORL 		 •	 POP 		 •	 PUSH 	 •	 RET 		 •	 RETI 		 •	 RL 		 •	 RLC 		 •	 RR 		 Absolute Call Absolute Jump Bitwise AND Compare and Jump if Not Equal Clear Register or Bit Complement Register or Bit Decimal Adjust Decrement Register Divide Accumulator by B Decrement Register and Jump if Not Zero Increment Register Jump if Bit Set Jump if Bit Set and Clear Bit Jump if Carry Set Jump to Address Jump if Bit Not Set Jump if Carry Not Set Jump if Accumulator Not Zero Jump if Accumulator Zero Long Call Long Jump Move Memory Move Code Memory Move Extended Memory Multiply Accumulator by B No Operation Bitwise OR Pop Value From Stack Push Value Onto Stack Return From Subroutine Return From Interrupt Rotate Accumulator Left Rotate Accumulator Left Through Carry Rotate Accumulator Right •	 ADD, ADDC 	Add Accumulator (With Carry)

279
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Appendix H

•	 RRC 		 •	 SETB 		 •	 SJMP 		 •	 SUBB 		 •	 SWAP 	 •	 XCH 		 •	 XCHD 	 •	 XRL 		

Rotate Accumulator Right Through Carry Set Bit Short Jump Subtract From Accumulator With Borrow Swap Accumulator Nibbles Exchange Bytes Exchange Digits Bitwise Exclusive OR

280
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Bibliography

Bibliography
1.	 AYALA, K.J., 1999. 8051 Microcontroller: Architecture, Programming, and Applications. 2nd edn. Delmar Thomson Learning. 2.	 BARNETT, R.H., 1994. The 8051 Family of Microcontrollers. 1st edn. Upper Saddle River, NJ, USA: Prentice Hall PTR. 3.	CALCUTT, D.M., COWAN, F.J. and PARCHIZADEH, G.H., 1998. 8051 Microcontrollers Hardware, Software and Applications. London, UK: Arnold. 4.	 CHEW, M.T. and GUPTA, G.S., 2005. Embedded Programming with Field-Programmable MixedSignal Microcontrollers. Silicon Laboratories. 5.	HUANG, H., 2009. Embedded System Design with the C8051. Stanford, CT, USA: Cengage Learning. 6.	 LABROSSE, J.J., 2002. Embedded Systems Building Blocks. 2nd edn. San Francisco, CA, USA: CMP Books. 7.	 LABROSSE, J.J., 2002. MicroC/OS-II, The Real-Time Kernel. 2nd edn. San Francisco, CA, USA: CMP Books. 8.	MACKENZIE, I.S., 1998. The 8051 Microcontroller. 3rd edn. Upper Saddle River, NJ, USA: Prentice Hall PTR. 9.	 MAZIDI, M.A. and MAZIDI, J.G., 1999. The 8051 Microcontroller and Embedded Systems with Disk. 1st edn. Upper Saddle River, NJ, USA: Prentice Hall PTR. 10.	 PONT, M.J., 2002. Embedded C. 1st edn. Boston, MA, USA: Addison-Wesley Longman Publishing Co., Inc. 11.	 PONT, M.J., 2001. Patterns for time-triggered embedded systems: building reliable applications with the 8051 family of microcontrollers. New York, NY, USA: ACM Press/Addison-Wesley Publishing Co. 12.	 PREDKO, M., 1999. Programming and Customizing the 8051 Microcontroller. New York, NY, USA: McGraw-Hill, Inc. 13.	 SCHULTZ, T.W., 2004. C And The 8051. Pagefree Publishing. 14.	 SCHULTZ, T.W., 1999. C and the 8051 (volume II): building efficient applications. Upper Saddle River, NJ, USA: Prentice Hall PTR. 15.	 SCHULTZ, T.W., 1997. C and the 8051: Hardware, Modular Programming and Multitasking with Cdrom. 2nd edn. Upper Saddle River, NJ, USA: Prentice Hall PTR. 16.	STEWART, J.W., 1999. The 8051 microcontroller (2nd ed.): hardware, software and interfacing. Upper Saddle River, NJ, USA: Prentice-Hall, Inc. 17.	 THORNE, M., 1986. Programming the 8086/8088 for the IBM PC and compatibles. Redwood City, CA, USA: Benjamin-Cummings Publishing Co., Inc. 18.	VARIOUS, 1993. MCS51 Microcontroller Family User’s Manual. Santa Clara, CA, USA: Intel Corporation.

281
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Bibliography

19.	 C.L. Liu and J.W. Layland, “Scheduling Algorithms for Multi-programming in a Hard Real-Time Environment,”J. ACM, vol. 20, no. 1, pp. 40–61, 1973. 20.	 J. Blaut, 2004, “8051 RTOS”, B.Sc. Eng. Thesis, University of Malta.

282
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Index for Part I

Index for Part I
Symbols
8032 141 extras 141 T2CON 146 timer 2 144 PX0 53, 120 PX1 53, 120 RB8 51, 101 RD 47 REN 51, 101 RI 51, 101, 123 RS0 53 RS1 53 RXD 47 SM0 51, 101 SM1 51, 101 SM2 51, 101 SMOD 49 T0 47 T1 47 TB8 51, 101 TF0 49, 82 TF1 49, 82 TH0 74 TH1 74 TI 51, 101, 123 TL0 74 TL1 74 TR0 49, 82 TR1 49, 82 TXD 47 WR 47

B
baud rate A51 example 132 setup 103 timer 2 148 big endian 169

C
CALL ACALL 68 LCALL 68 conditional branching 65 Control Bit Symbol AC 53 C/T 50, 77 CY 53 EA 52, 117 ES 52, 117 ET0 52, 117 ET1 52, 117 ET2 52 EX0 52, 117 EX1 52, 117 F0 53 GATE 50, 77 GF1 49 GF2 49 IDL 49 IE0 49 IE1 49 INT0 47 INT1 47 IT0 49 IT1 49 M0 50, 77 M1 50, 77 OV 53 P 53 PD 49 PS 53, 120 PT0 53, 120 PT1 53, 120 PT2 53

D
Development Boards C8051F020TB 166 Flite-32 153 Flite-32 IVT setup 179 NMIY-0031 161 direct jumps 67

E
endian big 169 little 169 Examples Big Endian and Little Endian - C 170 PaulOS RTOS - C 220 Traffic Lights A51 136 UART baud rate A51 132

I
Interfacing 4-bit mode 271

283
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II 7-Segment LEDs 250 DC Motor 275 H-bridge 277 Keypad 261 LCD 264 LEDs 247 Servo Motor 283 Stepper Motor 285 Switches 258 Interrupts 69, 112, 115 common problems 128 considerations 125 IVT 152 polling sequence 118 priorities 119 sequence of events 120 serial 123 setting up 117 timer 2 151 Interrupt Vector Table 116, 152 ISR stand-alone - PaulOS 218 OS_WAIT4RES 233 OS_WAIT4RES() 226 OS_WAIT4SEM() 226, 239 OS_WAITI() 226, 231 OS_WAIT_MESSAGE() 226, 236 OS_WAITP() 212, 226, 229 OS_WAITT() 226, 231 Master-Slave 108 memory bit-addressable 30 code area 26 external 26 internal data 27 on-chip 27 organisation 23

Index for Part I

P
PaulOS OS_CPU_DOWN() 218 OS_CREATE_TASK() 206, 209 OS_DEFER() 205, 206, 216 OS_INIT_RTOS() 206, 207 OS_KILL_IT() 205, 206, 216 OS_PAUSE_RTOS() 218 OS_PERIODIC() 206 OS_PERIODIC_A() 218 OS_RESUME_RTOS() 218 OS_RESUME_TASK() 206 OS_RTOS_GO() 206, 207, 209 OS_RUNNING_TASK_ID() 205, 210 OS_SCHECK() 205, 207, 210 OS_SIGNAL_TASK() 206, 207, 211 OS_WAITI() 206, 213 OS_WAITP() 205, 206 OS_WAITS() 206, 214 OS_WAITS_A() 218 OS_WAITT() 206, 215 OS_WAITT_A() 218 ready 205 running 203 stand-alone ISR 218 waiting 204 ports P0 35 P1 40 P2 47 P3 47

J
jumps conditional 65 direct 67

K
KEIL setup 173

L
little endian 169

M
MagnOS description 225 OS_CHANGE_TASK_PRIORITY() 226, 232 OS_CHECK_MSG() 226, 236 OS_CHECK_TASk_PRIORITY() 232 OS_CHECK_TASK_PRIORITY() 226 OS_CHECK_TASK_SEMA4() 226, 237 OS_CLEAR_MSG() 226, 235 OS_CREATE_TASK() 226, 240 OS_GET_MSG() 226, 236 OS_INIT_RTOS() 226, 230 OS_KILL_IT() 239 OS_KILL_TASK() 226 OS_RELEASE_RES() 226, 233 OS_RTOS_GO() 226, 228 OS_RUNNING_TASK_ID() 226, 230 OS_SEMA4MINUS() 226, 238 OS_SEMA4_PLUS() 226, 238 OS_SEND_MSG() 226, 234

R
register banks 29 RETI 123 round-robin rtos SanctOS 191 RTOS

284
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II co-operative 189 MagnOS 225 pre-emptive 190, 225 ready state 187 round-robin 188, 191 running state 187 SanctOS 191 states 187 types 188 waiting state 187 R 57 SBUF 51 SCON 51 SP 49, 59 T2CON 146 TCON 49, 81 TH0 51 TH1 51 timer 2 145 timer mode control bits 77 timer-related 74 TL0 51 TL1 51 TMOD 50, 76 Switch bounce 258

Index for Part I

S
SanctOS OS_CREATE_TASK() 191 OS_INIT_RTOS() 191 OS_INIT_RTOS(uchar iemask) 192 Serial Buffer 123 SFR 32 ACC 54, 56 B 54, 58 DPH 49 DPL 49 DPTR 49, 58 IE 52, 117 IP 53 P0 35 P1 40 P2 47 P3 47 PC 58 PCON 49 PSW 53

T
Timer detecting overflow 85 initialisation 83 mode 0 77 mode 1 78 mode 2 79 mode 3 81 pulse duration 89 reading registers 84 timing events 87 Timer 2 144 auto relaod 149 capture mode 150 Timers 71

285
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

Index for Part II

Index for Part II
Examples
Buffered serial interrupt routines  80 SCC2691 UART  86 UART not under interrupt control  91 Light control using RTOS  98 Random display using RTOS  102 Master-Slave communication  105 Timer 0 Mode 3  247 Timer 1 as a baud-rate generator  247 Timer 2 as a baud-rate generator  251 XON/XOFF serial routine  253

P
programming pitfalls 12 tips 12

S
SFR DPTR 13

T
tips C tips  18 DPTR 13 interrupts  15, 17 port usage  13 programming 12 ram size  12 serial 14 SFRs 13 SP setting  12 UART 14

286
Download free eBooks at bookboon.com

PaulOS An 8051 Real-Time Operating System Part II

End Notes

End Notes
1.	 The original idea for this RTOS came from the book “C and the 8051 – Building Efficient Applications – Volume II” by Thomas W. Schultz and published by Prectice Hall (0-13-5211212). In this book, Prof. Schultz discusses the development of two real-time kernels. The first one is the RTKS which I corrected and developed into PaulOS co-operative RTOS. The second one is the RTKB which I also corrected, modified and developed into MagnOS pre-emptive RTOS. Both operating systems, RTKS and RTKB as written in the book are not fully functional, contain some errors and lack some essential components. I did correspond with Prof. Schultz and sent him my modifications and final versions of the programs which he later acknowledged in the 3rd edition of the book “C and the 8051”, again published by Prentice-Hall (0-58961-237-X). So I am particularly grateful to Prof. Schultz for being the catalyst of my increased interest in RTOSs. 2.	 The development of a pre-emptive RTOS, named RTKB is described in the book “C and the 8051 – Building Efficient Applications – Volume II” published by Prentice-Hall (0-13-521121-2. A third edition was later published having the ISBN 1-58961-237-X where the author acknowledged my contribution to the development of a working version of his original RTOS.

287
Download free eBooks at bookboon.com

