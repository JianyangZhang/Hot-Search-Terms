Applications	of	Prolog
Attila	Csenki

Download	free	books	at

Attila Csenki

Applications of Prolog

2 Download free eBooks at bookboon.com

Applications of Prolog ¬© 2009 Attila Csenki & Ventus Publishing ApS ISBN 978-87-7681-514-1

To my wife Agnes who patiently endured me working on this book for most of my spare time during last two years.

3 Download free eBooks at bookboon.com

Applications of Prolog

Contents

Contents
Preface 1 Enigma 1225: Rows are Columns 1.1 A Puzzle . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.2 First Thoughts . . . . . . . . . . . . . . . . . . . . . . . . 1.3 Symbolic Solutions . . . . . . . . . . . . . . . . . . . . . . 1.4 Implementation Details . . . . . . . . . . . . . . . . . . . 1.4.1 Design Decisions . . . . . . . . . . . . . . . . . . . 1.4.2 Admissible Permutations . . . . . . . . . . . . . . 1.4.3 Generating Symbolic Matrices . . . . . . . . . . . 1.4.4 Permuting Rows . . . . . . . . . . . . . . . . . . . 1.4.5 Transposing . . . . . . . . . . . . . . . . . . . . . . 1.4.6 Most General Patterned Symbolic Matrices . . . . 1.4.7 Distinct Rows . . . . . . . . . . . . . . . . . . . . . 1.4.8 Evaluating Patterns . . . . . . . . . . . . . . . . . 1.4.9 Computing Totals . . . . . . . . . . . . . . . . . . 1.4.10 Complete Implementation . . . . . . . . . . . . . . 1.5 Enhanced Implementation . . . . . . . . . . . . . . . . . . 1.5.1 What is Wrong with the Present Implementation? 1.5.2 Some Results from the Theory of Permutations . . 1.5.3 Generating Representative Permutations . . . . . . 1.5.4 Finishing Touches . . . . . . . . . . . . . . . . . . 15 17 17 17 18 20 20 21 21 22 22 22 24 25 28 28 31 31 32 35 43

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . .

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

4 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Contents

2 Blind Search 2.1 Digression on the Module System in Prolog . . . . 2.2 Basic Search Problem . . . . . . . . . . . . . . . . 2.3 Depth First Search . . . . . . . . . . . . . . . . . . 2.3.1 Na¬® ƒ±ve Solution . . . . . . . . . . . . . . . . 2.3.2 Incremental Development Using an Agenda 2.4 Breadth First Search . . . . . . . . . . . . . . . . . 2.5 Bounded Depth First Search . . . . . . . . . . . . 2.6 Iterative Deepening . . . . . . . . . . . . . . . . . . 2.7 The Module blindsearches . . . . . . . . . . . . 2.8 Application: A Loop Puzzle . . . . . . . . . . . . . 2.8.1 The Puzzle . . . . . . . . . . . . . . . . . . 2.8.2 A ‚ÄòHand-Knit‚Äô Solution . . . . . . . . . . . 2.8.3 Project: Automating the Solution Process . 2.8.4 Project: Displaying the Board . . . . . . . 2.8.5 Complete Implementation . . . . . . . . . . 2.8.6 Full Board Coverage . . . . . . . . . . . . . 2.8.7 Avoiding Multiple Solutions . . . . . . . . . 2.8.8 Variants of the Loop Puzzle . . . . . . . . . 2.9 Application: The Eight Puzzle . . . . . . . . . . . 2.9.1 The Puzzle . . . . . . . . . . . . . . . . . . 2.9.2 Prolog Implementation . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . .

47 47 49 52 54 54 67 68 72 74 76 76 77 83 89 91 91 93 95 99 99 100

5 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Contents

3 Informed Search 3.1 The Network Search Problem with Costs . . . . . . . . . . . 3.1.1 Cost Measures . . . . . . . . . . . . . . . . . . . . . 3.1.2 The A‚ÄìAlgorithm . . . . . . . . . . . . . . . . . . . 3.1.3 Iterative Deepening A‚àó and its ‚ÄìAdmissible Version 3.2 Case Study: The Eight Puzzle Revisited . . . . . . . . . . . 3.2.1 The Heuristics . . . . . . . . . . . . . . . . . . . . . 3.2.2 Prolog Implementation . . . . . . . . . . . . . . . . . 3.3 Project: Robot Navigation . . . . . . . . . . . . . . . . . . . 3.4 Project: The Shortest Route in a Maze . . . . . . . . . . . 3.4.1 Suggested Implementation Details . . . . . . . . . . 3.5 Project: Moving a Knight . . . . . . . . . . . . . . . . . . . 4 Text Processing 4.1 Text Removal . . . . . . . . . . . . . . . . . . . 4.1.1 Practical Context . . . . . . . . . . . . . 4.1.2 SpeciÔ¨Åcation . . . . . . . . . . . . . . . 4.1.3 Implementation . . . . . . . . . . . . . . 4.1.4 Using a Linux Shell Script . . . . . . . 4.1.5 Application: Removing Model Solutions A TEX . . . 4.2 Text Generation and Drawing with L 4.2.1 Cycloids . . . . . . . . . . . . . . . . . . 4.2.2 Task . . . . . . . . . . . . . . . . . . . . 4.2.3 Solution . . . . . . . . . . . . . . . . . . 4.3 Exercises . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

103 103 104 105 108 114 114 115 118 121 123 128 133 133 133 134 135 139 143 146 146 147 148 151

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

. . . . . . . . . . .

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

6 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Contents

A Solutions of Selected Exercises A.1 Chapter 1 Exercises . . . . . A.2 Chapter 2 Exercises . . . . . A.3 Chapter 3 Exercises . . . . . A.4 Chapter 4 Exercises . . . . . B Software References Index Errata to Volume 1

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

. . . .

161 161 171 186 191 197 199 201 203

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

7 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Figures

List of Figures
1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 2.10 2.11 2.12 2.13 A Feasible Solution . . . . . . . . . . . . . . . . . . . Hand Computations for Pattern Evaluation . . . . . Suggested Hand Computations for total/2 . . . . . Generating Feasible Solutions by square/5 . . . . . The Cycles œÑ1 and œÑ2 . . . . . . . . . . . . . . . . . . Enumeration Scheme for {(m, n) : m, n = 0, 1, 2, . . .}. Enumeration Scheme for {(m, n) : m, n = 0, 1, 2, . . .}. Suggested Hand Computations for split/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . (See Exercise (See Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.12.) 1.13.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 27 28 29 32 40 42 45 48 49 49 50 51 53 54 56 57 58 59 59 61

A Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File links.pl . . . . . . . . . . . . . . . . . . . . . . . . . . Fragment of the File df1.pl . . . . . . . . . . . . . . . . . . . . . The Search Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . The Pruned Search Tree . . . . . . . . . . . . . . . . . . . . . . . Depth First Search ‚Äì The Conduit Model . . . . . . . . . . . . . The File naive.pl . . . . . . . . . . . . . . . . . . . . . . . . . . The File df1.pl . . . . . . . . . . . . . . . . . . . . . . . . . . . Illustrative Query for depth first/2 ‚Äì First Version . . . . . . . The File df2.pl . . . . . . . . . . . . . . . . . . . . . . . . . . . Illustrative Query for depth first/2 ‚Äì Second Version . . . . . The New Network Component . . . . . . . . . . . . . . . . . . . Hand Computations for the Query ?- depth first(s,g,Path).

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

8 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Figures

2.14 2.15 2.16 2.17 2.18 2.19 2.20 2.21 2.22 2.23 2.24 2.25 2.26 2.27 2.28 2.29 2.30 2.31 2.32 2.33 2.34 2.35 2.36 2.37 2.38 2.39 2.40 2.41

p f g The File df3.pl ‚Äì Depth First with Closed Nodes and Open Paths The File df4.pl ‚Äì Depth First with Path Checking . . . . . . . . . The File searchinfo.pl . . . . . . . . . . . . . . . . . . . . . . . . Interactive Session for depth first/4 ‚Äì Path Checking . . . . . . A Network (see Exercise 2.4, p. 67) . . . . . . . . . . . . . . . . . . Breadth First . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File bf.pl ‚Äì Breadth First with Path Checking . . . . . . . . Interactive Session for breadth first/4 . . . . . . . . . . . . . . . The File bdf.pl ‚Äì Bounded Depth First (for Exercise 2.7) . . . . . The File iterd.pl ‚Äì Iterative Deepening . . . . . . . . . . . . . . Sample Session ‚Äì Iterative Deepening . . . . . . . . . . . . . . . . . Sample Session ‚Äì ModiÔ¨Åed Iterative Deepening (for Exercise 2.8) . The File netsearch.pl (for Exercise 2.10) . . . . . . Sample Session ‚Äì The Loop Puzzle . . . . . . . . . . The File loop puzzle1.pl . . . . . . . . . . . . . . Constructing a Solution of the Loop Puzzle . . . . . The File hand knit.pl . . . . . . . . . . . . . . . . . The File loop puzzle1a.pl . . . . . . . . . . . . . . The File automated.pl . . . . . . . . . . . . . . . . Constructing a Loop . . . . . . . . . . . . . . . . . . Running the Automated Implementation of the Loop Semi-Automated Solution of the Loop Puzzle . . . . Session for Displaying the Board . . . . . . . . . . . Illustrating Exercise 2.16 . . . . . . . . . . . . . . . . Illustrating Exercise 2.17 . . . . . . . . . . . . . . . . Solving the Puzzle Interactively. (See Exercise 2.18.) Illustrating Exercise 2.19 . . . . . . . . . . . . . . . . Some positions not visited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Puzzle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

63 65 65 66 67 68 69 69 72 73 74 75 75 78 79 80 81 83 84 86 87 88 89 90 91 92 93 94

9 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Figures

2.42 2.43 2.44 2.45 2.46 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 3.10 3.11 3.12 3.13 3.14 3.15

All positions visited . . . . . . . . . . . Solving the Loop Puzzle ‚Äì Variant One . Solving the Loop Puzzle ‚Äì Variant Two An Eight Puzzle . . . . . . . . . . . . . Solving the Eight Puzzle . . . . . . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . . . c . . . . . . . . . . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

. . . . .

94 97 98 99 101 103 107 110 111 111 113 114 116 119 122 123 125 126 129 131

A Network with Costs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Hand Computations: The Evolution of the Agenda for the A‚ÄìAlgorithm (from d to An Interactive Session. (See Exercise 3.1.) . . . . . . . . . . . . . . . . . . . . . . . A Directed Network. (See Exercise 3.2.) . . . . . . . . . . . . . . . . . . . . . . . . Adjacency matrix of the network in Fig. 3.4 . . . . . . . . . . . . . . . . . . . . . . Network for Exercise 3.3, Part (c) . . . . . . . . . . . . . . . . . . . . . . . . . . . . Calculating the Manhattan Distance between the tile arrangements in Fig. 2.45 . . Solving the Eight Puzzle by Heuristic Search . . . . . . . . . . . . . . . . . . . . . Robot Navigation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Maze Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Calculating the Euclidean Heuristic H1 . . . . . . . . . . . . . . . . . . . . . . . . Calculating the Alternative Heuristic H2 . . . . . . . . . . . . . . . . . . . . . . . . Search Graph for the Gates‚Äô Position . . . . . . . . . . . . . . . . . . . . . . . . . . Sample Session: Moving a Knight . . . . . . . . . . . . . . . . . . . . . . . . . . . . The Knight Moves One Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . in Fig 3.1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Figures

4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 4.10 4.11 4.12 4.13 4.14 4.15 4.16 4.17 4.18 4.19 4.20 4.21 4.22 4.23 4.24

Processing the File exam.tex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File with waters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File without waters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Running the Shell Script sieve . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Another Run of the Shell Script sieve . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File part sln.tex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Structure of the Printed Exam Script with Solutions . . . . . . . . . . . . . . . . . . . . The File part.tex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Running the Shell Script sieve . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Drawing a Cycloid (œÜ = œÄ/2) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Prolate Cycloid Drawn with \writecurve from Fig. 4.14 (r = 5, a = 8, 3.5 revs) . . . . Curtate Cycloid Drawn with \writecurve similar to Fig. 4.14 (r = 5, a = 3, 3.5 revs) . Common Cycloid Drawn with \writecurve similar to Fig. 4.14 (r = 5, a = 5, 3.5 revs) A Generating the L TEX Command \writecurve with define command/4 . . . . . . . . . ‚ÄòQuarter‚Äô Cycloid Drawn with \writecurve (r = 10, a = 4, 1/4 revs) . . . . . . . . . . . A Generating the L TEX Command \defcirc with circ command/4 . . . . . . . . . . . . . A Generating the L TEX Command \defcirc with circ command/4 . . . . . . . . . . . . . A Generating the L TEX Command \defcirc with imp circ command/4 . . . . . . . . . . Polygon Drawn with \halfcirc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Logarithmic Spiral Drawn with \spiral . . . . . . . . . . . . . . . . . . . . . . . . . . . Growing Spirals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File spirals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . The File spirals.tex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Running the Shell Script curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . .

134 135 136 140 142 143 144 145 145 146 146 147 147 148 151 151 152 153 154 157 158 158 159 160

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

11 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Figures

A.1 Hand Computations for total/2 . . . . . . . . . . . . . . . . . . . . . . . . . . A.2 Ferrers Diagrams and their Prolog Representations . . . . . . . . . . . . . . . . A.3 Creating Distinct Temporary Predicate Names . . . . . . . . . . . . . . . . . . A.4 Annotated Hand Computations for split/4 . . . . . . . . . . . . . . . . . . . A.5 Hand Computations for the Query ?- depth first(d,c). . . . . . . . . . . . A.6 Interactive Session for the Query ?- depth first(d,c). . . . . . . . . . . . . A.7 Hand Computations for the Query ?- depth first(u,c). . . . . . . . . . . . A.8 Tree for Finding Successor Nodes in the New Component . . . . . . . . . . . . A.9 Interactive Session for the Query ?- depth first(u,c). . . . . . . . . . . . . A.10 Sample Session for depth first/4 . . . . . . . . . . . . . . . . . . . . . . . . . A.11 DeÔ¨Ånition of extend path dl/3 . . . . . . . . . . . . . . . . . . . . . . . . . . A.12 New Clauses for dfs loop/4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . A.13 Updating of the Agenda by dfs loop/4 . . . . . . . . . . . . . . . . . . . . . . A.14 Clauses Added to bf.pl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A.15 DeÔ¨Ånition of b dfs loop/5 (Exercise 2.7) . . . . . . . . . . . . . . . . . . . . . A.16 ModiÔ¨Åed Version of iterd.pl (Exercise 2.8) . . . . . . . . . . . . . . . . . . . . A.17 Automated Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A.18 Hand Computations: The Evolution of the Agenda for the A‚ÄìAlgorithm (from 10 in Fig 3.4) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A.19 Interactive Session for Searching the Network in Fig. 3.6 . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . node . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 to . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . node . . . . . .

. . . . . . . . . . . . . . . . .

164 166 167 170 172 173 173 173 174 176 177 178 178 182 183 184 188

. 189 . 190

.

12 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Tables

List of Tables
1.1 1.2 1.3 2.1 3.1 3.2 3.3 3.4 A.1 A.2 A.3 A.4 A.5 A.6 CPU times for Various Board Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 A Ferrers Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 Suggested Examples for Exercise 1.10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 CPU Times (in Seconds) for the Eight Puzzle with Blind Search . . . . . . . . . . . . . . . . . . 100 Straight Line Distances between Nodes in Fig. 3.1 . . . . . . . . . . Node Co-ordinates in the Network in Fig. 3.4 . . . . . . . . . . . . . Node Co-ordinates in the Network in Fig. 3.6 . . . . . . . . . . . . . CPU Times (in Seconds) for the Eight Puzzle with Heuristic Search Partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . Example Paths and Prolog Implementations ‚Äì Case One . . Example Paths and Prolog Implementations ‚Äì Case Two . . Values of H . . . . . . . . . . . . . . . . . . . . . . . . . . . Distances between Nodes (Edge Lengths) in Fig. 3.4 . . . . Results for the Eight Puzzle (Hill Climbing and Best First) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 110 113 117 165 175 176 187 187 190

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

13 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

List of Tables

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

14 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Preface

Preface
This book is the second volume by the author on Prolog programming and its applications written for Ventus. Whereas in the Ô¨Årst book [9], speciÔ¨Åc Prolog programming techniques were explained, in this volume we discuss some areas where Prolog can be fruitfully employed. Both books owe their existence to the recognition that the higher educational system (in the UK) does not oÔ¨Äer enough opportunities for students to experience the satisfaction associated with successfully completing a technical task. In the writer‚Äôs opinion, the learning experience of today‚Äôs average student is dominated too much by assessments. The book comprises four chapters, the Ô¨Årst three of them are devoted to Prolog in ArtiÔ¨Åcial Intelligence A (AI). The last one is on text processing using Prolog with L TEX in mind. The Ô¨Årst chapter solves an intriguing AI puzzle which was Ô¨Årst published in the New Scientist magazine [1] in 2003. The Prolog solution presented here combines problem speciÔ¨Åc knowledge using Finite Mathematics with the well-know AI technique ‚Äògenerate-and-test‚Äô. Even though this chapter did not emanate from my teaching activities, the presentation follows a well-tested pattern: the problem is broken down into manageable and identiÔ¨Åable subproblems which then are more or less readily implemented in Prolog. Many interesting hurdles are identiÔ¨Åed and solved thereby. The availability of uniÔ¨Åcation as a pattern matching tool makes Prolog uniquely suitable for solving such problems. This Ô¨Årst chapter is an adaptation of work reported in [7]. Further recent developments on solving this problem can be found in [4]. The second and third chapters are respectively devoted to blind search and informed search. The material presented in them can be used in lectures to teach Prolog for AI as well as in AI lectures themselves. I have tried to compile a varied and interesting mixture of applications most of which won‚Äôt be available anywhere else. Some of the problems considered here served over the years in my lectures as coursework material, though, for various reasons, the discussion is more thorough here. The fourth chapter is the least conventional one for a Prolog book. It is in two parts.
A 1. A tool is developed in Prolog for manipulating L TEX Ô¨Åles. A A TEX commands for drawing parametric curves in documents written in L TEX. 2. Prolog is used to generate L

I also explain here how an SWI-Prolog program can be embedded into a Linux shell script, removing thereby the need for the user to deal with Prolog directly. This results in applications of direct practical interest. For the maximum beneÔ¨Åt (and fun) readers should work through parts of this book interactively with SWI-Prolog. I have tried to retain the experimental and exploratory style of the Ô¨Årst volume [9] even though sometimes digression to more theoretical topics was unavoidable. There are 54 exercises in this book, 32 of them are solved in Appendix A. The last chapter is somewhat of an exception since there the exercises themselves are the main vehicle for conveying the subject material. Therefore, detailed sample solutions are provided for 6 of the 7 exercises in that chapter.

15 Download free eBooks at bookboon.com

Applications of Prolog

Preface

The associated software (Prolog sorces, Linux shell scripts, data Ô¨Åles) listed in Appendix B is freely available A from the Ventus website. All three systems used here (Linux, SWI-Prolog, L TEX) are freely available on the Internet.

Bradford, October 2009

Attila Csenki a.csenki@bradford.ac.uk

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

16 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

Chapter 1

Enigma 1225: Rows are Columns1
1.1 A Puzzle

A regular feature in the New Scientist magazine is Enigma, a weekly puzzle entry which readers are invited to solve. In the 8 February 2003 issue [1] the following puzzle was published. First, draw a chessboard. Now number the horizontal rows 1, 2, ..., 8, from top to bottom and number the vertical columns 1, 2, ..., 8, from left to right.You have to put a whole number in each of the sixty-four squares, subject to the following: 1. No two rows are exactly the same. 2. Each row is equal to one of the columns, but not to the column with the same number as the row. 3. If N is the largest number you write on the chessboard then you must also write 1, 2, ..., N ‚àí 1 on the chessboard. The sum of the sixty-four numbers you write on the chessboard is called your total. What is the largest total you can obtain? We are going to solve this puzzle here using Prolog. The solution to be described will illustrate two techniques: uniÔ¨Åcation and generate-and-test. UniÔ¨Åcation is a built-in pattern matching mechanism in Prolog which has been used in [9]; for example, the diÔ¨Äerence list technique essentially depended on it. For our approach here, uniÔ¨Åcation will again be crucial in that the proposed method of solution hinges on the availability of built-in uniÔ¨Åcation. It will be used as a kind of concise symbolic pattern generating facility without which the current approach wouldn‚Äôt be viable. Generate-and-test is easily implemented in Prolog. Prolog‚Äôs backtracking mechanism is used to generate candidate solutions to the problem which then are tested to see whether certain of the problem-speciÔ¨Åc constraints are satisÔ¨Åed.

1.2
1 This

First Thoughts
chapter is based on [7]. The author thankfully acknowledges the permission by Elsevier to republish the material here.

Fig. 1.1 shows a board arrangement with all required constraints satisÔ¨Åed. It is seen that the Ô¨Årst requirement

17 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

1 2 3 4 5 6 7 8

3 3 1 6 6 6 6 6 1

1 3 3 6 6 6 6 6 2

3 1 3 6 6 6 6 6 3

6 6 6 4 4 5 2 5 4

6 6 6 5 4 4 5 2 5

6 6 6 2 5 4 4 5 6

6 6 6 5 2 5 4 4 7

6 6 6 4 5 2 5 4 8

Figure 1.1: A Feasible Solution

is satisÔ¨Åed since the rows are all distinct. The second condition is also seen to hold whereby rows and columns are interrelated in the following fashion: Column Row We use the permutation œÄ= 1 2 2 3 3 1 4 5 5 6 6 7 7 8 8 4 (1.1) 1 2 2 3 3 1 4 5 5 6 6 7 7 8 8 4

to denote the corresponding column‚Äìto‚Äìrow transformation. The board also satisÔ¨Åes the latter part of the second condition since no row is mapped to a column in the same position. In terms of permutations, this requirement implies that no entry remains Ô¨Åxed; these are those permutations which in our context are permissible. 2 The third condition is obviously also satisÔ¨Åed with N = 6. The board‚Äôs total is 301, not the maximum, which, as we shall see later, is 544.

1.3

Symbolic Solutions

The solution scheme described below in i‚Äìv is based on Ô¨Årst generating all feasible solutions (an example of which was seen in Sect. 1.2) and then choosing a one with the maximum total. i. Take an admissible permutation, such as œÄ in (1.1). ii. Find an 8 √ó 8 matrix with symbolic entries whose rows and columns are interrelated by the permutation
2 Such

permutations are called derangements ([3], p. 73).

18 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

in i. As an example, let us consider for ‚é° X3 ‚é¢ X3 ‚é¢ ‚é¢ X1 ‚é¢ ‚é¢ X6 M1 = ‚é¢ ‚é¢ X6 ‚é¢ ‚é¢ X6 ‚é¢ ‚é£ X6 X6 ‚é° ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ M2 = ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é£ Y3 Y3 Y1 Y1 Y1 Y1 Y1 Y1

the permutation œÄ two such matrices, M1 and M2 , with ‚é§ X1 X3 X6 X6 X6 X6 X6 X3 X1 X6 X6 X6 X6 X6 ‚é• ‚é• X3 X3 X6 X6 X6 X6 X6 ‚é• ‚é• X6 X6 X4 X5 X2 X5 X4 ‚é• ‚é• X6 X6 X4 X4 X5 X2 X5 ‚é• ‚é• X6 X6 X5 X4 X4 X5 X2 ‚é• ‚é• X6 X6 X2 X5 X4 X4 X5 ‚é¶ X6 X6 X5 X2 X5 X4 X4 Y1 Y3 Y3 Y1 Y1 Y1 Y1 Y1 Y3 Y1 Y3 Y1 Y1 Y1 Y1 Y1 Y1 Y1 Y1 Y4 Y4 Y5 Y2 Y5 Y1 Y1 Y1 Y5 Y4 Y4 Y5 Y2 Y1 Y1 Y1 Y2 Y5 Y4 Y4 Y5 Y1 Y1 Y1 Y5 Y2 Y5 Y4 Y4 Y1 Y1 Y1 Y4 Y5 Y2 Y5 Y4 ‚é§ ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é¶

M1 and M2 both satisfy conditions 1 and 2. We also observe that the pattern of M2 may be obtained from that of M1 by specialization (by matching the variables X1 and X6 ). Thus, any total achievable for M2 is also achievable for M1 . For any given permissible permutation, we can therefore concentrate on the most general pattern of variables, M. (We term a pattern of variables most general if it cannot be obtained by specialization from a more general one.) All this is reminiscent of ‚ÄòuniÔ¨Åcation‚Äô and the ‚Äòmost general uniÔ¨Åer‚Äô, and we will indeed be using Prolog‚Äôs uniÔ¨Åcation mechanism in this step. iii. Verify condition 1 for the symbolic matrix M. part of condition 2 is satisÔ¨Åed. 4
3

Once this test is passed, we are sure that also the latter

iv. We now evaluate the pattern M. If N symbols have been used in M, assign the values 1, ..., N to them
3 This test is necessary since at this stage a matrix may have been generated failing to satisfy condition 1 as is illustrated by the (admissible) permutation ‚Äû ¬´ 1 2 3 4 5 6 7 8 œÅ= (1.2) 2 3 1 5 4 7 8 6

and the corresponding most general matrix M3 : 2 Z4 6 Z4 6 6 Z1 6 6 Z M3 = 6 9 6 Z9 6 6 Z7 4 Z 5 Z6

Z1 Z4 Z4 Z9 Z9 Z6 Z7 Z5

Z4 Z1 Z4 Z9 Z9 Z5 Z6 Z7

Z9 Z9 Z9 Z3 Z3 Z10 Z10 Z10

Z9 Z9 Z9 Z3 Z3 Z10 Z10 Z10

Z5 Z7 Z6 Z10 Z10 Z8 Z8 Z2

Z6 Z5 Z7 Z10 Z10 Z2 Z8 Z8

Z7 Z6 Z5 Z10 Z10 Z8 Z2 Z8

3 7 7 7 7 7 7 7 7 7 5

4 Were it not so, there would exist a row and a column with the same index such that the two were identical. However, this row will be identical (by way of the admissible permutation) to some other column too. Hence two columns and therefore also two rows would be identical, thus failing the test.

19 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

in reverse order by Ô¨Årst assigning N to the most frequently occurring symbol, N ‚àí 1 to the second most frequently occurring symbol etc. The total thus achieved will be a maximum for the given pattern M. v. The problem is Ô¨Ånally solved by generating and evaluating all patterns according to i‚Äìiv and selecting a one with the maximum total.

1.4
1.4.1

Implementation Details
Design Decisions

The original formulation from the New Scientist uses a chessboard but the problem can be equally set with a square board of any size. In our implementation, we shall allow for any board size since this will allow the limitations of the method employed to be explored. We write matrices in Prolog as lists of their rows which themselves are lists. Permutations will be represented by the list of the bottom entries of their two-line representation; thus, [2, 3, 1, 5, 6, 7, 8, 4] stands for œÄ in (1.1).

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

20 Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

Applications of Prolog

Enigma 1225: Rows are Columns

1.4.2

Admissible Permutations

First, we want to generate all permutations of a list. Let us assume that we want to do this by the predicate permute(+List,-Perm) and let us see how List = [1, 2, 3, 4] might be permuted. A permuted list, Perm = [3, 4, 1, 2] say, may be obtained by ‚Ä¢ Removing from List the entry E = 3 , leaving the reduced list R = [1, 2, 4] ‚Ä¢ Permuting the reduced list R to get P = [4, 1, 2] ‚Ä¢ Assembling the permuted list as [E|P] = [3, 4, 1, 2] . Lists with a single entry are left unchanged. This gives rise to the deÔ¨Ånition
permute([X],[X]). permute(L,[E|P]) :- remove_one(L,E,R), permute(R,P).

with the predicate remove one(+List,?Entry,?Reduced) deÔ¨Åned by
remove_one([H|T],H,T). remove_one([H|T],E,[H|L]) :- remove_one(T,E,L).

(Here we remove either the head or an entry from the tail.) For a permutation to be admissible, all entries must have changed position. We implement this by
admissible(L,P) :- permute(L,P), all_changed(L,P). all_changed([X],[Y]) :- X ¬Ø Y. all_changed([H1|T1],[H2|T2]) :- H1 ¬Ø H2, all_changed(T1,T2).

Exercise 1.1. Provide an alternative deÔ¨Ånition of remove one/3 by using one clause and append/3 .

1.4.3

Generating Symbolic Matrices

To generate a list of N unbound variables, L , we use var list(+N,-L) which is deÔ¨Åned in terms of length(-L,+N) by
var_list(N,L) :- length(L,N).

(See [9, p. 110, footnote 15].) Matrices with distinct symbolic entries may now be produced by mapping; for example, a 3 √ó 2 matrix is obtained by
?- maplist(var list,[2,2,2],M). M = [[_G370, _G373], [_G379, _G382], [_G388, _G391]]

Exercise 1.2. Use the above idea to deÔ¨Åne var matrix(+Size,-M) for generating a square symbolic matrix of any size.

21 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

1.4.4

Permuting Rows

This is accomplished by list permute(+Perm,+L,-P) as indicated below.
?- var matrix(3, M), list permute([3,1,2], M, P), write matrix( M), nl, write matrix( P). [_G779, _G782, _G785] [_G791, _G794, _G797] [_G803, _G806, _G809] [_G803, _G806, _G809] [_G779, _G782, _G785] [_G791, _G794, _G797]

(The permutation Perm establishes a correspondence between the entries of P and those of L .) Exercise 1.3. DeÔ¨Åne the predicate list permute/3 by recursion, using nth1/3 from [9, p. 107].

1.4.5

Transposing

This will be accomplished by transpose(+M,-T) .
?- maplist(var list,[2,2,2], M), transpose( M, T), write_matrix( M), nl, write matrix( T). [_G779, _G782] [_G788, _G791] [_G797, _G800] [_G779, _G788, _G797] [_G782, _G791, _G800]

Exercise 1.4. Use maplist/3 to deÔ¨Åne transpose/2 . Allow for any not necessarily square matrix as indicated above. Hint. First deÔ¨Åne a predicate col(+Matrix,+N,-Column) for returning the N th column of a matrix.

1.4.6

Most General Patterned Symbolic Matrices

It is now that Prolog shows its true strength: we use uniÔ¨Åcation to generate symbolic square matrices with certain patterns.5 For example, we may produce a 3 √ó 3 symmetric matrix thus
?- var matrix(3, M), transpose( M, M), write matrix( M). [_G535, _G538, _G541] [_G538, _G550, _G553] [_G541, _G553, _G565]
5 Trying to produce the results in this section by a programming language without built-in uniÔ¨Åcation will be a much more involved exercise.

22 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

More importantly, we are now in a position to produce symbolic matrices with prescribed patterns. For example, below we generate the most general 3 √ó 3 matrix whose rows and columns are interrelated by the permutation 1 2 3 3 1 2
?- var matrix(3, M), list permute([3,1,2], M, P), transpose( P, M), write_matrix( M). [_G748, _G748, _G754] [_G754, _G748, _G748] [_G748, _G754, _G748]

UniÔ¨Åcation is again seen to play a crucial rÀÜ ole here as M is declared to be the transpose of P : ‚Ä¢ transpose/2 receives in its Ô¨Årst argument the Prolog term for P . ‚Ä¢ The term for the transpose of P is returned in the second argument of transpose/2 . ‚Ä¢ This then is uniÔ¨Åed with the term for M thereby producing the intended pattern.

AXA Global Graduate Program
Find out more and apply

23 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

1.4.7

Distinct Rows

We want to test whether all rows of a matrix with symbolic entries are distinct. Matrices are lists, we therefore need to test for distinctness of list entries which are Prolog terms. The matrix [[A, B], [C, D]] should pass the test, whereas [[A, B], [A, B]] should not. The negation of the uniÔ¨Åcation operator (\=/2 ) cannot tell apart the rows of the Ô¨Årst matrix; we need here a ‚Äòstronger‚Äô (i. e. more specialized) notion of equality as deÔ¨Åned by the term equivalence operator ==/2 and its negation, \==/2 . (See inset overleaf.) Thus, using \==/2 will allow the rows of the former matrix to be recognized as diÔ¨Äerent, whereas those of the latter are veriÔ¨Åed identical.
?- [A, B] \== [C, D]. A = _G240 B = _G243 C = _G246 D = _G249 Yes ?- [A, B] \== [A, B]. No

Built-in Predicates: ==/2 and \==/2 These two predicates are used to test for term ‚Äôequivalence‚Äô and its negation, respectively. Two terms are equivalent if there exists a term to which both of them have been bound prior to the invocation of ==/2 . For example, the query ?- X = u, g(X,V) = Y, f(h(g(u,V)),Y) == f(h(Y),g(X,V)). X = u V = G448 Y = g(u, G448) Yes succeeds since both sides have been bound (by prior uniÔ¨Åcation) to the term f(h(g(u,V)),g(u,V)) . However, the query ?- f(h(g(u,V)),Y) == f(h(Y),g(X,V)). No fails even though the two terms are uniÔ¨Åable: ?- f(h(g(u,V)),Y) = f(h(Y),g(X,V)). V = G325 Y = g(u, G325) X = u Yes

Exercise 1.5. Use \==/2 to deÔ¨Åne a predicate distinct/1 for testing the distinctness of entries of a list as discussed above.

24 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

1.4.8

Evaluating Patterns

Given a patterned symbolic matrix, we want to sort the list of its entries according to their frequencies of occurrence and assign the rank order to each. For example, in the matrix M from the second query in Sect. 1.4.6, p. 22, the entry G748 occurs six times while G754 occurs thrice. Therefore, as shown below, G754 and G748 will be assigned the values 1 and 2 respectively.
?- var matrix(3, M), list permute([3,1,2], M, P), transpose( P, M), eval matrix( M,Freq), write matrix( M). [2, 2, 1] [1, 2, 2] [2, 1, 2] Freq = [ (3, 1), (6, 2)]

This shall be accomplished by the predicate eval matrix(?M,-Freq) ; it expects a symbolic matrix M in its Ô¨Årst argument which then is uniÔ¨Åed with an integer matrix whose each entry will be the rank order of the frequency of the corresponding symbolic entry. The second argument Freq is uniÔ¨Åed with the list of frequencies for each number in the matrix as indicated above. The hand computations in Fig. 1.2 on p. 27 indicate the steps involved in implementing eval matrix/2 .
1 2 3

Produce the list of matrix entries by flatten(+Matrix,-Entries) . Discard multiple occurrences by setof(E,member(E,+Entries),-Set) . Use maplist(count var(+Entries),+Set,-Multiplicities) to count how many times each variable occurs in the matrix. Exercise 1.6. DeÔ¨Åne the predicate count var(+VarList,+Var,-Num) . It will behave as follows.
?- count var([ A, B, A, C, B, A], B,N). N = 2

4

Use zip(+Multiplicities,+Set,-Frequencies) to obtain the list of matrix entry frequencies by zipping the lists produced in 2 and 3 . Exercise 1.7. DeÔ¨Åne the predicate zip/3 . It should behave as follows.
?- zip([1,2,3],[a,b,c],L). L = [ (1, a), (2, b), (3, c)]

5

Use sort(+Frequencies,-FreqSorted) (Prolog‚Äôs built-in sort/2 ) to sort the pairs from less frequent matrix entries will precede those with more frequent ones.

4

. Tuples with

6

Use maplist(snd,+FreqSorted,-VarsSorted) to retain the tuples‚Äô second entries only. We get a complete list of matrix entries, with no multiple copies, featuring in the rank order of their frequencies. snd/2 extracts the second entry of a 2‚Äìtuple and is deÔ¨Åned by

25 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

snd((_,X),X).
7 8

Use length(+VarsSorted,-NVars) to count the number of distinct matrix entries. Use from to/3 to generate the list of integers [1, ..., NVars] . (The predicate from to/3 is known from [9, p. 17].) Unify each variable in VarsSorted with the rank order of its frequency. A single call to from to(1,+NVars,?VarsSorted) will accomplish both steps, 8 and 9 . The eÔ¨Äect of this call will also be that ‚Ä¢ The initial (input) matrix will be bound to the integer matrix of frequency ranks. This will form the Ô¨Årst output of eval matrix/2 . ‚Ä¢ FreqSorted will be bound to the list of frequency pairs, forming the second output of eval matrix/2 .

9

The complete deÔ¨Ånition of eval matrix/2 , now a mere sequencing of clauses from the source Ô¨Åle enigma.pl.

1

‚Äì

9

, will be found in

26 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

The predicate eval matrix/2 has been deÔ¨Åned in a style reminiscent of that used in functional programming . (The predicates maplist/3 , zip/3 and snd/2 have indeed direct analogues in Haskell [30].) In [24], Parker espouses the virtues of this style for Prolog and calls it the ‚Äòstream data analysis paradigm‚Äô. Fig. 1.2 corresponds to what is called in [24] a ‚ÄòdataÔ¨Çow diagram‚Äô or ‚ÄòHenderson diagram‚Äô.

:; :;
;

1

:; :;
3

:::::::::::::::; :;
2

;

:;
6

;

,

:;

;

:::::::::;

:; ::::::::::::::; :;
7

4

:; :;
;

;

;

;

:;
Figure 1.2: Hand Computations for Pattern Evaluation

9

27 Download free eBooks at bookboon.com

;

:;

;

5

:;

:;

:;

8

:;

;

Applications of Prolog

Enigma 1225: Rows are Columns

total( [(1,10),(2,100),(3,1000)], Total)

:; :;

total([(1,10),(2,100),(3,1000)], 0, Total) total([(2,100),(3,1000)], 10, Total) total([(3,1000)], 210, Total) Total = 3210

:;

:; total([], 3210, Total) :;

:; success

Figure 1.3: Suggested Hand Computations for total/2

1.4.9

Computing Totals

Exercise 1.8. For the computation of the matrix total we shall need a predicate total(+IntPairs,-Total) which should sum the product of paired entries as exempliÔ¨Åed below.
?- total([(1,10),(2,100),(3,1000)],Total). Total = 3210

DeÔ¨Åne total/2 by the accumulator technique along the hand computations shown in Fig. 1.3.

1.4.10

Complete Implementation

In (P-1.1), we show the deÔ¨Ånition of square/5 which has been assembled from the predicates in Sects. 1.4.2‚Äì 1.4.9. Prolog Code P-1.1: DeÔ¨Ånition of square/5
1 2 3 4 5 6 7 8

square(Size,M,Total,Freq,Perm) :- var_matrix(Size,M), from_to(1,Size,One_to_Size), admissible(One_to_Size,Perm), list_permute(Perm,M,P), transpose(P,M), distinct(M), eval_matrix(M,Freq), total(Freq,Total).

square/5 may be used to search for feasible solutions as shown by the query in Fig. 1.4 for a 4 √ó 4 board. We know that all boards with the maximum total will be amongst those generated by the current process. Therefore, the largest of all totals thus generated will be the maximum total. We use setof/3 to obtain the sorted list of all totals generated (without duplicates) and select the maximum value by the built-in predicate last/2 :6
6 There is some inconsistency between versions of SWI‚ÄìProlog here. Version 3.4.5 is used in the query below, but, the order of the arguments in last/2 will have to be reversed if using version 5.2.7.

28 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

9

?- square(4, M,Total,Freq,Perm), write matrix( M). [1, 1, 2, 3] [1, 1, 3, 2] [3, 2, 4, 4] [2, 3, 4, 4] Total = 40 Freq = [ (4, 1), (4, 2), (4, 3), (4, 4)] Perm = [2, 1, 4, 3] ; [1, 2, 2, 1] [1, 1, 2, 2] [2, 1, 1, 2] [2, 2, 1, 1] Total = 24 Freq = [ (8, 1), (8, 2)] Perm = [2, 3, 4, 1] ; ...

6

8 Figure 1.4: Generating Feasible Solutions by square/5

7

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

29 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

?- setof( Tot, M^ Freq^ Perm^square(8, M, Tot, Freq, Perm),Tots), last(Max,Tots). Tots = [160, 244, 288, 301, 400, 544] Max = 544

We now know that the maximum total is 544 and may Ô¨Ånd a board with that total (and the corresponding permutation) by
?- square(8, M,544, ,Perm), [ 1 1 2 3 4 5 [ 1 1 3 2 5 4 [ 3 2 8 8 9 10 [ 2 3 8 8 10 9 [ 5 4 10 9 13 13 [ 4 5 9 10 13 13 [ 7 6 12 11 15 14 [ 6 7 11 12 14 15 write imatrix( M). 6 7] 7 6] 11 12] 12 11] 14 15] 15 14] 16 16] 16 16]

Perm = [2, 1, 4, 3, 6, 5, 8, 7]

Exercise 1.9. DeÔ¨Åne the predicate write imatrix/1 for displaying on the terminal an integer matrix with non-negative entries, right justiÔ¨Åed. In your deÔ¨Ånition, you should use writef(+Format,+Arguments) (Prolog‚Äôs formatted write ); see inset. The built-in predicates concat atom/2 [9, p. 126] and int to atom/2 (see inset) may be used to construct writef ‚Äôs Ô¨Årst argument.

Built-in Predicate: writef(+Format,+Arguments) This is one of Prolog‚Äôs predicates for formatted write . Arguments is a list whose entries are displayed on the terminal according to the atom Format . Example: ?- writef(‚Äô[%8r%8r%8r]‚Äô,[12, 345, 6789]). [ 12 345 6789] displays the list [12, 345, 6789] with its entries right justiÔ¨Åed, each occupying up to eight digits. Consult the manual [33] for the options available for Format .

Built-in Predicate: int to atom(+Int,-Atom) UniÔ¨Åes Atom with the ASCII representation of Int . Example: ?- int to atom(1953,A). A = ‚Äô1953‚Äô

30 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

Size CPU Seconds

3 0.00

4 0.06

5 0.11

6 2.03

7 15.37

8 209.59

9 3,334.14

Table 1.1: CPU times for Various Board Sizes

1.5
1.5.1

Enhanced Implementation
What is Wrong with the Present Implementation?

The implementation obtained in Sect. 1.4.10 has serious limitations. Table 1.1 shows the CPU times needed for solving the puzzle for up to size 9 on a 300 MHz PC. The size of the original puzzle seems to be the practical limit of what can be solved by this method.7 Table 1.1 indicates that the computing time increases roughly with the factorial of Size. This means for the original puzzle that 8! = 40, 320 permutations have to be generated of which 14, 833 will be admissible.8 Each of these will give rise to a patterned symbolic matrix, each to be tested by distinct/1 . The number of patterned matrices passing this test is 13, 713.9 All of them are then evaluated, resulting in a list with 13, 713 entries. After removing duplicates with setof/3 , we end up with a list of just six values! There is obviously a great deal of duplication of eÔ¨Äort here. To reduce the number of permutations to be considered, we are going to introduce in the next section a partitioning of the set of all permutations into subsets, called types, such that permutations of the same type will share certain pertinent properties. More precisely, each of the following properties will be such that permutations of the same type either all have it or none has it.10 ‚Ä¢ Being admissible, ‚Ä¢ For admissible permutations, the corresponding most general symbolic pattern having distinct rows. Furthermore, ‚Ä¢ For permutations of the same type, the corresponding most general symbolic pattern will evaluate to the same maximum total.
7 There is another problem for larger sizes which could be overcome, however. For sizes exceeding 9, insuÔ¨Écient memory will be available for using setof/3 to collect the values of total. To remedy the situation, we could instead calculate the maximum total in an incremental fashion by using, for instance, assert/1 to save in the database the most recent maximum value of total. 8 The number of admissible permutations can be found by the query ?- bagof( A,admissible([1,2,3,4,5,6,7,8], A), As), length( As,L). L = 14833 Alternatively, the number of admissible permutations of {1, . . . , n}, an , may be calculated by the recurrence relation

an = n! ‚àí (f1n + f2n + . . . + f(n‚àí1)n + 1) ‚Äún‚Äù an‚àíi i denotes the number of permutations of {1, . . . , n} which leave exactly i entries Ô¨Åxed. Start with a1 = 0. Other ways of calculating an may be found in [3, p. 73]. 9 We Ô¨Ånd this by the query ?- bagof( Tot, M^ Freq^ Perm^square(8, M, Tot, Freq, Perm), Tots), length( Tots,L). L = 13713 The matrix M3 in footnote 3, p. 19, is an example for a pattern which will be tested by distinct/1 and fail. 10 We may call them therefore type-properties. where fin =

31 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

E

8

2

E

5

1

E

Figure 1.5: The Cycles œÑ1 and œÑ2 It will therefore suÔ¨Éce to concentrate on a representative permutation from each type (Sect. 1.5.3). Before elaborating on this idea, however, we Ô¨Årst review some results from the Theory of Permutations [3].

1.5.2

Some Results from the Theory of Permutations

The Cycle Notation for Permutations Let us look at the permutation œÑ= 1 6 2 5 3 4 4 8 5 7 6 3 7 2 8 1

It can be thought of as the composition of two cycles œÑ1 and œÑ2 with œÑ1 = 2 5 5 7 7 2 , œÑ2 = 1 6 3 4 4 8 6 3 8 1

It is seen from Fig. 1.5 that both cycles (as the name implies) eÔ¨Äect a cyclical interchange on a subset of {1, . . . , 8}; these subsets form a partition of {1, . . . , 8} = {2, 5, 7} ‚à™ {1, 3, 4, 6, 8}. We may use the cycle notation to denote cycles: œÑ1 = (5 7 2), œÑ2 = (6 3 4 8 1). The permutation œÑ is said to be the product of the cycles œÑ1 and œÑ2 , œÑ = (5 7 2)(6 3 4 8 1) (1.3)

As the individual cycles of a product operate on disjoint sets, the order in which the cycles are listed is immaterial, though shorter cycles are usually written before longer ones. Thus œÑ = (6 3 4 8 1)(5 7 2). The entries of a cycle in the cycle notation may be rotated [9]; for example, (3 4 8 1 6) still refers to the cycle œÑ2 . Another example of a permutation in the cycle notation is œÅ = (4 5)(1 2 3)(6 7 8) (1.4)

from (1.2) on p. 19; it is the product of three cycles. Finally, permissible permutations (so-called derangements ) are now easily recognized as those without a 1‚Äìcycle.

32 Download free eBooks at bookboon.com

E
6

E

E
E

7

4 3

E

Applications of Prolog

Enigma 1225: Rows are Columns

Types The permutation œÑ in (1.3) is the product of two cycles, œÑ1 and œÑ2 , of length 3 and 5, respectively. Therefore, œÑ is said to be of type [31 51 ].11 œÄ in (1.1) is another permutation of the same type, since œÄ = (3 1 2)(7 8 4 5 6) (1.5)

On the other hand, œÅ in (1.4) is seen to be of type [21 32 ]. We note in passing that each type corresponds to a partition of the number of elements permuted. A partition of a positive whole number is its representation as the sum of some positive whole numbers. For example, the above types deÔ¨Åne the partitions 8 = 3 + 5 and 8 = 2 + 3 + 3. Types in our context become signiÔ¨Åcant by the following Observation. Column‚Äìto‚Äìrow transformations of the same type give rise to most general patterned symbolic matrices which are essentially the same in that they can be transformed into each other by appropriate row‚Äìto‚Äìrow and column‚Äìto‚Äìcolumn rearrangements. We won‚Äôt prove this result here but illustrate it by an example. To determine the most general symbolic matrix for œÑ from that of œÄ , proceed as follows. 1. Write the permutations œÄ and œÑ in cycle notation as shown below. 2) 1 œÄ = (3 ‚Üì ‚Üì ‚Üì 2) 7 œÑ = (5 Shorter cycles should precede longer ones. 2. Read oÔ¨Ä the rearrangement as 3 5 or, written in the usual way, as 1 7 2 2 3 5 4 4 5 8 6 1 7 6 8 3 (1.6) 1 7 2 2 7 6 8 3 4 4 5 8 6 1 (as in (1.5) and (1.3)) and place them above each other (7 ‚Üì (6 8 ‚Üì 3 4 ‚Üì 4 5 ‚Üì 8 6) ‚Üì 1)

3. Produce the most general patterned symbolic matrix for œÄ by
?- var matrix(8, M), list permute([2,3,1,5,6,7,8,4], M, P), transpose( P, M), write matrix( M). [_G868, _G871, _G868, _G877, _G877, _G877, _G877, _G877] [_G868, _G868, _G871, _G877, _G877, _G877, _G877, _G877] [_G871, _G868, _G868, _G877, _G877, _G877, _G877, _G877] [_G877, _G877, _G877, _G958, _G961, _G964, _G961, _G958] [_G877, _G877, _G877, _G958, _G958, _G961, _G964, _G961] [_G877, _G877, _G877, _G961, _G958, _G958, _G961, _G964] [_G877, _G877, _G877, _G964, _G961, _G958, _G958, _G961] [_G877, _G877, _G877, _G961, _G964, _G961, _G958, _G958]
11 In this notation for types (see [3]), the superscripts stand for the number of times cycles of a particular length occur. The square brackets have nothing to do with Prolog‚Äôs list notation.

33 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

Rename the variables as necessary to see that the above is M1 (p. 19).

4. Rearrange the columns of M1 according to (1.6) to get ‚é° ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é£ X6 X6 X6 X2 X5 X4 X4 X5 X1 X3 X3 X6 X6 X6 X6 X6 X6 X6 X6 X4 X5 X2 X5 X4 X6 X6 X6 X4 X4 X5 X2 X5 X3 X1 X3 X6 X6 X6 X6 X6 X6 X6 X6 X5 X2 X5 X4 X4 X3 X3 X1 X6 X6 X6 X6 X6 X6 X6 X6 X5 X4 X4 X5 X2 ‚é§ ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é¶

5. Now, using (1.6) again, rearrange the rows of the matrix from the previous step.

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

34 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

‚é° ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é£

X4 X6 X5 X2 X6 X4 X6 X5

X6 X3 X6 X6 X3 X6 X1 X6

X2 X6 X4 X4 X6 X5 X6 X5

X5 X6 X5 X4 X6 X2 X6 X4

X6 X1 X6 X6 X3 X6 X3 X6

X5 X6 X4 X5 X6 X4 X6 X2

X6 X3 X6 X6 X1 X6 X3 X6

X4 X6 X2 X5 X6 X5 X6 X4

‚é§ ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é• ‚é¶

This is the most general patterned symbolic matrix for œÑ as is conÔ¨Årmed by the query below.
?- var matrix(8, M), list permute([6,5,4,8,7,3,2,1], M, P), transpose( P, M), write matrix( M). [_G868, _G871, _G874, _G877, _G871, _G877, _G871, _G868] [_G871, _G898, _G871, _G871, _G907, _G871, _G898, _G871] [_G877, _G871, _G868, _G877, _G871, _G868, _G871, _G874] [_G874, _G871, _G868, _G868, _G871, _G877, _G871, _G877] [_G871, _G898, _G871, _G871, _G898, _G871, _G907, _G871] [_G868, _G871, _G877, _G874, _G871, _G868, _G871, _G877] [_G871, _G907, _G871, _G871, _G898, _G871, _G898, _G871] [_G877, _G871, _G877, _G868, _G871, _G874, _G871, _G868]

Row‚Äìto‚Äìrow and column‚Äìto‚Äìcolumn rearrangements obviously retain the total of a numerical matrix. Therefore, most general patterned symbolic matrices belonging to permutations of the same type will evaluate to the same maximum total. This conÔ¨Årms the last of the three results announced in Sect. 1.5.1. The other two are more straightforward. Admissibility (i.e. not having any 1‚Äìcycle) is clearly a type-property. Finally, a matrix with distinct rows will be transformed to a such by a row‚Äìto‚Äìrow or column‚Äìto‚Äìcolumn rearrangement. Therefore, row-distinctness is also a type-property.

1.5.3

Generating Representative Permutations

Generating Permutation Types The following algorithm, which is from [3, p. 440], is for obtaining all partitions of a number. It will serve as a basis for generating all permutation types for a given problem size. (As mentioned earlier, there is a one‚Äìto‚Äìone correspondence between partitions of a number and permutation types.) The following rule is the basis for a method of listing all partitions of n in lexicographic order.12 The Ô¨Årst partition is [n]. Suppose the current partition Œª has parts Œª1 Œª2 . . . Œªr . Then the next partition is found as follows: (i) if Œªr = 1, then the parts of the next partition are Œª1 , Œª2 , . . . , Œªr‚àí1 , Œªr ‚àí 1, 1;
12 The following is an appropriate ordering. For two partitions of n, p = [1Œ±1 2Œ±2 . . . nŒ±n ] and r = [1Œ≤1 2Œ≤2 . . . nŒ≤n ], we say that p comes before r (denoted by p ‚â∫n r ) if for some k ‚àà {1, . . . , n}, Œ±k > Œ≤k and Œ±i = Œ≤i for all i ‚àà {k + 1, . . . , n}. For example,

[11 31 41 ] ‚â∫8 [14 41 ] since, more explicitly, [11 20 31 41 50 60 70 80 ] ‚â∫8 [14 20 30 41 50 60 70 80 ]. (Longest possible identical tail sections are shaded.) In the ascending chain of successors produced by the algorithm, every partition of n appears since ‚â∫n is a total ordering on the partitions of n.

35 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

(1)

(3)

(5)

Current Partition

√ó √ó √ó

√ó

√ó √ó √ó √ó √ó

√ó

√ó

√ó √ó √ó

[12 21 42 52 ] (2) (4)

[14 42 52 ] (6)

[21 32 41 52 ]

Next Partition

√ó √ó √ó √ó [14 42 52 ]

√ó √ó √ó

√ó √ó √ó

√ó √ó

√ó √ó [12 32 41 52 ] (i)

[21 32 41 52 ] (ii) Table 1.2: A Ferrers Diagram

Step Used

(ii)

(ii) if Œªr = Œªr‚àí1 = ¬∑ ¬∑ ¬∑ = Œªr‚àís+1 = 1 but Œªr‚àís = x = 1, then the parts of the next partition are obtained by replacing Œªr‚àís , Œªr‚àís+1 , . . . , Œªr by x ‚àí 1, x ‚àí 1, x ‚àí 1, . . . , x ‚àí 1, y , where 1 y x ‚àí 1 and the number of parts x ‚àí 1 is chosen so that the result is a partition of n. To make the recursive step of this algorithm more accessible, we show in Table 1.2 some typical instances for generating partitions of n = 22. Ferrers Diagrams ([3]) are used in Table 1.2 to illustrate partitions. Tokens involved in the recursive step are marked (√ó). We paraphrase the algorithm in plain English as it may look rather cryptic at Ô¨Årst sight. We lay out n tokens to represent the current partition as a Ferrers diagram. The initial pattern will be just a single row of n tokens, denoting the partition [n]. All subsequent diagrams will have several rows and (as a rule) longer rows are placed above shorter ones. To decide which of the recursive steps (i) or (ii) applies, we inspect the bottom row. If it contains more than one token, we then remove its last (i.e. rightmost) token and start a new row by placing it below what was hitherto the bottom row. This completes step (i). On the other hand, if the bottom row consists of a single token, we then scan the diagram from bottom to top. There are now two possibilities. We may Ô¨Ånd that all rows are single-token rows in which case we have found the last partition, [1n ], and stop.

36 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

(This has been omitted in the algorithm.) The other possibility is that there is a row containing more than one token. In this case, we remove from the diagram all single-token rows as well as the bottom non-single-token row which has x( 2) tokens, say. (These tokens have been marked in Table 1.2, parts (1) and (3).) The tokens thus removed are now used to build up as many new rows of length x ‚àí 1 as possible; we place them below the other (undisturbed) tokens. All the remaining tokens, less than x ‚àí 1, if any, are placed below all the other tokens. This completes step (ii). Partitions will be represented in our Prolog implementation by lists of pairs; for example, [(2,1), (3,2), (4,1), (5,2)] stands for [21 32 41 52 ]. As a Ô¨Årst step towards implementing a type generator , we deÔ¨Åne next partition(+Current,-Next) which for a Current partition returns the Next partition; for example,

?- next partition([(2,1), (3,2), (4,1), (5,2)], Next). Next = [ (1, 2), (3, 2), (4, 1), (5, 2)]

In (P-1.2) we deÔ¨Åne those three clauses of next partition/2 which are typiÔ¨Åed by the cases in Table 1.2; the deÔ¨Ånition of the remaining clauses is asked for in Exercise 1.10.

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

37 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

Current Partition Next Partition Step Used Current Partition Next Partition Step Used

[23 41 62 ] ... ... ... [2 4 6 ]
1 2 2

... 1 1 3 [1 3 6 ] ... [13 51 72 ] ... ...

[43 52 ] ... ... ... [33 42 51 ] ...

... [1 2 3 4 ] ...
5 3 1 2

...

Table 1.3: Suggested Examples for Exercise 1.10 Prolog Code P-1.2: Three clauses of the predicate next partition/2
1 2 3

next_partition([(1,Alpha),(2,1)|T], [(1,NewAlpha)|T]) :NewAlpha is Alpha + 2. next_partition([(1,Alpha1),(L,AlphaL)|T], [(Rest,1), (NewL,Ratio), (L,NewAlphaL)|T]) :L > 2, AlphaL > 1, NewL is L - 1, Rest is (Alpha1 + L) mod NewL, Rest > 0, Ratio is (Alpha1 + L) // NewL, NewAlphaL is AlphaL - 1. next_partition([(2,1)|T],[(1,2)|T]).

% Cases (1)-(2) in Table 1.2 % % % Cases (3)-(4) in Table 1.2 % % % % % % % % % % % Cases (5)-(6) in Table 1.2

4 5 6 7 8 9 10 11 12 13 14

15

Exercise 1.10. The complete deÔ¨Ånition of next partition/2 comprises ten clauses three of which have been deÔ¨Åned already. Typical examples covered by each of the remaining seven clauses are partially shown in Table 1.3. Complete Table 1.3 and then deÔ¨Åne the missing clauses of next partition/2 . (It may be helpful to devise the corresponding Ferrers diagrams by using coins.) The predicate next partition/2 returns for a given partition its successor. We want, however, a generator (also called enumerator ) of partitions, i.e. a predicate which on backtracking will eventually return all partitions. The more general question is as follows: How do we ‚Äòconvert‚Äô a successor predicate into a generator? The key to answering this question is by recognizing that this type of problem has been met before. In Exercise 4.6, [9, p. 134], the following deÔ¨Ånition of int(+N,?NextN) was considered,
int(I, I). int(Last, I) :- succ(Last, New), int(New, I).

This deÔ¨Ånition can be used as a template for deÔ¨Åning another generator: replace succ and int respectively by next partition and part thus giving,

38 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

part(P, P). part(Last, Next) :- next_partition(Last, New), part(New, Next).

This will result in an acceptable solution,
?- part([(1,2),(2,1),(4,2),(5,2)], P). P = [ (1, 2), (2, 1), (4, 2), (5, 2)] ; P = [ (1, 4), (4, 2), (5, 2)] ; P = [ (2, 1), (3, 2), (4, 1), (5, 2)] ; ...

A better idea still is to write a higher order predicate, generator/3 , say, to accomplish the same task for any successor predicate. We then have, for example,
?- generator(next partition,[(1,2),(2,1),(4,2),(5,2)], P). P = [ (1, 2), (2, 1), (4, 2), (5, 2)] ; P = [ (1, 4), (4, 2), (5, 2)] ; P = [ (2, 1), (3, 2), (4, 1), (5, 2)] ; ...

and
?- generator(succ,7,I). I = 7 ; I = 8 ; I = 9 ; ...

We deÔ¨Åne generator(+Pred,+Init,?Element) in (P-1.3) by Prolog Code P-1.3: DeÔ¨Ånition of generator/3
1 2 3 4 5

generator(Pred,From,Element) :retractall(temp(_,_)), assert(temp(First,First)), assert(temp(Last,E) :- (call(Pred,Last,New), temp(New,E))), temp(From,Element).

(P-1.3) shows that ‚Ä¢ The temporary generator to be deÔ¨Åned in the database is named temp/2 . Possible earlier deÔ¨Ånitions are removed Ô¨Årst. ‚Ä¢ Following our template, two clauses of temp/2 are written to the database. For instance, after running the above example, the database may be inspected thus
?- listing(temp). temp(A, A). temp(A, B) :- call(succ, A, C), temp(C, B).

As the predicate name is open at this stage, call/3 is used to invoke the predicate in Pred . (See inset.) ‚Ä¢ Finally, temp/2 , just written to the database, is invoked and backtracking is used to produce the sequence.

39 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

(0, 0) E (0, 1)
E E

(0, 2) E (0, 3) (1, 2)
E

(0, 4) E

...

(1, 0)
E

(1, 1) (2, 1) (3, 1)
E E

(1, 3)

(2, 0) (3, 0) (4, 0)
E

(2, 2)

Figure 1.6: Enumeration Scheme for {(m, n) : m, n = 0, 1, 2, . . .}. (See Exercise 1.12.)

Built-in Predicate: call/n, n = 1, 2, 3, ... call(+Goal) invokes Goal . Combine call/1 with =../2 , the built in predicate univ ([9] or [33]), if the arity of the predicate in Goal is known at run time only. Example: ?- Functor = append, Args = [[1,2],[3],L], Goal =.. [ Functor| Args], call(Goal). L = [1, 2, 3] Goal = append([1, 2], [3], [1, 2, 3]) Use call(+Predicate, +Arg1, +Arg2, ...) to invoke a Predicate whose arity is known at compile time. Examples: ?- Pred = append, call(Pred,[1,2],[3],L). Pred = append L = [1, 2, 3] ?- Pred = append([1,2]), call(Pred,[3],L). Pred = append([1, 2]) L = [1, 2, 3] call/n is a higher order predicate.

Exercise 1.11. DeÔ¨Åne a predicate next int(+Upper,+I,-NextI) for unifying NextI with the value of I incremented by 1. The predicate should fail if Upper does not exceed I . Use next int/3 in conjunction with generator/3 to generate all integers between 3 and 9. Exercise 1.12. Fig. 1.6 indicates an enumeration scheme for all pairs of non-negative integers (the Cartesian product). DeÔ¨Åne next pair/2 for returning the successor of any given pair. Then use next pair/2 in conjunction with generator/3 for deÔ¨Åning an enumerator for the said Cartesian product. Exercise 1.13. (An improved generator ) The predicate pairs/1 , deÔ¨Åned by
pairs((I,J)) :- int(0,Sum), between(0,Sum,I), J is Sum - I.

Download free eBooks at bookboon.com

E

40

E

E

E

E

Applications of Prolog

Enigma 1225: Rows are Columns

enumerates the pairs of non-negative integers as shown in Fig. 1.7.13 It will return on backtracking all pairs starting from (0, 0).
?- pairs(P). P = 0, 0 ; P = 0, 1 ; P = 1, 0 ; P = 0, 2 ; P = 1, 1 ; ...

An alternative implementation of pairs/1 may conceivably be obtained by replacing in its deÔ¨Ånition the predicates int/2 and between/3 by their respective deÔ¨Ånitions using generator/3 :
pairs_alt((I,J)) :- generator(succ,0,Sum), generator(next_int(Sum),0,I), J is Sum - I.

Testing will reveal, however, that this implementation is Ô¨Çawed. The problem is due to the use by generator/3 of the same name temp for predicates written to the database.

13 The

built-in predicate between/3 is described in [9, p. 41].

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

41 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

(0, 0) E (0, 1) E (0, 2) E (0, 3) E (0, 4) E
E E E E E E E

...

(1, 0) (2, 0) (3, 0) (4, 0)

(1, 1) (2, 1) (3, 1)

(1, 2)
E

(1, 3)
E

(2, 2)
E

Figure 1.7: Enumeration Scheme for {(m, n) : m, n = 0, 1, 2, . . .}. (See Exercise 1.13.) (The call to generator(next int(Sum),0,I) will interfere with that of generator(succ,0,Sum) .) The problem could be avoided though if generator/3 created temporary predicates with a diÔ¨Äerent and unique name every time it is invoked. DeÔ¨Åne such an improved version of generator/3 . Hint. It is suggested that the temporary predicates be named temp 0 , temp 1 , etc. You should use the built-in predicate current predicate/2 (described in the SWI manual [33]) for Ô¨Ånding out whether a proposed new predicate name is available. Use concat atom/2 [9, p. 126] for constructing new predicate names.

Admissible Representative Permutations How many permutation types will have to be considered for the original 8 √ó 8 problem? This is easily found out by a query,
?- bagof( P,generator(next partition,[(8,1)], P), Ps), length( Ps,NTypes). NTypes = 22

The number 22 is further reduced by concentrating on admissible permutations, i.e. on those without a 1‚Äìcycle; the types of these we obtain by14
?- bagof( P, I^ A^ T^(generator(next partition,[(8,1)], P), P = [( I, A)| T], I > 1), Ps). Ps = [[(8, 1)], [(2, 1),(6, 1)], [(3, 1),(5, 1)], [(4, 2)], [(2, 2),(4, 1)], [(2, 1),(3, 2)], [(2, 4)]]

We therefore have to consider here a mere 7 types. (Contrast this with the 14, 833 admissible permutations considered earlier!) All we have to do now is to create for each admissible type a representative permutation. Suppose we want to construct a representative permutation for the type [21 33 51 ], a partition of 16. An example permutation of this type in the cycle notation is obtained by simply grouping the elements of {1, . . . , 16} according to the length of the cycles needed: (1 2)(3 4 5)(6 7 8)(9 10 11)(12 13 14 15 16)
14 This

(1.7)

query gives rise to ad partition(+N,?P) , a predicate for generating (and testing) admissible partitions of N : ad partition(N,[(I,A)|T]) :- generator(next partition,[(N,1)],[(I,A)|T]), I > 1.

42 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

Using the two-line notation, we rewrite this as 1 2 2 1 3 4 4 5 5 3 6 7 7 8 8 6 9 10 10 11 11 9 12 13 13 14 14 15 15 16 16 12 (1.8)

which then in the Prolog implementation will be denoted by [2,1,4,5,3,7,8,6,10,11,9,13,14,15,16,12] The Prolog implementation of (1.7)‚Äì(1.9) is in three steps: (a) A predicate split(+N,+Type,-S) is used for partitioning [1, . . . , 16] into a list of sublists S according to Type :15 ?- split(16,[(2,1),(3,3),(5,1)],_S), write term( S,[]). [[1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14,15,16]] split/3 is deÔ¨Åned below in terms of an auxiliary predicate split/4 which itself uses the accumulator technique.
split(N,Type,S) :- from_to(1,N,L), split(L,Type,[],S).

(1.9)

Exercise 1.14. DeÔ¨Åne split/4 . (Some suggested hand computations are shown in Fig. 1.8, p. 45.) (b) maplist/3 is applied to rotate each sublist in the above list‚Äìof‚Äìlists.16
?- split(16,[(2,1),(3,3),(5,1)],_S), maplist(rotate, S,_R), write term( R,[]). [[2,1], [4,5,3], [7,8,6], [10,11,9], [13,14,15,16,12]]

(c) Finally, flatten/2 is used to obtain the list in (1.9). (a)‚Äì(c) give rise to rep perm(+N,+Type,-Perm) , a predicate for Ô¨Ånding a representative permutation of a given type.
rep_perm(N,Type,Perm) :- split(N,Type,S), maplist(rotate,S,R), flatten(R,Perm).

1.5.4

Finishing Touches

Based on the ideas in Sect. 1.5.3, we are now in a position to deÔ¨Åne a new version of the predicate square/5 , deÔ¨Åned in (P-1.1); the new deÔ¨Ånition is shown in (P-1.4). Now the queries from Sect. 1.4.10 may be completed as before and with a much reduced computing time. For example, for a 14 √ó 14 board we Ô¨Ånd by a near instantaneus response that the maximum total is 4900. (The earlier version won‚Äôt solve this problem due to memory shortage and excessive computing time.)
15 The Ô¨Årst argument of split/3 is redundant as it can be computed from Type . Not having to recompute it, however, will save computing time. 16 Prolog implementations of list rotation are discussed in [5], [8] and [9].

43 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

Prolog Code P-1.4: DeÔ¨Ånition of square2/5
1 2 3 4 5 6 7 8

square2(Size,M,Total,Freq,Perm) :- var_matrix(Size,M), ad_partition(Size,Type), rep_perm(Size,Type,Perm), list_permute(Perm,M,P), transpose(P,M), distinct(M), eval_matrix(M,Freq), total(Freq,Total).

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Deutsche Bank db.com/careers

44 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Enigma 1225: Rows are Columns

split([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(2,1),(3,3),(5,1)], [], S) split([3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(2,0),(3,3),(5,1)], [[1,2]], S) split([3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(3,3),(5,1)], [[1,2]], S)

:; :;

:; :; :; :;

split([6,7,8,9,10,11,12,13,14,15,16], [(3,2),(5,1)], [[3,4,5], [1,2]], S)

split([9,10,11,12,13,14,15,16], [(3,1),(5,1)], [[6,7,8], [3,4,5], [1,2]], S)

split([12,13,14,15,16], [(3,0),(5,1)], [[9,10,11], [6,7,8], [3,4,5], [1,2]], S) split([12,13,14,15,16], [(5,1)], [[9,10,11], [6,7,8], [3,4,5], [1,2]], S)

:; :;

split([], [(5,0)], [[12,13,14,15,16], [9,10,11], [6,7,8], [3,4,5], [1,2]], S) S = [[1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14,15,16]]

:; success

Figure 1.8: Suggested Hand Computations for split/4

45 Download free eBooks at bookboon.com

Applications of Prolog

Enigma 1225: Rows are Columns

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

46 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

Chapter 2

Blind Search
Many problems in ArtiÔ¨Åcial Intelligence (AI) can be formulated as network search problems. The crudest algorithms for solving problems of this kind, the so called blind search algorithms, use the network‚Äôs connectivity information only. We are going to consider examples, applications and Prolog implementations of blind search algorithms in this chapter. Since implementing solutions of problems based on search usually involves code of some complexity, modularization will enhance clarity, code reusability and readibility. In preparation for these more complex tasks in this chapter, Prolog‚Äôs module system will be discussed in the next section.

2.1

Digression on the Module System in Prolog

In some (mostly larger) applications there will be a need to use several input Ô¨Åles for a Prolog project. We have met an example thereof already in Fig. 3.5 of [9, p. 85] where consult/1 was used as a directive to include in the database deÔ¨Ånitions of predicates from other than the top level source Ô¨Åle. As a result, all predicates thus deÔ¨Åned became visible to the user: had we wished to introduce some further predicates, we would have had to choose the names so as to avoid those already used. Clearly, there are situations where it is preferable to make available (that is, to export ) only those predicates to the outside world which will be used by other non-local predicates and to hide the rest. This can be achieved by the built-in predicates module/2 and use module/1 . As an illustrative example, consider the network in Fig. 2.1.1 The network connectivity in links.pl is deÔ¨Åned by the predicate link/2 which uses the auxiliary predicate connect/2 (Fig. 2.2). The Ô¨Årst line of links.pl is the module directive indicating that the module name is edges and that the predicate link/2 is to be exported. All other predicates deÔ¨Åned in links.pl (here: connect/2 ) are local to the module and (normally) not visible outside this module. Suppose now that in some other source Ô¨Åle, link/2 is used in the deÔ¨Ånition of some new predicate (Fig. 2.3). Then, the (visible) predicates from links.pl will be imported by means of the directive
:- use_module(links).2

The new predicate thus deÔ¨Åned may be used as usual:
1 This 2 Notice

is a network from the AI‚Äìclassic [34]. that the argument in use module/1 is the Ô¨Ålename without the .pl extension.

47 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

a u d

b u

c u ug

¬† u d

d d du s ¬† ¬† ¬†

u e

u f

Figure 2.1: A Network
?- consult(df1). % links compiled into edges 0.00 sec, 1,644 bytes % df1 compiled 0.00 sec, 3,208 bytes Yes ?- successors(a,L).

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

48 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

:- module(edges,[link/2]). connect(a,b). connect(a,d). connect(a,s). connect(b,c). connect(b,e). connect(d,e). connect(d,s). connect(e,f). connect(f,g). link(Node1,Node2) :- connect(Node1,Node2). link(Node1,Node2) :- connect(Node2,Node1). Figure 2.2: The File links.pl :- use module(links). ... ... successors(Node,SuccNodes) :findall(Successor,link(Node,Successor),SuccNodes). Figure 2.3: Fragment of the File df1.pl
L = [b, d, s] ; No

In our example, the predicate connect/2 will not be available for use (since it is local to the module edges that resides in links.pl). A local predicate may be accessed, however, by preÔ¨Åxing its name by the module name in the following fashion:3 ?- edges:connect(a,N). N = b ; N = d ; N = s ; No (Notice the distinct uses of the module name and the name of the Ô¨Åle in which the module resides.)

2.2

Basic Search Problem

Let us assume that for the network in Fig. 2.1 we want to Ô¨Ånd a path from the start node s to the goal node g . The search may be conducted by using the (associated) search tree shown in Fig. 2.4. It is seen that the
will suggest a correction if the predicate name is used without the requisite preÔ¨Åx: ?- connect(a,N). Correct to: edges:connect(a, N)? yes N = b; ...
3 SWI‚ÄìProlog

49 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

0 . . . . . . . . . . . . . . . . . . . . . . . . . .$ .s . $$ ¬à¬à¬à¬à $ $ ¬à¬à¬à $ ¬à¬à¬à $$$ $$$ ¬à a d 1. . . . . . . . . . . . ¬à¬à¬à ¬Å¬Ä¬Ä ¬ó &¬Ä &¬ó ¬à¬à¬à ¬ó ¬Å ¬Ä¬Ä & & ¬ó ¬à¬à ¬ó ¬Ä¬Ä ¬Å & & ¬ó ¬Ä ¬ó ¬à¬à¬à ¬Å & & e d s s a 2. . . . . . b rr . . . . &¬ê & e . . . . ¬ê & & e rr . . . . ¬ê & & r ¬ê r & & e c f 3. . e b a d . . . . ¬í . . . . . . . .  ¬í  ¬í 4. . g e b . . . . . . f . . . Figure 2.4: The Search Tree search tree is inÔ¨Ånite but highly repetitive. The start node s is at the root node (level 0). At level 1, all tree nodes are labelled by those network nodes which can be reached in one step from the start node. In general, a node labelled n in the tree at level has successor (or child ) nodes labelled s1 , s2 , . . . if the nodes s1 , s2 , . . . in the network can be reached in one step from node n. These successor nodes are said to be at level + 1. The node labelled n is said to be a parent of the nodes s1 , s2 , . . .. In Fig. 2.4, to avoid repetition, those parts of the tree which can be generated by expanding a node from some level above have been omitted. Some Further Terminology ‚Ä¢ The connections between the nodes in a network are called links. ‚Ä¢ The connections in a tree are called branches. ‚Ä¢ In a tree, a node is said to be the ancestor of another if there is a chain of branches (upwards) which connects the latter node to the former. In a tree, a node is said to be a descendant of another node if the latter is an ancestor of the former. In Fig. 2.5 we show, for later reference, the fully developed (and ‚Äôpruned ‚Äô) search tree. It is obtained from Fig. 2.4 by arranging that in any chain of branches (corresponding to a path in the network) there should be no two nodes with the same label (implying that in the network no node be visited more than once). All information pertinent to the present problem is recorded thus in the Ô¨Åle links.pl (Fig. 2.2) by link/2 . Notice that the order in which child nodes are generated by link/2 will govern the development of the trees in Figs. 2.4 and 2.5: children of the same node are written down from left to right in the order as they would be obtained by backtracking; for example, the node labelled d at level 1 in Fig. 2.4 is expanded by
?- link(d,Child).

50 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

s 0 . . . . . . . . . . . . . . . . . . . . . . .¬Ä¬Ä  ¬Ä¬Ä  ¬Ä¬Ä   ¬Ä¬Ä  ¬Ä a d 1. . . . . . . . . . . . . ¬ò & ¬ò &¬ò¬ò & & ¬ò¬ò ¬ò¬ò & & & & ¬ò ¬ò d a e 2. . . . . . . .b De ¬†t D e ¬† t D D e ¬† t f b e e b 3. . . c ¬°e ¬°t t e ¬° e ¬° t t  e ¬° e ¬° t t  e c a d c f b g e 4. . . . . . . f

5. . . . . .

g

g

c

f

6. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . g

Figure 2.5: The Pruned Search Tree

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩ for Engin

M

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction M supervisor ina cons I was the North Sea supe advising and the N he helping foremen advi s solve problems Real work he helping International Internationa al opportunities ÔøΩree wo work or placements s solve p
Click on the ad to read more

51 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

Child = e ; Child = s ; Child = a ; No

(The same may be deduced, of course, by inspection from links.pl, Fig. 2.2.) link/2 will serve as input to the implementations of the search algorithms to be discussed next.

2.3

Depth First Search

The most concise and easy to remember illustration of Depth First is by the conduit model (Fig. 2.6). We start with the search tree in Fig. 2.5 which is assumed to be a network of pipes with inlet at the root node s. The tree is rotated by 90‚ó¶ counterclockwise and connected to a valve which is initially closed. The valve is then opened and the system is observed as it gets Ô¨Çooded under the inÔ¨Çuence of gravity. The order in which the nodes are wetted corresponds to Depth First.

52 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

¬†¬ê¬ê ¬† ¬ê ¬ê ¬†

a

b

3¬ó¬ó ¬ó¬ó 33 3 ¬ó¬ó 3 ¬ó 33

d

7e 7 e 7 e

b f

e

v  v  v

¬°v ¬° v ¬° v

e

f

g

c a c g b f d f g c g

√ó s

a

E ¬†¬ê¬ê ¬† ¬ê ¬ê ¬†

:::

d

e

b

¬†v ¬† v ¬† v
53

e c

Figure 2.6: Depth First Search ‚Äì The Conduit Model

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

e  e  e

¬°e ¬° e ¬° e

Download free eBooks at bookboon.com

E

Click on the ad to read more

Applications of Prolog

Blind Search

:- use module(links). path(Node1,Node2,[Node1,Node2]) :- link(Node1,Node2). path(Node1,Node2,[Node1|Path32]) :- link(Node1,Node3), write(‚Äôvisiting node ‚Äô), write(Node3), nl, path(Node3,Node2,Path32). Figure 2.7: The File naive.pl

2.3.1

Na¬® ƒ±ve Solution

We may be tempted to use Prolog‚Äôs backtracking mechanism to furnish a solution by recursion; our attempt is shown in Fig. 2.7.4 However, it turns out that the implementation does not work due to cycling in the network. The query shown below illustrates the problems arising.

?- path(s,g,Path). visiting node a visiting node b visiting node c visiting node b visiting node c ... Action (h for help) ? abort % Execution Aborted

2.3.2

Incremental Development Using an Agenda

We implement Depth First search incrementally using a new approach. The idea is keeping track of the nodes to be visited by means of a list, the so called list of open nodes, also called the agenda. This book‚Äìkeeping measure will turn out to be amenable to generalization; in fact, it will be seen that the various search algorithms diÔ¨Äer only in the way the agenda is updated.

First Version A Ô¨Årst, preliminary, form of Depth First search is stated in Algorithm 2.3.1. The deÔ¨Ånition of the corresponding predicate, depth first/2 , is shown in Fig. 2.8. (At this stage, we are attempting an implementation which merely succeeds once the goal node is found.)
4 The

shaded entries facilitate explanatory screen displays only.

54 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

Algorithm 2.3.1: DepthFirst(StartN ode, GoalN ode) comment: First temptative implementation of Depth First Search RootN ode ‚Üê StartN ode OpenList ‚Üê [RootN ode] [H |T ] ‚Üê OpenList while‚éß H = GoalN ode SuccList ‚Üê successors of H ‚é™ ‚é™ ‚é™ ‚é™ + T ‚é®OpenList ‚Üê SuccList + do if OpenList = [] ‚é™ ‚é™ then return (f ailure) ‚é™ ‚é™ ‚é© [H |T ] ‚Üê OpenList return (success)

What is the crucial feature of this algorithm? It is the way the list of open nodes is manipulated. There are two possibilities:

55 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

:- use module(links). depth first(Start,Goal) :- dfs loop([Start],Goal). dfs loop([Goal| ],Goal). dfs loop([CurrNode|OtherNodes],Goal) :successors(CurrNode,SuccNodes), write(‚ÄôNode ‚Äô), write(CurrNode), write(‚Äô is being expanded. ‚Äô), append(SuccNodes,OtherNodes,NewOpenNodes), write(‚ÄôSuccessor nodes: ‚Äô), write(SuccNodes), nl, write(‚ÄôOpen nodes: ‚Äô), write(NewOpenNodes), nl, dfs loop(NewOpenNodes,Goal). successors(Node,SuccNodes) :findall(Successor,link(Node,Successor),SuccNodes). Figure 2.8: The File df1.pl ‚Ä¢ Inspection. We may inspect the agenda‚Äôs head to see whether it is the goal node. ‚Ä¢ Updating. If the head is not the goal node, we determine the head‚Äôs successor or successors. They are collected into a list, SuccList , say, (which may well be empty) and a new agenda will be formed by appending the tail of the old agenda to SuccList . The order of entries in the list just created is essential: the successors of the most recently visited node are placed to the front, thereby becomig candidates for more immediate attention. As mentioned earlier, search algorithms diÔ¨Äer from each other only in the way the list of open nodes is updated. The updating mechanism of Depth First is on a last‚Äìin‚ÄìÔ¨Årst‚Äìout (LIFO) basis. The (unsatisfactory) behaviour of depth first/2 in the present form is exempliÔ¨Åed in Fig. 2.9. Obviously, the order of the nodes‚Äô expansion is as expected but we descend into ever greater depths of (the leftmost part of) the tree in Fig. 2.4. There are two possible solutions to this problem ‚Äì they will be discussed below. Using a List of ‚ÄòClosed Nodes‚Äô The underlying idea of this approach is that a node on the search tree should not be included in the open list (again) if a node with the same label has ever been visited before. The examples below will show (and indeed a moment of reÔ¨Çection should conÔ¨Årm) that this method may not Ô¨Ånd all goal nodes (or all paths to the goal node(s)). The realization of the idea is as follows. Once we remove H from the list of open nodes (Algorithm 2.3.1) we should include H into another list, the list of closed nodes, indicating that it should not be expanded (i.e. included in the list of open nodes) ever again. This version of Depth First search is shown as Algorithm 2.3.2. The corresponding Prolog program, df2.pl, is shown in Fig. 2.10. Finally, an interactive session with this second version of depth first/2 is shown in Fig. 2.11. The missing (shaded) parts in Fig. 2.10 are goals for displaying information on the progress of the search as seen in Fig. 2.11. Exercise 2.1. Complete the code in Fig. 2.10 such that the response shown in Fig. 2.11 is achieved.

56 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9

?- depth first(s,g). Node s is being expanded. Successor nodes: [a, d] Open nodes: [a, d] Node a is being expanded. Successor nodes: [b, d, s] Open nodes: [b, d, s, d] Node b is being expanded. Successor nodes: [c, e, a] Open nodes: [c, e, a, d, s, d] ... Action (h for help) ? abort % Execution Aborted

6

8 Figure 2.9: Illustrative Query for depth first/2 ‚Äì First Version

7

Algorithm 2.3.2: DepthFirst(StartN ode, GoalN ode) comment: Depth First Search with a List of Closed Nodes RootN ode ‚Üê StartN ode OpenList ‚Üê [RootN ode] ClosedList ‚Üê [] [H |T ] ‚Üê OpenList while‚éß H = GoalN ode ‚é™SuccList ‚Üê successors of H ‚é™ ‚é™ ‚é™ + T ‚é™OpenList ‚Üê (SuccList ‚à© ClosedListc) + ‚é™ ‚é® ClosedList ‚Üê [H |ClosedList] do ‚é™if OpenList = [] ‚é™ ‚é™ ‚é™ ‚é™ then return (f ailure) ‚é™ ‚é© [H |T ] ‚Üê OpenList return (success)

(1) (2) (3)

57 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(links). % clause 0 depth first(Start,Goal) :- ... , dfs loop([Start],[],Goal). % dfs loop([Goal| ], ,Goal) :- ... . dfs loop([CurrNode|OtherNodes],ClosedList,Goal) :' successors(CurrNode,SuccNodes), ... , ‚é´ ‚é¨ findall(Node,(member(Node,SuccNodes), ' not(member(Node,ClosedList))),Nodes), ‚é≠ append(Nodes,OtherNodes,NewOpenNodes), ... , dfs loop(NewOpenNodes,[CurrNode|ClosedList],Goal). T successors(Node,SuccNodes) :findall(Successor,link(Node,Successor),SuccNodes). Figure 2.10: The File df2.pl % clause 1 %¬ß clause 2 ¬§ Implements (1) ¬¶ ¬• % ¬§ %¬ß Implements (2) ¬¶ ¬• % % % ¬ß ¬§ Implements (3) ¬¶ ¬•

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

58 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

9

?- depth first(s,g). Open: [s], Closed: [] Node s is being expanded. Successors: Open: [a, d], Closed: [s] Node a is being expanded. Successors: Open: [b, d, d], Closed: [a, s] Node b is being expanded. Successors: Open: [c, e, d, d], Closed: [b, a, s] Node c is being expanded. Successors: Open: [e, d, d], Closed: [c, b, a, s] Node e is being expanded. Successors: Open: [f, d, d, d], Closed: [e, c, b, Node f is being expanded. Successors: Open: [g, d, d, d], Closed: [f, e, c, Goal found: g Yes

6
[a, d] [b, d, s] [c, e, a] [b] [f, b, d] a, s] [g, e] b, a, s]

8 Figure 2.11: Illustrative Query for depth first/2 ‚Äì Second Version u u ¬Ñ ¬Ñ ¬Ñ ¬Ñ ¬Ñ ¬Ñ ¬Ñ ¬Ñu v

7

u w

Figure 2.12: The New Network Component Exercise 2.2. Suppose we want to model a network which arises by augmenting the graph in Fig. 2.1 with the one shown in Fig. 2.12, p. 59. (The new network thus comprises two unconnected components.) (a) Augment the database in Fig. 2.2 to reÔ¨Çect the connectivity of the new network. (b) Write down hand computations for the queries (i) ?- depth first(d,c). (ii) ?- depth first(u,c).

The predicate depth first/2 from df2.pl (Fig. 2.10) Ô¨Ånds a goal node (if there is one) but does not return the correspondig path. (We ignore the shaded clauses in Fig. 2.10 as they are there for explanatory reasons only.) A new, improved version, depth first(+Start,+Goal,-Path) , say, should return also the Path found,

59 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

given the Start node and the Goal node. We modify the auxiliary predicate dfs loop/3 from df2.pl in two ways. ‚Ä¢ Now, its Ô¨Årst argument will take the list of open paths (and not that of open nodes). This is the argument where we accumulate (maintain) the agenda. ‚Ä¢ Into an additional (fourth) argument will the path from Start to Goal be copied as soon as it appears at the head of the agenda. The search is then Ô¨Ånished. ‚Ä¢ The second and third arguments of dfs loop/4 will hold, as before, the list of closed nodes and the goal node, respectively. The hand computations in Fig. 2.13, p. 61, indicate the required behaviour of the new version of depth first/3 . Paths will be represented by the lists of nodes visited; internally, they will be read from right to left. For example, the list [g, f, e, b, a, s] will stand for the path s ‚Üí a ‚Üí b ‚Üí e ‚Üí f ‚Üí g . In Fig. 2.13, all paths we have been temporarily admitted to the agenda which arise by expanding the head of the head of the agenda. (Expanding a node means Ô¨Ånding its successors.) Immediately after expansion, however, those paths have been removed (indicated by /////) whose head features in the list of closed nodes in the line above. To implement the corresponding predicate depth first/3 (Fig.2.14, p. 63), Algorithm 2.3.3 has been used with an auxiliary procedure EXTENDPATH.

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

60 Download free eBooks at bookboon.com

22-08-2014 12:56:57

Click on the ad to read more

Applications of Prolog

Blind Search

depth Ô¨Årst(s, g, Path)

:; :; :; :; :;

dfs loop([[s]], [], g, Path)

dfs loop([[a,s], [d,s]], [s], g, Path)

dfs loop([[b,a,s], [d,a,s], /////, [s,a,s] [d,s]], [a,s], g, Path)

dfs loop([[c,b,a,s], [e,b,a,s], ///////, [a,b,a,s] [d,a,s], [d,s]], [b,a,s], g, Path) dfs loop([[b,c,b,a,s], //////// [e,b,a,s], [d,a,s], [d,s]], [c,b,a,s], g, Path)

:; :; :;

dfs loop([[f,e,b,a,s], [b,e,b,a,s], //////// [d,e,b,a,s], [d,a,s], [d,s]], [e,c,b,a,s], g, Path)

dfs loop([[g,f,e,b,a,s], [e,f,e,b,a,s], ///////// [d,e,b,a,s], [d,a,s], [d,s]], [f,e,c,b,a,s], g, Path) dfs loop([[g,f,e,b,a,s], [d,e,b,a,s], [d,a,s], [d,s]], [f,e,c,b,a,s], g, [g,f,e,b,a,s]) depth Ô¨Årst(s, g, [g,f,e,b,a,s])

:;

:; success

Figure 2.13: Hand Computations for the Query ?- depth first(s,g,Path). Exercise 2.3. DeÔ¨Åne extend path(+Nodes,+Path,-NewPaths) from Algorithm 2.3.3.

61 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

Algorithm 2.3.3: DepthFirst(StartN ode, GoalN ode) comment: Depth First with Closed Nodes and Open Paths procedure ExtendPath([x1 , ¬∑ ¬∑ ¬∑ , xN ], list) comment: To return [] if the Ô¨Årst argument is [] for i ‚Üê 1 to N do listi ‚Üê [xi |list] return ([list1 , ¬∑ ¬∑ ¬∑ , listN ]) main RootN ode ‚Üê StartN ode OpenP aths ‚Üê [[RootN ode]] ClosedN odes ‚Üê [] [[H |T ]|T ailOpenP aths] ‚Üê OpenP aths while‚éß H = GoalN ode SuccList ‚Üê successors of H ‚é™ ‚é™ ‚é™ ‚é™ N ewOpenN odes ‚Üê (SuccList ‚à© ClosedListc ) ‚é™ ‚é™ ‚é™ ‚é™ ‚é®N ewP aths ‚Üê ExtendPath(N ewOpenN odes, [H |T ]) + T ailOpenP aths do OpenP aths ‚Üê N ewP aths + ‚é™ ‚é™ if OpenP aths = [] ‚é™ ‚é™ ‚é™ ‚é™ ‚é™ then return (f ailure) ‚é™ ‚é© [[H |T ]|T ailOpenP aths] ‚Üê OpenP aths P ath ‚Üê Reverse([H |T ])5 output (P ath)

In the query shown below, the predicate depth fist/3 thus deÔ¨Åned Ô¨Ånds the leftmost path to the goal node in Fig. 2.4. On backtracking, no further paths to the goal node will be found.
?- depth first(s,g,Path). Path = [s, a, b, e, f, g] ; No

Path Checking This technique allows all paths to the goal node to be found. We do not use a list of closed nodes here. Instead, upon preÔ¨Åxing the head of the agenda by each of the successors of its head, we check for each of the lists thus created whether it is a path. In Algorithm 2.3.4, p. 64, this test is carried out by the as yet unspeciÔ¨Åed procedure ISPATH. Usually, paths will be required not to contain cycles. Then, the procedure ISPATH checks for distinct entries of the argument list.6 The main body of Algorithm 2.3.4 has been implemented by the predicate depth first/4 , deÔ¨Åned in df4.pl, Fig. 2.15, p. 65. A few noteworthy features of this implementation of Depth First are as follows.
5 For 6 By

a pseudocode of REVERSE, see [9, p. 24]. induction, this test simpliÔ¨Åes to showing that the head of a putative path is not an entry in its tail.

62 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(links). depth first(Start,Goal,PathFound) :dfs loop([[Start]],[],Goal,PathFoundRev), reverse(PathFoundRev,PathFound). dfs loop([[Goal|PathTail]| ], ,Goal,[Goal|PathTail]). dfs loop([[CurrNode|T]|Others],ClosedList,Goal,PathFound) :successors(CurrNode,SuccNodes), findall(Node,(member(Node,SuccNodes), not(member(Node,ClosedList))),Nodes), extend path(Nodes,[CurrNode|T],Paths), append(Paths,Others,NewOpenPaths), dfs loop(NewOpenPaths,[CurrNode|ClosedList],Goal,PathFound). successors(Node,SuccNodes) :findall(Successor,link(Node,Successor),SuccNodes). % auxiliary predicate extend path/3 ... ... Figure 2.14: The File df3.pl ‚Äì Depth First with Closed Nodes and Open Paths

This e-book is made with

SetaPDF

SETA SIGN

PDF components for PHP developers

www.setasign.com
63 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

‚Ä¢ The arguments of depth first(+Start,+G Pred,+C Pred,-PathFound) , the main predicate, play the following rÀÜ ole: ‚Äì As before, Start is uniÔ¨Åed with the start node. ‚Äì G Pred is uniÔ¨Åed with the name of the goal predicate. (In earlier implementations, a goal node was expected.) Due to this generalization, in more complex applications, now a goal node may be speciÔ¨Åed by a condition. Several goal nodes may thus also be accounted for. ‚Äì The third argument, C Pred , is uniÔ¨Åed with the name of the connectivity predicate which in earlier implementations was link/2 . Greater Ô¨Çexibility is aÔ¨Äorded by this additional argument. In the example query in Fig. 2.17, p. 66, the connectivity predicate link/2 is used which is deÔ¨Åned in links.pl (see p. 49) from where it is imported by the Ô¨Årst use module/1 directive in df4.pl. ‚Äì Finally, on return, the last argument is uniÔ¨Åed with the path found. Algorithm 2.3.4: DepthFirst(StartN ode, G P red, C P red) comment: Depth First with Path Checking. Procedures are assumed available for ‚Ä¢ Testing whether a path is a goal path by using the procedure in G P red; ‚Ä¢ Finding successors of a node by using the connectivity procedure in C P red. procedure IsPath(list) comment: Returns a Boolean value. Is application speciÔ¨Åc. . . . main RootN ode ‚Üê StartN ode OpenP aths ‚Üê [[RootN ode]] [[H |T ]|T ailOpenP aths] ‚Üê OpenP aths while‚éß [H |T ] is not a goal path SuccList ‚Üê successors of H ‚é™ ‚é™ ‚é™ ‚é™ ON odes ‚Üê list of S ‚àà SuccList with IsPath([S, H |T ]) ‚é™ ‚é™ ‚é™ ‚é™ ‚é®N ewP aths ‚Üê ExtendPath(ON odes, [H |T ]) + T ailOpenP aths do OpenP aths ‚Üê N ewP aths + ‚é™ ‚é™ if OpenP aths = [] ‚é™ ‚é™ ‚é™ ‚é™ then return (f ailure) ‚é™ ‚é™ ‚é© [[H |T ]|T ailOpenP aths] ‚Üê OpenP aths P ath ‚Üê Reverse([H |T ]) output (P ath)

64 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(links). :- use module(searchinfo). depth first(Start,G Pred,C Pred,PathFound) :dfs loop([[Start]],G Pred,C Pred,PathFoundRev), reverse(PathFoundRev,PathFound). dfs loop([Path| ],G Pred, ,Path) :- call(G Pred,Path). dfs loop([[CurrNode|T]|Others],G Pred,C Pred,PathFound) :successors(C Pred,CurrNode,SuccNodes), findall(Node,(member(Node,SuccNodes), is path([Node,CurrNode|T])),Nodes), extend path(Nodes,[CurrNode|T],Paths), append(Paths,Others,NewOpenPaths), dfs loop(NewOpenPaths,G Pred,C Pred,PathFound). % auxiliary predicates ... successors(C Pred,Node,SuccNodes) :findall(Successor,call(C Pred,Node,Successor),SuccNodes). extend path([], ,[]). extend path([Node|Nodes],Path,[[Node|Path]|Extended]) :extend path(Nodes,Path,Extended). Figure 2.15: The File df4.pl ‚Äì Depth First with Path Checking

:- module(info,[goal path/1, is path/1]). goal path([g| ]). is path([H|T]) :- not(member(H,T)). Figure 2.16: The File searchinfo.pl

65 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9

?- consult(df4). % links compiled into edges 0.05 sec, 1,900 bytes % searchinfo compiled into info 0.00 sec, 1,016 bytes % df4 compiled 0.05 sec, 4,944 bytes Yes ?- depth first(s,goal path,link,Path). Path = [s, a, b, e, f, g] ; Path = [s, a, d, e, f, g] ; Path = [s, d, e, f, g] ; Path = [s, d, a, b, e, f, g] ; No

6

8 Figure 2.17: Interactive Session for depth first/4 ‚Äì Path Checking

7

‚Ä¢ The while loop in Algorithm 2.3.4 is implemented by dfs loop/4 . It uses the predicate is path/1 , an implementation of the procedure ISPATH.

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

66 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

a u d

¬† u d

d ¬† d ¬† du s ¬† ¬† ¬†

b u ¬† ¬†

c u ug

u e

u f

Figure 2.18: A Network (see Exercise 2.4, p. 67) This predicate is imported from searchinfo.pl (Fig. 2.16, p. 65) by the second use module/1 directive in df4.pl. In the present version of is path/1 , paths are deÔ¨Åned to be lists with distinct entries. ‚Ä¢ call/2 and call/3 , are used (see p. 40) to invoke the imported predicates goal path/1 and link/2 at run time. ‚Ä¢ It is seen from Fig. 2.17 that on backtracking all paths to the goal node are found. Exercise 2.4. A new network is shown in Fig. 2.18, p. 67. (a) Augment the Ô¨Åle links.pl to reÔ¨Çect the connectivity of the new network. (b) Suppose we want to Ô¨Ånd all paths from s to g such that no edge is traversed more than once but we don‚Äôt mind visiting nodes several times. DeÔ¨Åne a new version of is path/1 in searchinfo.pl to this new speciÔ¨Åcation. (c) Run depth first/4 to Ô¨Ånd all paths from s to g .

Exercise 2.5. Rewrite the deÔ¨Ånition of depth first/4 in Fig. 2.15 using diÔ¨Äerence lists. Hints. You should represent paths, as before, by ordinary lists and write the agenda in terms of diÔ¨Äerence lists. Modify accordingly the predicates dfs loop and extend path . The latter should be invoked by a new version of depth first/4 , called depth first dl/4 . You should conÔ¨Årm the advantage of using diÔ¨Äerence lists by a sample session. (The model solution is found in the Ô¨Åle df.pl along with the old version based on ordinary lists.)

2.4

Breadth First Search

Another blind search algorithm is Breadth First. It visits the nodes of the search tree level by level from left to right as indicated in Fig. 2.19. It always Ô¨Ånds a shortest path to the goal node. Now the agenda is updated on a Ô¨Årst‚Äìin‚ÄìÔ¨Årst‚Äìout (FIFO) basis, thus the successors of a node just expanded will be put to the end of the list of open nodes. The deÔ¨Ånition of breadth first/4 in Fig. 2.20, p. 69, is arrived at by minor modiÔ¨Åcations of the code in Fig. 2.15:

67 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

s ¬Ä¬Ä¬Ä  ¬Ä¬Ä  ¬Ä¬Ä  ¬Ä¬Ä  Ea E d &¬ò¬ò &¬ò¬ò & & ¬ò ¬ò¬ò & & ¬ò¬ò & & ¬ò E b Ed E e E a D ¬†t D ee ¬† t D D Ec Ee E e E f¬† E t E b b e ¬°t ¬° t E ¬° Et d f E t t Et b E ¬°e ¬° e ¬° e c a e  e  e c e

f

g

g

g

c

f

g Figure 2.19: Breadth First ‚Ä¢ Rename the loop predicate to bfs loop , ‚Ä¢ Change the order of the Ô¨Årst two arguments in the append goal, ‚Ä¢ Leave the deÔ¨Ånition of the auxiliary predicates unchanged. The behaviour of breadth first/4 is shown in Fig. 2.21. The same paths are found as before, albeit in a diÔ¨Äerent order. Exercise 2.6. Rewrite the deÔ¨Ånition of breadth first/4 in Fig. 2.20 using diÔ¨Äerence lists. Compare the performance of your solution with that of the old version. Hints. You may take the model solution of Exercise 2.5, p. 175, or your own solution, and make the necessary changes: rename the loop predicate; modify the updating of the agenda (now represented as a diÔ¨Äerence list); and, use extend path dl/3 as deÔ¨Åned in the solution of Exercise 2.5. For later reference, the new version should be placed in the same Ô¨Åle as the earlier, list based version (i.e. bf.pl).

2.5

Bounded Depth First Search

Analysing Depth First and Breadth First will show that (e.g. [29]), on average, to Ô¨Ånd a goal node, ‚Ä¢ Depth First needs less computer memory than Breadth First, ‚Ä¢ The time requirement of Breadth First is asymptotically comparable to that of Depth First, and,

68 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(links). :- use module(searchinfo). breadth first(Start,G Pred,C Pred,PathFound) :bfs loop([[Start]],G Pred,C Pred,PathFoundRev), reverse(PathFoundRev,PathFound). bfs loop([Path| ],G Pred, ,Path) :- call(G Pred,Path). bfs loop([[CurrNode|T]|Others],G Pred,C Pred,PathFound) :successors(C Pred,CurrNode,SuccNodes), findall(Node,(member(Node,SuccNodes),   is path([Node,CurrNode|T])),Nodes), ModiÔ¨Åed Goal extend path(Nodes,[CurrNode|T],Paths), ' (see Fig. 2.15, append(Others,Paths,NewOpenPaths), p. 65) bfs loop(NewOpenPaths,G Pred,C Pred,PathFound).   % auxiliary predicates ... ... ' ¬§ ¬ß Copy from Fig. 2.15, p. 65 ¬¶ ¬•

Figure 2.20: The File bf.pl ‚Äì Breadth First with Path Checking

9

?- consult(bf). % links compiled into edges 0.00 sec, 1,900 bytes % searchinfo compiled into info 0.00 sec, 1,016 bytes % bf compiled 0.05 sec, 4,948 bytes Yes ?- breadth first(s,goal path,link,Path). Path = [s, d, e, f, g] ; Path = [s, a, b, e, f, g] ; Path = [s, a, d, e, f, g] ; Path = [s, d, a, b, e, f, g] ; No

6

8 Figure 2.21: Interactive Session for breadth first/4

7

69 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

‚Ä¢ Breadth First always Ô¨Ånds the shortest path to the goal node (if there is one) whereas (for inÔ¨Ånite search trees) Depth First may fail to Ô¨Ånd a goal node even if one exists.

Bounded Depth First search, shown in Algorithm 2.5.1, p. 71, combines the idea of the two search algorithms: it will explore the search tree up to a speciÔ¨Åed depth (the horizon ) by Depth First. Bounded Depth First is also the basis for the more sophisticated Iterative Deepening, to be discussed in the next section.

70 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

Algorithm 2.5.1: Bounded DF(StartN ode, G P red, C P red, Horizon) comment: Bounded Depth First Search. Procedures are assumed available for ‚Ä¢ Testing whether a path is a goal path by using the procedure in G P red; ‚Ä¢ Finding successors of a node by using the connectivity procedure in C P red. procedure IsPath(list) comment: Returns a Boolean value. Is application speciÔ¨Åc. . . . main RootN ode ‚Üê StartN ode OpenP aths ‚Üê [[RootN ode]] [[H |T ]|T ailOpenP aths] ‚Üê OpenP aths ListLength ‚Üê Length([H |T ]) P athLength ‚Üê ListLength ‚àí 1 while‚éß [H |T ] is not a goal path if P athLength < Horizon ‚é™ ‚éß ‚é™ ‚é™ ‚é™ SuccList ‚Üê successors of H ‚é™ ‚é™ ‚é™ ‚é™ ‚é® ‚é™ ‚é™ ON odes ‚Üê list of S ‚àà SuccList with ‚é™ ‚é™ then ‚é™ ‚é™ IsPath([S, H |T ]) ‚é™ ‚é™ ‚é™ ‚é™ ‚é© ‚é™ ‚é™ N ewP aths ‚Üê ExtendPath(ON odes, [H |T ]) ‚é™ ‚é™ ‚é® else N ewP aths ‚Üê [] do OpenP aths ‚Üê N ewP aths + + T ailOpenP aths ‚é™ ‚é™ ‚é™ ‚é™ if OpenP aths = [] ‚é™ ‚é™ ‚é™ ‚é™ then return (f ailure) ‚é™ ‚é™ ‚é™ ‚é™ [[ H |T ]|T ailOpenP aths] ‚Üê OpenP aths ‚é™ ‚é™ ‚é™ ‚é™ListLength ‚Üê Length([H |T ]) ‚é™ ‚é™ ‚é© P athLength ‚Üê ListLength ‚àí 1 P ath ‚Üê Reverse([H |T ]) output (P ath)

Exercise 2.7. In the query below, the predicate bounded df/5 is used to search the tree in Fig. 2.5 up to level 5 for the goal node g .
?- bounded df(s,goal path,link,5,PathFound). PathFound = [s, a, b, e, f, g] ; PathFound = [s, a, d, e, f, g] ; PathFound = [s, d, e, f, g] ;

71 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- module(bounded depth first,[bounded df/5]).7 :- use module(links). :- use module(searchinfo). bounded df(Start,G Pred,C Pred,Horizon,PathFound) :b dfs loop([[Start]],G Pred,C Pred,Horizon,PathFoundRev), reverse(PathFoundRev,PathFound).  ¬® Loop Predicate b dfs loop/5 ' ... to be deÔ¨Åned here  ¬© ¬ß ¬§ % auxiliary predicates ... ' Copy from Fig. 2.15, p. 65 ... ¬¶ ¬• Figure 2.22: The File bdf.pl ‚Äì Bounded Depth First (for Exercise 2.7)
No

Based on Algorithm 2.5.1, deÔ¨Åne bounded df/5 by completing the missing parts in Fig. 2.22. Hint. The deÔ¨Ånition of b dfs loop/5 may be obtained from that of dfs loop/4 in Fig. 2.15 by augmenting the latter with a new argument for the horizon.

2.6

Iterative Deepening

Bounded Depth First search is invoked here repeatedly with a successively larger horizon. This may be performed until a path to the goal node is found or until some CPU time limit is exceeded. We choose the former with unit increment. An implementation and a test run are shown in Figs. 2.23 and 2.24, respectively.8 Iterative Deepening may seem computationally wasteful as at any one stage the previous stage is recomputed but it can be shown that it is asymptotically optimal (eg [29]). Exercise 2.8. The interactive session in Fig. 2.24 illustrates that, on backtracking, Iterative Deepening will rediscover the goal paths found earlier. Modify our implementation of Iterative Deepening such that this does not happen, i.e. paths found earlier for a smaller horizon should be ignored. Hint. Fig. 2.25 shows a sample session with this modiÔ¨Åed version. The previous horizon is recorded in the database by means of the predicate lastdepth/1 . Goal paths shorter than the value herein are ignored. To implement this, you will have to modify the Ô¨Årst clause of b dfs loop/5 in bdf.pl. You will also have to arrange for the updating of lastdepth/1 in the database. Exercise 2.9. Yet another, and perhaps the most usual form of Iterative Deepening will Ô¨Ånd the (leftmost) goal node at the shallowest depth (presuming that one exists) and then stop searching. For our example, such a version will respond as follows,
?- iterative deepening(s,goal path,link,PathFound).
7 The 8 The

predicate bounded df/5 is declared public because it will be used later in another module (see Sect. 2.6). notes in Fig. 2.24 concerning the horizon refer to Fig 2.5, p. 51.

72 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(bdf). iterative deepening(Start,G Pred,C Pred,PathFound) :iterative deepening aux(1,Start,G Pred,C Pred,PathFound). iterative deepening aux(Depth,Start,G Pred,C Pred,PathFound) :bounded df(Start,G Pred,C Pred,Depth,PathFound). iterative deepening aux(Depth,Start,G Pred,C Pred,PathFound) :NewDepth is Depth + 1, iterative deepening aux(NewDepth,Start,G Pred,C Pred,PathFound).

Figure 2.23: The File iterd.pl ‚Äì Iterative Deepening

PathFound = [s, d, e, f, g] ; No

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

73 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

9

?- consult(iterd). % links compiled into edges 0.06 sec, 1,856 bytes % searchinfo compiled into info 0.00 sec, 1,016 bytes % bdf compiled into bounded depth first 0.06 sec, 5,784 bytes % iterd compiled 0.06 sec, 7,664 bytes Yes ?- iterative deepening(s,goal path,link,PathFound). Horizon = 4 PathFound = [s, d, e, f, g] ; ‚é´' ‚é¨ PathFound = [s, a, b, e, f, g] ; ' Horizon = 5 PathFound = [s, a, d, e, f, g] ; ‚é≠ PathFound = [s, d, e, f, g] ; ‚é´ ‚é™ PathFound = [s, a, b, e, f, g] ; ‚é™ ‚é¨ PathFound = [s, a, d, e, f, g] ; ' Horizon = 6 PathFound = [s, d, e, f, g] ; ‚é™ ‚é™ PathFound = [s, d, a, b, e, f, g] ; ‚é≠ PathFound = [s, a, b, e, f, g] ; ...

6

8 Figure 2.24: Sample Session ‚Äì Iterative Deepening Implement this version of Iterative Deepening.

7

Finally, notice that, for Ô¨Ånite search trees, Iterative Deepening has an unpleasant feature not found with the other blind search algorithms: if there is no goal node, Iterative Deepening won‚Äôt terminate.9 This will cause problems in applications where a sequence of potential start nodes is supplied to the algorithm some of which won‚Äôt lead to a goal node. (An example of this will be seen in Sect. 2.8).

2.7

The Module blindsearches

The implementations of the algorithms from the preceding sections have been put together in blindsearches.pl to form the module blindsearches . This allows us to create an implementation of the network search problem anew which then may serve as a template for other uses of blindsearches . The top level is netsearch.pl, Fig. 2.26, p. 75. The following shows an interactive session using search/0 from netsearch.pl.
?- consult(netsearch). % links compiled into edges 0.00 sec, 1,900 bytes % searchinfo compiled into info 0.00 sec, 1,016 bytes % blindsearches compiled into blindsearches 0.06 sec, 7,284 bytes % netsearch compiled 0.06 sec, 14,312 bytes ?- search. Enter start state (a/b/c/d/e/f/s)... s. Select algorithm (df/df dl/bf/bf dl/bdf/id)... bdf.
example, if we apply the query ?- iterative deepening(u,goal path,link,PathFound). with the database in links.pl (as augmented in Exercise 2.2, p. 59), we won‚Äôt get any response.
9 For

74 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9

?- iterative deepening(s,goal path,link,PathFound). PathFound = [s, d, e, f, g] ; PathFound = [s, a, b, e, f, g] ; PathFound = [s, a, d, e, f, g] ; ' PathFound = [s, d, a, b, e, f, g] ; ¬†¬£ ¬† ¬£ +¬¢C ¬° ¬¢Ctrl ¬° Action (h for help) ? abort % Execution Aborted ?- lastdepth(D). ' D = 396 Yes

6

No response after this

Last value of horizon 7

8

Figure 2.25: Sample Session ‚Äì ModiÔ¨Åed Iterative Deepening (for Exercise 2.8)

:- use module(links). :- use module(searchinfo). :- use module(blindsearches). search :G = goal path, get start state(S) , select algorithm(A) , (A = bdf, get horizon(Horizon) ; true), !, ((A = df, depth first(S,G,link,PathFound)); (A = df dl, depth first dl(S,G,link,PathFound)); (A = bf, breadth first(S,G,link,PathFound)); (A = bf dl, breadth first dl(S,G,link,PathFound)); (A = bdf, bounded df(S,G,link,Horizon,PathFound)); (A = id, iterative deepening(S,G,link,PathFound))), show nodes(PathFound) , terminate . % missing predicates (shaded) to be defined here ... ... Figure 2.26: The File netsearch.pl (for Exercise 2.10)

75 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

Enter horizon... 5. Nodes visited: s -> a -> b -> e -> f -> g Stop search? (y/n) n. Nodes visited: s -> a -> d -> e -> f -> g Stop search? (y/n) y. Yes

Exercise 2.10. DeÔ¨Åne the missing predicates (shaded) in Fig. 2.26. (You will have to use the built-in predicate read/1 for reading a term. Notice that the input from the keyboard always Ô¨Ånishes with a dot (. ) as shown above.)

2.8
2.8.1

Application: A Loop Puzzle
The Puzzle

This is a more substantial example showing that some problems can be formulated as a network search problem thereby making them amenable to a solution by the algorithms described earlier. The idea of the puzzle considered here originates from the puzzle magazine [17].

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

76 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

We are given a rectangular board some positions of which are marked by circles (0) and sharps (#) as shown in the upper half of Fig. 2.27, p. 78. The task is to place a closed loop of a rope onto the board such that the following conditions are met: ‚Ä¢ The rope connects contiguous positions horizontally or vertically but not diagonally. It does not selfintersect. ‚Ä¢ Each position is visited by the rope at most once. (This follows, of course, also from the fact that the rope is not self-intersecting.) In particular, there may well be positions which are not visited at all. ‚Ä¢ Each marked position is visited exactly once. ‚Ä¢ Adjacent marks on the rope of the like kind (i.e. both circles or both sharps) are connected by a straight piece of rope. ‚Ä¢ Adjacent marks on the rope which are diÔ¨Äerent (i.e. if one is a circle and the other is a sharp) are connected by a piece of rope which takes a right angle turn. A puzzle from [17] is solved in Fig. 2.27 by the model implementation. It is run interactively and carries out the following steps in turn: 1. It displays a sketch of the board and the arrangement of the marks (circles and sharps). 2. It gives the user a choice between the various search algorithms. 3. It tries to solve the problem and, if a solution exists, it gives a pictorial display of the loop‚Äôs position on the board.10 If no solution is found, loop/0 should fail. Furthermore, if there are several solutions, the implementation should Ô¨Ånd all of them.

2.8.2

A ‚ÄòHand-Knit‚Äô Solution

The core question is obviously how the present problem translates to a network search problem. (For the time being, we won‚Äôt be concerned with the generation of the interface and display of the loop found as they are relatively straightforward, though laborious.) As a Ô¨Årst step, we want to illustrate by way of the speciÔ¨Åc case from Sect. 2.8.1 how the problem can be solved by directly creating (i.e. deÔ¨Åning by facts) the predicates needed by the module blindsearches . The information concerning the speciÔ¨Åcs of the puzzle is deÔ¨Åned in the Ô¨Åle loop puzzle1.pl shown in Fig. 2.28. Before deÔ¨Åning the connectivity predicate which, as usual, will be called link/2 , we will have to Ô¨Ånd a suitable representation for the system‚Äôs states. The rope will be pieced together segment by segment, i.e. by progressing from one mark to the next. It seems therefore appropriate to identify the states of the system (i.e. the nodes of the corresponding network) with rope segments connecting marked positions. A list representation will be used for rope segments and progression in the list will be from right to left. Thus, for example, movement from a circle at position pos(1,4) to a sharp at position pos(2,2) is indicated by either of the following two segments. [pos(2,2),pos(2,3),pos(2,4)] (2.1)

10 A solution may be missed, however, if Bounded Depth First search is used. Furthermore, if Iterative Deepening is selected in our implememtation, it will not terminate if the internally attempted start state does not lead to a solution.

77 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9
?- consult(loop puzzle1). % blindsearches compiled into blindsearches 0.00 sec, 7,284 bytes % small_board compiled into small_board 0.00 sec, 6,224 bytes % board compiled into board 0.05 sec, 7,696 bytes % loops compiled into loops 0.11 sec, 31,028 bytes % loop_puzzle1 compiled 0.11 sec, 32,324 bytes Yes ?- loop. +---+---+---+---+---+---+ | | | | 0 | | # | 1 +---+---+---+---+---+---+ | # | # | | | | | 2 +---+---+---+---+---+---+ | | | | | 0 | | 3 +---+---+---+---+---+---+ | # | 0 | | | | | 4 +---+---+---+---+---+---+ | | | | | # | | 5 +---+---+---+---+---+---+ | | | | | | 0 | 6 +---+---+---+---+---+---+ 1 2 3 4 5 6 Select algorithm (df/df_dl/bf/bf_dl/bdf/id)... df. +-------+-------+-------+-------+-------+-------+ | | | | | | | | ************************0 | ********# | | * | | | * | * | * | +---*---+-------+-------+---*---+---*---+---*---+ | * | | | * | * | * | | # | #**************** | * | * | | * | * | | | * | * | +---*---+---*---+-------+-------+---*---+---*---+ | * | * | | | * | * | | * | ************************0 | * | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | # | 0******************************** | | * | * | | | | | +---*---+---*---+-------+-------+-------+-------+ | * | * | | | | | | * | ************************#******** | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | ****************************************0 | | | | | | | | +-------+-------+-------+-------+-------+-------+ Stop search? (y/n) y. Yes

6

8

7

Figure 2.27: Sample Session ‚Äì The Loop Puzzle

78 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

' :- use module(loops). ¬§ ¬ß c Number of rows size(6,6). ¬¶ ¬• T circle(pos(1,4)). circle(pos(3,5)). circle(pos(4,2)). circle(pos(6,6)).

¬ß ¬§ Top level module is in loops.pl ¬¶ ¬• ¬ß ¬§ Number of columns ¬¶ ¬•

sharp(pos(1,6)). sharp(pos(2,1)). sharp(pos(2,2)). sharp(pos(4,1)). sharp(pos(5,5)). Figure 2.28: The File loop puzzle1.pl and [pos(2,2),pos(1,2),pos(1,3)] (2.2) These segments are indicated by solid arrows in Fig. 2.29. Notice that the position at which the segment arrives, here pos(2,2), features as the head of its list representation whereas the board position from which the segment originates is omitted from the list.

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

79 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

+---+---+---+---+---+---+ | | | | 0 | | # | c +---+---+---+---+---+---+ T | # | # ' | | | | | +---+---+---+---+---+---+ | | | | | 0 | | +---+---+---+---+---+---+ | # | 0 | | | | | +---+---+---+---+---+---+ | | | | | # | | +---+---+---+---+---+---+ | | | | | | 0 | +---+---+---+---+---+---+ 1 2 3 4 5 6

1 2 3 4 5 6

Figure 2.29: Constructing a Solution of the Loop Puzzle (This will enable us simply to string together the Ô¨Ånal rope from its segments without being concerned with duplication of some positions.) The marked positions connected by a segment will be adjacent on the rope of which the segment is part of. We require therefore that the only marked position be the head of the segment‚Äôs list representation. Thus, for example, [pos(4,1),pos(3,1),pos(2,1),pos(1,1),pos(1,2),pos(1,3)] is not a segment as it meets the marked position pos(2,1) ‚Äòon its way‚Äô from pos(1,4) to pos(4,1). We now take the segment [pos(1,4),pos(2,4),pos(3,4),pos(4,4),pos(5,4)] (2.3) which is deemed to stretch from the sharp at pos(5,5) to the circle at pos(1,4). This is indicated by the dashed arrow in Fig. 2.29. (The other potential segment connecting the same positions as the one in (2.3) must be ruled out since it is blocked by the mark (circle) in pos(3,5).) To indicate that the segment in (2.2) is linked to that in (2.3), we declare in the database the following fact:
link([pos(1,4),pos(2,4),pos(3,4),pos(4,4),pos(5,4)], [pos(2,2),pos(1,2),pos(1,3)]).

Notice that the order of the arguments in link/2 matters: according to our interpretation, the segment in the Ô¨Årst argument is visited Ô¨Årst, followed by the segment in the second argument. The corresponding fact linking the segments in (2.3) and (2.1) does not hold if self-intersecting loops are excluded. Let us assume, however, that at this stage we do not care whether a rope is self-intersecting since this will be attended to later when we deÔ¨Åne the predicate is path/1 . Then, a more concise and more general form of the above fact is given by
link([pos(1,4)|_], [pos(2,2),pos(1,2),pos(1,3)]).

(This simply states that the segment [pos(2,2),pos(1,2),pos(1,3)] will join any segment pointing at pos(1,4).) There are three other segments also originating from the circle in pos(1,4); they give rise to the following fact each.
link([pos(1,4)|_], [pos(2,1),pos(1,1),pos(1,2),pos(1,3)]). link([pos(1,4)|_], [pos(2,2),pos(2,3),pos(2,4)]). link([pos(1,4)|_], [pos(5,5),pos(5,4),pos(4,4),pos(3,4),pos(2,4)]).

80 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- use module(blindsearches). ... ' ¬ß DeÔ¨Åne link/2 here (see Exercise 2.11, p. 81) ¬¶ ¬§ ¬• ¬® ¬© ¬® ¬© 

start state([pos(2,1),pos(1,1),pos(1,2),pos(1,3)]).  The goal path ' goal path([H|T]) :- length([H|T],9), has 9 segments  last(E,T), '  link(H,E). The goal path is closed ‚é´   is path([H|T]) :- not(prohibit([H|T])). ‚é™ ‚é™ Exclude self‚é¨ ' intersecting prohibit([S|[H| ]]) :- not(disjoint(S,H)). ‚é™ ‚é™ paths ‚é≠  prohibit([S|[ |T]]) :- prohibit([S|T]). disjoint([], ). disjoint([H|T],S) :- not(member(H,S)), disjoint(T,S). Figure 2.30: The File hand knit.pl



In a similar fashion, the segments originating from the circle in pos(3,5) give rise to the facts
link([pos(3,5)|_], link([pos(3,5)|_], link([pos(3,5)|_], link([pos(3,5)|_], link([pos(3,5)|_], link([pos(3,5)|_], [pos(1,6),pos(2,6),pos(3,6)]). [pos(1,6),pos(1,5),pos(2,5)]). [pos(2,1),pos(3,1),pos(3,2),pos(3,3),pos(3,4)]). [pos(2,2),pos(3,2),pos(3,3),pos(3,4)]). [pos(2,2),pos(2,3),pos(2,4),pos(2,5)]). [pos(4,1),pos(3,1),pos(3,2),pos(3,3),pos(3,4)]).

Exercise 2.11. Complete the deÔ¨Ånition of link/2 in this fashion. There will be 37 facts in total forming 9 groups, each group corresponding to a marked position. (You will Ô¨Ånd the solution of this exercise in the Ô¨Åle hand knit.pl.) The deÔ¨Ånition of link/2 and those of some other predicates11 are in the Ô¨Åle hand knit.pl, partially shown in Fig. 2.30. It is also seen from hand knit.pl that one of the segments has been chosen as a start state by visual inspection of Fig. 2.29.12 We are now in a position to Ô¨Ånd a solution interactively. After consulting hand knit.pl, we invoke depth first/4 as follows.
?- start write [[pos(2, [pos(4, [pos(6, [pos(5,
12 11 Notice

state( S), depth first( S,goal path,link, PathFound), term( PathFound,[]). 1), pos(1, 1), pos(1, 2), pos(1, 3)], 1), pos(3, 1)], 6), pos(6, 5), pos(6, 4), pos(6, 3), pos(6, 2), pos(6, 1), pos(5, 1)], 5), pos(5, 6)],

that the predicate is path/1 in hand knit.pl is ‚Äòvisible‚Äô from the module blindsearches without it being exported. A reasoned way to get hold of a start state is as follows. Pick any marked position and try out all segments originating from it. If there is a solution to the problem, then at least one of the segments thus produced may serve as a start state since the rope must pass through this position in particular.

81 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

[pos(4, [pos(1, [pos(3, [pos(2, [pos(1,

2), 6), 5), 2), 4),

pos(5, pos(2, pos(2, pos(3, pos(2,

2), 6), 5), 2), 4),

pos(5, pos(3, pos(1, pos(3, pos(2,

3), pos(5, 4)], 6), pos(4, 6), pos(4, 5), pos(4, 4), pos(4, 3)], 5)], 3), pos(3, 4)], 3)]]

A list comprising 9 path segments has been returned. It is to be read from left to right but the list representations of the segments are read from right to left. It is perhaps easier to interpret the result if we subsequently reverse this list and then Ô¨Çatten it. The list thus produced will be a right-to-left display of the positions visited.
?- start state( S), depth first( S,goal path,link, PathFound), reverse( PathFound, R), flatten( R, F), write_term( F,[]). [pos(1, 4), pos(2, 4), pos(2, 3), pos(2, 2), pos(3, 2), pos(3, pos(3, 4), pos(3, 5), pos(2, 5), pos(1, 5), pos(1, 6), pos(2, pos(3, 6), pos(4, 6), pos(4, 5), pos(4, 4), pos(4, 3), pos(4, pos(5, 2), pos(5, 3), pos(5, 4), pos(5, 5), pos(5, 6), pos(6, pos(6, 5), pos(6, 4), pos(6, 3), pos(6, 2), pos(6, 1), pos(5, pos(4, 1), pos(3, 1), pos(2, 1), pos(1, 1), pos(1, 2), pos(1,

3), 6), 2), 6), 1), 3)]

82 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

:- use module(blindsearches). :- use module(automated). size(6,6). circle(pos(1,4)). circle(pos(3,5)). circle(pos(4,2)). circle(pos(6,6)). sharp(pos(1,6)). sharp(pos(2,1)). sharp(pos(2,2)). sharp(pos(4,1)). sharp(pos(5,5)). Figure 2.31: The File loop puzzle1a.pl The path thus obtained is seen to be the one shown in Fig. 2.27.13

2.8.3

Project: Automating the Solution Process

In the ‚Äòhand-knit‚Äô solution from the previous section, the information speciÔ¨Åc to the puzzle was conveyed to Prolog via the predicate link/2 , deÔ¨Åned in hand knit.pl by Prolog facts which were arrived at laboriously by visual inspection of loop puzzle1.pl. This arrangement, though unsatisfactory, has been useful in showing that this type of puzzle can be solved as a network search problem. We are aiming for a more Ô¨Çexible and automated implementation, however, which will solve any problem of this type by combining the problemspeciÔ¨Åc information from a Ô¨Åle like loop puzzle1.pl with a rule-based and not problem-dependent deÔ¨Ånition of link/2 .14 You will be asked to Ô¨Ånd a rule-based deÔ¨Ånition of link/2 in Exercise 2.12 below. The suggested Ô¨Åle structure is as follows. The information concerning this particular puzzle should be recorded in the Ô¨Åle loop puzzle1a.pl15 as shown in Fig 2.31, p. 83. All the other predicates pertinent to this type of puzzle should be deÔ¨Åned in the Ô¨Åle automated.pl as outlined in Fig. 2.32, p. 84. Exercise 2.12. To get a semi-automated solution16 of the loop puzzle as indicated by the interactive session in Fig. 2.35, p. 88, augment the Ô¨Åle hand knit.pl by deÔ¨Åning link/2 by rules. The augmented Ô¨Åle will be the Ô¨Årst version of automated.pl. Below you will Ô¨Ånd some guidance on the implementation of link/2 .

Implementing link/2 At variance with the fact-based version of link/2 , now linking intersecting segments will be disallowed. Thus, for example, whereas
13 To obtain a loop, the positions pos(1,4) and pos(1,3) have been joined since they are the two extreme entries (Ô¨Årst and last) of the path found. 14 Another approach more in tune with Sect. 2.8.2 will Ô¨Årst create in the database at runtime the problem-speciÔ¨Åc facts deÔ¨Åning link/2 . (Alternatively, a problem-speciÔ¨Åc (temporary) Ô¨Åle akin to hand knit.pl may be created and consulted at runtime.) This should be accomplished by a second order predicate reading the deÔ¨Ånitions of size/2 , circle/1 and sharp/1 from loop puzzle1.pl (or its analogue). Subsequently, run the search as in Sect. 2.8.2. 15 The suÔ¨Éx ‚Äòa‚Äô in the Ô¨Ålename indicates that the solution process is automated. 16 The initial segment is supplied via start state/1 by manual input. A fully automated solution is considered in Exercise 2.13.

83 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

:- module(auto,[link/2,maybe start state/1,goal path/1,is path/1]). ¬§ ¬ß T For Exercise 2.13 only ¬¶ ¬• ¬§ ¬ß ' DeÔ¨Åne link/2 here (see Exercise 2.12) ... ¬¶ ¬• ¬®  ' DeÔ¨Åne maybe start state/1 here (see ... Exercise 2.13)  ¬© ‚é´   ‚é™ goal path([H|T]) :- number of marks(M), ‚é™ ModiÔ¨Åed deÔ¨Ånition ‚é¨ length([H|T],M), ' of goal path/1 ‚é™ last(E,T), ‚é™ (see Exercise 2.13) ‚é≠   link(H,E). ¬ß ¬§ ' DeÔ¨Åne number of marks/1 here (see Exercise 2.13) ... ¬¶ ¬• ‚é´ ‚é™ ‚é™ ‚é™ is path([H|T]) :- not(prohibit([H|T])). ‚é™ ‚é™ ‚é™ ‚é™   ‚é™ ‚é™ Copy from ‚é¨ prohibit([S|[H| ]]) :- not(disjoint(S,H)). ‚é™ ' hand knit.pl prohibit([S|[ |T]]) :- prohibit([S|T]). ‚é™ ‚é™ (see Fig. 2.30) ‚é™ ‚é™   ‚é™ ‚é™ ‚é™ disjoint([], ). ‚é™ ‚é™ ‚é™ ‚é≠ disjoint([H|T],S) :- not(member(H,S)), disjoint(T,S). Figure 2.32: The File automated.pl

84 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

link([pos(5,5),pos(4,5),pos(4,4),pos(4,3)], [pos(1,4),pos(2,4),pos(3,4),pos(4,4),pos(5,4)]).

follows from the deÔ¨Ånition of link/2 in hand knit.pl, it cannot be inferred by our rule-based version of link/2 in automated.pl: ?- link([pos(5,5),pos(4,5),pos(4,4),pos(4,3)],S). S = [pos(4, 2), pos(5, 2), pos(5, 3), pos(5, 4)] ; S = [pos(6, 6), pos(5, 6)] ; S = [pos(6, 6), pos(6, 5)] ; No Does it matter if this additional condition is imposed? No, the Ô¨Ånal result won‚Äôt be aÔ¨Äected as paths containing self-intersecting linked segments are themselves self-intersecting and will therefore be disallowed by is path/1 . However, whereas link/2 was previously deÔ¨Åned by a relatively small number of facts, the resulting network is more complex. It will be seen that the imposed condition is easily incorporated in the deÔ¨Ånition of link/2 and, as indicated above, it should give rise to a simpler network, i.e. to a one with a lesser number of connections. (You will be asked to compare the two networks as part of Exercise 2.14, p. 87.) The dashed arrows in Fig. 2.33 stand for segments connected to [pos(5,5),pos(4,5),pos(4,4),pos(4,3)] which itself is shown as a continuous arrow. We require furthermore that

85 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

+---+---+---+---+---+---+ | | | | 0 | | # | +---+---+---+---+---+---+ | # | # | | | | | +---+---+---+---+---+---+ | | | | | 0 | | +---+---+---+---+---+---+ | # | 0 | | | | | c +---+---+---+---+---+---+ | | T | | | # | | c +---+---+---+---+---+---+ | | | | | E | 0 | +---+---+---+---+---+---+ 1 2 3 4 5 6

1 2 3 4 5 6

Figure 2.33: Constructing a Loop ‚Ä¢ link/2 should fail if the Ô¨Årst argument is not uniÔ¨Åed with a valid segment:
?- link([pos(5,3),pos(6,3),pos(6,4),pos(6,5)], S). No

‚Ä¢ link/2 should also fail if the arguments are uniÔ¨Åed with valid segments, that, however, are not linked:
?- link([pos(6,6),pos(5,6)], [pos(6,6),pos(6,5)]). No

‚Ä¢ link/2 should succeed if the arguments are uniÔ¨Åed with linked segments:
?- link([pos(2,1),pos(3,1)], [pos(2,2)]). Yes

We now want to indicate how link/2 should be deÔ¨Åned. Let us assume that two marked positions of the like kind should be linked. This will be accomplished by the clause
link([Pos1|T1],[Pos2|T2]) :- ((circle(Pos1), circle(Pos2)); (sharp(Pos1), sharp(Pos2))), straight(Pos1,[Pos2|T2],Pos2), not((member(Pos,T2),(circle(Pos);sharp(Pos)))), disjoint([Pos1|T1],[Pos2|T2]).

where the auxiliary predicate straight(+P1,?S,+P2) connects any two positions P1 and P2 sharing the same row or column; details of what is required may be gleaned from the query below.
?- auto:straight(pos(3,4),S,pos(3,8)). S = [pos(3, 8), pos(3, 7), pos(3, 6), pos(3, 5)] ?- auto:straight(pos(8,3),S,pos(4,3)). S = [pos(4, 3), pos(5, 3), pos(6, 3), pos(7, 3)]

(We use the preÔ¨Åx auto in the above query as straight/3 is not visible from outside the module auto .) You are recommended to use the built-in predicates bagof/3 , between/3 and reverse/2 in your deÔ¨Ånition of straight/3 . The corresponding clause of link/2 for linking marked positions of an unlike kind uses the auxiliary predicate turn(+P1,?R,+P2) where the positions P1 and P2 (not sharing the same row or column) are linked by the list R taking a right angle turn; for example,

86 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

1

?- consult(loop puzzle1a). ... ?- maybe start state( S), depth first( S,goal path,link, PathFound), reverse( PathFound, R), flatten( R, F), write term( F,[]). [pos(1, 4), ..., pos(1, 3)] Yes 0 )

(

Figure 2.34: Running the Automated Implementation of the Loop Puzzle
?- auto:turn(pos(6,4),R,pos(4,1)). R = [pos(4, 1), pos(5, 1), pos(6, 1), pos(6, 2), pos(6, 3)] ?- auto:turn(pos(8,3),R,pos(4,2)). 17 R = [pos(4, 2), pos(5, 2), pos(6, 2), pos(7, 2), pos(8, 2)]

To deÔ¨Åne turn/3 , use straight/3 and append/3 . Fully Automated Implementation Exercise 2.13. To get an automated solution of the loop puzzle as indicated by the interactive session in Fig. 2.34, now augment the Ô¨Åle automated.pl as follows. ‚Ä¢ DeÔ¨Åne the predicate maybe start state/1 , and make it a visible predicate by augmenting the module directive as indicated in Fig. 2.32. It should return on backtracking all segments emanating from an arbitrary but Ô¨Åxed marked position. As explained in footnote 12, p. 81, one of the segments returned by maybe start state/1 will form part of the loop we are looking for. ‚Ä¢ DeÔ¨Åne the predicate number of marks/1 and modify the deÔ¨Ånition of goal path/1 as indicated in Fig. 2.32.

Exercise 2.14. (This exercise explores the idea mentioned in footnote 14, p. 83.) The ‚Äòhand-knit‚Äô solution outlined in Sect. 2.8.2 involved a manual implementation of link/2 by deÔ¨Åning it by Prolog facts. These facts were, of course, speciÔ¨Åc to the puzzle to be solved. Having now deÔ¨Åned link/2 by rules not referring to the particulars of the puzzle at hand, we have been able to automate the solution process. An alternative closer to the original idea would be automatically to deÔ¨Åne in the database link/2 by the facts applicable to the particular problem. Use link/2 to deÔ¨Åne by facts an equivalent new link predicate and use it to solve the loop puzzle. Determine the number of nodes and the number of directed edges of the corresponding network. Determine these quantities also for the network associated with the ‚Äòhand-knit‚Äô solution (Sect. 2.8.2) to conÔ¨Årm that the latter is indeed more complex.

17 The

L-shaped segment degenerates here into a straight line since it connects positions in adjacent columns.

87 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9

?- consult(loop puzzle1a). % blindsearches compiled into blindsearches 0.05 sec, 7,380 bytes % automated compiled into auto 0.00 sec, 5,752 bytes % loop puzzle1a compiled 0.05 sec, 14,576 bytes Yes ‚é´ ‚é¨ ?- consult(user). Manual deÔ¨Ånition ' |: start state([pos(2,1),pos(1,1),pos(1,2),pos(1,3)]). ¬£ ¬†¬£ ¬† of start state/1 ‚é≠ +¬¢D ¬° |: ¬¢Ctrl ¬° % user compiled 34.11 sec, 388 bytes Yes ?- start state( S), depth first( S,goal path,link, PathFound), reverse( PathFound, R), write term( F,[]). [pos(1, 4), pos(2, 4), pos(2, 3), pos(2, 2), pos(3, 2), pos(3, 3), pos(3, 4), pos(3, pos(1, 6), pos(2, 6), pos(3, 6), pos(4, 6), pos(4, 5), pos(4, 4), pos(4, 3), pos(4, pos(5, 4), pos(5, 5), pos(5, 6), pos(6, 6), pos(6, 5), pos(6, 4), pos(6, 3), pos(6, pos(4, 1), pos(3, 1), pos(2, 1), pos(1, 1), pos(1, 2), pos(1, 3)] Yes

6

flatten( R, F), 5), pos(2, 5), pos(1, 5), 2), pos(5, 2), pos(5, 3), 2), pos(6, 1), pos(5, 1),

8 Figure 2.35: Semi-Automated Solution of the Loop Puzzle

7

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

88 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

9
?- consult([loop puzzle1a, small board]). | {z }

6

T ... % loop_puzzle1a compiled 0.05 sec, 15,076 bytes % small_board compiled into small_board 0.06 sec, 6,216 bytes Yes ?- size( Row, Col), bagof( C,circle( C), Cs), ' bagof( S,sharp( S), Ss), make small board( Row, Col, Cs, Ss, Board), disp board( Board). +---+---+---+---+---+---+ | | | | 0 | | # | 1 size/2 , circle/1 and sharp/1 to +---+---+---+---+---+---+ be taken from loop puzzle1a.pl | # | # | | | | | 2 (see Fig. 2.31, p. 83) +---+---+---+---+---+---+ | | | | | 0 | | 3 +---+---+---+---+---+---+ | # | 0 | | | | | 4 +---+---+---+---+---+---+ | | | | | # | | 5 +---+---+---+---+---+---+ | | | | | | 0 | 6 +---+---+---+---+---+---+ 1 2 3 4 5 6 8 Figure 2.36: Session for Displaying the Board
Yes

7

2.8.4

Project: Displaying the Board

Exercise 2.15. To display the marks‚Äô position on the board, deÔ¨Åne ‚Ä¢ make small board(+Row,+Col,+Circles,+Sharps,-Board) for unifying Board with the list of lines to be displayed where each line itself is represented as a list of one-character atoms; and, ‚Ä¢ disp board(+Board) for displaying Board on the terminal. Fig. 2.36 shows how these predicates should behave. (The model solution is in small board.pl.) Exercise 2.16. To display a path on the board, deÔ¨Åne ‚Ä¢ make board(+Row,+Col,+Path,-Board) for creating a list-of-lists representation of Board , and, ‚Ä¢ show board(+Board) for displaying Board on the terminal. Path is uniÔ¨Åed with a list of contiguous co-ordinate entries of the form pos(. . .,. . .) . Fig. 2.37 illustrates the point for a 2 √ó 5 board. (The model solution is in board.pl.)

89 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9
?- consult(board). % board compiled into board 0.00 sec, 8,216 bytes ?- make board(2,5,[pos(1,1),pos(1,2),pos(2,2),pos(2,3),pos(2,4),pos(1,4),pos(1,5)], Board), show board( Board). +-------+-------+-------+-------+-------+ | | | | | | | ********* | | ********* | | | * | | * | | +-------+---*---+-------+---*---+-------+ | | * | | * | | | | ***************** | | | | | | | | +-------+-------+-------+-------+-------+

6

8 Figure 2.37: Illustrating Exercise 2.16

Yes

7

.

90 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

9
?- make board(2,5,[pos(1,1),pos(1,2),pos(2,2),pos(2,3),pos(2,4),pos(1,4),pos(1,5)], Board), change board(‚Äôc‚Äô,[pos(1,2),pos(1,4),pos(2,2),pos(2,4)], Board, NewBoard), show board( NewBoard). +-------+-------+-------+-------+-------+ | | | | | | | ********c | | c******** | | | * | | * | | +-------+---*---+-------+---*---+-------+ | | * | | * | | | | c***************c | | | | | | | | +-------+-------+-------+-------+-------+ Yes 8

6

7 Figure 2.38: Illustrating Exercise 2.17

Exercise 2.17. Finally, for putting circles and sharps on the board, a predicate for writing a given character to speciÔ¨Åed positions on the board will be useful. This will be accomplished by change board/4 as illustrated in Fig. 2.38. (In the example we mark corner positions of the path with the character ‚Äòc‚Äô.) DeÔ¨Åne change board/4 . (The model solution is in board.pl.)

2.8.5

Complete Implementation

All the building blocks for solving the puzzle and displaying the loop found are now in place. In fact, this can be done interactively as shown in Fig. 2.39. Exercise 2.18. It is very tedious to solve the loop puzzle interactively as shown in Fig. 2.39. Combine now the predicates from above to create a more user-friendly implementation which can be run as shown in Fig. 2.27, p. 78. You may model your implementation of the dialogue on that in netsearch.pl (see Fig. 2.26, p. 75). (For the model solution, see loops.pl.)

2.8.6

Full Board Coverage

Exercise 2.19. Suppose now that the speciÔ¨Åcation is made somewhat stricter. In addition to the initial requirements we now also want every small square to be visited by the loop. You should modify your implementation to include this new feature. Notes. 1. Whereas the earlier puzzle has a unique solution which happens to visit every position (even if we don‚Äôt insist on this), the case shown in Fig. 2.40 (with the data in loop puzzle2.pl) is more complex and will admit solutions of both kinds (Figs. 2.41 and 2.42). Use loop puzzle2.pl for testing your solution.

91 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9
?- consult([loop puzzle1a, board]). % blindsearches compiled into blindsearches 0.05 sec, 7,380 bytes % automated compiled into auto 0.00 sec, 6,252 bytes % loop_puzzle1a compiled 0.05 sec, 15,076 bytes % board compiled into board 0.06 sec, 8,168 bytes ?- maybe start state( Start), depth first( Start,goal path,link, PathFound), reverse( PathFound, Rev), flatten( Rev, F), last( L, F), size( Row, Col), make board( Row, Col,[ L| F], B0), bagof( C,circle( C), Cs), change board(‚Äô0‚Äô, Cs, B0, B1), bagof( S,sharp( S), Ss), change board(‚Äô#‚Äô, Ss, B1, B2), show board( B2). +-------+-------+-------+-------+-------+-------+ | | | | | | | | ************************0 | ********# | | * | | | * | * | * | +---*---+-------+-------+---*---+---*---+---*---+ | * | | | * | * | * | | # | #**************** | * | * | | * | * | | | * | * | +---*---+---*---+-------+-------+---*---+---*---+ | * | * | | | * | * | | * | ************************0 | * | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | # | 0******************************** | | * | * | | | | | +---*---+---*---+-------+-------+-------+-------+ | * | * | | | | | | * | ************************#******** | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | ****************************************0 | | | | | | | | +-------+-------+-------+-------+-------+-------+

6

8 Figure 2.39: Solving the Puzzle Interactively. (See Exercise 2.18.)

Yes

7

92 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

+---+---+---+---+---+---+---+---+ | # | | | | | # | | # | +---+---+---+---+---+---+---+---+ | | | | | | | 0 | | +---+---+---+---+---+---+---+---+ | | | | | | # | | # | +---+---+---+---+---+---+---+---+ | | 0 | | | | | | | +---+---+---+---+---+---+---+---+ | | | 0 | | | | 0 | | +---+---+---+---+---+---+---+---+ | | | | # | # | | | | +---+---+---+---+---+---+---+---+ | | | | | | # | | | +---+---+---+---+---+---+---+---+ | | 0 | | | | | 0 | | +---+---+---+---+---+---+---+---+ | 0 | | | | | | | | +---+---+---+---+---+---+---+---+ 1 2 3 4 5 6 7 8 Figure 2.40: Illustrating Exercise 2.19

1 2 3 4 5 6 7 8 9

2. You may Ô¨Ånd that due to stack overÔ¨Çow your Prolog implementation won‚Äôt be able to solve this more complex puzzle by Breadth First because the agenda will become very large (Sect. 2.5).

2.8.7

Avoiding Multiple Solutions

This may be another desired feature of the implementation: Every loop satisfying the speciÔ¨Åcations should be displayed only once. There are two ways a solution may be discovered more than once. 1. As loops can be traversed in two directions, both versions will be found even though the display won‚Äôt allow us to distinguish between them. To illustrate the point, let us consider the loop shown in Fig. 2.42. We take pos(2,7) to be the seed position. Then the loop can be built up by starting with the segment [pos(5,7), pos(4,7), pos(3,7)] bearing in mind that segments are read from right to left. Alternatively, [pos(1,1), pos(2,1), pos(2,2), pos(2,3), pos(2,4), pos(2,5), pos(2,6)] may also be taken as the starting segment emanating from the same seed. It starts the loop in the opposite direction. We won‚Äôt be concerned here with duplication due to this cause; we simply accept that as far as this cause is concerned each solution of the puzzle will be displayed exactly twice. 2. The second cause for Ô¨Ånding multiple instances of the same loop is elusive and it won‚Äôt arise with every test case. The case shown in Fig. 2.42 is, however, one of those where this will occur. One of the segments emanating from the seed position pos(2,7) is [pos(1,6), pos(1,7)], pointing to the sharp in pos(1,6). The same segment can also be thought of, however, as emanating from the sharp in pos(1,8). This is

93 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

+-------+-------+-------+-------+-------+-------+-------+-------+ | | | | | | | | | | #***************************************#***************# | | * | | | | | | | * | +---*---+-------+-------+-------+-------+-------+-------+---*---+ | * | | | | | | | * | | ************************************************0 | * | | | | | | | | * | * | +-------+-------+-------+-------+-------+-------+---*---+---*---+ | | | | | | | * | * | | ****************************************# | * | # | | * | | | | | * | * | * | +---*---+-------+-------+-------+-------+---*---+---*---+---*---+ | * | | | | | * | * | * | | * | 0******************************** | * | * | | * | * | | | | | * | * | +---*---+---*---+-------+-------+-------+-------+---*---+---*---+ | * | * | | | | | * | * | | * | * | 0*******************************0 | * | | * | * | * | | | | | * | +---*---+---*---+---*---+-------+-------+-------+-------+---*---+ | * | * | * | | | | | * | | * | * | ********#*******# | | | * | | * | * | | | * | | | * | +---*---+---*---+-------+-------+---*---+-------+-------+---*---+ | * | * | | | * | | | * | | * | * | | | * | #******** | * | | * | * | | | * | * | * | * | +---*---+---*---+-------+-------+---*---+---*---+---*---+---*---+ | * | * | | | * | * | * | * | | * | 0************************ | * | 0******** | | * | | | | | * | | | +---*---+-------+-------+-------+-------+---*---+-------+-------+ | * | | | | | * | | | | 0**************************************** | | | | | | | | | | | | +-------+-------+-------+-------+-------+-------+-------+-------+

Figure 2.41: Some positions not visited
+-------+-------+-------+-------+-------+-------+-------+-------+ | | | | | | | | | | #***************************************#***************# | | * | | | | | | | * | +---*---+-------+-------+-------+-------+-------+-------+---*---+ | * | | | | | | | * | | ************************************************0 | * | | | | | | | | * | * | +-------+-------+-------+-------+-------+-------+---*---+---*---+ | | | | | | | * | * | | ****************************************# | * | # | | * | | | | | * | * | * | +---*---+-------+-------+-------+-------+---*---+---*---+---*---+ | * | | | | | * | * | * | | * | 0************************ | * | * | * | | * | * | | | * | * | * | * | +---*---+---*---+-------+-------+---*---+---*---+---*---+---*---+ | * | * | | | * | * | * | * | | * | * | 0******** | * | * | 0 | * | | * | * | * | * | * | * | * | * | +---*---+---*---+---*---+---*---+---*---+---*---+---*---+---*---+ | * | * | * | * | * | * | * | * | | * | * | * | #*******# | * | * | * | | * | * | * | | | * | * | * | +---*---+---*---+---*---+-------+-------+---*---+---*---+---*---+ | * | * | * | | | * | * | * | | * | * | ************************# | * | * | | * | * | | | | | * | * | +---*---+---*---+-------+-------+-------+-------+---*---+---*---+ | * | * | | | | | * | * | | * | 0***************************************0 | * | | * | | | | | | | * | +---*---+-------+-------+-------+-------+-------+-------+---*---+ | * | | | | | | | * | | 0******************************************************** | | | | | | | | | | +-------+-------+-------+-------+-------+-------+-------+-------+

Figure 2.42: All positions visited

94 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

yet another starting segment giving rise to the same loop. For this version of the loop, the last segment will be [pos(1,8), pos(2,8)], pointing at the position where the loop was mistakenly deemed to have started from. Situations such as this will be avoided if we stipulate that the head of the last segment be identical to the seed position; an augmented deÔ¨Ånition of goal path/1 to reÔ¨Çect this, is shown in (P-2.1). Prolog Code P-2.1: Augmented deÔ¨Ånition of goal path/1
1 2 3 4 5 6

goal_path([LastSegment|T]) :- number of marks(M), length([LastSegment|T],M), last(FirstSegment,T), link(LastSegment,FirstSegment), seed([SeedPosition]), % added goal LastSegment = [SeedPosition|_]. % added goal

2.8.8

Variants of the Loop Puzzle

A Loop with ‚ÄòKinks‚Äô In this loop puzzle from [18], one symbol is used only, the circle (0) say, for marking some positions on a rectangular board. We are required to Ô¨Ånd a loop such that

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

95 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

‚Ä¢ Each board position should be visited by the loop exactly once. ‚Ä¢ Pairs of marks lying adjacent on the loop should be connected by L-shaped segments (which may be referred to as kinks ). An example from [18] is solved by the model implementation in Fig. 2.43. Exercise 2.20. Write a Prolog solution for the above loop puzzle. It may be assumed that not all four corner positions are marked. (This assumption will allow a start state (i.e. an initial loop segment) to be ‚Äògrown‚Äô from this empty corner.) It may also be assumed that top and bottom rows, and leftmost and rightmost columns all contain at least one mark. You may retain the structure of the earlier implementation. Use the modules small board and board as before for displaying the positions of the marks and that of the loop. The puzzle speciÔ¨Åc source Ô¨Åles for the model solution are kinks.pl and kinks1.pl ‚Äì kinks5.pl.

A ‚ÄòStraight‚Äô Loop This puzzle originates from [16]. As before, one symbol is used only for marking some positions on a rectangular board, the circle (0), say. We want to Ô¨Ånd a loop such that ‚Ä¢ Each board position is visited by the loop exactly once. ‚Ä¢ Marked positions are traversed without a right angle turn; hence the attribute straight. An example from [16] is solved by the model implementation in Fig. 2.44. Exercise 2.21. Write a Prolog implementation for solving the above loop puzzle. Hints. 1. In the model solution, all viable loop segments of length three form the system states; they may be denoted, for instance, by a term state/3 with its arguments standing for three contiguous board positions. Given some state, the link/2 predicate will generate all its children as shown in the queries below for the puzzle in Fig. 2.44.
?- link(state(pos(3,3),pos(2,3),pos(2,4)),S). S = state(pos(3, 2), pos(3, 3), pos(2, 3)) ; S = state(pos(3, 4), pos(3, 3), pos(2, 3)) ; S = state(pos(4, 3), pos(3, 3), pos(2, 3)) ; No ?- link(state(pos(3,4),pos(3,3),pos(2,3)),S). S = state(pos(3, 5), pos(3, 4), pos(3, 3)) ; No

It is seen that linked segments overlap by one position and that the state/3 term can be thought of as a ‚Äòwindow‚Äô of size three progressing to the left. The second query above shows that the mark in pos(3,4) is traversed by a straight segment. 2. Because of the straightness condition, there can‚Äôt be any marks in the corners. We may therefore place the initial segment in the top left-hand corner. The Ô¨Åles straightloop.pl and straightloop1.pl ‚Äì straightloop3.pl are the puzzle speciÔ¨Åc source for the model solution.

96 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9
?- consult(kinks5). % blindsearches compiled into blindsearches 0.00 sec, 7,312 bytes % small_board compiled into small_board 0.00 sec, 6,224 bytes ' % board compiled into board 0.00 sec, 7,696 bytes % kinks compiled into kinks 0.00 sec, 34,736 bytes % kinks5 compiled 0.10 sec, 36,480 bytes Yes ?- loop. +---+---+---+---+---+---+---+---+ | | | | 0 | | | | 0 | 1 For displaying the boards, use the +---+---+---+---+---+---+---+---+ | | 0 | | | 0 | | | | 2 modules small board and board +---+---+---+---+---+---+---+---+ | | | | 0 | | 0 | | | 3 as speciÔ¨Åed in Sect. 2.8.4. +---+---+---+---+---+---+---+---+ | | 0 | | | | | | | 4 +---+---+---+---+---+---+---+---+ | | | | | 0 | | 0 | | 5 +---+---+---+---+---+---+---+---+ | | | 0 | | | 0 | | | 6 +---+---+---+---+---+---+---+---+ | | | 0 | | 0 | | | 0 | 7 +---+---+---+---+---+---+---+---+ | 0 | | | 0 | | | | | 8 +---+---+---+---+---+---+---+---+ 1 2 3 4 5 6 7 8 Select algorithm (df/df_dl/bf/bf_dl/bdf/id)... id. +-------+-------+-------+-------+-------+-------+-------+-------+ | | | | | | | | | | ************************0 | ************************0 | | * | | | * | * | | | * | +---*---+-------+-------+---*---+---*---+-------+-------+---*---+ | * | | | * | * | | | * | | * | 0**************** | 0**************** | * | | * | * | | | | | * | * | +---*---+---*---+-------+-------+-------+-------+---*---+---*---+ | * | * | | | | | * | * | | * | ****************0 | ********0 | * | * | | * | | | * | * | * | * | * | +---*---+-------+-------+---*---+---*---+---*---+---*---+---*---+ | * | | | * | * | * | * | * | | * | 0******** | * | * | * | * | * | | * | * | * | * | * | * | * | * | +---*---+---*---+---*---+---*---+---*---+---*---+---*---+---*---+ | * | * | * | * | * | * | * | * | | * | * | * | ********0 | ********0 | * | | * | * | * | | | | | * | +---*---+---*---+---*---+-------+-------+-------+-------+---*---+ | * | * | * | | | | | * | | * | * | 0**************** | 0**************** | | * | * | | | * | * | | | +---*---+---*---+-------+-------+---*---+---*---+-------+-------+ | * | * | | | * | * | | | | * | ********0 | ********0 | ****************0 | | * | | * | * | | | | * | +---*---+-------+---*---+---*---+-------+-------+-------+---*---+ | * | | * | * | | | | * | | 0**************** | 0******************************** | | | | | | | | | | +-------+-------+-------+-------+-------+-------+-------+-------+ Stop search? (y/n) y. Yes

6

8 Figure 2.43: Solving the Loop Puzzle ‚Äì Variant One

7

97 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9

?- consult(straightloop3). % blindsearches compiled into blindsearches 0.00 sec, 7,328 bytes % small_board compiled into small_board 0.00 sec, 6,224 bytes ' % board compiled into board 0.00 sec, 7,712 bytes % straightloop compiled into straightloop 0.00 sec, 30,048 bytes % straightloop3 compiled 0.00 sec, 31,192 bytes Yes ?- loop. +---+---+---+---+---+---+ | | | | | | | 1 For displaying the boards, use the +---+---+---+---+---+---+ | | 0 | | 0 | | | 2 modules small board and board +---+---+---+---+---+---+ | 0 | | | 0 | | | 3 as speciÔ¨Åed in Sect. 2.8.4. +---+---+---+---+---+---+ | | | 0 | | | | 4 +---+---+---+---+---+---+ | | | 0 | | 0 | | 5 +---+---+---+---+---+---+ | | | | 0 | | | 6 +---+---+---+---+---+---+ 1 2 3 4 5 6 Select algorithm (df/df_dl/bf/bf_dl/bdf/id)... id. +-------+-------+-------+-------+-------+-------+ | | | | | | | | ********* | ************************* | | * | * | * | | | * | +---*---+---*---+---*---+-------+-------+---*---+ | * | * | * | | | * | | * | 0 | ********0******** | * | | * | * | | | * | * | +---*---+---*---+-------+-------+---*---+---*---+ | * | * | | | * | * | | 0 | ****************0******** | * | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | * | ********0************************ | | * | * | | | | | +---*---+---*---+-------+-------+-------+-------+ | * | * | | | | | | * | ********0***************0******** | | * | | | | | * | +---*---+-------+-------+-------+-------+---*---+ | * | | | | | * | | ************************0**************** | | | | | | | | +-------+-------+-------+-------+-------+-------+ Stop search? (y/n) y. Yes

6

8

7

Figure 2.44: Solving the Loop Puzzle ‚Äì Variant Two

98 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

3 8 7

4

5 2

1 8 7

2

3 4

1

6

6

5

Initial State

Goal State

Figure 2.45: An Eight Puzzle

2.9
2.9.1

Application: The Eight Puzzle
The Puzzle

This is a standard example in AI and it is used for assessing the performance of search algorithms [27]. There are eight tiles, numbered 1 to 8, on a 3 √ó 3 board. The objective is to transform an initial tile arrangement into a given goal state; an example is shown in Fig. 2.45. In each transformation step, a new tile arrangement should be obtained by sliding a tile to the empty position.

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

99 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Blind Search

The number of states of this puzzle is 9! = 362, 880. However, the state space is known to fall into two distinct components the states of each of which are mutually reachable from within but not from the other component‚Äôs states. Below we show another popular choice for the goal state, residing in the other component. 1 4 7 2 5 8 3 6

Alternative Goal State

Thus, if this latter arrangement is also admitted as a goal state, the puzzle will be solvable for any initial state.

2.9.2

Prolog Implementation

A sample run of the model implementation is shown in Fig. 2.46. The user may choose from eleven test cases; the Ô¨Årst ten are from [15]. The test cases 1‚Äì10 are in order of increasing diÔ¨Éculty and are solvable with the goal state in Fig. 2.45. The eleventh test case is solvable for the alternative goal state. Test Case Number Goal Node at Depth bdf CPU Seconds bf id 1 8 0.0 0.3 0.3 2 8 0.2 0.5 0.4 3 10 0.5 3.0 1.2 4 12 2.3 43.6 5.2 5 13 3.6 99.6 8.2 6 16 2.9 1523 34.2 7 16 17.7 40.8 8 20 144.4 556.0 9 30 10 30 -

Table 2.1: CPU Times (in Seconds) for the Eight Puzzle with Blind Search

A summary of the results obtained on a 300 MHz PC is shown in Table 2.1: no entries are shown for unsuccessful runs due to stack overÔ¨Çow or prohibitively long computing times; and, the value chosen for the horizon in Bounded Depth First search is the minimum number of moves needed to reach the goal state (row two in Table 2.1).18 Implementation Details The system‚Äôs states are internally represented by the term state/9 ; for example, the initial tile arrangement in Fig. 2.45 will be represented by state(3,4,5,8,0,2,7,1,6). (The zero stands for ‚Äòno tile‚Äô.) The link/2 predicate is deÔ¨Åned in eight links.pl by focusing on the movement of the position with no tile; for example, two of the four states linked to the initial state in Fig. 2.45 are generated by means of the following clauses of link/2 ,
link(InState,OutState) :- down(InState,OutState). link(InState,OutState) :- left(InState,OutState).

The pertinent clauses of down/2 and left/2 are respectively deÔ¨Åned by
18 This will be found by Breadth First or Iterative Deepening as these algorithms Ô¨Ånd a shortest route to the goal node. In cases where both these algorithms fail, the minimum number of moves to the goal state has been established by an appropriate informed search algorithm from Chap. 3.

100 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

9
?- consult(eight puzzle). % blindsearches compiled into blindsearches 0.00 sec, 7,408 bytes % eight links compiled into links 0.00 sec, 4,152 bytes % eight puzzle compiled 0.05 sec, 19,576 bytes Yes ?- tiles. Start state for test case number 1: 8 1 2 7 3 6 4 5 --------------... --------------Start state for test case number 6: 3 4 5 8 2 7 1 6 --------------... Select test case (a number between 1 and 11)... 6. Select algorithm (df/df dl/bf/bf dl/bdf/id)... id. % 2,299,419 inferences in 34.17 seconds (67294 Lips) Solution in 16 steps. Show result in full? (y/n) y. 3 4 5 8 2 7 1 6 --------------3 4 5 8 1 2 7 6 --------------3 4 5 8 1 2 7 6 --------------... --------------1 3 8 2 4 7 6 5 --------------1 2 3 8 4 7 6 5 --------------Yes

6

8

7 Figure 2.46: Solving the Eight Puzzle

101 Download free eBooks at bookboon.com

Applications of Prolog

Blind Search

down(state(A,B,C,D,0,E,F,G,H),state(A,B,C,D,G,E,F,0,H)). left(state(A,B,C,D,0,E,F,G,H),state(A,B,C,0,D,E,F,G,H)).

Exercise 2.22. Complete the deÔ¨Ånition of link/2 . All the other problem relevant predicates are deÔ¨Åned in the top module in eight puzzle.pl which imports predicates from both eight links.pl and blindsearches.pl. Tail Recursion If the last goal in the body of a recursive clause is the head, it is termed tail recursive. If all recursive clauses of a predicate are tail recursive, and a cut (! ) precedes the last goal in each, the Prolog compiler will not retain reference to the earlier goals and the implementation will not crash due to stack overÔ¨Çow, and, it will run faster. Some compilers will recognize tail recursion automatically without the additional cut(s). It is good practice to use the cut for tail recursive code whatever system one uses. The entries of Table 2.1 have been obtained by tail recursive versions using cuts. This is an important addition here as some test cases proved unsolvable without the additional cut.

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

102 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

Chapter 3

Informed Search
In this chapter we are going to discuss graph search algorithms and applications thereof for Ô¨Ånding a minimum cost path from a start node to the goal node.

3.1

The Network Search Problem with Costs

The network search problem in Sect. 2.2 (Fig. 2.1) was devoid of any cost information. Let us now assume that the costs to traverse the edges of the graph in Fig. 2.1 are as indicated in Fig. 3.1. There are two possible interpretations of the Ô¨Ågures in Fig. 3.1: they can be thought of as costs of edge traversal or, alternatively, as edge lengths. (We prefer the latter interpretation in which case, of course, Fig. 3.1 is not to scale.) The task is to determine a minimum length path connecting s and g , or, more generally, minimum length paths connecting any two nodes. The algorithms considered in this chapter assume the knowledge of an heuristic distance measure, H , between nodes. Values of H for the network in Fig. 3.1 are shown in Table 3.1. They are taken to be the estimated straight line distances between nodes and may be obtained by drawing the network in Fig. 3.1 to scale and taking measurements. Three algorithms will be introduced here: the A‚ÄìAlgorithm, Iterative Deepening A‚àó and Iterative Deepening A‚àó ‚Äì . a u d 55 ¬† u d b u c u ug 28 u e 37 u f

52

43

d 85 d du s ¬† ¬† ¬† 62 35

54

Figure 3.1: A Network with Costs

103 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

85 98 109 77 55 95 52 a

40 51 71 54 61 43 b

30 25 54 63 88 c

62 76 73 35 d

34 45 37 e

31 28 f

14 g

s

Table 3.1: Straight Line Distances between Nodes in Fig. 3.1

3.1.1

Cost Measures

An estimated overall cost measure, calculated by the heuristic evaluation function F , will be attached to every path; it is represented as F =G+H (3.1) where G is the actual cost incurred thus far by travelling from the start node to the current node and H , the

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

104 Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

Applications of Prolog

Informed Search

heuristic, is the estimated cost of getting from the current node to the goal node. Assume, for example, that in the network shown in Fig. 3.1 we start in d and want to end up in c. Equation (3.1) then reads for the path d ‚Üí s ‚Üí a (with obvious notation) as follows F (d ‚Üí s ‚Üí a, c) = G(d ‚Üí s ‚Üí a) + H (a, c) = (62 + 85) + 95 = 147 + 95 = 242

(3.2)

3.1.2

The A‚ÄìAlgorithm

We know from Chap. 2 that for blind search algorithms the updating of the agenda is crucial: Breadth First comes about by appending the list of extended paths to the list of open paths; Depth First requires these lists to be concatenated the other way round. For the A‚ÄìAlgorithm, the updating of the agenda is equally important. The new agenda is obtained from the old one in the steps 1 and 2 below.
1

Extend the head of the old agenda to get a list of successor paths. An intermediate, ‚Äòworking‚Äô list will be formed by appending the tail of the old agenda to this list. The new agenda is obtained by sorting the paths in the working list from F ‚Äìvalues. The steps
1 1

2

in ascending order of their

3

and

2

are iterated until the path at the head of the agenda leads to the goal node.

In the example shown in Fig. 3.2, the paths are preÔ¨Åxed by their respective F ‚Äìvalues and postÔ¨Åxed by their respective G‚Äìvalues. Using this notation and the cost information, the example path in (3.2) is now denoted by 242 ‚àí [a, s, d] ‚àí 147. Notice that this path also features in Fig. 3.2. It can be shown (e.g. [23]) that if the heuristic H is admissible , i.e. it never overestimates the actual minimum distance travelled between two nodes, the A‚ÄìAlgorithm will deliver a minimum cost path if such a path exists.1 In this case the A‚ÄìAlgorithm is referred to as an A‚àó ‚ÄìAlgorithm and is termed admissible. (As the straight line distance is a minimum, the heuristic deÔ¨Åned by Table 3.1 is admissible.) Implementation The predicate a search(+Start,+Goal,-PathFound) in asearches.pl implements the A‚ÄìAlgorithm. A few salient features of a search/3 will be discussed only; for details, the reader is referred to the source code which broadly follows the pattern of implementation of the blind search algorithms (Fig. 2.15, p. 65 and Fig. 2.20, p. 69). The implementation of the A‚ÄìAlgorithm in asearches.pl uses the built-in predicate keysort/2 to implement step 2 (see inset on p. 108). The module invoking a search/3 should have deÔ¨Åned (or imported) the following predicates. ‚Ä¢ The connectivity predicate link/2 . For the network search problem, this is imported from links.pl (Fig. 2.2, p. 49). ‚Ä¢ The estimated cost deÔ¨Åned by e cost/3 . For the network search problem, this is deÔ¨Åned in graph a.pl by
1 To be more precise, this holds only under some additional conditions which are satisÔ¨Åed, however, in most practical applications [23].

105 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

e_cost(Node,Goal,D) :- dist(Node,Goal,D). e_cost(Node,Goal,D) :- dist(Goal,Node,D).

with dist/3 essentially implementing Table 3.1,
dist(s,a,85). ... dist(s,f,31). dist(s,g,14). dist(g,a,98). ... dist(g,f,28). ... dist(b,a,52).

AXA Global Graduate Program
Find out more and apply

106 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

[88-[d]-0]

:; [98-[e,d]-35, 92-[s,d]-62, 150-[a,d]-55] :; :; [242-[a,s,d]-147, 98-[e,d]-35, 150-[a,d]-55] :; :; [126-[f,e,d]-72, 132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147] :; :; :; :;
1 2 1 1 2 1 2

1

2

[92-[s,d]-62, 98-[e,d]-35, 150-[a,d]-55]

[98-[e,d]-35, 150-[a,d]-55, 242-[a,s,d]-147]

[126-[f,e,d]-72, 132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147]

[125-[g,f,e,d]-100, 132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147] [125-[g,f,e,d]-100, 132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147] [132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147] [132-[b,e,d]-89, 150-[a,d]-55, 242-[a,s,d]-147]

:; :; :; :; success
3 2 1

2

[132-[c,b,e,d]-132, 236-[a,b,e,d]-141, 150-[a,d]-55, 242-[a,s,d]-147] [132-[c,b,e,d]-132, 150-[a,d]-55, 236-[a,b,e,d]-141, 242-[a,s,d]-147]

Figure 3.2: Hand Computations: The Evolution of the Agenda for the A‚ÄìAlgorithm (from d to c in Fig 3.1)

107 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

‚Ä¢ The actual edge costs deÔ¨Åned by edge cost/3 . For the network search problem, this is deÔ¨Åned in graph a.pl by
edge_cost(Node1,Node2,Cost) :- link(Node1,Node2), e_cost(Node1,Node2,Cost).

Built-in Predicate: keysort(+List,-Sorted) UniÔ¨Åes Sorted with the sorted version of List . The entries in List have to be in the form key-term and they will be sorted in ascending order of the value of key . Example: Sort a list of names with ages according to increasing values of age. (Facts for age/2 to be entered manually.) ?- consult(user). |: age(adam,34). |: age(tracy,18). |: ¬£ age(george,15). ¬†¬£ ¬† |: ¬¢Ctrl ¬° +¬¢D ¬° % user compiled 0.00 sec, 480 bytes Yes ?- bagof( Age- Name,age( Name, Age),L), keysort(L,Sorted). L = [34-adam, 18-tracy, 15-george] Sorted = [15-george, 18-tracy, 34-adam] Yes

The interactive session below shows that the path d ‚Üí e ‚Üí b ‚Üí c is a shortest one from d to c.
?- consult(graph a). % asearches compiled into a ida idaeps 0.00 sec, 7,736 bytes % links compiled into edges 0.00 sec, 1,804 bytes % graph a compiled 0.00 sec, 16,584 bytes ?- a search(d,c,PathFound), total cost(PathFound,Cost). PathFound = [d, e, b, c] Cost = 132

3.1.3

Iterative Deepening A‚àó and its ‚ÄìAdmissible Version

Application of the A‚ÄìAlgorithm to a more substantial example in Sect. 3.2 will reveal that the A‚ÄìAlgorithm may fail due to excessive memory requirements.2 Clearly, there is scope for improvement. In the mid 1980s, a new algorithm was conceived by Korf [20] combining the idea of Iterative Deepening (Sect. 2.6) with a heuristic evaluation function; the resulting algorithm is known as Iterative Deepening A‚àó (IDA‚àó ).3 The underlying idea is as follows. ‚Ä¢ Use Depth First as the ‚Äòcore‚Äô of the algorithm.
2 We can see at this stage already that there is a special case of the A‚ÄìAlgorithm where lots of memory is required: the A‚ÄìAlgorithm specializes to Breadth First if unit edge costs and the zero heuristic are assumed. 3 Noteworthy is also a more recent work by Korf [21] analysing IDA‚àó .

108 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

‚Ä¢ Convert the core into a kind of Bounded Depth First Search with the bound (the horizon) now not being imposed on the length of the paths but on their F -values. ‚Ä¢ Finally, imbed this ‚ÄòmodiÔ¨Åed‚Äô Bounded Depth First Search into a framework which repeatedly invokes it with a sequence of increasing bounds. The corresponding sequence of bounds in Iterative Deepening was deÔ¨Åned as a sequence of multiples of some constant increment; a unit increment in the model implementation. The approach here is more sophisticated. Now, in any given phase of the iteration, the next value of the bound is obtained as the minimum of the F -values of all those paths which had to be ignored in the present phase. This approach ensures that in the new iteration cycle the least number of paths is extended. The pseudocode of IDA‚àó won‚Äôt be given here; it should be possible to reconstruct it from the above informal description. It can be shown that IDA‚àó is admissible under the same assumptions as A‚àó . The so-called ‚Äìadmissible version of IDA‚àó (IDA‚àó ‚Äì ) is a generalization of IDA‚àó . It is obtained by extending the F -horizon to + the minimum of all F -values of paths ignored with some Ô¨Åxed ‚â• 0. (It clearly specializes to IDA‚àó for = 0.) This algorithm may ‚Äòcatch‚Äô a solution which otherwise would fall just outside the current F -horizon. IDA‚àó ‚Äì may therefore Ô¨Ånd suboptimal solutions with

109 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

9

?- consult(graph a). % asearches compiled into a ida idaeps 0.00 sec, 7,736 bytes % links compiled into edges 0.00 sec, 1,804 bytes % graph a compiled 0.00 sec, 16,584 bytes Yes ?- path. Select start node s, a, b, ..., f, g: d. Select goal node s, a, b, ..., f, g: c. Select algorithm (a/ida/idaeps)... a. % 586 inferences in 0.00 seconds (Infinite Lips) Solution in 3 steps. d -> e -> b -> c Total cost: 132 Yes 8

6

7

Figure 3.3: An Interactive Session. (See Exercise 3.1.) Node Co-ordinates 1 (1, 4) 2 (2, 7) 3 (2, 9) 4 (3, 4) 5 (3, 5) 6 (3, 9) 7 (4, 1) 8 (4, 5) 9 (4, 9) 10 (5, 4)

Table 3.2: Node Co-ordinates in the Network in Fig. 3.4

broadly the same eÔ¨Äort and memory as IDA‚àó .4 Both versions, IDA‚àó and IDA‚àó ‚Äì , are implemented in asearches.pl. Exercise 3.1. Complete the deÔ¨Ånition of graph a.pl to solve the network search problem in Fig. 3.1 as illustrated by the interactive session in Fig. 3.3. (The user should be able to run any of the three algorithms discussed here.) Exercise 3.2. Fig. 3.4 shows a small directed network with the nodes‚Äô co-ordinates shown in Table 3.2. Let the length of an edge be the city block (or Manhattan ) distance of its endpoints.5 (a) Find the shortest route from node 1 to node 10 manually by using the A‚ÄìAlgorithm with the straight line heuristic. (b) Write a module (graph b.pl, say), which uses asearches.pl, for Ô¨Ånding the shortest route as before but now the user should be able to select the algorithm in the style shown in Fig. 3.3.

Exercise 3.3. (Adjacency matrix ) To represent the network in Fig. 3.4, you will have directly deÔ¨Åned the connectivity predicate link/2 by a collection of facts.6 A more Ô¨Çexible and elegant alternative to record the connectivity of a network is by using an adjacency matrix . The entries of this are zero everywhere except for
may not return an optimal solution. An example for this will be seen in Sect. 3.2. city block distance between two points is the shortest distance when measured in a zigzag parallel to the co-ordinate axes. Thus, for example, the nodes 6 and 8 are |3 ‚àí 4| + |9 ‚àí 5| = 5 units apart. 6 In all likelihood the same goes for the predicate that you will have used to record the nodes‚Äô co-ordinates from Table 3.2.
5 The 4 IDA‚àó ‚Äì

110 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

4

1

 ¬¢  ¬† ¬†¬¢ 2 ¬† ¬¢ e f ¬† d ¬¢ e ¬¢ ¬† fd e 5 8 E E ¬† ¬Ç ¬Ö 10 e f¬¢ d ¬¢f ¬† ! ¬° ! ¬° e d ¬° e ¬° d ¬¢¬† f ¬° ¬† f ¬Ç¬¢ d e¬° 3 d ¬° ¬° e f df ¬° e ¬° ¬Ç d ¬Ö¬° e x¬° E f
6 9

E7 e e

Figure 3.4: A Directed Network. (See Exercise 3.2.) ‚é° ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é¢ ‚é£
1 2 3 4 5 6 7 8 9 10

0 0 0 0 0 0 0 0 0 0

1 0 0 0 0 0 0 0 0 0

1 0 0 0 0 0 0 0 0 0

0 1 1 0 0 0 0 0 0 0

0 1 1 0 0 0 0 0 0 0

0 1 1 0 0 0 0 0 0 0

0 0 0 1 0 0 0 0 0 0

0 0 0 0 1 1 0 0 0 0

0 0 0 0 1 1 0 0 0 0

0 0 0 0 0 0 1 1 1 0

‚é§

‚é•2 ‚é• ‚é•3 ‚é• ‚é•4 ‚é• ‚é•5 ‚é• ‚é•6 ‚é•7 ‚é• ‚é•8 ‚é• ‚é¶9
10

1

Figure 3.5: Adjacency matrix of the network in Fig. 3.4 positions (i, j ) where there is a directed edge from node i to node j ; these entries are unity. Fig. 3.5 shows the adjacency matrix for the network in Fig. 3.4. Let this be deÔ¨Åned by a Prolog fact such as
adj(1,[[0,1,1,0,0,0,0,0,0,0], [0,0,0,1,1,1,0,0,0,0], . . . . . . . . . . [0,0,0,0,0,0,0,0,0,0]]).

(3.3)

Let us also assume that the co-ordinates of the nodes from Table 3.2 are implemented by the Prolog fact
co_ord(1,[(1,4),(2,7),(2,9),(3,4),(3,5),(3,9),(4,1),(4,5),(4,9),(5,4)]).

(a) DeÔ¨Åne a predicate make links(+A) which will write to the database the facts for link/2 corresponding to the adjacency matrix A . Also deÔ¨Åne a predicate make co ordinates(+C) which takes a list of co-ordinates (list of pairs) C and writes to the database the corresponding facts in the form in(Node,X co ord,Y co ord) . (Remove old deÔ¨Ånitions from the database before writing to it.) (b) Now, after revising your solution of Exercise 3.2, it should be possible to search the network in Fig. 3.4 thus

111 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

?- adj(1, A), co ord(1, Co), path( A, Co). Select start node 1, ..., 10: 1. Select goal node 1, ..., 10: 10. Select algorithm (a/ida/idaeps)... a. % 561 inferences in 0.00 seconds (Infinite Lips) Solution in 4 steps. 1 -> 2 -> 5 -> 8 -> 10 Total cost: 10 Yes

Notice in particular that the predicate path(+A,+Co) should initiate the search for the network with adjacency matrix A and list of node co-ordinates Co . Make use of make links/1 and make co ordinates/1 from part (a) when deÔ¨Åning path/2 . Your implementation will be able to cope with any directed network speciÔ¨Åed in this manner. (Minor point: Display the correct number of nodes for the user to choose from.) (c) Use your implementation to determine the shortest path from node 1 to node 26 in the network in Fig. 3.6, p. 113. The node co-ordinates are given in Table 3.3, and, as before, the edge lengths should be calculated

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

112 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

1

21 2 11 18 E #f ¬£ f ¬¢ g ¬¢ ¬°f ! ! ¬°  ¬†  ¬† d d d e ¬° fd ¬†¬¢ fd ¬† ¬¢ ge ¬° ¬£ f d 7 24 14 5 9 16 ¬° E E E ¬† ¬¢ f d ¬† ¬¢ g e¬° ¬£ f d ¬Ç ¬Ç ¬Ç f d ¬£ ¬¢ ¬¢ ¬° ¬° e ¬¢ d ¬¢ e ¬¢ !e ¬° !f ¬° !f ¬°    d d f ¬† f ¬† f ¬† g e ¬¢ ¬¢ d ¬¢ ¬¢ ¬¢ ¬° ¬† ¬† ¬°g ¬£e ¬† f¬¢ e ¬° e ¬° fd f¬¢ e ¬° fd f¬¢ 3 19 22 12 ¬£ ¬° E¬† f ¬Ç 26 d ¬Ç¬† f ¬Ç¬° g E ¬Ö¬† f e e¬° e¬° e¬° f¬¢ d f¬¢ d ¬¢f ¬† ¬¢f ¬† ¬°e ¬°e ¬°e !d ¬¢f d ¬¢f e ¬£g ¬°  ¬† e d ¬¢f ¬¢ ¬¢ ¬¢ ¬° e ¬° e ¬¢¬† ¬° e ¬¢¬† ¬† e¬£ g¬° d d e d f f f f f ¬£e ¬° ¬¢ d ¬¢ d ¬¢ d ¬Ç ¬† f ¬† f ¬Ç ¬Ç ¬Ö¬° E e ¬Ö¬¢ e ¬Ö¬¢ e x¬° E f x¬° E f x¬† f e g 17 6 8 15 25 10 ¬¢ ¬†    d f ¬¢ ¬† d f ¬£ ¬°e g ¬¢ ¬† e df ¬¢¬† d f ¬£¬° e g ¬¢ ¬† e ¬¢¬† ¬Ö e ¬° E ¬† ¬† ¬† ¬Ç d ¬Ç d ¬Ö¬¢ e x¬¢ f x¬£ f ¬á¬¢ g 4 13 20 23

Figure 3.6: Network for Exercise 3.3, Part (c) Node Co-ordinates Node Co-ordinates Node Co-ordinates 1 (1, 2) 10 (5, 20) 19 (9, 8) 2 (2, 7) 11 (6, 13) 20 (9, 18) 3 (2, 14) 12 (6, 17) 4 (2, 20) 13 (6, 19) 5 (3, 2) 14 (7, 2) 6 (3, 17) 15 (7, 15) 7 (4, 5) 16 (8, 7) 8 (4, 8) 17 (8, 19) 9 (5, 2) 18 (9, 4)

21 22 23 24 25 26 (10, 3) (10, 16) (10, 19) (11, 3) (11, 12) (12, 5)

Table 3.3: Node Co-ordinates in the Network in Fig. 3.6

by the city block distance.7 (The model solution for this exercise is in graph c.pl.) Exercise 3.4. (Sparsity ) If the adjacency matrix of a network is sparse, i.e. most of its entries are zero (Fig. 3.5), it is a good idea to apply a compression scheme for storing it in the database. The following is a simple compression scheme. As each row can be thought of as a concatenation of lists comprising zeros and ones, we shall denote repetitions of the same character C by N-C where N is the number of times the character C appears. Thus, for example, [1-0, 2-1, 7-0] will stand for the Ô¨Årst row of the matrix in (3.3). DeÔ¨Åne a predicate decompress(+C,-A) for converting a compressed matrix C into the corresponding adjacency matrix A .8 Hint. A concise deÔ¨Ånition may be achieved by adopting the functional programming style : 1. DeÔ¨Åne a predicate for converting terms of the form N-C to a list comprising N copies of C . 2. DeÔ¨Åne now a predicate by mapping the predicate in (1) followed by applying flatten/2 .
shall meet this network in a diÔ¨Äerent context in Sect. 3.4 as the search graph of the maze problem in Fig. 3.10, p. 122. query in Exercise 3.3, part (b), may then equivalently be issued by ?- c adj(1, C), decompress( C, A), co ord(1, Co), path( A, Co).
8 The 7 We

if c adj/2 is used in an obvious manner for deÔ¨Åning compressed adjacency matrices.

113 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

3 . . . . . . . . . 3 . . . . . . . . . 3 . . . . . .

. 4 . . . . . . . . . . . 4 . . . . . . . . . 4 . . .

. . 5 . . . . . . . . . . . 5 . . . . . . . . . . . 5

. . . 8 . . . . .

. . . . . 2 . . . . . 2 . . . . . . . 2 . . . . . . .

. . . . . . 7 . .

. . . . . . . 1 . . . . . . . 1 . . . . . 1 . . . . . 1 . . . . . . . .

. . . . . . . . 6 . . . . . . . 6 .

MH =

2

+

2

+

2

+

0

+

2

+

0

+

3

+

1

=

12

Figure 3.7: Calculating the Manhattan Distance between the tile arrangements in Fig. 2.45 3. Finally, implement decompression by mapping the predicate in (2) to the compressed matrix. (The solution is in graph c.pl.)

3.2

Case Study: The Eight Puzzle Revisited

For some choices of the terminal states for the Eight Puzzle we have not been able to Ô¨Ånd a solution using blind search (Table 2.1, p. 100). We are going to re-examine this puzzle here by informed search.

3.2.1

The Heuristics

A popular heuristic for the Eight Puzzle is the Manhattan Distance (MH). For two tile arrangements, the MH is the minimum total number moves all eight tiles need to be moved individually from their initial to their respective Ô¨Ånal positions. Whereas in the original version of the puzzle prior to moving a tile we had to make space by moving tiles which were ‚Äòin the way‚Äô, now in this relaxed problem the obstacle tiles are simply ignored. (As before, moves sideways and up and down are allowed only.) For example, the MH between the tile arrangements in Fig. 2.45, p. 99, is 12 as shown in Fig. 3.7. The MH never exceeds the actual distance (i.e. the minimum number of moves needed to convey one conÔ¨Åguration to the other) which is 16 here (Fig. 2.46, p. 101). The MH is therefore an admissible heuristic. The predicate e cost(mh,+State1,+State2,-C) 9 returns the estimated cost between State1 and State2 as measured by the MH; for the states in Fig. 2.45 we have, for example,
?- e cost(mh,state(3,4,5,8,0,2,7,1,6),state(1,2,3,8,0,4,7,6,5),C). C = 12
9 In

the Ô¨Årst argument we indicate the heuristic employed. (In Exercise 3.5 we will be considering another heuristic too.)

114 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

To implement this predicate, we Ô¨Årst represent the system‚Äôs states in matrix form, i.e. by a list comprising three lists.
matrix_form(state(T11,T12,T13,T21,T22,T23,T31,T32,T33), [[T11,T12,T13],[T21,T22,T23],[T31,T32,T33]]).

Given now two matrix representations, Matrix1 and Matrix2 , we Ô¨Ånd the number of steps D needed to convey the tile located at (i, j ) in Matrix1 to its new position in Matrix2 by applying mh distance/5 , deÔ¨Åned by
mh(I,J,Matrix1,Matrix2,D) :- ijth(I,J,Matrix1,E), ((E \= 0, ijth(K,L,Matrix2,E), D is abs(I - K) + abs(J - L)); D = 0), !.10

For example, the number of steps in the seventh sequence of tile moves in Fig. 3.7 is veriÔ¨Åed by
?- mh(3,2,[[3,4,5],[8,0,2],[7,1,6]],[[1,2,3],[8,0,4],[7,6,5]],D). D = 3

Finally, as seen in Fig. 3.7, the MH between any two tile arrangements (in matrix notation) is the sum of the number of moves for each individual tile.
mh(Matrix1,Matrix2,D) :- mh(1,1,Matrix1,Matrix2,D11), ... mh(3,3,Matrix1,Matrix2,D33), D is D11 + D12 + ... + D33.

Exercise 3.5. Another heuristic for the eight puzzle is the number of misplaced tiles (MP): each tile already in the right position will contribute zero whereas each of the other tiles will contribute unity. Implement this heuristic by e cost(mp,+State1,+State2,-C) . Example:
?- e cost(mp,state(3,4,5,8,0,2,7,1,6),state(1,2,3,8,0,4,7,6,5),C). C = 6

Thus, this heuristic does not exceed the MH11 which itself is admissible. Hence MP is admissible. (MP is deÔ¨Åned in eight puzzle a.pl.)

3.2.2

Prolog Implementation

The Prolog implementation is in the Ô¨Åle eight puzzle a.pl. A sample run is shown in Fig. 3.8, p. 116. For example, case 9 is now solvable while previously it was not viable (Table 2.1, p. 100). Table 3.4 shows the CPU times for the heuristic searches using a 300 MHz machine. (Unsuccessful cases and those with excessive computing times have been omitted.) Comparing Table 3.4 with Table 2.1 shows the dramatic beneÔ¨Åt of using
10 The

predicate ijth(?I,?J,+Matrix,?Entry) is deÔ¨Åned here by

ijth(I,J,ListOfRows,E) :- nth1(I,ListOfRows,Row), nth1(J,Row,E). It is used in two modes. First, to get access to the (i, j )th entry of a matrix, use the mode ijth(+I,+J,+Matrix,-Entry) . Then, to identify the position of Entry in Matrix , use ijth/4 in the mode ijth(-I,-J,+Matrix,+Entry) . 11 In fact, MP is at most the number of tiles, i.e. 8. Since MH is 12 here, we know without checking further that MP is less than MH.

115 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

9

?- consult(eight puzzle a). % asearches compiled into a ida idaeps 0.00 sec, 7,704 bytes % eight links compiled into links 0.00 sec, 4,100 bytes % eight puzzle a compiled 0.00 sec, 22,288 bytes Yes ?- tiles. Start state for test case number 1: 8 1 2 7 3 6 4 5 --------------... --------------Start state for test case number 9: 5 6 7 4 8 3 2 1 --------------... Select test case (a number between 1 and 10)... 9. Select heuristic (mh/mp)... mh. Select algorithm (a/ida/idaeps)... a. Solution in 30 steps. Show result in full? (y/n) y. 5 6 7 4 8 3 2 1 --------------5 6 7 4 2 8 3 1 --------------...

6

--------------1 3 8 2 4 7 6 5 --------------1 2 3 8 4 7 6 5 --------------Yes 8

7

Figure 3.8: Solving the Eight Puzzle by Heuristic Search

116 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

Test Case Number Goal Node at Depth a mp CPU ida Seconds a mh ida

1 8 0.1 0.1 0.0 0.1

2 8 0.1 0.1 0.0 0.1

3 10 0.0 0.1 0.1 0.0

4 12 0.3 0.5 0.1 0.1

5 13 0.7 1.0 0.1 0.1

6 16 26.8 4.2 0.9 0.3

7 16 14.3 5.1 0.7 0.8

8 20 59.9 38.0 8.1

9 30 42.0 2.8

10 30 52.9

Table 3.4: CPU Times (in Seconds) for the Eight Puzzle with Heuristic Search

heuristic search. It conÔ¨Årms furthermore that MH is better than MP and that IDA‚àó is preferable to the A‚àó ‚ÄìAlgorithm. Case 9 becomes viable for the number of misplaced tiles heuristic for IDA‚àó ‚Äì . With = 25, we get a solution in 32 steps in 30.4 CPU seconds. Exercise 3.6. (Other Algorithms ) As precursors to the A‚ÄìAlgorithm, in many AI books two other algorithms are also discussed: Hill Climbing and Best First Search (e.g. [34]).

If it really matters, make it happen ‚Äì with a career at Siemens.

siemens.com/careers

117 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

Hill Climbing is a modiÔ¨Åcation of Depth First in that the nodes obtained by expanding a parent node will be, prior to them being put to the front of the agenda, sorted in ascending order of their estimated distances to the goal node.12 Best First is an extension of the previous idea in that now, prior to choosing the node to be expanded next, all open paths in the agenda are sorted in ascending order of their estimated distances to the goal node.13 You should implement these two algorithms. Notes. (a) Model your implementation of the search algorithms on asearches.pl. As in asearches.pl, represent the estimated cost of a path by a preÔ¨Åx; no postÔ¨Åx is needed now. (b) Model your solution of the Eight Puzzle on eight puzzle a.pl. (c) Run the implementation and interpret the results. (The model solution will be found in bsearches.pl and eight puzzle b.pl.)

3.3

Project: Robot Navigation14

Develop a Prolog program that can be used to guide a robot in the matrix shown in Fig. 3.9 along a shortest route from any cell to any other cell.15 The robot should be able to move parallel to the walls but not diagonally. Notes. 1. Use the search algorithms‚Äô implementations in asearches.pl. 2. Use the city block distance as a heuristic H . 3. There are several possibilities to model the ‚Äôcost‚Äô of a path. The simplest is to take its length as a measure of cost, i.e. G = path length (3.4) The length is the sum of the edge costs each of which is in our application unity; we therefore declare edge_cost(_,_,1). Using this measure, the cost of the path found in Fig. 3.9 is 14. 4. Experiments using the cost measure in (3.4) suggest that the problem cannot always be solved by the A‚ÄìAlgorithm as the agenda may become excessively large. This will happen if there are too many paths of the same length sharing the same endpoints. The cost deÔ¨Åned by G = path length + Œ¥ √ó path tortuosity (3.5)

12 The underlying intuitive expectation is here that expanding nodes that are deemed closer to the goal node will lead faster to the goal node. 13 Best First is therefore a kind of A‚ÄìAlgorithm with the G component in (3.1) set to zero. 14 A simpliÔ¨Åed version of the problem described in this section served as a coursework problem in the late Prof. Imad Torsun‚Äôs Prolog lectures in the late 1990s. 15 The matrix layout (robot Ô¨Çoorplan on Fig. 3.9) is taken from [23, p. 83].

118 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

9
?- consult(robot). % rsearches compiled into rsearches 0.00 sec, 7,924 bytes % floorplan compiled into floorplan 0.05 sec, 9,524 bytes % robot compiled 0.05 sec, 25,116 bytes Yes ?- robot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . . . . . . . . . . . . . . +---+---+---+---+---+---+---+---+---+---+---+ 1 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 2 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 3 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 4 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 5 | | |XXX|XXX|XXX|XXX|XXX|XXX| | | | | | | +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 6 | | |XXX|XXX| | |XXX|XXX| | | | | | | +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 7 | | |XXX|XXX| | |XXX|XXX| | | | | | | +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 8 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 9 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 10 | | | | | | . . . | | | | . . . +---+---+---+---+---+ +---+---+---+ 11 | | | | | | . . . | | | | . . . +---+---+---+---+---+ +---+---+---+ . . . . . . . . . . . . . . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Select start cell ... cell(5,11). Select goal cell ... cell(7,3). Select algorithm (a/ida/idaeps)... a. % 842,633 inferences in 5.66 seconds (148875 Lips) From cell(5, 11) to cell(7, 3) in 14 moves: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . . . . . . . . . . . . . . +---+---+---+---+---+---+---+---+---+---+---+ 1 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 2 | | | | | | | | | | | | . . . +---+---+---+---+---+---+---+---+---+---+---+ 3 | | | | | | | * * * * * | | | . . . +---+---+---+---+---+---+---+---+-*-+---+---+ 4 | | | | | | | | | * | | | . . . +---+---+---+---+---+---+---+---+-*-+---+---+---+---+---+ 5 | | |XXX|XXX|XXX|XXX|XXX|XXX| * | | | | | | +---+---+---+---+---+---+---+---+-*-+---+---+---+---+---+ 6 | | |XXX|XXX| | |XXX|XXX| * | | | | | | +---+---+---+---+---+---+---+---+-*-+---+---+---+---+---+ 7 | | |XXX|XXX| | |XXX|XXX| * | | | | | | +---+---+---+---+---+---+---+---+-*-+---+---+---+---+---+ 8 | | | | | * * * * * * * * * | | | . . . +---+---+---+---+-*-+---+---+---+---+---+---+ 9 | | | | | * | | | | | | | . . . +---+---+---+---+-*-+---+---+---+---+---+---+ 10 | | | | | * | . . . | | | | . . . +---+---+---+---+-*-+ +---+---+---+ 11 | | | | | * | . . . | | | | . . . +---+---+---+---+---+ +---+---+---+ . . . . . . . . . . . . . . 1 2 3 4 5 6 7 8 9 10 11 12 13 14

6

1 2 3 4 5 6 7 8 9 10 11

1 2 3 4 5 6 7 8 9 10 11

8 Figure 3.9: Robot Navigation

Yes

7

119 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

where path tortuosity = number of turns will diÔ¨Äerentiate between such paths suÔ¨Éciently enough for excessive growth of the agenda to be avoided. To guarantee that all least cost paths are also shortest paths, choose Œ¥ > 0 small enough such that a shorter path, however tortuous, will always be assigned a smaller cost. Assuming that no path will have more than, say, nine turns, Œ¥ = 0.1 will do. Using this measure, the cost of the path found in Fig. 3.9 is 14.3.16 5. Your implementation using (3.4) will always succeed if Iterative Deepening A‚àó is used but may run out of memory for the A‚ÄìAlgorithm. 6. A more ambitious implementation will use (3.5), and this will always succeed, also for the A‚ÄìAlgorithm. The implementations in asearches.pl can cope with the usual cost structure only, i.e. where each edge is assigned a Ô¨Åxed cost. To cater for the more complex cost structure in (3.5), you should devise a modiÔ¨Åed version of asearches.pl. (The model solution uses rsearches.pl that is an adaptation of asearches.pl.) 7. The predicate deÔ¨Åning the Ô¨Çoor layout, called cell/2 in the model implementation, may be deÔ¨Åned by facts as follows.
cell(1,1). cell(1,2). ... cell(11,11).

It would be rather tedious, however, to enter these facts into the database manually and therefore they are assert ed ([9, p. 80]) by invoking a rule-based equivalent, position/2 , prior to running the main body of the program. For example, the upper block of cell positions may be deÔ¨Åned by
position(X,Y) :- between(1,11,X), between(1,4,Y).

which then is followed by the assert ion of the facts deÔ¨Åning cell/2 by layout/0 as shown below.
layout :- retractall(cell( , )), position(X,Y), assert(cell(X,Y)), fail. layout. 9 > > = > > ; ¬Ø failure driven loop ([9, p. 77]) catch-all clause

This is a simple form of memoization (e.g. [19], p. 179 and [28], p. 181), aimed at saving computing time during the search process. In addition, it introduces some Ô¨Çexibility, as the suggested arrangement allows the Ô¨Çoor layout to be easily modiÔ¨Åed if required. 8. The top level module of the model implementation is in robot.pl. It uses the modules in rsearches.pl (or asearches.pl, depending on which cost measure is being employed) and floorplan.pl. The latter implements the path‚Äôs display on the terminal as shown in Fig. 3.9. (A less ambitious solution will display the path by showing its co-ordinates only.)
16 By contrast, the path from cell(5,11) to cell(7,3) and having turns at cell(5,8), cell(9,8), cell(9,4) and cell(7,4) has the same length as the one found in Fig. 3.9 but it is more tortuous as it changes directions four times rather than thrice. It will be assigned the cost of 14.4.

120 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

3.4

Project: The Shortest Route in a Maze

Develop a Prolog program for searching for a shortest path in a maze of a speciÔ¨Åc kind with the following features. ‚Ä¢ The program should search in mazes exempliÔ¨Åed in Fig. 3.10 whereby ‚Äì The gates are arranged in groups parallel to each other; ‚Äì Adjacent groups of gates are a unit distance apart; ‚Äì Groups of gates are numbered 1, 2, . . . (up to 12 in Fig. 3.10); ‚Äì Group number 1 comprises the IN gate only; ‚Äì The group with the highest number (here: 12) comprises the OUT gate only; ‚Äì Gates are of unit width; ‚Äì The position of the gates relative to the left wall is recorded by a number (1, . . . , 20 in Fig. 3.10) and the overall width of the maze is determined by the position of the rightmost gate; ‚Ä¢ The program should display on the terminal the maze and the shortest path found. Furthermore, as seen in Fig. 3.10, the program should also have the following features.

www.sylvania.com

We do not reinvent the wheel we reinvent light.
Fascinating lighting offers an infinite spectrum of possibilities: Innovative technologies and new markets provide both opportunities and challenges. An environment in which your expertise is in high demand. Enjoy the supportive working atmosphere within our global group and benefit from international career paths. Implement sustainable ideas in close cooperation with other specialists and contribute to influencing our future. Come and join us in reinventing light every day.

Light is OSRAM

121 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

9
?- consult(maze). % maze_disp compiled into display 0.05 sec, 18,816 bytes % asearches compiled into a_ida_idaeps 0.00 sec, 7,660 bytes % maze compiled 0.11 sec, 41,972 bytes Yes ?- maze. Select test case (a number between 1 and 5)... 2. Select heuristic (zero/ed/alt)... ed. Select algorithm (a/ida/idaeps)... a. % 77,949 inferences in 0.55 seconds (141725 Lips) OUT 10 15 20 | | * | . . . | 12+---+---+---+---+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+12 | | * | . . . | | * * * * * . . . | | | * | . . | | . . | 11+---+---+ * +---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+11 | | * | . . | | . . | | * . . . . | | | * | . . . | | | | . | 10+---+---+ * +---+---+---+---+---+---+---+---+---+---+---+---+ +---+---+ +---+10 | | * | . . . | | | | . | | * * * . . . . | | | * | . | | . . | | . | 9+---+---+---+ * +---+---+---+ +---+---+---+---+---+---+---+---+---+ +---+---+ 9 | | * | . | | . . | | . | | * * * * * * * . . . | | . | * | . . | | . | 8+---+---+---+---+---+---+ * +---+---+---+---+---+---+---+---+---+---+---+ +---+ 8 | . | * | . . | | . | | . * * * * * * * * * * * * * * * * * . | | | | . . | * | . | 7+---+ +---+---+---+---+---+---+---+---+---+---+---+---+ * +---+---+---+---+---+ 7 | | | . . | * | . | | . . * * * * * . | | . . | * | . | | | | . | 6+---+---+---+---+---+---+---+---+---+---+---+---+ * +---+---+---+ +---+ +---+ 6 | . . | * | . | | | | . | | * * * * * * * * * * * * * * * * * * * * * * * . . | | | * | . . . | . | 5+---+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ . + 5 | | * | . . . | . | | * * * * * * * . . . | | | * | | | . . . | 4+---+---+---+---+ * +---+---+ +---+---+---+---+---+---+---+---+---+---+---+---+ 4 | | * | | | . . . | | * * * * * * * . . . | | | * | . . . | | . | 3+---+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ +---+---+---+ 3 | | * | . . . | | . | | * * * * * * * * * * * . . . | | . | * | . | | . | . | 2+---+---+---+---+---+---+ * +---+---+---+---+---+---+ +---+---+---+---+---+ . + 2 | . | * | . | | . | . | | * * * * * * * * * * * . . . | | | * | . . . . | 1+---+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 1 | | * | . . . . | IN 5 10 15 20 Length of shortest path is 54 Yes

6

8

7 Figure 3.10: Maze Search

122 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

| . . . . | | . | | . . | | . | 8+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+---+---+---+ +---+ | . | | . . | | . | | . . . . | | |Y | . . | . | . | u 7+---+ r +---+---+---+---+---+---+---+---+---+---+---+---+ . +---+---+---+---+---+ | | |r . | . | . | rr . | . . . . | | . . | | . | | | | . | r rr 6+---+---+---+---+---+---+---+---+---+---+---+---+ +---+---+---+ +---+ +---+ | . . | | . | | | | . | rr | . . . . | rr . | | | . . | . | rr 5+---+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ . + | | | . . r . | . | | . . . . | rr | | . | | | . . . | rr 4+---+---+---+---+ . +---+---+ +---+---+---+---+---+---+---+---+---+---+---+---+ rr | | . | | | . . . | | . . .r . | | | | . . . r| | . | ru+---+---+---+ 3+---+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ | | | . . . | | . | X | . . . . | | . | | . | | . | . | 2+---+---+---+---+---+---+ +---+---+---+---+---+---+ +---+---+---+---+---+ . + | . | | . | | . | . | | . . . . | | | | . . . . | 1+---+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ | | | . . . . | IN 5 10 15 20

8

7

6

5

4

3

2

1

Figure 3.11: Calculating the Euclidean Heuristic H1 ‚Ä¢ The user should choose between three evaluation functions (of the form F = G + H ), whereby the heuristic component, H , is one of the following: zero (zero), the Euclidean distance (ed), or, an alternative distance (alt) which will be described in Sect. 3.4.1. (All three suggested choices of H will be seen admissible.) ‚Ä¢ The user should choose between three algorithms: A‚àó , Iterative Deepening A‚àó and Iterative Deepening A‚àó ‚Äì . ‚Ä¢ The program should return a display of the shortest path found and its length.

3.4.1

Suggested Implementation Details
gates(2,[[2], [7,14,20], [2,17], [5,8], [2,20], [13,17,19], [2,15], [7,19], [4,8,18], [3,16,19], [3,12], [5]]).

The predicate gates/2 will be used to specify the structure of a maze. For example,

speciÔ¨Åes the maze shown in Fig. 3.10. The Ô¨Årst argument of gates/2 stands for the ‚Äòtest case number‚Äô; its second argument takes a list-of-lists deÔ¨Åning the structure of the maze in an obvious manner. Heuristics The zero heuristic H0 . Put simply H0 ‚â° 0. The Euclidean heuristic H1 . This is the straight line (‚ÄòEuclidean‚Äô) distance e between any two gates. Fig. 3.11 illustrates H1 : to estimate the distance between two gates X and Y , simply use Pythagoras (3.6). H1 (X, Y ) = e(X, Y ) = (17 ‚àí 2)2 + (3 ‚àí 7)2 = 15.52 (3.6)

123 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

The alternative heuristic H2 . If X and Y are in adjacent rows then put H2 (X, Y ) = e(X, Y ). Assume now that X and Y are at least two rows apart. H2 (X, Y ) is then deÔ¨Åned with reference to Fig. 3.12. Take for each row of gates between X and Y every gate in that row as an intermediate gate in a two-stage ‚ÄòÔ¨Çight‚Äô between X and Y . Keep the row Ô¨Åxed and compute the minimum of such ‚ÄòÔ¨Çight distances‚Äô ‚Äî each such minimum ‚ÄòÔ¨Çight distance‚Äô is obviously a lower bound on the true maze distance between X and Y . The alternative heuristic H2 (X, Y ) is deÔ¨Åned as the maximum of all such minimum Ô¨Çight distances, obtained by varying the in-between rows of gates. Equations (3.7)-(3.8) illustrate the computation of H2 . H2 (X, Y ) = max { min { min { min { e(X, U1 ) + e(U1 , Y ), e(X, U2 ) + e(U2 , Y ) } , e(X, V1 ) + e(V1 , Y ), e(X, V2 ) + e(V2 , Y ) } , e(X, W1 ) + e(W1 , Y ), e(X, W2 ) + e(W2 , Y ), e(X, W3 ) + e(W3 , Y ) } }

(3.7)

At Navigant, there is no limit to the impact you can have. As you envision your future and all the wonderful rewards your exceptional talents will bring, we offer this simple guiding principle: It‚Äôs not what we do. It‚Äôs how we do it.

Impact matters.
navigant.com

¬©2013 Navigant Consulting, Inc. All rights reserved. Navigant Consulting is not a certified public accounting firm and does not provide audit, attest, or public accounting services. See navigant.com/licensing for a complete listing of private investigator licenses.

124 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

| . . . . | | . | | . . | | . | 8+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+---+---+---+ +---+ | . | | . . | | . | | . . . . | Y | | | . . | . | . | 7+---+ u +---+---+---+---+---+---+---+---+---+---+---+---+ . +---+---+---+---+---+ | | | . . | . | . | | . . . W2 W3 . | W1 | . . | | . | | | | . | 6+---+---+---+---+---+---+---+---+---+---+---+---+ u +---+---+---+ u +---+ u +---+ | . . | | . | | | | . | | . . . .2| V1 V | | | . . . | . | u+ 5+---+ u +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ . | | | . . . | . | | .1 . . . | U U2 | | . | | | . . . | u +---+---+ u +---+---+---+---+---+---+---+---+---+---+---+---+ 4+---+---+---+---+ . | | . | | | . . . | | . . . . | | | | . . . | | . | u 3+---+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+ +---+---+---+ | | | . . . | | . | X | . . . . | | . | | . | | . | . | 2+---+---+---+---+---+---+ +---+---+---+---+---+---+ +---+---+---+---+---+ . + | . | | . | | . | . | | . . . . | | | | . . . . | 1+---+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ | | | . . . . | IN 5 10 15 20

8

7

6

5

4

3

2

1

Figure 3.12: Calculating the Alternative Heuristic H2

H2 (X, Y ) = max {

min { min { min {

16.28, 15.77 } , 17.13, 21.72 } , 16.05, 18.03, 20.62 } } = 17.13

(3.8)

The result is an admissible heuristic. Equations (3.6) and (3.7)-(3.8) show that H2 is not worse than the Euclidean heuristic H1 , i.e. H1 (X, Y ) ‚â§ H2 (X, Y ) ‚â§ true distance between X and Y H2 will be, however, more expensive to compute than either H0 or H1 . Manual Implementation As a Ô¨Årst step towards a full implementation, the problem shall be solved for the maze in Fig. 3.10 with the zero heuristic H0 and without returning a pictorial display of the path found. In this initial phase we won‚Äôt be making use of gates/2 directly. Instead, the necessary information about the maze will be represented by a collection of facts deÔ¨Åning edge cost/3 thus
edge_cost(state(1,2),state(2,7),6). edge_cost(state(1,2),state(2,14),13). ...

(The Ô¨Ålename chosen to hold these clauses, tedious.pl, reÔ¨Çects the eÔ¨Äort involved.) The above deÔ¨Ånition of edge cost/3 can be derived from the search graph indicated in Fig. 3.13 below. We deÔ¨Åne link/2 in terms of edge cost/3 by

125 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

state(1,2) 6 ¬®¬® ¬® ¬® % ¬® state(2,7) d 6 ¬® 13 c state(2,14) r rr 19 rr j r state(2,20) ¬† ¬© ¬† state(3,17) 19 ¬† 4

rr ¬® ¬® 4 7r 13 10 ¬®¬® r ¬® r c ¬® % j r c state(4,5) state(4,8) . . . . . . Figure 3.13: Search Graph for the Gates‚Äô Position

Do you have to be a banker to work in investment banking?
Agile minds value ideas as well as experience Global Graduate Programs
Ours is a complex, fast-moving, global business. There‚Äôs no time for traditional thinking, and no space for complacency. Instead, we believe that success comes from many perspectives ‚Äî and that an inclusive workforce goes hand in hand with delivering innovative solutions for our clients. It‚Äôs why we employ 135 different nationalities. It‚Äôs why we‚Äôve taken proactive steps to increase female representation at the highest levels. And it‚Äôs just one of the reasons why you‚Äôll find the working culture here so refreshing. Discover something different at db.com/careers

Download free eBooks at bookboon.com

E
126

¬† 13 11 d ¬† ¬Ç d ¬© ¬† state(3,2)

d 4 d E ¬Ç d

Deutsche Bank db.com/careers

Click on the ad to read more

Applications of Prolog

Informed Search

link(Node1,Node2) :- edge_cost(Node1,Node2,_).

The positions of the terminal gates will be recorded in tedious.pl by
start_state(state(1,2)). final_state(state(12,5)).

Finally, the zero heuristic will be implemented by the deÔ¨Ånition
e_cost(_,_,0).

We are now in a position to Ô¨Ånd interactively the path shown in Fig. 3.10:
?- consult(tedious). % asearches compiled into a ida idaeps 0.00 sec, 7,704 bytes % tedious compiled 0.00 sec, 15,544 bytes Yes ?- start state( S), final state( G), a search( S, G, PathFound), write term( PathFound,[]). [state(1, 2), state(2, 7), state(3, 2), state(4, 5), state(5, 2), state(6, 13), state(7, 15), state(8, 7), state(9, 4), state(10, 3), state(11, 3), state(12, 5)] Yes

Exercise 3.7. Complete the Ô¨Åle tedious.pl and run the search for the maze in Fig. 3.10 by using the heuristic H0 .

Full Implementation The predicates which will be used by the search algorithms in asearches.pl should be deÔ¨Åned in the top module, maze.pl, say. Below you will Ô¨Ånd some guidelines for these and another predicate used to display the result. A rule-based version (in one clause) of link/2 will deÔ¨Åne the node connectivity; then, for example, for the maze shown in Fig. 3.10 we get
?- consult(maze). ... ?- maze.17 Select test case (a number between 1 and 5)... 2. Select heuristic (zero/ed/alt)... ed. Select algorithm (a/ida/idaeps)... a. ... ?- link(state(3,17),Gate). Gate = state(4, 5) ; Gate = state(4, 8) ; No
17 This predicate, among other things, writes to the database the gates‚Äô arrangement chosen by the user. The predicate gates/1 will be used to hold this information. maze :- (retractall(gates( ));true), select testcase(N), assert((gates(AllGates) :- gates(N,AllGates))), ...

Now you should deÔ¨Åne link/2 for extracting the connectivity information from gates/1 .

127 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

The predicate e cost(+Heur,+G1,+G2,-Est) should return in Est the estimated distance of the gates G1 and G2 . Equations (3.6) and (3.7)-(3.8) are conÔ¨Årmed for example by
?- e cost(ed,state(3,17),state(7,2),Est). Est = 15.5242 ?- e cost(alt,state(3,17),state(7,2),Est). Est = 17.1327

The pictorial display of the maze and the path found is accomplished by the predicate show picture(+Pic) , deÔ¨Åned in the module maze disp.pl, with Pic specifying the maze and the path. To produce for example the display in Fig. 3.10, Pic will be uniÔ¨Åed with the list of pairs [(5, [5]), (3, [3,12]), (3, [3,16,19]), ..., (2, [2])] (Pic allows to identify for each row the gate through which the path passes and the position of all the gates in that row.) Exercise 3.8. Complete the implementation of the maze search problem as described above. Exercise 3.9. The model implementation uses the straight line distance to derive heuristics. Modify the implementation by basing the heuristics on the city block distance and observe and interpret changes in the CPU time. Exercise 3.10. The idea of the alternative heuristic function H2 can be reÔ¨Åned. For example, H3 (X, Y ) may be deÔ¨Åned for gates X and Y at least three rows apart by maximizing the minimum Ô¨Çight distances between X and Y with two intermediate gates. Put H3 (X, Y ) = H2 (X, Y ) if X and Y are less than three rows apart. Hn (n ‚â• 4) may be deÔ¨Åned in an analogous manner. Hn is a better heuristic than Hn‚àí1 , i.e. Hn ‚â• Hn‚àí1 but it will be more expensive to compute. Experiment with these heuristics to Ô¨Ånd out whether the computational beneÔ¨Åt in the search process outwheighs the increased computing time for the heuristics themselves. Exercise 3.11. The search graph of the maze problem is acyclic , i.e. no node can be visited more than once (e.g. Fig. 3.13). Path checking is therefore not required in this case. Disable path checking in asearches.pl and conÔ¨Årm that the resulting implementation uses less CPU time.

3.5

Project: Moving a Knight

Write a Prolog program which, given two positions on the chessboard, will Ô¨Ånd a shortest sequence of moves a knight needs between these two positions.18 Your program will behave as indicated in Fig. 3.14. You should experiment with the suggested heuristics to Ô¨Ånd out how long the search takes with each. The model solution is in knight.pl and it uses asearches.pl.
18 The

present search problem originates from [10].

128 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

9
?- consult(knight). % asearches compiled into a_ida_idaeps 0.00 sec, 7,704 bytes % knight compiled 0.05 sec, 19,104 bytes Yes ?- jumps. Select heuristic (min/mh/ed/co)... ed. Select algorithm (a/ida)... ida. Select initial position of knight ([a-h][1-8])... a8. Select final position of knight ([a-h][1-8])... h1. cost limit/CPU time: 1/399.3 cost limit/CPU time: 4.42719/399.35 cost limit/CPU time: 4.49285/399.35 cost limit/CPU time: 4.52982/399.35 cost limit/CPU time: 4.60768/399.35 cost limit/CPU time: 4.61245/399.41 cost limit/CPU time: 4.63246/399.46 cost limit/CPU time: 4.84391/399.52 cost limit/CPU time: 4.89443/399.63 cost limit/CPU time: 5.2249/399.74 cost limit/CPU time: 5.23607/399.9 cost limit/CPU time: 5.26491/400.06 cost limit/CPU time: 5.40588/400.23 cost limit/CPU time: 5.40832/400.39 cost limit/CPU time: 5.41421/400.61 cost limit/CPU time: 5.44721/400.94 cost limit/CPU time: 5.72029/401.33 cost limit/CPU time: 5.78885/401.77 cost limit/CPU time: 5.84708/402.26 cost limit/CPU time: 5.86356/402.76 cost limit/CPU time: 5.89737/403.31 cost limit/CPU time: 6/403.91 % 474,024 inferences in 4.66 seconds (101722 Lips) Solution in 6 steps: a8 b6 a4 b2 d1 f2 h1 +---+---+---+---+---+---+---+---+ 8 | X | | | | | | | | +---+---+---+---+---+---+---+---+ 7 | | | | | | | | | +---+---+---+---+---+---+---+---+ 6 | | X | | | | | | | +---+---+---+---+---+---+---+---+ 5 | | | | | | | | | +---+---+---+---+---+---+---+---+ 4 | X | | | | | | | | +---+---+---+---+---+---+---+---+ 3 | | | | | | | | | +---+---+---+---+---+---+---+---+ 2 | | X | | | | X | | | +---+---+---+---+---+---+---+---+ 1 | | | | X | | | | X | +---+---+---+---+---+---+---+---+ a b c d e f g h Yes

6

8

7

Figure 3.14: Sample Session: Moving a Knight

129 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

Suggested Heuristics Let the letters annotating the board‚Äôs columns be replaced by 1, . . . , 8 and refer to the knight‚Äôs position by a pair P = (x, y ) with co-ordinates x, y ‚àà {1, . . . , 8}. DeÔ¨Åne two heuristics H1 and H2 by Hq (P, P ) =
d1 (P,P ) , 3 d2 (P,P ) ‚àö , 5

when q = 1 when q = 2

(3.9)

where d1 and d2 denote respectively the city block distance (also called ‚ÄòManhattan distance‚Äô) and the Euclidean distance: when q = 1 |x ‚àí x | + |y ‚àí y |, dq ((x, y ), (x , y )) = (x ‚àí x )2 + (y ‚àí y )2 , when q = 2 H1 and H2 are referred to in Fig. 3.14 by mh and ed , respectively.

Real drive. Unreal destination.

As an intern, you‚Äôre eager to put what you‚Äôve learned to the test. At Ernst & Young, you‚Äôll have the perfect testing ground. There are plenty of real work challenges. Along with real-time feedback from mentors and leaders. You‚Äôll also get to test what you learn. Even better, you‚Äôll get experience to learn where your career may lead. Visit ey.com/internships. See More | Opportunities

¬© 2012 Ernst & Young LLP. All Rights Reserved.

130 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Informed Search

+---+---+---+---+---+---+---+---+ 8 | | | | | | | | | u e ! ¬° +---+---+---+---+---+---+---+---+ e ¬° 7 | | | r | | | ¬® | | | ¬â B r e ¬° ¬® +---+---+---+---+---+---+---+---+ rr ¬® e ¬° ¬® 6 | | | | | r| | | | ¬®¬® ¬°e r +---+---+---+---+---+---+---+---+ ¬® r % j ¬° e| r 5 | | | ¬® | | | | | ¬° e +---+---+---+---+---+---+---+---+  ¬° ¬Ö e 4 | | | | | | | | | +---+---+---+---+---+---+---+---+ 3 | | | | | | | | | +---+---+---+---+---+---+---+---+ 2 | | | | | | | | | +---+---+---+---+---+---+---+---+ 1 | | | | | | | | | +---+---+---+---+---+---+---+---+ 1 2 3 4 5 6 7 8 Figure 3.15: The Knight Moves One Step An interesting property of these heuristics is that none dominates the other.19 Admissibility. We show that both H1 and H2 are admissible. For pairs of positions one step apart, it is dq (P, P ) = 3, when q = 1 ‚àö 5, when q = 2

(This is illustrated in Fig. 3.15 for P = (4, 6).) In general, if the sequence of positions P = P0 , P1 , . . . , Pn = P takes the knight from P to P in the minimum number of moves n, say, then, by the Triangle Inequality for dq it is dq (P, P ) = dq (P0 , Pn ) 3n, when q = 1 (3.10) ‚àö ‚â§ dq (P0 , P1 ) + . . . + dq (Pn‚àí1 , Pn ) = 5n, when q = 2 From (3.10) we have by the deÔ¨Ånition of Hq in (3.9) that Hq (P, P ) ‚â§ n Generalization. We note in passing that for any q ‚â• 1, Hq , deÔ¨Åned by Hq (P, P ) = with dq ((x, y ), (x , y )) = (|x ‚àí x |q + |y ‚àí y |q )1/q
19 By this we mean that there are positions P , P , Q and Q such H (P, P ) < H (P, P ) and H (Q, Q ) > H (Q, Q ). This holds 1 2 1 2 for example for P = (4, 3), P = (7, 4), Q = (4, 3) and Q = (6, 1).

dq (P, P ) (1 + 2q )1/q

131 Download free eBooks at bookboon.com

Applications of Prolog

Informed Search

is an admissible heuristic.20 Combined heuristic. This we deÔ¨Åne by Hco (P, P ) = max{H1 (P, P ), H2 (P, P )} It is of course also admissible and it is a genuine improvement on both H1 and H2 since, as we have seen earlier, none dominates the other. A Non-Admissible Heuristic. DeÔ¨Åne Hmin by Hmin ((x, y ), (x , y )) = min{|x ‚àí x |, |y ‚àí y |} This is not admissible since Hmin ((7, 2), (1, 8)) = 6 but (7, 2) ‚Üí (5, 3) ‚Üí (3, 4) ‚Üí (2, 6) ‚Üí (1, 8) is a sequence of 4 moves from (7, 2) to (1, 8). IDA‚àó will indeed Ô¨Ånd this non-optimal sequence of moves if it is used with Hmin .

20 The

reasoning is as before with the following addenda. It is dq (P, P ) = P ‚àí P
q

with the q ‚Äìnorm .

q

deÔ¨Åned by (x, y )
q

= (|x|q + |y |q )1/q the q ‚Äìnorm
q

The Triangle Inequality for dq follows from the Minkowski Inequality for P +P See, e.g. [31].
q

‚â§ P

q

+ P

132 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Chapter 4

Text Processing
Whereas the problems considered thus far were taken from ArtiÔ¨Åcial Intelligence, we are going now to apply Prolog to problems in text processing. The present chapter is in three parts. First, the Prolog implementation is described of a tool for removing from a Ô¨Åle sections of text situated between marker strings. (The tool is therefore a primitive static program slicer; [32] and [12].) This tool then is A used in a practical context for removing sample solutions from the L TEX source code of a solved exam script. It is also shown in this context how SWI-Prolog code can be embedded into a Linux shell script. A The second part addresses the question of how Prolog can be used to generate L TEX code for drawing parametric curves. Some new features of Prolog will thereby also be introduced. The Ô¨Ånal part comprises a sequence of solved Prolog exercises, implementing a tool for drawing families of A parametric curves in L TEX. The exercises are of increasing complexity and Ô¨Ånally describe how SWI-Prolog can interact with Linux through a shell script.

4.1
4.1.1

Text Removal
Practical Context

A I use L TEX on Linux for preparing examination papers. This is done in the following steps. A TEX source Ô¨Åle in a text editor. 1. Create a L A TEX Ô¨Åle into a a DVI Ô¨Åle. 2. Translate the L

3. Translate the DVI Ô¨Åle into a PDF Ô¨Åle. 4. View the PDF Ô¨Åle. These steps are performed for exam.tex by running the Linux commands in Fig. 4.1.1 Upon execution of the last line in Fig. 4.1, a new window will pop up and the exam paper may be viewed. External examiners require examination papers with model answers. I create therefore a PDF Ô¨Åle with model solutions in the Ô¨Årst instance where answers are appended to each subquestion. The answers are placed between
1 bash-3.1$

is the system prompt in Fig. 4.1.

133 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

 

bash-3.1$ latex exam.tex bash-3.1$ dvipdf exam.dvi bash-3.1$ kpdf exam.pdf

 

Figure 4.1: Processing the File exam.tex some marker strings enabling me eventually to locate and remove all text between them when creating the Ô¨Ånal A L TEX source leading to the printed PDF for students. It is this text removal process which is automated by the Prolog implementation to be discussed here.

4.1.2

SpeciÔ¨Åcation

Write a predicate sieve(+Infile,-Outfile,+Startmarker,+Endmarker) of arity 4 for removing all text in the Ô¨Åle named in Infile in between all occurrences of lines starting with text in Startmarker and those starting with text in Endmarker . The result should be saved in the Ô¨Åle named in Outfile . Outfile is without marker lines. If Outfile already exists, its old version should be overwritten, if it does not exist, it should be newly created. The Ô¨Åle shown in Fig. 4.2 is an example of Infile with the marker phrases ‚Äòwater st‚Äô and

The stuff you'll need to make a good living

STUDY. PLAY.

The stuff that makes life worth living

NORWAY. YOUR IDEAL STUDY DESTINATION.
WWW.STUDYINNORWAY.NO FACEBOOK.COM/STUDYINNORWAY

134 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

‚Äòwater e‚Äô, say. (The Ô¨Åle comprises a random collection of geographical names.) After the Prolog query
birmingham new york lake district

las vegas grand canaria london water starts pacific ocean loch ness

'

¬ß Line starting with Startmarker ¬¶

¬§ ¬•

north sea water ends kalahari desert st andreas fault north pole water starts mediterranean sea lake balaton lake konstanz river thames river danube water ends britain europe

'

¬ß Line starting with Endmarker ¬¶ ¬ß Line starting with Startmarker ¬¶

¬§ ¬• ¬§ ¬•

'

'

¬ß Line starting with Endmarker ¬¶

¬§ ¬•

Figure 4.2: The File with waters
?- sieve(‚Äôwith\ waters‚Äô, ‚Äôwithout\ waters‚Äô, ‚Äôwater st‚Äô, ‚Äôwater e‚Äô). 2 Yes

the Ô¨Åle without_waters will have been created. This is shown in Fig. 4.3.

4.1.3

Implementation

DeÔ¨Ånition of Predicates The main predicate sieve/4 is deÔ¨Åned in terms of sieve/2 , both are shown in (P-4.1).
2 Notice that the sequence of two characters ‚Äò\ ‚Äô represents the underscore. Likewise, ‚Äò\. ‚Äô will have to be typed for the dot in a Ô¨Ålename or marker string.

135 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

birmingham new york lake district

las vegas grand canaria london kalahari desert st andreas fault north pole britain europe

Figure 4.3: The File without waters

Prolog Code P-4.1: DeÔ¨Ånition of sieve/4 and sieve/2
1 2 3 4 5 6 7 8 9

sieve(File_In, File_Out, Start_String, End_String) :see(File_In), tell(File_Out), told, append(File_Out), switch_off, sieve(Start_String, End_String), told, seen, !. sieve(Start_String, End_String) :atom_chars(Start_String, Start_List), atom_chars(End_String, End_List), get_line(Line), ((append(Start_List,_,Line), switch_on); true), (Line = [end_of_file]; atom_codes(A,Line), ((switch(off), write(A)); true), ((append(End_List,_,Line), switch_off); true), sieve(Start_String, End_String)).

10 11 12 13 14 15 16 17 18 19

The predicates get line/1 (and its auxiliary get line/2 ), switch off/1 and switch on/1 are deÔ¨Åned in (P-4.2).

136 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Prolog Code P-4.2: Auxiliaries for (P-4.1)
1

:- dynamic(switch/1). switch_off :- retractall(switch(_)), assert(switch(off)). switch_on :- retractall(switch(_)), assert(switch(on)). get_line(List) :- get_line([], List). get_line(Acc, List) :- get_char(Next), ((Next = ‚Äô\n‚Äô, reverse([Next|Acc], List)); (Next = end_of_file, List = [Next]); get_line([Next|Acc], List)).

2 3

4 5

6

7 8 9 10

For the SWI-Prolog built-ins atom chars/2 and atom codes/2 , the reader is referred respectively to pages 126 and 19 of [9].

I joined MITAS because I wanted real responsibiliÔøΩ I joined MITAS because I wanted real responsibiliÔøΩ

Maersk.com/Mitas www.discovermitas.com

ÔøΩe Graduate Programme for Engineers and Geoscientists

ÔøΩ for Engin

M

Real work International Internationa al opportunities ÔøΩree wo work or placements

Month 16 I was a construction M supervisor ina cons I was the North Sea supe advising and the N he helping foremen advi s solve problems Real work he helping International Internationa al opportunities ÔøΩree wo work or placements s solve p
Click on the ad to read more

137 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Noteworthy are three more built-in predicates used here: the standard Prolog predicates see/1 , seen/0 (respectively for directing the input stream to a Ô¨Åle and redirecting it) and get char/1 for reading a character; the example below illustrates their use by reading the Ô¨Årst three characters of the Ô¨Åle with_waters in Fig. 4.2.
?- see(with waters), get char(First), get char(Sec), get char(Third), seen. First = b Sec = i Third = r Yes

Details of Implementation ‚Ä¢ The predicate get line/1 in (P-4.2) is deÔ¨Åned in terms of get line/2 by the accumulator technique. It reads into its argument the next line from the input stream. Example:
?- set prolog flag(toplevel print options, [max depth(20)]). Yes ?- see(with waters), get line(First), get line(Sec), seen. First = [b, i, r, m, i, n, g, h, a, m, ] Sec = [n, e, w, , y, o, r, k, ] Yes

The following observations apply. 1. It is seen from the above query that a line read by get line/1 is represented as a list of the characters it is composed of. 2. By deÔ¨Ånition the last character of each line in a Ô¨Åle is the new line character ‚Äò\n‚Äô. That explains the line break seen in the above query. 3. Finally (not demonstrated here), each Ô¨Åle ends with the end-of-Ô¨Åle marker ‚Äòend_of_file‚Äô. The one-entry list [end_of_file] is deemed to be the last line of every Ô¨Åle by the deÔ¨Ånition in (P-4.2). ‚Ä¢ The switches switch off/0 and switch on/0 are used, writing respectively switch(off) and switch(on) in the Prolog database, respectively for removal and retention of lines from the input Ô¨Åle. ‚Ä¢ The main predicates are sieve/4 and sieve/2 in (P-4.1), the latter deÔ¨Åned by recursion and called by the former. sieve/4 : this is the top level predicate. 1. Line 2 opens the input Ô¨Åle. 2. The goals in lines 3-4 in (P-4.1) make sure that the earlier version of the output Ô¨Åle (if there is such a Ô¨Åle) is deleted. 3. In line 5, the new output stream is opened via append/1 3 . 4. In line 6, the switch is set to the position (‚ÄòoÔ¨Ä‚Äô), anticipating that initially lines will be retained.
3 Not

to be confused with the predicate append/3 !

138 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

5. In line 7, sieve/2 is invoked and processing is carried out. 6. Lines 8 and 9 close respectively output and input. sieve/2 : this is called from sieve/4 . 1. Lines 14 and 18 contain the most interesting feature of this predicate: append/3 is used in them for pattern matching. For example, the goal
append(Start_List,_,Line)

succeeds if the initial segment of the list Line is Start_List. 2. atom chars/2 is used in sieve/2 to disassemble the start and end markers into lists in preparation for pattern matching. 3. Notice that the built-in predicate atom codes/2 can be used in two roles as the interactive session below demonstrates.
?- atom_codes(A,[b, i, r, m, i, n, g, h, a, m]). A = birmingham Yes ?- atom_codes(birmingham, L). L = [98, 105, 114, 109, 105, 110, 103, 104, 97, 109] Yes

In line 16 of (P-4.1), atom codes/2 is used in its Ô¨Årst role, i.e. to convert a list of characters to an atom. This atom is the current line, it is written to the output Ô¨Åle. 4. Recursion is stopped in sieve/2 (and control is returned to line 8 of sieve/4 ) when the end-of-Ô¨Åle marker is read (line 15).

4.1.4

Using a Linux Shell Script

SpeciÔ¨Åcation Imbed the Prolog implementation from Sect. 4.1.3 into a Linux shell script for providing the same functionality as the predicate sieve/4 does. The application obtained thereby will run without explicitly having to use the SWI-Prolog system. The intended behaviour of the script is illustrated in Fig. 4.4. The dialogue shown in Fig. 4.4 has the same eÔ¨Äect as the Prolog session envisaged in Sect. 4.1.2. [22] is an accessible introduction to Linux and the beginnings of shell scripting.

Implementation Plan

139 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

9

bash-3.1$ ./sieve with\ waters without\ waters water\ st water\ e % /home/acsenki/scripts/sieve.pl compiled 0.00 sec, 4,284 bytes Input file : ‚Äôwith waters‚Äô Output file: ‚Äôwithout waters‚Äô Text removal between the phrases ‚Äôwater st‚Äô and ‚Äôwater e‚Äô bash-3.1$ cat without waters birmingham new york lake district

6

las vegas grand canaria london kalahari desert st andreas fault north pole britain europe

8

7

Figure 4.4: Running the Shell Script sieve

Need help with your dissertation?
Get in-depth feedback & advice from experts in your topic area. Find out what you can do to improve the quality of your dissertation!

Get Help Now

Go to www.helpmyassignment.co.uk for more info

140 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

The shell script should 1. Receive four arguments from the user (two Ô¨Ålenames and two pattern strings), 2. Write them to a temporary Ô¨Åle temp, 3. Invoke SWI-Prolog in the batch mode, which then ‚Ä¢ Should open the temporary Ô¨Åle temp, ‚Ä¢ Should read the strings from temp, ‚Ä¢ Should call sieve/4 to perform text removal, ‚Ä¢ Should close temp 4. Close the Prolog system, 5. Report on the actions performed, 6. Delete temp. Shell Script and Additional Prolog Predicates The Linux shell script sieve in (S-4.1) is an implementation of the plan. Linux Shell Script S-4.1: sieve
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21

#!/bin/bash if [ $# -ne 4 ]; then echo "Error: supply four arguments" else if [ -e $1 ]; then echo $1 > temp echo $2 >> temp echo $3 >> temp echo $4 >> temp # pl -f sieve.pl -g go -t halt # echo "Input file : ‚Äô$1‚Äô" echo "Output file: ‚Äô$2‚Äô" echo "Text removal between the phrases ‚Äô$3‚Äô and ‚Äô$4‚Äô" # rm temp else echo "Error: file ‚Äô$1‚Äô does not exist" fi fi

In line 11 of (S-4.1), the Prolog source sieve.pl is invoked as a command line argument [33, Sect. 2.3]. sieve.pl comprises (P-4.1), (P-4.2) from Sect. 4.1.3 and the code in (P-4.3).

141 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Prolog Code P-4.3: DeÔ¨Ånition of go/0 and get string/1
1 2 3 4 5 6 7

go :- see(temp), get_string(File_In), get_string(File_Out), get_string(Start_String), get_string(End_String), sieve(File_In, File_Out, Start_String, End_String), seen. % % auxiliary predicate get_string/1 ... % get_string(String) :- get_line(List), append(ShortList, [‚Äô\n‚Äô],List), atom_chars(String, ShortList).

8 9 10

11 12 13

In go/0 from sieve.pl the existence of a Ô¨Åle named temp is assumed, comprising four lines, the two Ô¨Åle names (input and output Ô¨Åles) and the two marker patterns, forming one line each. The top level predicate is now go/0 which then uses sieve/4 . Running the Script The script sieve makes (and eventually deletes) a temporary Ô¨Åle temp, holding the four strings read by the predicate go/0 . The script invokes the Prolog source sieve.pl, eÔ¨Äecting a result as speciÔ¨Åed in Sect. 4.1.2. Some additional features are also demonstrated in the Linux command window Fig. 4.5. 9
bash-3.1$ chmod -x sieve bash-3.1$ ls -l sieve -rw--w----+ 1 acsenki 2042 426 Sep 2 16:11 sieve bash-3.1$ ./sieve with\ waters without\ waters water\ st water\ e bash: ./sieve: Permission denied bash-3.1$ chmod +x sieve bash-3.1$ ./sieve with\ waters without\ waters water\ st Error: supply four arguments bash-3.1$ ./sieve with\ waters without\ waters water\ st water\ e Input file : ‚Äôwith waters‚Äô Output file: ‚Äôwithout waters‚Äô Text removal between the phrases ‚Äôwater st‚Äô and ‚Äôwater e‚Äô bash-3.1$ ls temp ls: temp: No such file or directory

6

8

7

Figure 4.5: Another Run of the Shell Script sieve Comments on Fig. 4.5. 1. The Ô¨Årst three commands illustrate what happens if initially sieve is not executable. 2. The fourth command makes sieve executable. 3. The Ô¨Åfth command illustrates the script‚Äôs response if less than four arguments are supplied.

142 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

4. The next command shows the normal mode of operation. The response has to be read in conjunction with (S-4.1). The output Ô¨Åle created is without_waters; it is of course identical to that in Fig. 4.3.

5. The last command conÔ¨Årms that the temporary Ô¨Åle temp has been removed.

4.1.5

Application: Removing Model Solutions

A part_sln.tex (shown in Fig. 4.6) is a Ô¨Åle forming part of a collection of L TEX source Ô¨Åles to be assembled to a A A single L TEX source. Text between the user-deÔ¨Åned L TEX commands \solstart and \solend forms part of a

... \definecolor{hellgrau}{gray}{0.85} \newcommand{\solstart}{\begin{center}\textbf{- - - - - - - - - - - \fcolorbox{black}{hellgrau}{Start Solution}- - - - - - - - - - - -}\end{center}} \newcommand{\solend}{\begin{center}\textbf{- - - - - - - - - - - \fcolorbox{black}{hellgrau}{End Solution}- - - - - - - - - - - -}\end{center}} ... \begin{itemize} \item First question. \item Second question. \end{itemize} \solstart \begin{itemize} \item Answer to first question. \item Answer to second question. \end{itemize} \solend Further questions. ...

Figure 4.6: The File part sln.tex

model solution of exam questions, not to be shown to students in the Ô¨Ånal version. Fig. 4.7 shows the structure of the printed version of the exam script with solutions. The task is to use the shell script sieve for producing the Ô¨Åle part.tex from part_sln.tex; the latter is

143 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

... ‚Ä¢ First question. ‚Ä¢ Second question. - - - - - - - - - - - - Start Solution - - - - - - - - - - - ‚Ä¢ Answer to first question. ‚Ä¢ Answer to second question. - - - - - - - - - - - - End Solution - - - - - - - - - - - Further questions. ...

Figure 4.7: Structure of the Printed Exam Script with Solutions

144 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

shown in Fig. 4.8. In part.tex, all lines between \solstart and \solend have been removed, including the marker lines themselves.
... \definecolor{hellgrau}{gray}{0.85} \newcommand{\solstart}{\begin{center}\textbf{- - - - - - - - - - - \fcolorbox{black}{hellgrau}{Start Solution}- - - - - - - - - - - -}\end{center}} \newcommand{\solend}{\begin{center}\textbf{- - - - - - - - - - - \fcolorbox{black}{hellgrau}{End Solution}- - - - - - - - - - - -}\end{center}} ... \begin{itemize} \item First question. \item Second question. \end{itemize} Further questions. ...

Figure 4.8: The File part.tex It is seen in Fig. 4.8 in particular that the text between the marker phrases (\solstart and \solend) is removed only if they are the Ô¨Årst phrase of their respective lines. (This is why the command deÔ¨Ånitions in Fig. 4.8 are still there.) '
bash-3.1$ ./sieve part\ sln\.tex part\.tex \\solstart \\solend % /home/acsenki/scripts/sieve.pl compiled 0.01 sec, 4,284 bytes Input file : ‚Äôpart sln.tex‚Äô Output file: ‚Äôpart.tex‚Äô Text removal between the phrases ‚Äô\solstart‚Äô and ‚Äô\solend‚Äô

$

&

%

Figure 4.9: Running the Shell Script sieve The task was achieved by running the shell script as shown in Fig. 4.9. Fig. 4.9 illustrates how string arguments containing the backslash character or the dot are used when running the shell script.

145 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

4.2
4.2.1

A Text Generation and Drawing with L TEX

Cycloids

Cycloids are a class of plain curves, well known from the Calculus of Variations (see e.g. the early classic [13, p. 26] or [26, Ch. 22, p. 844]). A cycloid is described by a point P attached to a disc rolling on a straight line (the base line) (Fig. 4.10). The following notation will be used. ‚Ä¢ r is the radius of the disc, ‚Ä¢ a is the distance of P = (x, y ) from the disc‚Äôs centre C , ‚Ä¢ œÜ is the angle of rotation of the disc, measured in radians, clockwise positive. The disc rests initially on the co-ordinate origin, therefore, C = (0, r) and P = (0, r ‚àí a) for œÜ = 0; this is the disc on the left in Fig. 4.10. If P is outside the disc (a > r) the curve generated is a prolate cycloid (Fig. 4.11); if it is inside (a < r) a curtate cycloid is obtained (Fig. 4.12); and, if it is on the perimeter of the disc (a = r) a common cycloid (Fig. 4.13) is obtained. (For cycloids and other plane curves a good reference is [11, p. 165].) The co-ordinates of a point on the cycloid are given by 6
P

T a r T c

c

√ó C ‚Ä¢
P

‚Ä¢ √óC -

Figure 4.10: Drawing a Cycloid (œÜ = œÄ/2)

x = y =

rœÜ ‚àí a sin œÜ, r ‚àí a cos œÜ.

(4.1) (4.2)

The disc on the right in Fig. 4.10 is obtained by rotating the initial disc clockwise by œÜ = œÄ/2. According to (4.1)-(4.2), P ‚Äôs new position is P = (rœÜ ‚àí a sin œÜ, r ‚àí a cos œÜ) = (rœÄ/2 ‚àí a, r), whereas C obviously moves to C = (rœÜ, r) = (rœÄ/2, r). 6 Figure 4.11: Prolate Cycloid Drawn with \writecurve from Fig. 4.14 (r = 5, a = 8, 3.5 revs)

146 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

6 Figure 4.12: Curtate Cycloid Drawn with \writecurve similar to Fig. 4.14 (r = 5, a = 3, 3.5 revs) 6 Figure 4.13: Common Cycloid Drawn with \writecurve similar to Fig. 4.14 (r = 5, a = 5, 3.5 revs)

4.2.2

Task

A DeÔ¨Åne a Prolog predicate which will generate a L TEX command for drawing a cycloid of a given description.

Brain power

By 2020, wind could provide one-tenth of our planet‚Äôs electricity needs. Already today, SKF‚Äôs innovative knowhow is crucial to running a large proportion of the world‚Äôs wind turbines. Up to 25 % of the generating costs relate to maintenance. These can be reduced dramatically thanks to our systems for on-line condition monitoring and automatic lubrication. We help make it more economical to create cleaner, cheaper energy out of thin air. By sharing our experience, expertise, and creativity, industries can boost performance beyond expectations. Therefore we need the best employees who can meet this challenge!

The Power of Knowledge Engineering

Plug into The Power of Knowledge Engineering. Visit us at www.skf.com/knowledge

147 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

A The only tool available is the L TEX package epic (e.g. [14]). The package epic provides the command \drawline for connecting a sequence of points by a straight line segment . The syntax of this command is

\drawline[stretch](x1, y1 )(x2 , y2 )...(xn , yn ) where stretch is an optional parameter (not used here) and (x1 , y1 )(x2 , y2 )...(xn , yn ) is the sequence of coordinates of the points to be connected. The task is to deÔ¨Åne a Prolog predicate define command/4 for A displaying on the terminal text which is essentially the L TEX command sought. This is illustrated in Fig. 4.14. The text so obtained is then pasted (after possibly some minor modiÔ¨Åcations) into the desired location in the #
?- define command(5, 8, 3.5, 100). \newcommand{\writecurve}{\drawline(0,-3)(-0.645588,-2.80733) (-1.20712,-2.23862)(-1.60458,-1.32124)(-1.76588,-0.099392)(-1.63027,1.36808) ... (101.754,11.3212)(104.35,12.2386)(107.111,12.8073)(109.956,13.0)} Yes "

!

A Figure 4.14: Generating the L TEX Command \writecurve with define command/4 A TEX source Ô¨Åle. The curve thus drawn will comprise a sequence of straight line segments, an approximation to L the speciÔ¨Åed cycloid, looking like as a smooth curve if the subdivision of the parameter interval is Ô¨Åne enough. A A Fig. 4.11, for example, was drawn by applying the L TEX code (L-4.1). (The L TEX command \writecurve, as generated by Prolog in Fig. 4.14, is used in line 9 of (L-4.1).) A L TEX Code L-4.1: Drawing Fig. 4.11
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

\begin{figure}[h] \begin{center} \setlength{\unitlength}{1mm} \begin{picture}(118,16)(0,0) \thicklines \put(5,-5){\vector(0,1){21}} \put(0,0){\vector(1,0){115}} \thinlines \put(5,5){\makebox(0,0){\writecurve}} \end{picture} \end{center} \caption{Prolate Cycloid Drawn with \texttt{\writecurve} from Fig.~\ref{textprocessing:cycloids:generatecommand} ($r=5$, $a=8$, $3.5$ revs)} \label{textprocessing:cycloids:fig:prolate} \end{figure}

4.2.3

Solution

A The Prolog predicates for generating the L TEX command \writecurve are shown in (P-4.4).

148 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Prolog Code P-4.4: Prolog Code Generating \writecurve
1 2 3 4 5 6 7

cyc(R, A, Alpha, Pair) :- Pi is 3.1415926, Rad is Alpha * Pi / 180, S is sin(Rad), C is cos(Rad), X is R * Rad - A * S, Y is R - A * C, concat atom([‚Äô(‚Äô,X,‚Äô,‚Äô,Y,‚Äô)‚Äô], Pair). mesh(Revs, NInt, List) :- mesh(Revs, NInt, NInt, List, []), !. mesh( , , 0, [0|Acc], Acc). mesh(Revs, NInt, NumInt, List, Acc) :H is NumInt * (Revs * 360 / NInt), NewNumInt is NumInt - 1, mesh(Revs, NInt, NewNumInt, List, [H|Acc]). pairs(R, A, Revs, NInt, Pairs) :- mesh(Revs, NInt, Mesh), maplist(cyc(R,A), Mesh, Pairs). define command(R, A, Revs, NInt) :pairs(R, A, Revs, NInt, Pairs), concat atom([‚Äô\\newcommand{\\writecurve}{\\drawline‚Äô|Pairs], Atom), concat atom([Atom,‚Äô}‚Äô], C), write(C).

8

9 10 11 12 13

14 15

16 17 18 19 20

Comments on, and ExempliÔ¨Åcation of (P-4.4).
1

Let r = 10, a = 4 and C = (0, 10). A counterclockwise rotation by Œ± = 90‚ó¶ (& associated roll of the disc to the right) moves the point P = (0, 6) to P = (11.708, 10.0).
?- cyc(10, 4, 0, Pair). Pair = ‚Äô(0,6)‚Äô Yes - cyc(10, 4, 90, Pair). Pair = ‚Äô(11.708,10.0)‚Äô Yes

cyc/3 is essentially an implementation of (4.1)-(4.2) with the proviso that rotations are measured in degrees. The output of cyc/3 is an atom.
2

Let us asume that we want to plot the path of P between the two positions from 1 , involving a quarter turn clockwise. A crude approximation will take snapshots corresponding to the positions 0‚ó¶ , 15‚ó¶ , 30‚ó¶ , 45‚ó¶ , 60‚ó¶ , 75‚ó¶ and 90‚ó¶ . The number of intervals involved is therefore 6 (each of length 15‚ó¶ ). The 7 gridpoints are generated as a list by mesh/3 thus
?- mesh(0.25, 6, List). List = [0, 15, 30, 45, 60, 75, 90] Yes

149 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

3

A sequence of points on the path of P is generated by pairs/5 . For example, the 7 pairs of co-ordinates of P in 2 are obtained by
?- pairs(10, 4, 0.25, 6, Pairs). Pairs = [‚Äô(0,6)‚Äô, ‚Äô(1.58272,6.1363)‚Äô, ‚Äô(3.23599,6.5359)‚Äô, ‚Äô(5.02555,7.17157)‚Äô, ‚Äô(7.00787,8.0)‚Äô, ‚Äô(9.22627,8.96472)‚Äô, ‚Äô(11.708,10.0)‚Äô] Yes

pairs/5 uses mesh/3 as an auxiliary. Furthermore, cyc/5 is used in partial application in the second goal in the deÔ¨Ånition of pairs/5 in the Ô¨Årst argument of maplist/3 . The output of pairs/5 is a list of atoms. They represent the co-ordinates of the points which will form the vertices of the approximating polygon. \drawline from epic will be used to connect them.
4

define command/4 essentially concatenates the list entries from

2

thus

?- define_command(10, 4, 0.25, 6). \newcommand{\writecurve}{\drawline(0,6)(1.58272,6.1363)(3.23599,6.5359)(5.02555,7.17157) (7.00787,8.0)(9.22627,8.96472)(11.708,10.0)} Yes

Challenge the way we run

EXPERIENCE THE POWER OF FULL ENGAGEMENT‚Ä¶ RUN FASTER. RUN LONGER.. RUN EASIER‚Ä¶
1349906_A6_4+0.indd 1

READ MORE & PRE-ORDER TODAY WWW.GAITEYE.COM

150 Download free eBooks at bookboon.com

22-08-2014 12:56:57

Click on the ad to read more

Applications of Prolog

Text Processing

5

Numbers whose modulus is very small or very large are displayed by default in Prolog in the scientiÔ¨Åc number format (the ‚Äòexponential notation‚Äô). If applicable, change such numbers to be displayed in the Ô¨Çoating point format using the ‚Äònon-exponential notation‚Äô. For example, 1/888888 will be displayed as A 1.125e ‚àí 06. Change this to 0.000001125 in the L TEX Ô¨Åle.4 (Notice that this point does not apply to the output generated in 4 .)
A Now the L TEX command \writecurve is ready to be used inside a Ô¨Ågure and it will draw the desired A cycloid. Fig. 4.15 was drawn with the \writecurve L TEX command from 4 ; the code for Fig. 4.15 is not shown here as it is very similar to that shown in (L-4.1).

6

6 Figure 4.15: ‚ÄòQuarter‚Äô Cycloid Drawn with \writecurve (r = 10, a = 4, 1/4 revs)

4.3

Exercises

Exercise 4.1. The predicate sieve/4 was deÔ¨Åned in Sect. 4.1 for removing text situated between some speciÔ¨Åed pairs of markers. DeÔ¨Åne now a predicate retain/4 for retaining text between some speciÔ¨Åed pairs of A markers. (Such a predicate could be used, for example, for extracting all Ô¨Ågures from a L TEX document.) Use your Prolog implementation in a shell script for solving the same task.
A Exercise 4.2. The two circles shown in Fig. 4.10 were drawn with the user-deÔ¨Åned L TEX command \defcirc. The deÔ¨Ånition of \defcirc was generated interactively by running the predicate circ command/4 A as shown in Fig. 4.16. (L-4.2) shows a partial view of the L TEX picture environment deÔ¨Åning Fig. 4.10: lines ?- circ command(10, 0, 0, 100). \newcommand{\defcirc}{\drawline(10,0)(9.98027,0.627905) (9.92115,1.25333)(9.82287,1.87381)(9.68583,2.4869)(9.51057,3.09017) ... (9.82287,-1.87381)(9.92115,-1.25333)(9.98027,-0.627906)(10.0,-1.0718e-06)} Yes "

#

!

A Figure 4.16: Generating the L TEX Command \defcirc with circ command/4

9 and 11 illustrate the use of \defcirc.
4 The alternative is using sformat/3 (formatted write) in (P-4.4) for displaying numbers in non-exponential notation; see Exercise 4.3.

151 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

A A L TEX Code L-4.2: Partial view of the L TEX code for Fig. 4.10
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

\begin{figure}[h] \begin{center} \setlength{\unitlength}{1mm} \begin{picture}(118,25)(0,0) \thicklines \put(25,-5){\vector(0,1){30}} \put(0,-2){\vector(1,0){115}} \thinlines \put(25,8){\makebox(0,0){\defcirc}} ... \put(40.707963,8){\makebox(0,0){\defcirc}} ... \end{picture} \end{center} \caption{Drawing a Cycloid}\label{textprocessing:fig:definingcycloid} \end{figure}

DeÔ¨Åne the Prolog predicate circ command(+Radius, +CentreX, +CentreY, +NInt) 5 for displaying on the A terminal L TEX code deÔ¨Åning \defcirc. A TEX and the epic package are available.6 As before, assume that only basic L Exercise 4.3. You will have deÔ¨Åned in Exercise 4.2 a Prolog predicate circ command/4 the output of which may have to be put through the manual processing step described in 5 of Sect. 4.2.3. This exercise is about writing an improved implementation of circ command/4 , called imp circ command/4 , that will obviate this since its output will contain pairs of numbers in non-exponential notation only. The ‚Äòold‚Äô version of the predicate may be used to deÔ¨Åne a command for a circle of radius 10 with centre (0, 10) by approximating the circle with a regular 20 sided polygon (Fig. 4.17). Both entries of the sixteenth 1
?- circ command(10, 0, 10, 20). \newcommand{\defcirc}{\drawline(10,10)(9.51057,13.0902) (8.09017,15.8779)(5.87785,18.0902)(3.09017,19.5106)(2.67949e-07,20.0) (-3.09017,19.5106)(-5.87785,18.0902)(-8.09017,15.8779)(-9.51057,13.0902) (-10.0,10.0)(-9.51057,6.90983)(-8.09017,4.12215)(-5.87785,1.90983) (-3.09017,0.489435)(-8.03847e-07,3.19744e-14)(3.09017,0.489435)(5.87785,1.90983) (8.09017,4.12215)(9.51056,6.90983)(10.0,10.0)} Yes 0

(

)

A Figure 4.17: Generating the L TEX Command \defcirc with circ command/4 A pair in Fig. 4.17 are in the exponential notation, something L TEX won‚Äôt accept. The modiÔ¨Åed version produces essentially the same output with all the numbers in the Ô¨Çoating point notation (Fig. 4.18). You should deÔ¨Åne imp circ command/4 by using the SWI-Prolog built-in predicate sformat/3 . Hint. The predicate sformat/3 is there for producing formatted output returned as a string. Use the ‚Äòf‚Äô format (for Ô¨Çoating point, non-exponential) in the second argument of sformat/3 . For further information, see [6, p. 493]
5 NInt 6 In

denotes the number of intervals used when discretising a full revolution. A basic L TEX \circle is used to draw circles. It allows, however, to draw circles up to a certain size only.

152 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

9

?- imp circ command(10, 0, 10, 20). \newcommand{\defcirc}{\drawline(10.0000000,10.0000000) (9.5105652,13.0901699)(8.0901700,15.8778524)(5.8778527,18.0901698) (3.0901701,19.5105651)(0.0000003,20.0000000)(-3.0901696,19.5105653) (-5.8778522,18.0901702)(-8.0901697,15.8778529)(-9.5105650,13.0901704) (-10.0000000,10.0000005)(-9.5105653,6.9098306)(-8.0901703,4.1221480) (-5.8778531,1.9098305)(-3.0901707,0.4894351)(-0.0000008,0.0000000) (3.0901691,0.4894346)(5.8778518,1.9098295)(8.0901694,4.1221467) (9.5105648,6.9098291)(10.0000000,9.9999989)} Yes 8

6

7

A Figure 4.18: Generating the L TEX Command \defcirc with imp circ command/4

and [33].
A Exercise 4.4. We are now in a position to address the generation of L TEX code for any parametric two-dimensional curve. The aim is to deÔ¨Åne a predicate

gen command2(+CName, +Fun, +Lower, +Upper, +NInt, +Pars)

(4.3)

The arguments and the intended working of gen command2/6 are best explained with reference to an example.

This e-book is made with

SetaPDF

SETA SIGN

PDF components for PHP developers

www.setasign.com
153 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

The curve we are going to use is the improved circle imp circ/5 from (P-A.11), p. 193 (solution of Exercise 4.3). A TEX command for drawing a polygonial approximation with four sides to the lower half of a circular The L arc with radius 10, centre (0, 10) should be generated thus
?- gen command2(‚Äô\\halfcirc‚Äô, imp circ, 180, 360, 4, [10,0,10]). \newcommand{\halfcirc}{\drawline(-10.0000000,10.0000005)(-7.0710683,2.9289327)(-0.0000008,0.0000000) (7.0710671,2.9289315)(10.0000000,9.9999989)}
A Once this command deÔ¨Ånition is in the L TEX code, \halfcirc is ready to be used in a Ô¨Ågure. (The output may then look like the polygon in Fig. 4.19.) The arguments in (4.3) are easily matched to their respective values

6 v  v  v¬ó  3 ¬ó 3 ¬ó3 -

Figure 4.19: Polygon Drawn with \halfcirc in the query. On the other hand, imp circ(+R, +X, +Y, +Alpha, -Pair) , the predicate from (P-A.11), has 1. Three Ô¨Åxed (input) parameters: radius R , and the two co-ordinates of the centre X and Y ; 2. One argument: angle of rotation Alpha , measured counterclocwise positive from the circle‚Äôs rightmost point; 3. One output: Pair , returned as a string. The following is taking place in the query above. ‚Ä¢ The command name CName in (4.3) is uniÔ¨Åed with the string ‚Äò\halfcirc ‚Äô; ‚Ä¢ The predicate name Fun is uniÔ¨Åed with ‚Äòimp circ ‚Äô; ‚Ä¢ The domain of the argument Alpha is the interval [Lower, U pper] = [180, 360]. It is subdivided into NInt (= 4) intervals of equal length. The function values (pairs) are calculated internally for all interval endpoints, i.e. the 5 values of Alpha , [180, 225, 270, 315, 360]; ‚Ä¢ The argument Pars (list of parameters) is uniÔ¨Åed with [10, 0, 10], amounting to the uniÔ¨Åcations R = 10, X = 0, Y = 10; ‚Ä¢ And, Ô¨Ånally, after some processing, the command deÔ¨Ånition is written to the terminal.

154 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

Built-in Predicate: apply(+Pred,+List) Uses the entries of List as arguments to the predicate Pred . Partial application of Pred is possible. The examples below refer to a polynomial deÔ¨Åned by the predicate pol/5 , pol(A, B, C, X, Y) :- Y is A + B * X + C * XÀÜ2. ?- pol(4, 3, 2, 10, Y). Y = 234 Yes ?- apply(pol, [4, 3, 2, 10, Y]). Y = 234 Yes ?- apply(pol(4, 3), [2, 10, Y]). Y = 234 Yes apply/2 is a higher order predicate. Use apply(+Pred, +List) to invoke Pred whose arity is not known at compile time.

Detailed Plan. The main point is to recognize the need to be able to pass on a predicate name as an argument. The built-in predicate apply/2 is used to accomplish that. The implementation described here has a ‚Äòfunctional Ô¨Çavour‚Äô. 1. Write a predicate gen mesh(+Lower, +Upper, +NInt, -Mesh) for generating a list of meshpoints.
?- gen mesh(180, 360, 4, Mesh). Mesh = [180, 225, 270, 315, 360] Yes

2. DeÔ¨Åne a predicate applic(+Fun, +Pars, +Argument, -Outcome) for calculating values of a function, deÔ¨Åned by a predicate. For example, instead of having
?- imp_circ(10, 0, 10, 225, Outcome). Outcome = ‚Äô(-7.0710683,2.9289327)‚Äô Yes

we may now equivalently do
?- applic(imp circ, [10, 0, 10], 225, Outcome). Outcome = ‚Äô(-7.0710683,2.9289327)‚Äô Yes

The two queries may deliver the same but the second one will be preferable in our context as it allows the predicate name to be passed on as an argument; applic/4 is therefore a higher order predicate. Notice that the order of the arguments supplied to Fun is replicated by the entries of the list Pars and the arguments Argument and Outcome . Hint. Use the built-in predicate apply/2 . (See inset.)

155 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

3. DeÔ¨Åne a predicate gen vals(+Fun, +Lower, +Upper, +NInt, +Pars, -Vals) for calculating the list of values taken by a given function at equidistant gridpoints. Example:
?- gen vals(imp circ, 180, 360, 4, [10,0,10], Vals). Vals = [‚Äô(-10.0000000,10.0000005)‚Äô, ‚Äô(-7.0710683,2.9289327)‚Äô, ‚Äô(-0.0000008,0.0000000)‚Äô, ‚Äô(7.0710671,2.9289315)‚Äô, ‚Äô(10.0000000,9.9999989)‚Äô] Yes

Use here gen mesh/4 and applic/4 from above. Furthermore, use also the built-in predicate maplist/3 . 4. Finally deÔ¨Åne gen command2(+CName, +Fun, +Lower, +Upper, +NInt, +Pars) ; it should behave as exempliÔ¨Åed on p. 154.

A Exercise 4.5. The logarithmic spiral in Fig. 4.20 was drawn with the L TEX command \spiral the deÔ¨Ånition of which was generated with Prolog by using gen command2/6 from Exercise 4.4.

In the past four years we have drilled

81,000 km
That‚Äôs more than twice around the world.
Who are we?
We are the world‚Äôs leading oilfield services company. Working globally‚Äîoften in remote and challenging locations‚Äîwe invent, design, engineer, manufacture, apply, and maintain technology to help customers find and produce oil and gas safely.

Who are we looking for?
We offer countless opportunities in the following domains: n Engineering, Research, and Operations n Geoscience and Petrotechnical n Commercial and Business If you are a self-motivated graduate looking for a dynamic career, apply to join our team.

What will you be?

careers.slb.com

156 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Text Processing

?- gen command2(‚Äô\\spiral‚Äô, log spiral, 0, 2160, 300, [85, 0, 0]). \newcommand{\spiral}{\drawline(1.0000000,0.0000000)(1.0030823,0.1267188)(0.9901165,0.2542187) ... (25.6446869,-6.5844539)(26.5581065,-3.3550864)(27.0651201,-0.0000174)} Yes

6

-

Figure 4.20: Logarithmic Spiral Drawn with \spiral DeÔ¨Åne the predicate log spiral(+Alpha, +CentreX, +CentreY, +RotAngle, -Pair) and then redraw in A L TEX the spiral on Fig. 4.20. Hint. As is well known (e.g. [2]), a point on the logarithmic spiral with Cartesian co-ordinates (r cos œÜ, r sin œÜ) is deÔ¨Åned by r = ekœÜ with k = cot Œ±, where (r, œÜ) are the point‚Äôs polar co-ordinates and Œ± is the constant (acute) angle at which the spiral cuts all rays emitted from the origin. (œÜ and Œ± are both measured in radians in these formulae.) In the above query, we have made 2160‚ó¶/360‚ó¶ = 6 revolutions, subdivided the interval [0‚ó¶ , 2160‚ó¶] into 300 intervals of equal length, and, the angle Œ± measured 85‚ó¶ . (Obviously, the arguments Alpha and RotAngle in log spiral/5 are both measured in degrees .) The pole was taken to be the origin (0, 0). Note. An entire section is devoted to spirals in the beautiful book [25]. Questions concerning their selfsimilarity occupy the authors‚Äô attention. Exercise 4.6. You are asked to deÔ¨Åned the predicate curves/2 in this exercise. It will simplify and automate the command deÔ¨Ånitions considered in Exercise 4.4. A Assume that we want to draw possibly several parametric curves in L TEX each of which we can in isolation A specify, generate and draw as described in Exercise 4.4. The pasting-in from the terminal of the L TEX codes generated is cumbersome and error prone as it is a manual step. Therefore, we want to be able to create a A A Ô¨Åle where all the L TEX code will be deposited, ready to be included into our L TEX document via \include. Furthermore, the curves‚Äô interactive speciÔ¨Åcations (via the keyboard) is also best avoided for the same reason; the preferred way of doing this is via some input Ô¨Åle. Illustrative Example.

157 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

6 -

Figure 4.21: Growing Spirals
A TEX command for each of the four spirals can We want to generate Fig. 4.21 containing four spirals. The L be generated by gen command2/6 from Exercise 4.4. (It is assumed of course that the predicate log spiral/5 from Exercise 4.5 is available.) Once curves/2 is available, we can solve this task in the following three steps. 1

Create a Ô¨Åle stating the four curves‚Äô speciÔ¨Åcations in terms of gen command2/6 ; this has been done here in spirals shown in Fig. 4.22. The lines in spirals whose Ô¨Årst character is % serve as comment lines.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % % Spirals specified via gen command2/6 ... % % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % gen command2(‚Äô\\tinyspiral‚Äô, log spiral, 0, 360, 36, [85, 0, 0]). ... % gen command2(‚Äô\\tinyspiral‚Äô, log spiral, 0, 360, 36, [85, 0, 0]) % % gen command2(‚Äô\\smallspiral‚Äô, log spiral, 0, 720, 72, [85, 0, 0]). ... % gen command2(‚Äô\\smallspiral‚Äô, log spiral, 0, 720, 72, [85, 0, 0]) % % gen command2(‚Äô\\normalspiral‚Äô, log spiral, 0, 1080, 108, [85, 0, 0]). ... % gen command2(‚Äô\\normalspiral‚Äô, log spiral, 0, 1080, 108, [85, 0, 0]) % % gen command2(‚Äô\\largespiral‚Äô, log spiral, 0, 1440, 144, [85, 0, 0]). ... % gen command2(‚Äô\\largespiral‚Äô, log spiral, 0, 1440, 144, [85, 0, 0]) %

Figure 4.22: The File spirals
2

Perform now the following Prolog dialogue.
?- consult(draw). % draw compiled 0.00 sec, 11,432 bytes Yes ?- curves(‚Äôspirals‚Äô, ‚Äôspirals.tex‚Äô). Yes

158 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

3

The Ô¨Åle spirals.tex will have been created in step

2

.

This is shown in Fig. 4.23.

Notice that

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % % Spirals specified via gen command2/6 ... % % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % gen command2(‚Äô\\tinyspiral‚Äô, log spiral, 0, 360, 36, [85, 0, 0]). ... % \newcommand{\tinyspiral}{\drawline(1.0000000,0.0000000)(0.9999608,0.1763201) ... (1.6805635,-0.2963289)(1.7327464,-0.0000002)} % ... ... % % gen command2(‚Äô\\largespiral‚Äô, log spiral, 0, 1440, 144, [85, 0, 0]). ... % \newcommand{\largespiral}{\drawline(1.0000000,0.0000000)(0.9999608,0.1763201) ... (8.7429878,-1.5416285)(9.0144653,-0.0000039)} %

Figure 4.23: The File spirals.tex
A A spirals.tex is a valid L TEX Ô¨Åle best included into the L TEX source by means of \include{spirals}. Lines starting in spirals with % are copied unchanged by curves/2 into spirals.tex, becoming thereby A L TEX comment lines. curves/2 uses gen command/6 to generate the commands specifying the curves, here the four spirals.

DeÔ¨Åne the predicate curves/2 ! Hint. Use apply/2 to call a predicate whose name is known at runtime only. For example, in the query below, after deÔ¨Åning the predicate pol/5 the variable Pred is uniÔ¨Åed with pol(4, 3, 2, 10, Y) and then the goal pol(4, 3, 2, 10, Y) is satisÔ¨Åed via the call apply(Pred, []) .
?- consult(user). |: pol(A, C, X, Y) :- Y is A + B * X + C * X * X. ¬£ ¬£ ¬† ¬† B, |: ¬¢Ctrl ¬° +¬¢D ¬° % user://1 compiled 0.01 sec, 392 bytes Yes ?- Pred = pol(4, 3, 2, 10, Y), apply(Pred, []). Pred = pol(4, 3, 2, 10, 234) Y = 234 Yes

Exercise 4.7. Embed the predicate curves/2 from Exercise 4.6 into a Linux shell script called ‚Äòcurves‚Äô A for creating a L TEX Ô¨Åle for deÔ¨Åning parametric curves. The shell script will use two arguments corresponding to those of curves/2 . (This solution will have the beneÔ¨Åt of the underlying Prolog application remaining hidden

159 Download free eBooks at bookboon.com

Applications of Prolog

Text Processing

from the user.) Illustrative Example. Running the script curves as shown in Fig. 4.24 will have the same eÔ¨Äect as applying the predicate curves/2 in step 2 of Exercise 4.6. The Ô¨Åle spirals.tex created thereby was copied by means of the last line of Fig. 4.24 1
csenki@linux:‚àº/scripts> ./curves spirals spirals\.tex % /home/csenki/scripts/draw.pl compiled 0.00 sec, 11,800 bytes Input file : ‚Äôspirals‚Äô Output file: ‚Äôspirals.tex‚Äô LaTeX source ‚Äôspirals.tex‚Äô created csenki@linux:‚àº/scripts> cp spirals.tex ‚àº/texmatter/ventus

(

0

)

Figure 4.24: Running the Shell Script curves
A TEX source for the present document is kept. (This copy was made subsequently into a directory where all L A part of the L TEX source by writing ‚Äò\include{spirals}‚Äô in the source‚Äôs top level Ô¨Åle.)

160 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

Appendix A

Solutions of Selected Exercises
A.1 Chapter 1 Exercises

All Prolog source code for Chap. 1 is available in the Ô¨Åle enigma.pl. Exercise 1.1. We Ô¨Årst disassemble the list and then assemble the reduced list by leaving out one element:
remove_one(List,E,Reduced) :- append(Front,[E|Back],List), append(Front,Back,Reduced).

Exercise 1.2. DeÔ¨Åne
var_matrix(Size,M) :- repeat(Size,Size,RowLengths), maplist(var_list,RowLengths,M).

with the predicate repeat/3 ,
repeat(X,1,[X]) :- !. repeat(X,N,[X|R]) :- NewN is N - 1, repeat(X,NewN,R).

for producing lists with the same entry repeated a speciÔ¨Åed number of times. Exercise 1.3. We show three approaches. The Ô¨Årst is, as originally suggested, by recursion.
list_permute([],_,[]). list_permute([P1|Rest],L,[H|T]) :- nth1(P1,L,H), list_permute(Rest,L,T).

An alternative deÔ¨Ånition uses bagof/3 .
?- Perm = [3,1,2], L = [ R1, R2, R3], bagof( E, I^(member( I,Perm), nth1( I,L, E)),P). Perm = [3, 1, 2] L = [_G642, _G645, _G648] P = [_G648, _G642, _G645]

Finally, we may use maplist/3 as indicated by the query below.

161 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

?- dynamic(nth1 new/3), retractall(nth1 new( , , )), assert(nth1 new( L, I, E) :- nth1( I, L, E)), Perm = [3,1,2], L = [ R1, R2, R3], maplist(nth1_new(L),Perm,P). Perm = [3, 1, 2] L = [_G1122, _G1125, _G1128] P = [_G1128, _G1122, _G1125]

Exercise 1.4. The predicate col/3 , deÔ¨Åned by
col(Matrix,N,Column) :- maplist(nth1(N),Matrix,Column).

returns a speciÔ¨Åed column of a matrix as a list. We now assemble the transposed matrix T as the list of the columns of the original matrix M .
transpose(M,T) :[H|_] = M, % get H to measure NCols length(H,NCols), bagof(N,between(1,NCols,N),L), maplist(col(M),L,T).

Exercise 1.5. The predicate notin/2 , deÔ¨Åned by
notin(_,[]). notin(E,[H|T]) :- E \== H, notin(E,T).

Find and follow us: http://twitter.com/bioradlscareers www.linkedin.com/groupsDirectory, search for Bio-Rad Life Sciences Careers http://bio-radlifesciencescareersblog.blogspot.com

John Randall, PhD Senior Marketing Manager, Bio-Plex Business Unit

Bio-Rad is a longtime leader in the life science research industry and has been voted one of the Best Places to Work by our employees in the San Francisco Bay Area. Bring out your best in one of our many positions in research and development, sales, marketing, operations, and software development. Opportunities await ‚Äî share your passion at Bio-Rad!

www.bio-rad.com/careers

162 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

succeeds if the Ô¨Årst argument is not equivalent to any of the list entries. distinct/1 is deÔ¨Åned by recursion using notin/2 .
distinct([_]). distinct([H|T]) :- notin(H,T), distinct(T).

Exercise 1.6. We Ô¨Årst deÔ¨Åne retain var(+Var,+VarList,-List) by
retain_var(_,[],[]). retain_var(V,[H|T],[H|L]) :- H == V, retain_var(V,T,L). retain_var(V,[H|T],L) :- H \== V, retain_var(V,T,L).

It will be used as an auxiliary predicate where List will contain as many copies of Var as there are in VarList . For example,
?- retain var( B,[ A, B, A, C, B, A],L). L = [ G357, _G357]

Now, count the number of entries in List .
count_var(VarList,Var,Num) :- retain_var(Var,VarList,List), length(List,Num).

An alternative, more concise (one clause) solution is suggested by the query
?- bagof( E,(member( E,[ A, B, A, C, B, A]), E == A), L), length( L,N). N = 3

Exercise 1.7. We deÔ¨Åne zip/3 by recursion.
zip([],_,[]) :- !. zip(_,[],[]) :- !. zip([H1|T1],[H2|T2],[(H1,H2)|T]) :- zip(T1,T2,T).

The input lists need not be of the same length in which case the excess tail section of the longer one will be ignored. Exercise 1.8. DeÔ¨Åne total/2 by
total(IntPairs,Total) :- total(IntPairs,0,Total). % clause 0 total([],S,S). total([(X,Y)|T],Acc,S) :- NewAcc is Acc + X * Y, total(T,NewAcc,S). % clause 1 % clause 2

The corresponding annotated hand computations are shown in Fig. A.1. Exercise 1.9. We Ô¨Årst deÔ¨Åne write ilist(+Width,+List) by
write_ilist(Width, List) :- length(List,Length), int_to_atom(Width,WidthA), concat_atom([‚Äô%‚Äô,WidthA,‚Äôr‚Äô],Atom), repeat(Atom,Length,Format1), append(Format1,[‚Äô]‚Äô],Format2), concat_atom([‚Äô[‚Äô|Format2],Format), writef(Format,List).

163 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

total( [(1,10),(2,100),(3,1000)],Total)

:; :;
1 2

0

total([(1,10),(2,100),(3,1000)],0,Total) total([(2,100),(3,1000)],10,Total)
2

:;

2

total([(3,1000)],210,Total) Total = 3210

:; total([],3210,Total) :;

:; success

0

Figure A.1: Hand Computations for total/2 for displaying an integer list in the right justiÔ¨Åed fashion. Width takes the number of digits reserved for the display of each entry. For example,
?- write ilist(8, [12, 345, 6789]). [ 12 345 6789]

(repeat/2 has been taken from the solution of Exercise 1.2, p. 161.) The matrix is Ô¨Ånally displayed row-wise by
write_imatrix(Matrix) :- largest(Matrix,Max), ndigits(Max,ND), Width is ND + 2, write_imatrix(Width,M).

using the predicates ‚Ä¢ largest(+Matrix,-Max) for calculating the largest entry of Matrix (deÔ¨Ånition not shown here), ‚Ä¢ ndigits/2 for calculating the number of digits of a number is deÔ¨Åned in terms of digits/2 by
ndigits(N,ND) :- digits(N,D), length(D,ND).

(digits/2 was deÔ¨Åned in Exercise 4.8 of [9, p. 136] to return the list of digits of an integer; see also [9, pp. 173‚Äì174].) ‚Ä¢ write imatrix/2 with
write_imatrix(_,[]). write_imatrix(Width, [H|T]) :- write_ilist(Width, H), nl, write_imatrix(Width, T).

Exercise 1.10. The completed Table 1.3 is shown as Table A.1. As the full deÔ¨Ånition of next partition/2 is available in enigma.pl, we want to elaborate on one particular case only, typiÔ¨Åed by the Ô¨Åfth column in Table A.1. The Ferrers diagrams of the ‚Äòcurrent‚Äô and ‚Äònext‚Äô partition are shown in Fig. A.2, part (a) and (b), respectively. We proceed as follows.

164 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

Current Partition Next Partition Step Used Current Partition Next Partition Step Used

[23 41 62 ] [12 22 41 62 ] (i) [15 51 62 ] [21 42 62 ] (ii)

[41 63 ] [11 31 63 ] (i) [13 51 72 ] [42 72 ] (ii)

[43 52 ] [11 31 42 52 ] (i) [15 43 51 ] [33 42 51 ] (ii)

[13 24 31 42 ] [15 23 31 42 ] (ii)

Table A.1: Partitions

‚Ä¢ We unify the current partition‚Äôs list representation with [(1,A),(K,1)|T] . (The group of sixes will, since they remain unchanged, be subsumed in the list‚Äôs tail.) ‚Ä¢ The total number of marked tokens is A + L . They are to form as many groups of size L - 1 as possible. The number of them will be computed by integer division (// ). The leftovers form the bottom row of the

678'<)25<2850$67(5¬©6'(*5((
&KDOPHUV 8QLYHUVLW\ RI 7HFKQRORJ\ FRQGXFWV UHVHDUFK DQG HGXFDWLRQ LQ HQJLQHHU LQJ DQG QDWXUDO VFLHQFHV DUFKLWHFWXUH WHFKQRORJ\UHODWHG PDWKHPDWLFDO VFLHQFHV DQG QDXWLFDO VFLHQFHV %HKLQG DOO WKDW &KDOPHUV DFFRPSOLVKHV WKH DLP SHUVLVWV IRU FRQWULEXWLQJ WR D VXVWDLQDEOH IXWXUH ¬§ ERWK QDWLRQDOO\ DQG JOREDOO\ 9LVLW XV RQ &KDOPHUVVH RU 1H[W 6WRS &KDOPHUV RQ IDFHERRN

165 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

(a)

(b)

√ó √ó √ó √ó √ó √ó

√ó

√ó

√ó

√ó

√ó √ó √ó

√ó √ó √ó

√ó √ó

√ó √ó

[(1,5),(5,1),(6,2)]

[(2,1),(4,2),(6,2)]

Figure A.2: Ferrers Diagrams and their Prolog Representations new Ferrers diagram. The number of them is the division‚Äôs remainder (Prolog‚Äôs mod ). ‚Ä¢ These ideas give rise to the following clause.
next_partition([(1,A),(L,1)|T],[(Rest,1),(NewL,Rat)|T]) :- L > 2, NewL is L - 1, Rest is (A + L) mod NewL, Rest > 0, Rat is (A + L) // NewL.

Exercise 1.11. DeÔ¨Åne next int/3 by
next_int(High,I,NextI) :- succ(I,NextI), NextI =< High.

and use it as
?- generator(next int(9),3,I). I = 3 ; I = 4 ; ... I = 9 ; No

(This is in eÔ¨Äect a new implementation of the built-in predicate between/3 [9, p. 41].) Exercise 1.12. The horizontal and vertical transitions in Fig. 1.6 are encoded by
next_pair((0,0),(0,1)) :- !. next_pair((0,N),(0,NextN)) :- even(N), succ(N,NextN), !. next_pair((M,0),(NextM,0)) :- odd(M), succ(M,NextM), !.

where even/1 and odd/1 are respectively deÔ¨Åned by
even(N) :- 0 is N mod 2. odd(N) :- 1 is N mod 2.

The built-in conditional ->/2 [9, p. 91] may be used to implement the diagonal transitions in Fig. 1.6.

166 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

9

?- current predicate(Pred, ), No ?- tmp predname( Temp), Term Yes ?- current predicate(Pred, ), Pred = temp 0 ; No ?- tmp predname( Temp), Term Yes ?- current predicate(Pred, ), Pred = temp 1 ; Pred = temp 0 ; No

atom prefix(Pred,‚Äôtemp‚Äô). =.. [ Temp,( I, I)], assert( Term). atom prefix(Pred,‚Äôtemp‚Äô).

6

=.. [ Temp,( I, I)], assert( Term). atom prefix(Pred,‚Äôtemp‚Äô).

8 Figure A.3: Creating Distinct Temporary Predicate Names

7

next_pair((M,N),(NextM,NextN)) :- Sum is M + N, (odd(Sum) -> succ(M,NextM), succ(NextN,N); succ(NextM,M), succ(N,NextN)), !.

Pairs starting with (1,1) , say, are generated by

?- generator(next pair,(1,1),P). P = 1, 1 ; P = 0, 2 ; P = 0, 3 ; P = 1, 2 ; ...

Exercise 1.13. tmp predname/1 returns, each time it is invoked, an atom for naming a temporary predicate.

tmp_predname(Temp) :- int(0,N), int_to_atom(N,Tag), concat_atom([‚Äôtemp_‚Äô,Tag],Temp), not(current_predicate(Temp,_)), !.

The interactive session in Fig. A.3 illustrates how tmp predname/1 may be used to produce predicate names hitherto not present in the database. (See also inset.) In the deÔ¨Ånition of the new version of generator/3 , its structure is retained except that now the goals (terms) referring to the temporary predicate are constructed using the built-in predicate univ (=.. ) [9, p. 43].

167 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

Built-in Predicate: atom prefix(+Atom,+Prefix) Succeeds if the second argument is a Prefix to the Atom in the Ô¨Årst argument. Example: ?- atom prefix(software,soft). Yes ?- atom prefix(software,war). No

Link√∂ping University ‚Äì innovative, highly ranked, European
Interested in Engineering and its various branches? Kickstart your career with an English-taught master‚Äôs degree.

Click here!

168 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

generator2(Pred,From,Elem) :- tmp_predname(TempName), Term1 =.. [TempName,First,First], Term2 =.. [TempName,Last,E], Term3 =.. [TempName,New,E], Term4 =.. [TempName,From,Elem], assert(Term1), assert(Term2 :- (call(Pred,Last,New), Term3)), write(‚ÄôDefined ‚Äô), write(TempName), write(‚Äô/2 in the database.\n‚Äô), Term4.

(Lines reporting new predicates‚Äô names have been included.) We now use the new version of generator/3 to deÔ¨Åne a new version of pairs/1 by
pairs2((I,J)) :- generator2(succ,0,Sum), generator2(next_int(Sum),0,I), J is Sum - I.

It will behave on backtracking as intended:
?- pairs2(P). Defined temp_0/2 Defined temp_1/2 P = 0, 0 ; Defined temp_2/2 P = 0, 1 ; P = 1, 0 ; Defined temp_3/2 P = 0, 2 ; P = 1, 1 ; ... in the database. in the database. in the database.

in the database.

We may wish to remove all unwanted temporary predicates from the database. This is accomplished by the following failure driven loop.
?- current predicate(Pred, ), atom prefix(Pred,‚Äôtemp ‚Äô), Term =.. [Pred,‚Äô ‚Äô,‚Äô ‚Äô], retractall(Term), fail. No

The query below Ô¨Ånally conÔ¨Årms that no predicate of arity 2 whose name starts with ‚Äòtemp_‚Äô is left in the database.
?- current predicate(Pred, ), atom prefix(Pred,‚Äôtemp ‚Äô), atom concat(Pred,‚Äô/2‚Äô,P)1 , listing(P), fail. ERROR: No predicates for ‚Äòtemp_1/2‚Äô ERROR: No predicates for ‚Äòtemp_0/2‚Äô ERROR: No predicates for ‚Äòtemp_3/2‚Äô ERROR: No predicates for ‚Äòtemp_2/2‚Äô No

Exercise 1.14. Based on the annotated hand computations in Fig. A.4, p. 170, the predicate split/4 is deÔ¨Åned in (P-A.1).
1 We

have met atom concat/3 in [9, p. 138].

169 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

split([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(2,1),(3,3),(5,1)], [], S) split([3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(2,0),(3,3),(5,1)], [[1,2]], S) split([3,4,5,6,7,8,9,10,11,12,13,14,15,16], [(3,3),(5,1)], [[1,2]], S)

:; :;
2

3

:; :; :; :;
1 2 3 3

3

split([6,7,8,9,10,11,12,13,14,15,16], [(3,2),(5,1)], [[3,4,5], [1,2]], S)

split([9,10,11,12,13,14,15,16], [(3,1),(5,1)], [[6,7,8], [3,4,5], [1,2]], S)

split([12,13,14,15,16], [(3,0),(5,1)], [[9,10,11], [6,7,8], [3,4,5], [1,2]], S) split([12,13,14,15,16], [(5,1)], [[9,10,11], [6,7,8], [3,4,5], [1,2]], S)

:; :;

3

split([], [(5,0)], [[12,13,14,15,16], [9,10,11], [6,7,8], [3,4,5], [1,2]], S) reverse([[12,13,14,15,16], [9,10,11], [6,7,8], [3,4,5], [1,2]], S) S = [[1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14,15,16]]

:;

:; success

Figure A.4: Annotated Hand Computations for split/4

170 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

Prolog Code P-A.1: DeÔ¨Ånition of split/4
1 2 3 4 5 6 7 8

split([],[(_,0)],Acc,S) :- reverse(Acc,S), !. split(L,[(_,0)|T],Acc,S) :- split(L,T,Acc,S). split(L,[(K,AlphaK)|T],Acc,S) :AlphaK > 0, append(L1,L2,L), length(L1,K), NewAlphaK is AlphaK - 1, split(L2,[(K,NewAlphaK)|T],[L1|Acc],S).

% clause 1 % clause 2 % clause 3 % % % % %

(Notice the concise way L1 is declared to be the front part of L with a speciÔ¨Åc length.)

A.2

Chapter 2 Exercises

All Prolog source Ô¨Åles for Chap. 2 are available in the directory plsearch. Exercise 2.2, part (a). Add to the database in Fig. 2.2 the facts
connect(u,v). connect(u,w). connect(v,w).

171 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

depth Ô¨Årst(d,c)

:; dfs loop([d],[],c) :; :; dfs loop([f,b,s,a],[e,d],c) :; :; dfs loop([b,s,a],[g,f,e,d],c) :; :; success
1 2 2 2 2

0

2

dfs loop([e,s,a],[d],c)

dfs loop([g,b,s,a],[f,e,d],c)

dfs loop([c,a,s,a],[b,g,f,e,d],c)

Figure A.5: Hand Computations for the Query ?- depth first(d,c). Part (b). The successor nodes used in the hand computations for the query ?- depth first(d,c). (Fig. A.5) may be gleaned from Fig. 2.4, p. 50. The interactive session in Fig. A.6, p. 173, conÔ¨Årms the hand computations. The hand computations for the query ?- depth first(u,c). are shown in Fig. A.7, p. 173. (The tree in Fig. A.8, p. 173, drawn by inspecting the database, may be used to work out successor nodes.) They are conÔ¨Årmed by the query in Fig. A.9, p. 174. The query in Fig. A.9 illustrates a perhaps unexpected feature of our implementation: it is possible for a node to be open and closed at the same time. (Algorithm 2.3.2 does not check for this condition.) Exercise 2.3. We consider two possibilities. The Ô¨Årst deÔ¨Ånition in (P-A.2) uses maplist/3 . Prolog Code P-A.2: First deÔ¨Ånition of extend path/3
1 2

extend_path(Nodes,Path,ExtendedPath) :maplist(glue(Path),Nodes,ExtendedPath). glue(T,H,[H|T]).

3

The auxiliary predicate glue/3 in (P-A.2) is for ‚Äòglueing‚Äô head and tail together. (The order of arguments of glue/3 is chosen so as to facilitate partial application of glue/3 in (P-A.2) by Ô¨Åxing its Ô¨Årst argument.) In (P-A.3) another deÔ¨Ånition of extend path/3 is shown. It uses recursion. Prolog Code P-A.3: Second deÔ¨Ånition of extend path/3
1 2 3

extend_path([],_,[]). extend_path([Node|Nodes],Path,[[Node|Path]|Extended]) :extend_path(Nodes,Path,Extended).

% clause 1 % clause 2 %

We shall be working with (P-A.3) in the main body of the text. Exercise 2.4. For the new connectivity, add the clause
connect(b,s).

to the Ô¨Åle links.pl. The new version of is path/1 (in the Ô¨Åle searchinfo.pl) will be formulated as a negation, i.e.

172 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

9

?- consult(df2). % links compiled into edges 0.00 sec, % df2 compiled 0.05 sec, 3,892 bytes Yes ?- depth first(d,c). Open: [d], Closed: [] Node d is being expanded. Successors: Open: [e, s, a], Closed: [d] Node e is being expanded. Successors: Open: [f, b, s, a], Closed: [e, d] Node f is being expanded. Successors: Open: [g, b, s, a], Closed: [f, e, d] Node g is being expanded. Successors: Open: [b, s, a], Closed: [g, f, e, d] Node b is being expanded. Successors: Open: [c, a, s, a], Closed: [b, g, f, Goal found: c Yes

6
1,900 bytes

[e, s, a] [f, b, d] [g, e] [f] [c, e, a] e, d]

8 Figure A.6: Interactive Session for the Query ?- depth first(d,c).

7

depth Ô¨Årst(u,c)

:; dfs loop([u],[],c) :; :; dfs loop([w,w],[v,u],c) :; :; dfs loop([],[w,w,v,u],c) :; failure
2 2 2

0

2

dfs loop([v,w],[u],c)

dfs loop([w],[w,v,u],c)

Figure A.7: Hand Computations for the Query ?- depth first(u,c). u ¬Å ¬Å  ¬Å  ¬Å  v w ¬É ¬É  ¬É  ¬É  ¬É  ¬É w u u v . . . . . . . . . . . . Figure A.8: Tree for Finding Successor Nodes in the New Component

173 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

9

?- depth first(u,c). Open: [u], Closed: [] Node u is being expanded. Successors: Open: [v, w], Closed: [u] Node v is being expanded. Successors: Open: [w, w], Closed: [v, u] Node w is being expanded. Successors: Open: [w], Closed: [w, v, u] Node w is being expanded. Successors: Open: [], Closed: [w, w, v, u] No

6
[v, w] [w, u] [u, v] [u, v]

8 Figure A.9: Interactive Session for the Query ?- depth first(u,c).

7

is_path(L) :- not(prohibit(L)).

with prohibit/1 specifying the conditions which a path must not have.

174 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

Example Path n3 u ¬† T ¬† ¬© E ¬∑¬∑¬∑ u E u E u n2 n1 n3 n4 u' u T c E u u u ¬∑¬∑¬∑ E E n2 n1

Prolog Clause

same([N1,N2,N3,N1,N2| ]).

same([N1,N2,N3,N4,N1,N2| ]).

Table A.2: Example Paths and Prolog Implementations ‚Äì Case One

‚Ä¢ Not allowed is a path whose leading edge is the same as some other edge in its tail (see Table A.2). This condition is implemented by
same([N1,N2,_,N1,N2|_]). same([N1,N2,_|T]) :- same([N1,N2|T]).

‚Ä¢ Not allowed is a path whose leading edge is opposite to some other edge in its tail (see Table A.3). This condition is implemented by
opposite([N1,_,N1|_]). opposite([N1,N2,_,_,N2,N1|_]). opposite([N1,N2,N3,N4,_|T]) :- opposite([N1,N2,N3,N4|T]).

It is seen by an inductive argument that if the above two conditions are observed, no path with repeated edges will ever be constructed by the search algorithm. Concentrating on the leading edge therefore does not pose a restriction but simpliÔ¨Åes the implementation. DeÔ¨Åne now prohibit/1 in searchinfo.pl by
prohibit(L) :- same(L). prohibit(L) :- opposite(L).

The new version of depth first/4 will behave as illustrated in Fig. A.10, p. 176. Exercise 2.5. The new version will be placed in the same Ô¨Åle as the old one (viz df.pl). We start by deÔ¨Åning a new version of extend path/3 , called extend path dl/3 , as shown in Fig. A.11, p. 177. This is a straightforward ‚Äòtranslation‚Äô of extend path/3 and it behaves as follows,
?- extend path dl([f,d],[e,b,a,s],L3-L1). L3 = [[f, e, b, a, s], [d, e, b, a, s]| G361] L1 = G361 ; No

175 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

Example Path ' ¬∑¬∑¬∑ u E u E u n2 n1 n3 u ¬† T ¬© ¬† ' ¬∑¬∑¬∑ u E u E u E u n1 n2 n4 n3 n4 u' u T c ' u u u u ¬∑¬∑¬∑ E E E n1 n2 n5

Prolog Clause opposite([N1,N2,N1| ]).

opposite([N1,N2,N3,N4,N2,N1| ]).

opposite([N1,N2,N3,N4,N5,N2,N1| ]).

Table A.3: Example Paths and Prolog Implementations ‚Äì Case Two

9

?- consult(df4). % links compiled into edges 0.00 sec, 1,964 bytes % searchinfo compiled into info 0.00 sec, 2,120 bytes % df4 compiled 0.05 sec, 6,272 bytes Yes ?- depth first(s,goal path,link,Path). Path = [s, a, b, e, f, g] ; Path = [s, a, b, s, d, e, f, g] ; Path = [s, a, d, e, f, g] ; Path = [s, a, d, s, b, e, f, g] ; Path = [s, d, e, f, g] ; Path = [s, d, a, b, e, f, g] ; Path = [s, d, a, s, b, e, f, g] ; Path = [s, b, e, f, g] ; Path = [s, b, a, d, e, f, g] ; Path = [s, b, a, s, d, e, f, g] ; No

6

8 Figure A.10: Sample Session for depth first/4

7

176 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

extend path dl([], ,E-E). extend path dl([N|Ns],Path,[[N|Path]|E1]-E2) :extend path dl(Ns,Path,E1-E2). Figure A.11: DeÔ¨Ånition of extend path dl/3 In the same fashion, direct translation of the two clauses of dfs loop/4 from Fig. 2.15, p. 65, gives the clauses shown in Fig. A.12, p. 178. (Notice that, as intended, the append goal has been dispensed with. Also notice that the new clauses won‚Äôt interfere with the old ones and we may place them in the same Ô¨Åle.) Fig. A.13, p. 178, illustrates the updating of the agenda by this new version of dfs loop/4 . The new version of depth first/4 is shown in (P-A.4). Prolog Code P-A.4: DeÔ¨Ånition of depth first dl/4
1 2 3

depth_first_dl(Start,G_Pred,C_Pred,PathFound) :dfs_loop([[Start]|L]-L,G_Pred,C_Pred,PathFoundRev), reverse(PathFoundRev,PathFound).

26 destinations 4 continents
Bartending is your ticket to the world

GET STARTED

177 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

dfs loop([Path| ]- ,G Pred, ,Path) :- call(G Pred,Path). dfs loop([[CurrNode|T]|L1]-L2,G Pred,C Pred,PathFound) :T successors(C Pred,CurrNode,SuccNodes), findall(Node,(member(Node,SuccNodes), is path([Node,CurrNode|T])),Nodes), c  ¬® LIFO updating extend path dl(Nodes,[CurrNode|T],L3-L1), of the agenda c  ¬© dfs loop(L3-L2,G Pred,C Pred,PathFound). Figure A.12: New Clauses for dfs loop/4

Old Agenda: [[e|T]|L1] - L2 T [e|[b,a,s]] Extended Paths: L3 - L1 [f|[e|T]] [d|[e|T]] ¬∑¬∑¬∑ ¬∑¬∑¬∑ L1 L2

New Agenda: L3 - L2 L3 Figure A.13: Updating of the Agenda by dfs loop/4

178 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

It is seen that on backtracking depth first/4 does not quite behave as expected:
?- depth first dl(s,goal path,link,Path). Path = [s, a, b, e, f, g] ; Path = [s, a, d, e, f, g] ; Path = [s, d, e, f, g] ; Path = [s, d, a, b, e, f, g] ; Path = [g] ; Path = [_G2571, g] ; ...

What is the explanation for the spurious solutions and non-termination, and, what is the remedy? The search should Ô¨Ånish once the agenda is empty. In the old version based on ordinary lists, dfs loop/4 terminates by failure if its Ô¨Årst argument is uniÔ¨Åed with the empty list:
?- dfs loop([],goal path,link,Path). No

As L-L stands for the empty list, the corresponding query would be

.

179 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

?- dfs loop(L-L,goal path,link,Path). L = [[g| G415]| G412] Path = [g| G415] ; ...

It succeeds, however. To prevent this from happening, we add in front of all other clauses of dfs loop/4 to the database the clause
dfs_loop(L-L,_,_,_) :- !, fail.

upon which, as expected, the above query will fail:
?- dfs loop(L-L,goal path,link,Path). No

Unfortunately, though, depth first dl/4 now always fails:
?- depth first dl(s,goal path,link,Path). No

To see why, we Ô¨Årst rewrite the new clause in the form
dfs_loop(A-A, B, C, D) :- !, fail.

The last query tries Ô¨Årst to satisfy the subgoal
dfs loop([[Start]|L]-L,G Pred,C Pred,PathFoundRev)

with Start = s , G Pred = goal path , C Pred = link and PathFoundRev = Path . The added new clause will now be tried Ô¨Årst. In particular, it will be attempted to unify its Ô¨Årst argument with [[s]|L]-L . UniÔ¨Åcation should not succeed simply because [[s]|L]-L does not stand for the empty list. Let‚Äôs explore interactively what really happens:
?- A-A = [[s]|L]-L. A = [[s], [s], [s], [s], [s], [s], [s], [s], [...]|...] L = [[s], [s], [s], [s], [s], [s], [s], [s], [...]|...] Yes

It is seen that matching succeeds because Prolog does not check whether uniÔ¨Åcation will give rise to an inÔ¨Ånite term (due to the same variable occurring in both terms to be uniÔ¨Åed).2 UniÔ¨Åcation of these terms will fail, however, if we use unify with occurs check/2 , an SWI‚ÄìProlog implementation of full uniÔ¨Åcation:
?- unify with occurs check(A-A,[[s]|L]-L). No
2 In the above query, essentially, uniÔ¨Åcation of [[s]|L] and L is attempted. This should fail. However, without an occurs check Prolog reports success: ?- [[s]|L] = L. L = [[s], [s], [s], [s], [s], [s], [s], [s], [...]|...] Yes

180 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

Built-in Predicate: unify with occurs check(?Term1,?Term2) UniÔ¨Åes the two terms Term1 and Term2 just as =/2 would do. If, however, using =/2 would give rise to an inÔ¨Ånite term, unify with occurs check/2 will fail. Example: ?- unify with occurs check(f(X,a),f(a,X)). X = a Yes ?- X = f(X). X = f(f(f(f(f(f(f(f(f(f(...)))))))))) Yes ?- unify with occurs check(X,f(X)). No

In the added clause (P-A.5), this implementation of uniÔ¨Åcation is therefore used. Prolog Code P-A.5: Additional clause of dfs loop/4
1

dfs loop(L1-L2, , , ) :- unify with occurs check(L1,L2), !, fail.

Prolog now responds as expected:
?- consult(df). % links compiled into edges 0.00 sec, 1,900 bytes % searchinfo compiled into info 0.00 sec, 1,016 bytes Warning: (c:/prolog/plsearch/df.pl:34): Clauses of dfs loop/4 are not together in the source-file3 % df compiled 0.00 sec, 6,272 bytes Yes ?- depth first dl(s,goal path,link,Path). Path = [s, a, b, e, f, g] ; Path = [s, a, d, e, f, g] ; Path = [s, d, e, f, g] ; Path = [s, d, a, b, e, f, g] ; No

The only drawback of unify with occurs check/2 is that it is computationally more expensive than the predicate =/2 . The computational advantage of the diÔ¨Äerence list based version is conÔ¨Årmed by
?- time(findall( P,depth first_dl(s,goal path,link, P), Ps)). % 1,293 inferences in 0.00 seconds (Infinite Lips) Yes ?- time(findall( P,depth first(s,goal path,link, P), Ps)). % 1,414 inferences in 0.06 seconds (23567 Lips) Yes
suppress this warning message, place the directive :- discontiguous dfs loop/4. just after the use module directives in df.pl.
3 To

181 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

:- discontiguous dfs loop/4. ... breadth first dl(Start,G Pred,C Pred,PathFound) :bfs loop([[Start]|L]-L,G Pred,C Pred,PathFoundRev), reverse(PathFoundRev,PathFound). bfs loop(L1-L2, , , ) :- unify with occurs check(L1,L2), !, fail. bfs loop([Path| ]- ,G Pred, ,Path) :- call(G Pred,Path). bfs loop([[CurrNode|T]|L1]-L2,G Pred,C Pred,PathFound) :T successors(C Pred,CurrNode,SuccNodes), findall(Node,(member(Node,SuccNodes), is path([Node,CurrNode|T])),Nodes), c  ¬® FIFO updating extend path dl(Nodes,[CurrNode|T],L2-L3), of the agenda c  ¬© bfs loop(L1-L3,G Pred,C Pred,PathFound).  Copied from the augmented version of df.pl % auxiliary predicates ... (Exercise 2.5, Fig. A.11, p. 177)  ... ‚é´ ‚é¨ extend path dl([], ,E-E). extend path dl([N|Ns],Path,[[N|Path]|E1]-E2) :- ‚é≠' extend path dl(Ns,Path,E1-E2). Figure A.14: Clauses Added to bf.pl

¬® ¬©

Exercise 2.6. The clauses added to bf.pl are shown in Fig. A.14. The new version responds as intended:
?- breadth Path = [s, Path = [s, Path = [s, Path = [s, No first dl(s,goal d, e, f, g] ; a, b, e, f, g] a, d, e, f, g] d, a, b, e, f, path,link,Path). ; ; g] ;

And, it performs better than the old one:
?- time(findall( P,breadth first dl(s,goal path,link, P), Ps)). % 1,293 inferences in 0.00 seconds (Infinite Lips) Yes ?- time(findall( P,breadth first(s,goal path,link, P), Ps)). % 1,378 inferences in 0.00 seconds (Infinite Lips) Yes

Exercise 2.7. See Fig. A.15.

182 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

b dfs loop([Path| ],G Pred, , ,Path) :- call(G Pred,Path). ' b dfs loop([[CurrNode|T]|Others],G Pred,C :‚é´ Pred,Hor,PathFound)  ¬® length([CurrNode|T],ListLength), ‚é¨ Clause essentially as ' PathLength is ListLength - 1, in Fig. 2.15, p. 65 ‚é≠  ¬© PathLength < Hor, # successors(C Pred,CurrNode,SuccNodes), New goals findall(Node,(member(Node,SuccNodes), due to the is path([Node,CurrNode|T])),Nodes), presence of extend path(Nodes,[CurrNode|T],Paths), the horizon ! " append(Paths,Others,NewOpenPaths), b dfs loop(NewOpenPaths,G Pred,C Pred,Hor,PathFound). b dfs loop([[CurrNode|T]|Others],G Pred,C ‚é´ Pred,Hor,PathFound) :length([CurrNode|T],ListLength), ‚é¨ ' PathLength is ListLength - 1, ‚é≠ PathLength >= Hor, b dfs loop(Others,G Pred,C Pred,Hor,PathFound). Figure A.15: DeÔ¨Ånition of b dfs loop/5 (Exercise 2.7)

Think Ume√•. Get a Master‚Äôs degree!
‚Ä¢ modern campus ‚Ä¢ world class research ‚Ä¢ 31 000 students ‚Ä¢ top class teachers ‚Ä¢ ranked nr 1 by international students Master‚Äôs programmes: ‚Ä¢ Architecture ‚Ä¢ Industrial Design ‚Ä¢ Science ‚Ä¢ Engineering

Sweden www.teknat.umu.se/english

183 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

:- use module(bdf). :- dynamic(lastdepth/1).

 Declare lastdepth/1 to be dynamic  iterative deepening(Start,G Pred,C Pred,PathFound)  :retractall(lastdepth( )), Initialize saved value ' assert(lastdepth(0)), of horizon to zero  iterative deepening aux(1,Start,G Pred,C Pred,PathFound). '

¬® ¬© ¬® ¬©

iterative deepening aux(Depth,Start,G Pred,C Pred,PathFound) :bounded df(Start,G Pred,C Pred,Depth,PathFound). iterative deepening aux(Depth,Start,G Pred,C Pred,PathFound) :¬®  retractall(lastdepth( )), Saving old value of ' assert(lastdepth(Depth)), horizon  ¬© NewDepth is Depth + 1, iterative deepening aux(NewDepth,Start,G Pred,C Pred,PathFound).

Figure A.16: ModiÔ¨Åed Version of iterd.pl (Exercise 2.8) Exercise 2.8. We add four new goals to the Ô¨Årst clause of b dfs loop/5 ; this is shown in (P-A.6). Prolog Code P-A.6: ModiÔ¨Åed Ô¨Årst clause of b dfs loop/5
1 2 3 4 5

b_dfs_loop([Path|_],G_Pred,_,_,Path) :- call(G_Pred,Path), lastdepth(LastDepth), length(Path,ListLength), PathLength is ListLength - 1, PathLength > LastDepth.

Furthermore, we need to modify iterd.pl which is shown in Fig. A.16. Exercise 2.9. To have a unique solution, add the cut (! ) in the deÔ¨Ånition of iterative deepening/4 as follows.
iterative_deepening(Start,G_Pred,C_Pred,PathFound) :iterative_deepening_aux(1,Start,G_Pred,C_Pred,PathFound), !.

Exercise 2.14. Let us assume that we have consulted loop puzzle1a.pl; then, automated.pl will also be loaded. The predicate segment/1 may be deÔ¨Åned interactively by
?- consult(user). |: segment(S) ¬£ ¬† ¬£ ¬† :- (circle(P); sharp(P)), link([P],S). |: ¬¢Ctrl ¬° +¬¢D ¬° % user compiled 61.14 sec, 332 bytes Yes

It will generate all segments for the particular problem:
?- segment(S). S = [pos(2,1), pos(1,1), pos(1,2), pos(1,3)] ;

184 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

S = [pos(2,2), pos(1,2), pos(1,3)] ; ...

All pairs of linked segments may be generated thus
?- segment(S1), link(S1,S2). S1 = [pos(2,1), pos(1,1), pos(1,2), pos(1,3)] ... S2 = [pos(2,2)] ;

This generator may be used to deÔ¨Åne a new version of link/2 by facts . (We can do this because the network and therefore the number of facts is Ô¨Ånite.) We do this by a failure driven loop:
?- segment(S1), link(S1,S2), assert(newlink(S1,S2)), fail. No ?- listing(newlink). newlink([pos(2,1), pos(1,1), pos(1,2), pos(1,3)], [pos(2,2)]). ...

Use now newlink/2 as you would use link/2 . The number of nodes and number of directed edges are respectively found by
?- setof( S,segment( S), Ss), length( Ss,L). L = 37 ?- setof(( S1, S2),newlink( S1, S2), Ps), length( Ps,L). L = 99

To Ô¨Ånd out the corresponding quantities for the ‚Äòhand-knit‚Äô solution, we Ô¨Årst consult the Ô¨Åle hand knit.pl. Then, we enter the marks‚Äô positions in the database, followed by a deÔ¨Ånition of segment/1 as before:
?- consult(user). |: circle(pos(1,4)). circle(pos(3,5)). |: circle(pos(4,2)). circle(pos(6,6)). |: sharp(pos(1,6)). sharp(pos(2,1)). sharp(pos(2,2)). |: sharp(pos(4,1)). sharp(pos(5,5)). |: segment(S) ¬£ ¬† ¬£ ¬† :- (circle(P); sharp(P)), link([P],S). |: ¬¢Ctrl ¬° +¬¢D ¬° % user compiled 0.03 sec, 1,256 bytes Yes

Whereas the number of nodes is conÔ¨Årmed to be 37 by exactly the same query as before, the number of edges is now found by
?- setof(( S1, S2),(segment( S1),link( S1, S2)), Ps), length( Ps,L). 4 L = 166

Exercise 2.19. The additional constraint requires that the length of the goal path be equal to the number of positions on the board ‚Äì the board size. Since paths are represented as lists of segments, which themselves are lists of board positions, the path length will be the length of the path‚Äôs Ô¨Çattened list representation. This is implemented in (P-A.7) by adding four new goals to the deÔ¨Ånition of goal path/1 . (The predicate goal path/1
4 Here we have explicitly to specify S1 to be a segment as link/2 has been deÔ¨Åned in hand knit.pl by using the wilde card ( ) in its Ô¨Årst argument. Failing to do so would instantiate S1 to the wildcard, returning an erroneous value for the number of network connections which, incidentally, would be the number of facts deÔ¨Åning link/2 in hand knit.pl.

185 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

is deÔ¨Åned in loops.pl.) Prolog Code P-A.7: Augmented deÔ¨Ånition of goal path/1
1 2 3 4 5 6 7 8

goal_path([H|T]) :- number_of_marks(M), length([H|T],M), last(E,T), link(H,E), size(Row,Col), Size is Row * Col, flatten([H|T],F), length(F,Size).

% % % %

added added added added

goal goal goal goal

A.3

Chapter 3 Exercises

All Prolog source Ô¨Åles for Chap. 3 are available in the directory plsearch. Exercise 3.2. Manual solution. We get the straight line distances from any node to node 10 by Pythagoras (Table A.4). The edge lengths for Fig. 3.4, shown in Table A.5, are obtained from the node co-ordinates in Table 3.2.

How could you take your studies to new heights?
By thinking about things that nobody has ever thought about before By writing a dissertation about the highest building on earth With an internship about natural hazards at popular tourist destinations By discussing with doctors, engineers and seismologists By all of the above

From climate change to space travel ‚Äì as one of the leading reinsurers, we examine risks of all kinds and insure against them. Learn with us how you can drive projects of global significance forwards. Profit from the know-how and network of our staff. Lay the foundation stone for your professional career, while still at university. Find out how you can get involved at Munich Re as a student at munichre.com/career.

186 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

Node Distance to node 10

1 4.00

2 4.24

3 5.83

4 2.00

5 2.24

6 5.39

7 3.16

8 1.41

9 5.10

Table A.4: Values of H

‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì ‚Äì 6 4 1

‚Äì ‚Äì ‚Äì ‚Äì 3 3 4 ‚Äì 2

‚Äì ‚Äì ‚Äì ‚Äì 1 5 6 3

‚Äì ‚Äì ‚Äì 4 ‚Äì ‚Äì 4

‚Äì 5 1 ‚Äì ‚Äì 5

‚Äì 1 5 ‚Äì 6

4 ‚Äì ‚Äì 7

2 ‚Äì 8

6 9

10

Table A.5: Distances between Nodes (Edge Lengths) in Fig. 3.4

The hand computations in Fig. A.18, p. 189, tell us that the shortest route is 1 ‚Üí 2 ‚Üí 5 ‚Üí 8 ‚Üí 10 and its length is 10. Prolog implementation. We deÔ¨Åne in graph b.pl the predicates link/2 and in/3 with obvious meanings.
link(1,2). link(1,3). ... in(1,1,4). in(2,2,7). ...

The heuristic is the Euclidean distance, deÔ¨Åned by e cost/3 in (P-A.8). Prolog Code P-A.8: DeÔ¨Ånition of e cost/3
1 2 3

e_cost(Node,Goal,D) :- in(Node,X1,Y1), in(Goal,X2,Y2), D is sqrt((X1 - X2)^2 + (Y1 - Y2)^2).

The edge costs are calculated by the city block distance, deÔ¨Åned by edge cost/3 in (P-A.9). Prolog Code P-A.9: DeÔ¨Ånition of e cost/3
1 2 3 4

edge_cost(Node1,Node2,Cost) :- link(Node1,Node2), in(Node1,X1,Y1), in(Node2,X2,Y2), Cost is abs(X1 - X2) + abs(Y1 - Y2).

187 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

?- consult(graph b). % asearches compiled into a ida idaeps 0.00 sec, 7,736 bytes % graph b compiled 0.00 sec, 14,800 bytes Yes ?- path. Select start node 1, ..., 10: 1. Select goal node 1, ..., 10: 10. Select algorithm (a/ida/idaeps)... a. % 561 inferences in 0.00 seconds (Infinite Lips) Solution in 4 steps. 1 -> 2 -> 5 -> 8 -> 10 Total cost: 10 Yes 8

9

6

7

Figure A.17: Automated Search The remaining predicates are adopted from graph a.pl with minor modiÔ¨Åcations. Fig. A.17 shows the automated search.

Scholarships

Open your mind to new opportunities

With 31,000 students, Linnaeus University is one of the larger universities in Sweden. We are a modern university, known for our strong international profile. Every year more than 1,600 international students from all over the world choose to enjoy the friendly atmosphere and active student life at Linnaeus University. Welcome to join us!

Bachelor programmes in Business & Economics | Computer Science/IT | Design | Mathematics Master programmes in Business & Economics | Behavioural Sciences | Computer Science/IT | Cultural Studies & Social Sciences | Design | Mathematics | Natural Sciences | Technology & Engineering Summer Academy courses

188 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Solutions of Selected Exercises

[4.00-[1]-0]

:; :; :; :; :; :; :; :; :; success
3 2 1 2 1 2 1 2

1

[8.24-[2,1]-4, 11.83-[3,1]-6] [8.24-[2,1]-4, 11.83-[3,1]-6]

[10-[4,2,1]-8, 9.24-[5,2,1]-7, 12.39-[6,2,1]-7, 11.83-[3,1]-6] [9.24-[5,2,1]-7, 10-[4,2,1]-8, 11.83-[3,1]-6, 12.39-[6,2,1]-7]

[9.41-[8,5,2,1]-8, 17.10-[9,5,2,1]-12, 10-[4,2,1]-8, 11.83-[3,1]-6, 12.39-[6,2,1]-7] [9.41-[8,5,2,1]-8, 10-[4,2,1]-8, 11.83-[3,1]-6, 12.39-[6,2,1]-7, 17.10-[9,5,2,1]-12]

[10.00-[10,8,5,2,1]-10, 10-[4,2,1]-8, 11.83-[3,1]-6, 12.39-[6,2,1]-7, 17.10-[9,5,2,1]-12] [10.00-[10,8,5,2,1]-10, 10-[4,2,1]-8, 11.83-[3,1]-6, 12.39-[6,2,1]-7, 17.10-[9,5,2,1]-12]

Figure A.18: Hand Computations: The Evolution of the Agenda for the A‚ÄìAlgorithm (from node 1 to node 10 in Fig 3.4)

189 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

Exercise 3.3, part (c). We search the network in Fig. 3.6 by the interactive session in Fig. A.19.5 9 6

?- consult(graph c). % asearches compiled into a ida idaeps 0.00 sec, 7,736 bytes % graph c compiled 0.00 sec, 31,068 bytes Yes ?- adj(2, A), co ord(2, Co), path( A, Co). Select start node 1, ..., 26: 1. Select goal node 1, ..., 26: 26. Select algorithm (a/ida/idaeps)... a. % 74,926 inferences in 0.02 seconds (4795264 Lips) Solution in 11 steps. 1 -> 2 -> 5 -> 7 -> 9 -> 11 -> 15 -> 16 -> 18 -> 21 -> 24 -> 26 Total cost: 54 Yes 8

7

Figure A.19: Interactive Session for Searching the Network in Fig. 3.6 Exercise 3.6. Table A.6 shows that Hill Climbing and Best First, save for the simplest of cases, do not Ô¨Ånd the shortest route to the goal node. It is also seen that Best First usually Ô¨Ånds a shorter route to the goal node but Test Case Number Goal Node at Depth hc Number mp bestf of hc Moves mh bestf 1 8 8 8 8 8 2 8 84 38 8 8 3 10 954 262 90 10 4 12 2200 112 32 5 13 445 91 339 45 6 16 444 90 338 44 7 16 442 88 336 42 8 20 348 196 406 66 9 30 1002 126 74 10 30 730 234 528 132

Table A.6: Results for the Eight Puzzle (Hill Climbing and Best First) at a much higher computational cost than Hill Climbing. Finally, the better heuristic (MH) is seen to deliver better solutions throughout. (Cases which could not be Ô¨Ånished due to prohibitively long CPU times are not shown here.) Exercise 3.11. Modify the clauses of a loop/3 and dfs contour loop/6 by replacing each occurrence of the goal
findall(Node,(member(Node,SuccNodes),not(member(Node,T))),Nodes)

by
findall(Node,member(Node,SuccNodes),Nodes)

(The modiÔ¨Åed code is in msearches.pl.) Thus, for example, the gain in CPU time is 17% for case 4 with Iterative Deepening A‚àó and the Euclidean heuristics.
5 The present search problem happens also to be of the type considered in Sect. 3.4. The result in Fig. A.19 is conÔ¨Årmed by Fig. 3.10, p. 122.

190 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

A.4

Chapter 4 Exercises

All Prolog source code for Chap. 4 is available in the Ô¨Åles sieve.pl and draw.pl. The Linux shell scripts (S-4.1), p. 141, and (S-A.1), p. 195, are in the Ô¨Åles sieve and curves, respectively. Exercise 4.2. circ command/4 is deÔ¨Åned in (P-A.10). Prolog Code P-A.10: DeÔ¨Ånition of circ command/4 and Auxiliaries
1 2 3 4 5 6 7 8

circ(R, X, Y, Alpha, Pair) :Pi is 3.1415926, Rad is Alpha * Pi / 180, S is sin(Rad), C is cos(Rad), PairX is X + R * C, PairY is Y + R * S, concat atom([‚Äô(‚Äô,PairX,‚Äô,‚Äô,PairY,‚Äô)‚Äô], Pair). circ pairs(R, X, Y, NInt, Pairs) :mesh(1, NInt, Mesh), maplist(circ(R, X, Y), Mesh, Pairs). circ command(R, X, Y, NInt) :circ pairs(R, X, Y, NInt, Pairs), concat atom([‚Äô\\newcommand{\\defcirc}{\\drawline‚Äô|Pairs], Atom), concat atom([Atom,‚Äô}‚Äô], C), write(C).

9 10 11

12 13 14 15 16

Illustration.
1

A counterclockwise rotation by Œ± = 60‚ó¶ on a circle of radius r = 10 with centre at (x, y ) = (5, 2) maps the ‚Äòrightmost‚Äô point on the perimeter (15, 2) to (10, 10.6603).
?- circ(10, 5, 2, 0, P). P = ‚Äô(15,2)‚Äô Yes ?- circ(10, 5, 2, 60, P). P = ‚Äô(10.0,10.6603)‚Äô Yes

The output of circ/5 is an atom.
2

A uniformly spaced sequence of points on the circle‚Äôs perimeter is generated by circ pairs/5 . For example, points on the circle in 1 spaced at Œ± = 60‚ó¶ (= 360‚ó¶ /6), beginning with (15, 2), are obtained by
?- circ_pairs(10, 5, 2, 6, Pairs). Pairs = [‚Äô(15,2)‚Äô, ‚Äô(10.0,10.6603)‚Äô, ‚Äô(3.09401e-07,10.6603)‚Äô, ‚Äô(-5.0,2.0)‚Äô, ‚Äô(-6.18802e-07,-6.66025)‚Äô, ‚Äô(10.0,-6.66025)‚Äô, ‚Äô(15.0,2.0)‚Äô] Yes

191 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

circ pairs/5 uses mesh/3 ((P-4.4), p. 149) as an auxiliary. The output of circ pairs/5 is a list of atoms. They represent the co-ordinates of the points which will form the vertices of the approximating polygon. \drawline from epic will be used to connect them.
3

circ command/4 essentially concatenates the list entries from

2

thus

?- circ command(10, 5, 2, 6). \newcommand{\defcirc}{\drawline(15,2)(10.0,10.6603)(3.09401e-07,10.6603) (-5.0,2.0)(-6.18802e-07,-6.66025)(10.0,-6.66025)(15.0,2.0)} Yes
4

The output from

3

A is manually adjusted (in an editor) to result in the L TEX deÔ¨Ånition

\newcommand{\defcirc}{\drawline(15,2)(10.0,10.6603)(3.09401e-07,10.6603) (-5.0,2.0)(0,-6.66025)(10.0,-6.66025)(15.0,2.0)}

Exercise 4.3. The deÔ¨Ånition of circ/5 is modiÔ¨Åed to imp circ/5 as shown in (P-A.11).

Cyber Crime Innovation

Web-enabled Applications

Are you ready to do what matters when it comes to Technology?

192 Download free eBooks at bookboon.com

Data Analytics

Implementation

Big Data

.NET Implementation

Click on the ad to read more

IT Consultancy

Technology

Information Management

Social Business

Technology Advisory

Enterprise Application

Java

SAP

Cloud Computing

CRM

Enterprise Content Management SQL End-to-End Solution

Applications of Prolog

Solutions of Selected Exercises

Prolog Code P-A.11: DeÔ¨Ånition of imp circ/5
1 2 3 4 5 6 7 8 9 10

imp_circ(R, X, Y, Alpha, Pair) :Pi is 3.1415926, Rad is Alpha * Pi / 180, S is sin(Rad), C is cos(Rad), PairX is X + R * C, sformat(SPairX, ‚Äô~7f‚Äô,PairX), PairY is Y + R * S, sformat(SPairY, ‚Äô~7f‚Äô,PairY), concat_atom([‚Äô(‚Äô,SPairX,‚Äô,‚Äô,SPairY,‚Äô)‚Äô], Pair).

Lines 6-9 in (P-A.11) illustrate the use of sformat/3 ; it uniÔ¨Åes the value in Ô¨Çoating point notation of a number with a string. Seven digits are used after the decimal point. The string then can serve as a component in the list of atoms in the Ô¨Årst argument of concat atom/2 . Rename circ pairs/5 and circ command/4 in (P-A.10) to imp circ pairs/5 and imp circ command/4 , respectively, and also change in them all instances of circ... to imp circ... . (These two predicates with these obvious changes are not shown here.) Exercise 4.4. The deÔ¨Ånition of gen command2/6 is shown in (P-A.12). Prolog Code P-A.12: DeÔ¨Ånition of gen command2/6
1 2 3 4

gen_mesh(Lower, Upper, NInt, Mesh) :Lower < Upper, integer(NInt), NInt > 0, gen_mesh(Lower, Upper, NInt, NInt, Mesh, []), !. gen_mesh(Lower, _, _, 0, [Lower|Acc], Acc). gen_mesh(Lower, Upper, NInt, NumInt, List, Acc) :H is Lower + NumInt * (Upper - Lower) / NInt, NewNumInt is NumInt - 1, gen_mesh(Lower, Upper, NInt, NewNumInt, List, [H|Acc]). applic(Fun, Pars, Argument, Outcome) :- append(Pars, [Argument], List), append(List, [Outcome], Args), apply(Fun, Args). gen_vals(Fun, Lower, Upper, NInt, Pars, Vals) :gen_mesh(Lower, Upper, NInt, Mesh), maplist(applic(Fun, Pars), Mesh, Vals). gen_command2(CName, Fun, Lower, Upper, NInt, Pars) :gen_vals(Fun, Lower, Upper, NInt, Pars, Vals), concat_atom([‚Äô\\newcommand{‚Äô, CName, ‚Äô}{\\drawline‚Äô|Vals], Atom), concat_atom([Atom,‚Äô}‚Äô], Command), write(Command).

5 6 7 8 9

10 11 12

13 14 15

16 17 18 19 20

gen mesh/4 is deÔ¨Åned by the accumulator technique using gen mesh/6 . In applic/4 , Ô¨Årst the argument list of apply/2 is assembled by list concatenation and then apply/2 is called. The remaining two predicates are

193 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

easily understood. Exercise 4.5. The deÔ¨Ånition of log spiral/5 is shown in (P-A.13). Prolog Code P-A.13: DeÔ¨Ånition of log spiral/5
1 2 3 4 5 6 7 8 9 10 11 12 13

log_spiral(Alpha, CentreX, CentreY, RotAngle, Pair) :Pi is 3.1415926, RadA is Alpha * Pi / 180, SA is sin(RadA), CA is cos(RadA), K is CA/SA, Phi is RotAngle * Pi / 180, R is exp(K * Phi), PairX is CentreX + R * cos(Phi), sformat(SPairX, ‚Äô~7f‚Äô,PairX), PairY is CentreY + R * sin(Phi), sformat(SPairY, ‚Äô~7f‚Äô,PairY), concat_atom([‚Äô(‚Äô,SPairX,‚Äô,‚Äô,SPairY,‚Äô)‚Äô], Pair).

Notice that the pattern set by (P A.11), p. 193, (the deÔ¨Ånition of the improved circle imp circ/5 ) is broadly followed here. This applies in particular to the use of sformat/3 for achieving a Ô¨Çoating point representation of the points‚Äô co-ordinates. (As before, seven digits are used after the comma.) Exercise 4.6. The deÔ¨Ånition of curves/2 is shown in (P-A.14). Prolog Code P-A.14: DeÔ¨Ånition of curves/2
1 2 3 4 5

curves(InFile, OutFile) :- see(InFile), tell(OutFile), execute, seen, told. execute :- get_line(L), ((L = [‚Äô\n‚Äô], execute); (L = [‚Äô%‚Äô|_], copy_comment(L), execute); (L = [end_of_file], true); (exec_line(L), execute)). copy_comment(List) :- atom_chars(Atom,List), write(Atom). exec_line(Line) :- atom_chars(A,Line), term_to_atom(T,A), apply(T,[]), write(‚Äô\n‚Äô).

6 7 8 9 10

11 12

13 14 15 16

Notice that the execute/0 in (P-A.14) uses the predicate get line/1 deÔ¨Åned in (P-4.2), p. 137. This predicate

194 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

reads from a Ô¨Åle the next line as a list of characters. Exercise 4.7. The deÔ¨Ånition of the shell script curves is shown in (S-A.1). It uses the temporary Ô¨Åle temp for communicating the two Ô¨Ålenames to the Prolog predicate curves/2 . (This construct has been seen before in Sect. 4.1.4.)

Linux Shell Script S-A.1: curves
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19

#!/bin/bash if [ $# -ne 2 ]; then echo "Error: supply two arguments" else if [ -e $1 ]; then echo $1 > temp echo $2 >> temp # pl -f draw.pl -g go -t halt # echo "Input file : ‚Äô$1‚Äô" echo "Output file: ‚Äô$2‚Äô" echo "LaTeX source ‚Äô$2‚Äô created" # rm temp else echo "Error: file ‚Äô$1‚Äô does not exist" fi fi

It calls go/0 (a predicate in draw.pl) which then uses curves/2 from Exercise 4.6; go/0 is deÔ¨Åned in (P-A.15).

Prolog Code P-A.15: DeÔ¨Ånition of go/0
1 2 3 4 5 6 7

go :- see(temp), get_string(InFile), get_string(OutFile), curves(InFile, OutFile). % % auxiliary predicate get_string/1 uses get_line/1 from (P-4.2), p. 137 % get_string(String) :- get_line(List), append(ShortList, [‚Äô\n‚Äô],List), atom_chars(String, ShortList).

8 9 10

The auxiliary predicate get string/1 in (P-A.15) uses get line/1 , known from (P-4.2), p. 137.

195 Download free eBooks at bookboon.com

Applications of Prolog

Solutions of Selected Exercises

AXA Global Graduate Program
Find out more and apply

196 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

Software

Appendix B

Software
Below are listed all the Ô¨Ålesnames referenced in this book. The Ô¨Åles are available on the Ventus website.

Referred to in Chap. 1
Prolog Source
enigma.pl

Referred to in Chap. 2
Prolog Source
automated.pl, bf.pl, bdf.pl, df.pl, df1.pl, df2.pl, df3.pl, df4.pl, blindsearches.pl, board.pl, eight_links.pl, eight_puzzle.pl, hand_knit.pl, iterd.pl, kinks.pl, kinks1.pl, kinks2.pl, kinks3.pl, kinks4.pl, kinks5.pl, links.pl, loop_puzzle1.pl, loop_puzzle1a.pl, loop_puzzle2.pl, loops.pl, naive.pl, netsearch.pl, searchinfo.pl, small_board.pl, straightloop.pl, straightloop1.pl, straightloop2.pl, straightloop3.pl

Referred to in Chap. 3
Prolog Source
asearches.pl, bsearches.pl, eight_puzzle_a.pl, eight_puzzle_b.pl, floorplan.pl, graph_a.pl, graph_b.pl, graph_c.pl, links.pl, knight.pl, maze.pl, maze_disp.pl, robot.pl, rsearches.pl, tedious.pl

Referred to in Chap. 4
Prolog Source
draw.pl, sieve.pl
A L TEX Source

exam.tex, part.tex, part_sln.tex, spirals.tex

197 Download free eBooks at bookboon.com

Applications of Prolog

Software

Shell Script
sieve, curves

Other Files
spirals, without_waters, with_waters

198 Download free eBooks at bookboon.com

Click on the ad to read more

Applications of Prolog

References

References
[1] K. Austin. Enigma 1225: Rows are columns. New Scientist, pages 55‚Äì55, 2003. February 8, 2003. [2] H.-J. Bartsch. Handbook of Mathematical Formulas. Academic Press, New York, 1974. [3] N. L. Biggs. Discrete Mathematics. Clarendon Press, Oxford, 1989. [4] H. Cambazard, B. O‚ÄôSullivan, and B.M. Smith. A constraint-based approach to enigma 1225. Computers and Mathematics with Applications, 58:1487‚Äì1497, 2009. [5] W. F. Clocksin. Clause and EÔ¨Äect ‚Äì Prolog Programming for the Working Programmer. Springer, London, 1997. [6] M. A. Covington, D. Nute, and A. Vellino. Prolog Programming in Depth. Prentice Hall, Upper Saddle River, NJ, 1997. [7] A. Csenki. Enigma 1225: Prolog-assisted solution of a puzzle using discrete mathematics. Computers and Mathematics with Applications, 52:383‚Äì400, 2006. [8] A. Csenki. Rotations in the plane and Prolog. Science of Computer Programming, 66:154‚Äì161, 2007. [9] A. Csenki. Prolog Techniques. Ventus Publishing ApS, Copenhagen, 2009. http://www.bookboon.com/uk/student/it/. [10] I. Fekete, T. Gregorics, and S. Nagy. Bevezet¬¥ es a Mesters¬¥ eges Intelligenci¬¥ aba (Introduction to ArtiÔ¨Åcial Intelligence). LSI Oktat¬¥ ok¬® ozpont a Mikroelektr¬¥ onika Kult¬¥ ur¬¥ aj¬¥ a¬¥ ert Alap¬¥ ƒ±tv¬¥ any, Budapest, 1990. [11] M. Fogiel. Handbook of Mathematical, ScientiÔ¨Åc, and Engineering Formulas, Tables, Graphs, Transforms. Research and Education Association, New York, 1984. [12] C. Fox, S. Danicic, M. Harman, and R. M. Hierons. ConSIT: a fully automated conditioned program slicer. Software ‚Äì Practice and Experience, 34:15‚Äì46, 2004. [13] I. M. Gelfand and S. V. Fomin. Calculus of Variations. Prentice‚ÄìHall, Englewood CliÔ¨Äs, NJ, 1963.
A TEX Companion. Addison‚ÄìWesley, Reading, Ma, 1994. [14] M. Goossens, F. Mittelbach, and A. Samarin. The L

[15] W. Jaksch. K¬® unstliche Intelligenz I ‚Äì Symbolische KI (ArtiÔ¨Åcial Intelligence I ‚Äì Symbolic AI). Technical report, University of Erlangen, Erlangen, Germany, 2002. http://www8.informatik.uni-erlangen.de/IMMD8/Lectures/KI-I/.

199 Download free eBooks at bookboon.com

Applications of Prolog

References

¬¥ A Hungarian monthly puzzle magazine, [16] EPS Trade Kft. Egyenes karika (Straight loop). LOGIKOKTEL, pages 2‚Äì2, 2001. Issue 2001/3. ¬¥ A Hungarian monthly puzzle magazine, [17] EPS Trade Kft. Fekete‚ÄìFeh¬¥ er (Black‚ÄìWhite). LOGIKOKTEL, pages 2‚Äì2, 2001. Issue 2001/3. ¬¥ A Hungarian monthly [18] EPS Trade Kft. Minden m¬¥ asodik t¬® or¬¥ espont (Every other kink). LOGIKOKTEL, puzzle magazine, pages 10‚Äì10, 2002. Issue 2002/8. [19] R. Knott. Using prolog to animate mathematics. In D. R. Brough, editor, Logic Programming ‚Äì New Frontiers. Intellect Books, Oxford, 1992. [20] R. E. Korf. Depth-Ô¨Årst iterative-deepening: An optimal admissible tree search. ArtiÔ¨Åcial Intelligence, 27:97‚Äì109, 1985. [21] R. E. Korf, M. Reids, and S. Edelkamp. Time complexity of iterative-deepening-A‚àó . ArtiÔ¨Åcial Intelligence, 129:199‚Äì218, 2001. [22] M. McGrath. Linux in Easy Steps. Computer Step, Southam, 2006. [23] N. J. Nilsson. ArtiÔ¨Åcial Intelligence: A New Synthesis. Morgan Kaufmann, San Francisco, Ca, 1998. [24] D. S. Parker. Stream data analysis in prolog. In L. Shapiro, editor, The Practice of Prolog. MIT Press, Cambridge, Ma, 1990. [25] H.-O. Peitgen, H. J¬® urgens, and D. Saupe. Chaos and Fractals ‚Äì New Frontiers of Science. Springer, New York, 1992. [26] K. F. Riley, M. P. Hobson, and S. J. Bence. Mathematical Methods for Physics and Engineering. Cambridge University Press, Cambridge, UK, second edition, 2002. [27] S. J. Russell and P. Norvig. ArtiÔ¨Åcial Intelligence ‚Äì A Modern Approach. Prentice Hall, Upper Saddle River, NJ, 1995. [28] L. Sterling and E. Shapiro. The Art of Prolog ‚Äì Advanced Programming Techniques. MIT Press, Cambridge Ma, London, 1986. [29] T. Dean T, J. Allen, and Y. Aloimonos. ArtiÔ¨Åcial Intelligence ‚Äì Theory and Practice. Benjamin/Cummings, Redwood City Ca., 1995. [30] S. Thompson. Haskell: The Craft of Functional Programming. Addison‚ÄìWesley, Harlow and London and New York, 1996. [31] S. Todd. Basic Numerical Mathematics, volume 2. Academic Press, Harlow and London and New York, 1978. Basic Numerical Algebra. [32] M. Weiser. Program slicing. IEEE Transactions on Software Engineering, 10:352‚Äì357, 1984. [33] J. Wielemaker. SWI‚ÄìProlog 5.4 Reference Manual. Amsterdam, 2004. http://www.wsi-prolog.org. [34] P. H. Winston. ArtiÔ¨Åcial Intelligence. Addison‚ÄìWesley, Reading, Ma, third edition, 1992.

200 Download free eBooks at bookboon.com

Applications of Prolog

Index

Index
// , 165 : , 49 ==/2 , 24 ! , 102 \=/2 , 24 \==/2 , 24 acyclic graph, 128 adjacency matrix, 110 agenda, 54, 105, 108 apply/2 , 155, 159 atom prefix/2 , 168 call/n , 40 Cartesian product, 40 city block distance, 110, 118, 130 conduit model, 52 consult(user) examples, 88, 108, 159, 184, 185 cut, see ! cycloid, 146‚Äì151 dataÔ¨Çow diagram, 27 derangement, 32 diÔ¨Äerence lists, 67, 68 discontiguous , 181 enumerator, see generator Ferrers Diagram, 36 formatted output, 152 functional programming, 27, 113 generate-and-test, 17 generator, 37‚Äì42 get char/1 , 138 hand computations, 25, 27, 28 Henderson diagram, see dataÔ¨Çow diagram heuristic, 103 admissible, 105, 114 alternative, 123‚Äì125 Euclidean, 123‚Äì124 zero, 123, 127 heuristic evaluation function, 104 higher order predicate, 40, 155 int to atom/2 , 30 interactive entry of code, see consult(user) keysort/2 , 108 last/2 , 28 A L TEX, 133‚Äì134, 143‚Äì160 Linux shell script, 139‚Äì145, 159, 195 logarithmic spiral, 156, 194 Manhattan distance, see city block distance and the eight puzzle, 114 maplist/3 , 150 and functional programming, 27 memoization, 120 Minkowski Inequality, 132 mod , 166 module/2 , see modules modules, 47‚Äì49 partial application, 150, 155, 172 partition of a number deÔ¨Ånition of, 33 generating partitions, 35‚Äì36 pattern matching, 139 problems for Prolog A L TEX code generation, 146‚Äì151 A drawing with L TEX, 146‚Äì160 eight puzzle, 99‚Äì102, 114‚Äì118

201 Download free eBooks at bookboon.com

Applications of Prolog

Index

knight, 128‚Äì132 loop puzzles, 76‚Äì96 maze, 121‚Äì128 robot navigation, 118‚Äì120 Rows are Columns, 17‚Äì46 text removal, 133‚Äì145 text retention, 151 relaxed problem, 114 rotation list rotation, 43 rotation of a cycle, 32 search, 47‚Äì128 blind search, 47‚Äì102 Bounded Depth First, 68‚Äì72 Breadth First, 67‚Äì68 Depth First, 52‚Äì67 Iterative Deepening, 72‚Äì74 informed search, 103‚Äì128 A‚ÄìAlgorithm, 105‚Äì108 Best First, 118 Hill Climbing, 118 Iterative Deepening A‚àó , 108‚Äì110 Iterative Deepening A‚àó ‚Äì , 109 search tree, 49 see/1 , 138 seen/0 , 138 sformat/3 , 152, 193, 194 shell script, see Linux shell script slicing, 133 snd/2 and functional programming, 27 deÔ¨Ånition of, 25 sort/2 , 25 stream data analysis, 27 tail recursion, 102 text processing, 133‚Äì160 Triangle Inequality, 131 unify with occurs check/2 , 181 use module/1 , see modules writef/2 , 30 zip/3

and functional programming, 27 deÔ¨Ånition of, 163 speciÔ¨Åcation of, 25

202 Download free eBooks at bookboon.com

Applications of Prolog

Errata to Volume 1

Errata to Volume 1
Correct the following typesetting errors in [9]. ‚Ä¢ Page 133: remove the fourth line of the second verse, i.e. the line ‚ÄòWent to mow a meadow,‚Äô. ‚Ä¢ Page 183: replace in reference [14] ‚ÄòN. J. Nilsson‚Äô by ‚ÄòS. J. Russell‚Äô. The author welcomes comments and observations on his Prolog books published by Ventus.

I‚ÄôM WITH ZF. ENGINEER AND EASY RIDER.
www.im-with-zf.com

CH ARLES JENKIN

S

Scan the code and find out more about me and what I do at ZF:

Quality Engineer ZF Friedrichshafen

AG

203 Download free eBooks at bookboon.com

Click on the ad to read more

